---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-pack-refs Documentation
docname: git-pack-refs
lang: zh_HANS-CN
aliases:
- "/docs/git-pack-refs/zh_HANS-CN/index.html"
---
<div class="sect1">
<h2 id="_名称"><a class="anchor" href="#_名称"></a>名称</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-pack-refs - 打包头和标签，以便有效地访问仓库</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_概述"><a class="anchor" href="#_概述"></a>概述</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git pack-refs</em> [--all] [--no-prune] [--auto] [--include &lt;pattern&gt;] [--exclude &lt;pattern&gt;]</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_描述"><a class="anchor" href="#_描述"></a>描述</h2>
<div class="sectionbody">
<div class="paragraph">
<p>传统上，分支和标签的提示（统称为 <em>refs</em>）是在 <code>$GIT_DIR/refs</code> 目录下的一个（子）目录中，为每个引用储存一个文件。 虽然许多分支的提示经常被更新，但大多数标签和一些分支的提示从未被更新。 当一个仓库库有成百上千的标签时，这种每个引用一个文件的格式既浪费了存储空间，又损害了性能。</p>
</div>
<div class="paragraph">
<p>这个命令是用来解决存储和性能问题的，将引用存储在一个文件中，<code>$GIT_DIR/packed-refs</code>。 当传统的 `$GIT_DIR/refs`目录层次中缺少一个引用时，就在这个文件中查找，如果找到就使用。</p>
</div>
<div class="paragraph">
<p>分支的后续更新总是在 <code>$GIT_DIR/refs</code> 目录层次下创建新文件。</p>
</div>
<div class="paragraph">
<p>处理一个有太多引用的仓库的推荐做法是，用 <code>--all</code> 来打包它的引用一次，然后偶尔运行 <code>git pack-refs</code> 。 根据定义，标签是固定的，不应该改变。 分支头会被初始的 <code>pack-refs --all</code> 打包，但只有当前活动的分支头会被解压，下一次 <code>pack-refs</code>（没有 <code>--all</code>）会让它们被解压。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_选项"><a class="anchor" href="#_选项"></a>选项</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-pack-refs---all"> <a class="anchor" href="#git-pack-refs---all"></a>--all </dt>
<dd>
<p>该命令默认打包所有已打包的标签和引用，而不打包其他引用。 这是因为分支会被积极开发，打包它们的提示无助于提高性能。 该选项会导致所有 引用也被打包，但隐藏引用、破损引用和符号引用除外。对于有许多具有历史意义的分支的仓库来说非常有用。</p>
</dd>
<dt class="hdlist1" id="git-pack-refs---no-prune"> <a class="anchor" href="#git-pack-refs---no-prune"></a>--no-prune </dt>
<dd>
<p>该命令通常在打包后删除 <code>$GIT_DIR/refs</code> 层次下的松散引用。 这个选项告诉它不要这样做。</p>
</dd>
<dt class="hdlist1" id="git-pack-refs---auto"> <a class="anchor" href="#git-pack-refs---auto"></a>--auto </dt>
<dd>
<p>根据引用数据库的当前状态按需打包引用。行为取决于仓库使用的引用格式，并可能在将来发生变化。</p>
<div class="ulist">
<ul>
<li>
<p>"files"：尚未为 <code>--auto</code> 实现特殊处理。</p>
</li>
<li>
<p>"reftable"：表被压缩，使得它们形成一个几何序列。对于两个表 N 和 N+1，其中 N+1 较新，这保持了 N 至少是 N+1 两倍大的属性。只有违反这个属性的表才会被压缩。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1" id="git-pack-refs---includeltgt"> <a class="anchor" href="#git-pack-refs---includeltgt"></a>--include &lt;模式&gt; </dt>
<dd>
<p>根据 <code>glob(7)</code> 模式打包引用。重复使用该选项会累积包含模式。如果一个引用同时包含在 <code>--include</code> 和 <code>--exclude</code> 中，则 <code>--exclude</code> 优先。使用 <code>--include</code> 会默认排除所有标记。符号引用和断开的引用将永远不会被打包。与 <code>--all</code> 一起使用时，它将是一个 空操作。使用 <code>--no-include</code> 清除并重置模式列表。</p>
</dd>
<dt class="hdlist1" id="git-pack-refs---excludeltgt"> <a class="anchor" href="#git-pack-refs---excludeltgt"></a>--exclude &lt;模式&gt; </dt>
<dd>
<p>不打包与给定的 <code>glob(7)</code> 模式匹配的引用。重复使用此选项会累积排除模式。使用 <code>--no-exclude</code> 可以清除并重置模式列表。如果一个引用已经打包，使用 `--exclude`不会将其解包。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>与 <code>--all</code> 一起使用时，只打包与所提供的 <code>--exclude</code> 模式不匹配的松散引用。</p>
</div>
<div class="paragraph">
<p>当与 <code>--include</code> 一起使用时，提供给 <code>--include</code> 的引用减去提供给 <code>--exclude</code> 的引用将被打包。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_漏洞"><a class="anchor" href="#_漏洞"></a>漏洞</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在引入 packed-refs 机制之前编写的旧文档可能仍然会说 ".git/refs/heads/&lt;branch&gt;文件存在" 这样的话，而它的意思是 "&lt;branch&gt; 分支存在"。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>属于 <a href='{{< relurl "docs/git/zh_HANS-CN" >}}'>git[1]</a> 文档</p>
</div>
</div>
</div>