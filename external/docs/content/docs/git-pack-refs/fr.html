---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-pack-refs Documentation
docname: git-pack-refs
lang: fr
aliases:
- "/docs/git-pack-refs/fr/index.html"
---
<div class="sect1">
<h2 id="_nom"><a class="anchor" href="#_nom"></a>NOM</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-pack-refs - Empaquette les têtes et les étiquettes pour un accès efficace au dépôt</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_synopsis"><a class="anchor" href="#_synopsis"></a>SYNOPSIS</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git pack-refs</em> [--all] [--no-prune] [--auto] [--include &lt;motif&gt;] [--exclude &lt;motif&gt;]</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_description"><a class="anchor" href="#_description"></a>DESCRIPTION</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Traditionnellement, des sommets de branches et les étiquettes (collectivement appelés <em>réfs</em>) sont stockés un fichier par réf dans un (sous-)répertoire sous le répertoire <code>$GIT_DIR/refs</code>. Bien que de nombreux sommets de branche ont tendance à être mis à jour souvent, la plupart des étiquettes et quelques sommets de branche ne sont jamais mis à jour. Lorsqu&#8217;un dépôt a des centaines ou des milliers d&#8217;étiquettes, ce format un fichier-par-réf gaspille l&#8217;espace de stockage et nuit aux performances.</p>
</div>
<div class="paragraph">
<p>Cette commande est utilisée pour résoudre le problème de stockage et de performance en stockant les réfs dans un seul fichier, <code>$GIT_DIR/packed-refs</code>. Lorsqu&#8217;une réf est absente de la hiérarchie traditionnelle du répertoire <code>$GIT_DIR/refs</code>, elle est recherchée dans ce fichier et utilisée si trouvée.</p>
</div>
<div class="paragraph">
<p>Les mises à jour ultérieures des branches créent toujours de nouveaux fichiers sous la hiérarchie des répertoires <code>$GIT_DIR/refs</code>.</p>
</div>
<div class="paragraph">
<p>Une pratique recommandée pour traiter un dépôt avec trop de réfs est d&#8217;empaqueter ses réfs avec <code>--all</code> une fois, et exécuter occasionnellement <code>git pack-refs</code>. Les étiquettes sont par définition fixes et ne sont pas censées changer. Les têtes de branche seront empaquetées avec le premier <code>pack-refs --all</code>, mais seules les têtes de branche actuellement actives seront dépaquetées, et les prochains <code>pack-refs</code> (sans <code>-all</code>) les laisseront dépaquetées.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_options"><a class="anchor" href="#_options"></a>OPTIONS</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-pack-refs---all"> <a class="anchor" href="#git-pack-refs---all"></a>--all </dt>
<dd>
<p>La commande par défaut empaquette toutes les étiquettes et réfs qui sont déjà empaquetées, et laisse les autres réfs seuls. C&#8217;est parce que les branches sont censées être activement développées et l&#8217;emballage de leurs sommets ne contribue pas à la performance. Cette option permet à toutes les réfs d&#8217;être empaquetées, à l&#8217;exception des réfs cachées, des refs cassées et des réfs symboliques. Utile pour un dépôt avec de nombreuses branches d&#8217;intérêt historique.</p>
</dd>
<dt class="hdlist1" id="git-pack-refs---no-prune"> <a class="anchor" href="#git-pack-refs---no-prune"></a>--no-prune </dt>
<dd>
<p>La commande supprime généralement les réfs libres sous la hiérarchie <code>$GIT_DIR/refs</code> après les avoir empaquetées. Cette option indique de ne pas le faire.</p>
</dd>
<dt class="hdlist1" id="git-pack-refs---auto"> <a class="anchor" href="#git-pack-refs---auto"></a>--auto </dt>
<dd>
<p>Pack refs as needed depending on the current state of the ref database. The behavior depends on the ref format used by the repository and may change in the future.</p>
<div class="ulist">
<ul>
<li>
<p>"files": No special handling for <code>--auto</code> has been implemented.</p>
</li>
<li>
<p>"reftable": Tables are compacted such that they form a geometric sequence. For two tables N and N+1, where N+1 is newer, this maintains the property that N is at least twice as big as N+1. Only tables that violate this property are compacted.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1" id="git-pack-refs---includeltmotifgt"> <a class="anchor" href="#git-pack-refs---includeltmotifgt"></a>--include &lt;motif&gt; </dt>
<dd>
<p>Empaquette les réfs correspondant à un motif <code>glob(7)</code>. Les répétitions de cette option augmente les motifs inclus. Si une réf est incluse à la fois dans <code>--include</code> et dans <code>--exclude</code>, <code>-exclude</code> a priorité. L&#8217;utilisation de <code>--include</code> annulera l&#8217;inclusion par défaut de toutes les étiquettes. Les réfs symboliques et les réfs cassées ne seront jamais empaquetées. Avec <code>--all</code>, aucune action ne sera réalisée. Utilisez <code>--no-include</code> pour effacer et réinitialiser la liste des motifs.</p>
</dd>
<dt class="hdlist1" id="git-pack-refs---excludeltmotifgt"> <a class="anchor" href="#git-pack-refs---excludeltmotifgt"></a>--exclude &lt;motif&gt; </dt>
<dd>
<p>Ne pas empaqueter les réfs correspondant au motif <code>glob(7)</code> donné. Les répétitions de cette option accumulent les motifs d&#8217;exclusion. Utilisez <code>--no-exclude</code> pour effacer et réinitialiser la liste des motifs. Si une réf est déjà empaquetée, la cibler avec <code>--exclude</code> ne le dépaquettera pas.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Utilisé avec <code>--all</code>, empaquette seulement les réfs libres qui ne correspondent à aucun des motifs <code>--exclude</code> fournis.</p>
</div>
<div class="paragraph">
<p>Utilisé avec <code>--include</code> , les réfs définies par <code>--include ` , moins celles qui sont fournis à `--exclude</code> seront empaquetées.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_bogues"><a class="anchor" href="#_bogues"></a>BOGUES</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Des documents plus anciens écrits avant l&#8217;introduction du mécanisme de références empaquetées peuvent encore dire des choses comme "le fichier .git/refs/heads/&lt;branche&gt; doit exister" alors que cela doit signifier "la branche &lt;branche&gt; existe".</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Fait partie de la suite <a href='{{< relurl "docs/git/fr" >}}'>git[1]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_traduction"><a class="anchor" href="#_traduction"></a>TRADUCTION</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Cette  page de manuel a été traduite par Jean-Noël Avila &lt;jn.avila AT free DOT fr&gt; et les membres du projet git-manpages-l10n. Veuillez signaler toute erreur de traduction par un rapport de bogue sur le site <a href="https://github.com/jnavila/git-manpages-l10n" class="bare">https://github.com/jnavila/git-manpages-l10n</a> .</p>
</div>
</div>
</div>