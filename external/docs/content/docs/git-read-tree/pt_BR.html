---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-read-tree Documentation
docname: git-read-tree
lang: pt_BR
aliases:
- "/docs/git-read-tree/pt_BR/index.html"
---
<div class="sect1">
<h2 id="_nome"><a class="anchor" href="#_nome"></a>NOME</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-read-tree - Lê as informações da árvore no índice</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resumo"><a class="anchor" href="#_resumo"></a>RESUMO</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git read-tree</em> [(-m [--trivial] [--aggressive] | --reset | --prefix=&lt;prefixo&gt;)
		[-u | -i]] [--index-output=&lt;arquivo&gt;] [--no-sparse-checkout]
		(--empty | &lt;tree-ish1&gt; [&lt;tree-ish2&gt; [&lt;tree-ish3&gt;]])</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_descrição"><a class="anchor" href="#_descrição"></a>DESCRIÇÃO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Lê as informações da árvore informada através da <code>&lt;árvore&gt;</code> no índice, mas na verdade não <strong>atualize</strong> nenhum dos arquivos que ele "armazena em cache". (consulte: <a href='{{< relurl "docs/git-checkout-index/pt_BR" >}}'>git-checkout-index[1]</a>)</p>
</div>
<div class="paragraph">
<p>Opcionalmente, ele pode mesclar uma árvore no índice, executar uma mesclagem de avanço rápido (ou seja, de 2 vias) ou uma mesclagem de 3 vias, com a opção <code>-m</code>. Quando usado com a opção <code>-m</code>, a opção <code>-u</code> faz com que ele também atualize os arquivos na árvore de trabalho com o resultado da mesclagem.</p>
</div>
<div class="paragraph">
<p>Apenas as mesclagens triviais são feitas pelo próprio comando <em>git read-tree</em>. Apenas os caminhos conflitantes estarão numa condição não mesclada durante o retorno do comando <em>git read-tree</em>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_opções"><a class="anchor" href="#_opções"></a>OPÇÕES</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-read-tree--m"> <a class="anchor" href="#git-read-tree--m"></a>-m </dt>
<dd>
<p>Performa uma mesclagem e não apenas uma leitura. O comando se recusará a ser executado se o arquivo no índice tiver entradas não mescladas, indicando que você não concluiu uma mesclagem anterior que você iniciou.</p>
</dd>
<dt class="hdlist1" id="git-read-tree---reset"> <a class="anchor" href="#git-read-tree---reset"></a>--reset </dt>
<dd>
<p>Igual a opção <code>-m</code>, exceto que as entradas não mescladas são descartadas em vez de falharem. Quando usado com a opção <code>-u</code>, as atualizações que levam à perda das alterações na árvore de trabalho ou dos arquivos ou dos diretórios não rastreados não abortarão a operação.</p>
</dd>
<dt class="hdlist1" id="git-read-tree--u"> <a class="anchor" href="#git-read-tree--u"></a>-u </dt>
<dd>
<p>Após uma mesclagem bem-sucedida, atualize os arquivos na árvore de trabalho com o resultado da mesclagem.</p>
</dd>
<dt class="hdlist1" id="git-read-tree--i"> <a class="anchor" href="#git-read-tree--i"></a>-i </dt>
<dd>
<p>Normalmente, para não perder as alterações locais, uma mesclagem exige que o arquivo no índice e os arquivos na árvore de trabalho estejam atualizados com o commit do cabeçalho atual. Esta opção desativa a verificação com a árvore de trabalho e deve ser usada ao criar uma mesclagem de árvores que não estejam diretamente relacionadas a condição atual da árvore de trabalho num arquivo temporário do índice.</p>
</dd>
<dt class="hdlist1" id="git-read-tree--n"> <a class="anchor" href="#git-read-tree--n"></a>-n </dt>
<dt class="hdlist1" id="git-read-tree---dry-run"> <a class="anchor" href="#git-read-tree---dry-run"></a>--dry-run </dt>
<dd>
<p>Verifique se o comando gera algum erro, sem atualizar de verdade, o índice ou os arquivos na árvore de trabalho.</p>
</dd>
<dt class="hdlist1" id="git-read-tree--v"> <a class="anchor" href="#git-read-tree--v"></a>-v </dt>
<dd>
<p>Exiba o progresso da averiguação dos arquivos.</p>
</dd>
<dt class="hdlist1" id="git-read-tree---trivial"> <a class="anchor" href="#git-read-tree---trivial"></a>--trivial </dt>
<dd>
<p>Restrinja a mesclagem de três vias através do comando <em>git read-tree</em> para que aconteça apenas caso não seja necessário a mesclagem no nível do arquivo, em vez de resolver a mesclagem para casos triviais e deixar os arquivos conflitantes não resolvidos no índice.</p>
</dd>
<dt class="hdlist1" id="git-read-tree---aggressive"> <a class="anchor" href="#git-read-tree---aggressive"></a>--aggressive </dt>
<dd>
<p>Normalmente, uma mesclagem de 3 vias pelo <em>git read-tree</em> resolve a mesclagem nos casos realmente triviais e deixa outros casos não resolvidos no índice para que as porcelanas possam implementar diferentes políticas de mesclagem. Esta opção faz com que o comando resolva mais alguns casos internamente:</p>
<div class="ulist">
<ul>
<li>
<p>Quando um lado remove um caminho e o outro lado deixa o caminho inalterado. A resolução é remover aquele caminho.</p>
</li>
<li>
<p>Quando ambos os lados removem um caminho. A resolução é remover aquele caminho.</p>
</li>
<li>
<p>Quando ambos os lados adicionam um caminho igualmente. A resolução é adicionar aquele caminho.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1" id="git-read-tree---prefixltprefixogt"> <a class="anchor" href="#git-read-tree---prefixltprefixogt"></a>--prefix=&lt;prefixo&gt; </dt>
<dd>
<p>Mantenha o conteúdo do índice atual e leia o conteúdo da árvore mencionada sob o diretório em <code>&lt;prefixo&gt;</code>. O comando se recusará a substituir as entradas que já existiam no arquivo do índice original.</p>
</dd>
<dt class="hdlist1" id="git-read-tree---index-outputltarquivogt"> <a class="anchor" href="#git-read-tree---index-outputltarquivogt"></a>--index-output=&lt;arquivo&gt; </dt>
<dd>
<p>Em vez de gravar os resultados no <code>$GIT_INDEX_FILE</code>, grave o índice resultante no arquivo mencionado. Enquanto o comando estiver funcionando, o arquivo do índice original será bloqueado com o mesmo mecanismo de sempre. O arquivo deve permitir ser renomeado(2) a partir de um arquivo temporário criado ao lado do arquivo do índice usual; normalmente, isso significa que ele precisa estar no mesmo sistema de arquivos que o próprio arquivo de índice, e você precisa de permissão de gravação nos diretórios onde o arquivo do índice e o arquivo de saída do índice estão localizados.</p>
</dd>
<dt class="hdlist1" id="git-read-tree---no-recurse-submodules"> <a class="anchor" href="#git-read-tree---no-recurse-submodules"></a>--[no-]recurse-submodules </dt>
<dd>
<p>A utilização do --recurse-submodules atualizará o conteúdo de todos os submódulos ativos de acordo com o commit registrado no superprojeto ao chamar de forma recursiva o "read-tree" e também ao definir os submódulos HEAD para ser desanexados naquele commit.</p>
</dd>
<dt class="hdlist1" id="git-read-tree---no-sparse-checkout"> <a class="anchor" href="#git-read-tree---no-sparse-checkout"></a>--no-sparse-checkout </dt>
<dd>
<p>Desative a compatibilidade com a verificação esparsa, mesmo que o <code>core.sparseCheckout</code> seja verdadeiro.</p>
</dd>
<dt class="hdlist1" id="git-read-tree---empty"> <a class="anchor" href="#git-read-tree---empty"></a>--empty </dt>
<dd>
<p>Em vez de ler o(s) objeto(s) da árvore no índice, apenas esvazie-a.</p>
</dd>
<dt class="hdlist1" id="git-read-tree--q"> <a class="anchor" href="#git-read-tree--q"></a>-q </dt>
<dt class="hdlist1" id="git-read-tree---quiet"> <a class="anchor" href="#git-read-tree---quiet"></a>--quiet </dt>
<dd>
<p>Silencioso, suprima as mensagens de feedback.</p>
</dd>
<dt class="hdlist1" id="git-read-tree-lttree-ishgt"> <a class="anchor" href="#git-read-tree-lttree-ishgt"></a>&lt;tree-ish#&gt; </dt>
<dd>
<p>O ID do(s) objeto(s) da árvore que será lido/mesclado.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_mesclando"><a class="anchor" href="#_mesclando"></a>MESCLANDO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Se <code>-m</code> seja utilizado, o comando <em>git read-tree</em> pode executar 3 tipos de mesclagem, uma única mesclagem na árvore caso apenas uma árvore seja informada, uma mesclagem de avanço rápido nas 2 árvores ou uma mesclagem de 3 vias caso 3 ou mais árvores sejam informadas.</p>
</div>
<div class="sect2">
<h3 id="_mesclagem_única_da_árvore"><a class="anchor" href="#_mesclagem_única_da_árvore"></a>Mesclagem Única da Árvore</h3>
<div class="paragraph">
<p>Caso apenas 1 árvore seja informada, <em>git read-tree</em> funcionará como se o usuário não a tivesse informado <code>-m</code>, exceto quando o índice original tiver uma entrada para um determinado nome do caminho e o conteúdo do caminho corresponder à árvore sendo lida, as estatísticas das informações do índice são utilizadas. (Em outras palavras, os <em>stat()</em> do índice têm precedência sobre os da árvore mesclada).</p>
</div>
<div class="paragraph">
<p>Significa que se você fizer um <code>git read-tree -m &lt;newtree&gt;</code> seguido de um <code>git checkout-index -f -u -a</code>, o comando <em>git checkout-index</em> verificará apenas o que realmente mudou.</p>
</div>
<div class="paragraph">
<p>É utilizado para evitar acertos falsos desnecessários quando <em>git diff-files</em> é executado após <em>git read-tree</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_mesclagem_de_duas_três_árvores"><a class="anchor" href="#_mesclagem_de_duas_três_árvores"></a>Mesclagem de duas, três árvores</h3>
<div class="paragraph">
<p>Normalmente, isso é invocado como <code>git read-tree -m $H $M</code>, onde <em>$H</em> é o commit principal do repositório atual e o <em>$M</em> é o cabeçalho de uma árvore estrangeira, que está simplesmente à frente de <em>$H</em> ( ou seja, estamos numa situação de avanço rápido).</p>
</div>
<div class="paragraph">
<p>Quando duas árvores são definidas, o usuário informa ao <em>git read-tree</em> o seguinte:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>O índice atual e a árvore de trabalho são derivadas de <em>$H</em>, mas
o usuário pode ter alterações locais desde <em>$H</em>.</p>
</li>
<li>
<p>O usuário deseja avançar rapidamente para <em>$M</em>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Nesse caso, o comando <code>git read-tree -m $H $M</code> garante que nenhuma alteração local seja perdida como resultado dessa "mesclagem". Aqui estão as regras de "transporte", onde "I" indica o índice, "clean" significa que o índice e a árvore de trabalho coincidem e "exists"/"nothing" se referem à presença de um caminho no commit informado:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>	I                   H        M        Result
       -------------------------------------------------------
     0  nada                nada     nada     (não acontece)
     1  nada                nada     existe   usa M
     2  nada                existe   nada     remove o caminho do índice
     3  nada                existe   existe,  usa M caso "averiguação inicial",
				     H == M   caso contrário, mantenha o índice
				     existe,  falha
				     H != M

        clean I==H  I==M
       ------------------
     4  sim  N/A   N/A     nada  nada  mantenha o índice
     5  não  N/A   N/A     nada  nada  mantenha o índice

     6  sim   N/A   sim     nada     existe   mantenha o índice
     7  não   N/A   sim     nada     existe   mantenha o índice
     8  sim   N/A   não     nada     existe   falha
     9  não   N/A   não     nada     existe   falha

     10 sim   sim   N/A     existe   nada     remove o caminho a partir do índice
     11 não   sim   N/A     existe   nada     falha
     12 sim   não   N/A     existe   nada     falha
     13 não   não   N/A     existe   nada     falha

	limpa (H==M)
       ------
     14 sim                 existe   existe   mantenha o índice
     15 não                 existe   existe   mantenha o índice

        clean I==H  I==M (H!=M)
       ------------------
     16 sim   não   não      existe   existe   falha
     17 não   não   não      existe   existe   falha
     18 sim   não   sim      existe   existe   mantenha o índice
     19 não   não   sim      existe   existe   mantenha o índice
     20 sim   sim   não      existe   existe   use M
     21 não   sim   não      existe   existe   falha</pre>
</div>
</div>
<div class="paragraph">
<p>Em todos os casos de "manter o índice", a entrada do índice permanece como no arquivo original do índice. Se a entrada não estiver atualizada, o comando <em>git read-tree</em> manterá intacta a cópia na árvore de trabalho quando estiver operando com a opção <code>-u</code>.</p>
</div>
<div class="paragraph">
<p>Quando essa forma de <em>git read-tree</em> for bem-sucedida, você poderá ver quais das "alterações locais" que você fez foram levadas adiante executando o comando <code>git diff-index --cached $M</code>. Observe que isso não corresponde necessariamente ao que o comando <code>git diff-index --cached $H</code> teria produzido antes dessa mesclagem de duas árvores. Isso ocorre devido aos casos 18 e 19 - se você já tivesse as alterações em $M (talvez você as tenha recebido como um patch por e-mail por exemplo), o <code>git diff-index --cached $H</code> teria informado sobre a alteração antes dessa mesclagem, mas ela não seria exibida na saída do comando <code>git diff-index --cached $M</code> após a mesclagem de duas árvores.</p>
</div>
<div class="paragraph">
<p>O caso 3 é um pouco complicado e precisa de explicação. O resultado dessa regra, logicamente, deve ser a remoção do caminho se o usuário tiver encenado a remoção do caminho e, em seguida, a alteração para um novo ramo. No entanto, isso impedirá a realização do verificação inicial, portanto, a regra é alterada para usar M (uma nova árvore) somente quando o conteúdo do índice estiver vazio. Caso contrário, a remoção do caminho é mantida, desde que <code>$H</code> e <code>$M</code> sejam os mesmos.</p>
</div>
</div>
<div class="sect2">
<h3 id="_mesclagem_de_3_vias"><a class="anchor" href="#_mesclagem_de_3_vias"></a>Mesclagem de 3 vias</h3>
<div class="paragraph">
<p>Cada entrada no "índice" possui dois bits na condição "stage". o estágio 0 é o normal e é o único que você veria em qualquer tipo de uso normal.</p>
</div>
<div class="paragraph">
<p>No entanto, quando você executar o comando <em>git read-tree</em> com três árvores, o "estágio" começa em 1.</p>
</div>
<div class="paragraph">
<p>Isso significa que você pode fazer</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git read-tree -m &lt;tree1&gt; &lt;tree2&gt; &lt;tree3&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Você terá um índice com todas as entradas <code>&lt;árvore1&gt;</code> em <em>stage1</em>, todas as entradas <code>&lt;árvore2&gt;</code> em <em>stage2</em> e todas as entradas <code>&lt;árvore3&gt;</code> em <em>stage3</em>. Ao realizar uma mesclagem de outro ramo no ramo atual, usamos a árvore ancestral comum como <code>&lt;árvore1&gt;</code>, o cabeçalho do ramo atual como <code>&lt;árvore2&gt;</code> e o cabeçalho do outro ramo como <code>&lt;árvore3&gt;</code>.</p>
</div>
<div class="paragraph">
<p>Além disso, o comando <em>git read-tree</em> possui uma lógica para caso especial que diz: caso você veja um arquivo que coincida em todos os aspectos nos seguintes condições, ele irá "retornar" novamente para "stage0":</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Os estágios 2 e 3 são os mesmos; pegue um ou outro (não faz diferença, o mesmo trabalho foi feito em nosso ramo no estágio 2 e em seu ramo da fase 3)</p>
</li>
<li>
<p>o estágio 1 e o estágio 2 são iguais, o estágio 3 é diferente; pegue o estágio 3 (o nosso ramo no estágio 2 não fez nada desde no seu ancestral do estágio 1, enquanto o ramo no estágio 3 trabalhou nele)</p>
</li>
<li>
<p>os estágios 1 e 3 são iguais e o estágio 2 é diferente, tomamos o estágio 2 (fizemos algo enquanto eles não fizeram nada)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>O comando <em>git write-tree</em> se recusa a escrever numa árvore sem sentido e irá reclamar das entradas que não foram mescladas caso veja uma única entrada que não seja o estágio 0.</p>
</div>
<div class="paragraph">
<p>OK, tudo isso soa como uma coleção de regras totalmente sem sentido, mas na verdade é exatamente o que você quer para fazer uma fusão rápida. Os diferentes estágios representam a "árvore de resultados" (estágio 0, também informado como "mesclado"), a árvore original (estágio 1, também informado como "orig") e as duas árvores que você está tentando mesclar (estágio 2 e 3, respectivamente).</p>
</div>
<div class="paragraph">
<p>A ordem dos estágios 1, 2 e 3 (portanto a ordem dos três argumentos da linha de comando <code>&lt;tree-ish&gt;</code>) tem importância quando você inicia uma mesclagem de três vias com um arquivo do índice que já esteja preenchido. Aqui está um resumo de como o algoritmo funciona:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>se um arquivo existir no formato idêntico em todas as três árvores, ele retornará automaticamente para a condição de "mesclado" através do comando <em>git read-tree</em>.</p>
</li>
<li>
<p>um arquivo que tenha qualquer diferença entre as três árvores permanecerá como lançamentos separados no índice. Cabe à "política da porcelana" determinar como remover os diferentes estágios não zerados e inserir uma versão mesclada.</p>
</li>
<li>
<p>o arquivo do índice salva e restaura com todas estas informações, para que você possa mesclar as coisas de maneira incremental, mas contanto que tenha as entradas nos estágios 1/2/3 (ou seja, "os lançamentos que não foram mesclados"), não será possível gravar o resultado. Então agora o algoritmo da mesclagem acaba sendo realmente simples:</p>
<div class="ulist">
<ul>
<li>
<p>você percorre o índice em ordem e ignora todas as entradas do estágio 0, pois elas já foram feitas.</p>
</li>
<li>
<p>caso encontre um "estágio1", que não coincida com o "estágio2" ou "estágio3", você sabe que ele foi removido das duas árvores (existia apenas na árvore original) e você remove essa entrada.</p>
</li>
<li>
<p>Se você encontrar uma árvore <em>stage2</em> e <em>stage3</em> correspondentes, remova uma delas e transforme a outra numa entrada <em>stage0</em>. Remova qualquer entrada <em>stage1</em> correspondente, se ela também existir. .. Todas as regras triviais normais ..</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Normalmente, você usaria o comando <code>git merge-index</code> com o comando <code>git merge-one-file</code> fornecido para realizar esta última etapa. O script atualiza os arquivos na árvore de trabalho à medida que mescla cada caminho e ao final de uma mesclagem bem-sucedida.</p>
</div>
<div class="paragraph">
<p>Quando você inicia uma mesclagem de três vias com um arquivo já preenchido no índice, presume-se que ele represente a condição dos arquivos na sua árvore de trabalho, e você pode até mesmo ter arquivos com alterações não registradas no arquivo do índice. Supõe-se ainda que esse estado seja "derivado" da árvore no estágio 2. A mesclagem de 3 vias se recusa a ser executada caso encontre uma entrada original no arquivo do índice que não corresponda ao estágio 2.</p>
</div>
<div class="paragraph">
<p>Isso é feito para evitar que você perca as suas alterações de trabalho que estão em andamento e misture as suas alterações aleatórias num commit mesclado não relacionado. Para ilustrar, imagine que você comece a partir do último commit em seu repositório:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ JC=`git rev-parse --verify "HEAD^0"`
$ git checkout-index -f -u -a $JC</pre>
</div>
</div>
<div class="paragraph">
<p>Você faz edições aleatórias, sem executar o comando <code>git update-index</code>. E então você percebe que o cume da sua árvore no topo (upstream) avançou desde que você se afastou dele:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git fetch git://.... linus
$ LT=`git rev-parse FETCH_HEAD`</pre>
</div>
</div>
<div class="paragraph">
<p>A sua árvore de trabalho ainda se baseia em seu <code>HEAD</code> (<code>$JC</code>), mas você fez algumas edições desde então. A mesclagem de 3 vias garante que você não adicionou ou modificou as entradas no índice desde <code>$JC</code> e, se não tiver feito, fará a coisa certa. Portanto, com a sequência a seguir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git read-tree -m -u `git merge-base $JC $LT` $JC $LT
$ git merge-index git-merge-one-file -a
$ echo "Merge with Linus" | \
  git commit-tree `git write-tree` -p $JC -p $LT</pre>
</div>
</div>
<div class="paragraph">
<p>o commit que seria feito é uma mesclagem direta entre $JC e $LT sem as alterações em andamento e a sua árvore de trabalho seria atualizada para o resultado desta mesclagem.</p>
</div>
<div class="paragraph">
<p>No entanto, caso tenha alterações locais na árvore de trabalho que seriam substituídas através desta mesclagem, o comando <em>git read-tree</em> se recusará a executar evitando que as suas alterações sejam perdidas.</p>
</div>
<div class="paragraph">
<p>Em outras palavras, não há necessidade de se preocupar com o que existe apenas na árvore de trabalho. Quando você tem alterações locais numa parte do projeto que não está envolvida na mesclagem, as suas alterações não interferem na mesclagem e são mantidas intactas. Quando eles <strong>interferem</strong>, a mesclagem nem sequer começa (o comando <code>git read-tree</code> reclama em voz alta e falha sem alterar nada). Nesse caso, você pode simplesmente continuar a fazer o que estava fazendo e, quando a árvore de trabalho estiver pronta (ou seja, você tiver concluído o trabalho em andamento), tente fazer a mesclagem novamente.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_averiguação_esparsa"><a class="anchor" href="#_averiguação_esparsa"></a>AVERIGUAÇÃO ESPARSA</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Observação: Os recursos do <em>skip-worktree</em> do comando <a href='{{< relurl "docs/git-update-index/pt_BR" >}}'>git-update-index[1]</a> e <code>read-tree</code> são anteriores à introdução do <a href='{{< relurl "docs/git-sparse-checkout/pt_BR" >}}'>git-sparse-checkout[1]</a>. Os usuários são incentivados a usar o comando <code>sparse-checkout</code> em vez destes comandos que possam ser redirecionados para necessidades relacionadas a <code>sparse-checkout</code> / <code>skip-worktree</code>. No entanto, as informações abaixo podem ser úteis para os usuários que tentam entender o estilo de predefinição usado no modo <code>non-cone</code> do comando <code>sparse-checkout</code>.</p>
</div>
<div class="paragraph">
<p>O <em>aparse checkout</em> permite preencher o diretório de trabalho de maneira esparsa. Ele usa o bit <code>skip-worktree</code> (consulte <a href='{{< relurl "docs/git-update-index/pt_BR" >}}'>git-update-index[1]</a>) para informar ao Git se vale a pena examinar um arquivo no diretório de trabalho.</p>
</div>
<div class="paragraph">
<p>O <code>git read-tree</code> e outros comandos com base em mesclagem (<code>git merge</code>, <code>git checkout</code>&#8230;&#8203;) podem ajudar a manter o bitmap do <code>skip-worktree</code> e a atualização do diretório de trabalho. O <code>$GIT_DIR/info/sparse-checkout</code> é usado para definir o bitmap de referência do <code>skip-worktree</code>. Quando o <code>git read-tree</code> precisa atualizar o diretório de trabalho, ele redefine o bit <code>skip-worktree</code> no índice com base nesse arquivo, que usa a mesma sintaxe dos arquivos <em>.gitignore</em>. Se uma entrada corresponder a uma predefinição nesse arquivo, ou se a entrada corresponder a um arquivo presente na árvore de trabalho, o <code>skip-worktree</code> não será definido nessa entrada. Caso contrário, o <code>skip-worktree</code> será definido.</p>
</div>
<div class="paragraph">
<p>Em seguida, ele compara o novo valor <em>skip-worktree</em> com o anterior. Caso o <em>skip-worktree</em> mude de definido para não definido, ele adicionará o arquivo correspondente novamente. Caso passe de não definido para definido, esse arquivo será removido.</p>
</div>
<div class="paragraph">
<p>Enquanto o <code>$GIT_DIR/info/sparse-checkout</code> é normalmente utilizado para definir quais arquivos estão nele, também é possível definir quais arquivos <em>não</em> estão, utilizando padrões de negação. Como por exemplo, para remover o arquivo <code>indesejado</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>/*
!unwanted</pre>
</div>
</div>
<div class="paragraph">
<p>Outra coisa complicada é repovoar totalmente o diretório ativo quando você não quiser mais uma verificação esparsa. Você não pode simplesmente desativar a "verificação esparsa" porque os bits <em>skip-worktree</em> ainda estão no índice e o seu diretório de trabalho ainda for escassamente preenchido. Você deve preencher novamente o diretório de trabalho com o conteúdo do arquivo <code>$GIT_DIR/info/sparse-checkout</code> da seguinte maneira:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>/*</pre>
</div>
</div>
<div class="paragraph">
<p>Em seguida você pode desativar a averiguação esparsa. A predefinição da compatibilidade à averiguação esparsa no <em>git read-tree</em> e comandos similares é desativada. Você precisa ativar o <code>core.sparseCheckout</code> para ter uma compatibilidade escassa da averiguação.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_veja_também"><a class="anchor" href="#_veja_também"></a>VEJA TAMBÉM</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href='{{< relurl "docs/git-write-tree/pt_BR" >}}'>git-write-tree[1]</a>, <a href='{{< relurl "docs/git-ls-files/pt_BR" >}}'>git-ls-files[1]</a>, <a href='{{< relurl "docs/gitignore/pt_BR" >}}'>gitignore[5]</a>, <a href='{{< relurl "docs/git-sparse-checkout/pt_BR" >}}'>git-sparse-checkout[1]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Parte do conjunto <a href='{{< relurl "docs/git/pt_BR" >}}'>git[1]</a></p>
</div>
</div>
</div>