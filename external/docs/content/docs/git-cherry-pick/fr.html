---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-cherry-pick Documentation
docname: git-cherry-pick
lang: fr
aliases:
- "/docs/git-cherry-pick/fr/index.html"
---
<div class="sect1">
<h2 id="_nom"><a class="anchor" href="#_nom"></a>NOM</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-cherry-pick - Applique les modifications introduites par certains commits existants</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_synopsis"><a class="anchor" href="#_synopsis"></a>SYNOPSIS</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git cherry-pick</em> [--edit] [-n] [-m &lt;numéro-de-parent&gt;] [-s] [-x] [--ff]
		  [-S[&lt;id-clé&gt;]] &lt;commit&gt;&#8230;&#8203;
<em>git cherry-pick</em> (--continue | --skip | --abort | --quit)</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_description"><a class="anchor" href="#_description"></a>DESCRIPTION</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Étant donné un ou plusieurs commits existants, appliquer la modification que chacun d&#8217;eux introduit, en enregistrant un nouveau commit pour chacun. Cela nécessite que votre arbre de travail soit propre (pas de modification depuis le commit HEAD).</p>
</div>
<div class="paragraph">
<p>Lorsqu&#8217;il n&#8217;est pas évident de savoir comment appliquer une modification, il se produit ce qui suit :</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>La branche actuelle et le pointeur <code>HEAD</code> restent au dernier commit effectué avec succès.</p>
</li>
<li>
<p>La référence <code>CHERRY_PICK_HEAD</code> est définie pour pointer vers le commit qui a introduit la modification difficile à appliquer.</p>
</li>
<li>
<p>Les chemins dans lesquels la modification s&#8217;est appliquée proprement sont mis à jour à la fois dans le fichier d&#8217;index et dans votre arbre de travail.</p>
</li>
<li>
<p>Pour les chemins conflictuels, le fichier d&#8217;index enregistre jusqu&#8217;à trois versions, comme décrit dans la section "VRAIE FUSION" de <a href='{{< relurl "docs/git-merge/fr" >}}'>git-merge[1]</a>. Les fichiers de l&#8217;arbre de travail incluront une description du conflit encadrée par les marqueurs de conflit habituels <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> et <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>.</p>
</li>
<li>
<p>Aucune autre modification n&#8217;est apportée.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Voir <a href='{{< relurl "docs/git-merge/fr" >}}'>git-merge[1]</a> pour quelques conseils sur la résolution de tels conflits.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_options"><a class="anchor" href="#_options"></a>OPTIONS</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-cherry-pick-ltcommitgt82308203"> <a class="anchor" href="#git-cherry-pick-ltcommitgt82308203"></a>&lt;commit&gt;&#8230;&#8203; </dt>
<dd>
<p>Les commits à picorer. Pour une liste plus complète des façons d&#8217;épeler les commits, voir <a href='{{< relurl "docs/gitrevisions/fr" >}}'>gitrevisions[7]</a>. Des ensembles de commits peuvent être passés mais aucune traversée n&#8217;est faite par défaut, comme si l&#8217;option <code>--no-walk</code> était spécifiée, voir <a href='{{< relurl "docs/git-rev-list/fr" >}}'>git-rev-list[1]</a>. Notez que la spécification d&#8217;une plage alimentera tous les arguments &lt;commit&gt;&#8230;&#8203; à un seul parcours de révision (voir un exemple plus bas qui utilise <em>maint master&#8230;&#8203;next</em>).</p>
</dd>
<dt class="hdlist1" id="git-cherry-pick--e"> <a class="anchor" href="#git-cherry-pick--e"></a>-e </dt>
<dt class="hdlist1" id="git-cherry-pick---edit"> <a class="anchor" href="#git-cherry-pick---edit"></a>--edit </dt>
<dd>
<p>Avec cette option, <em>git cherry-pick</em> vous permettra de modifier le message de validation avant de valider.</p>
</dd>
<dt class="hdlist1" id="git-cherry-pick---cleanupltmodegt"> <a class="anchor" href="#git-cherry-pick---cleanupltmodegt"></a>--cleanup=&lt;mode&gt; </dt>
<dd>
<p>Cette option détermine comment le message de valiation sera nettoyé avant d&#8217;être transmis à la machine de commit. Voir <a href='{{< relurl "docs/git-commit/fr" >}}'>git-commit[1]</a> pour plus de détails. En particulier, si la valeur de <em>&lt;mode&gt;</em> est <code>scissors</code>, les ciseaux seront ajoutés à <code>MERGE_MSG</code> avant d&#8217;être transmis dans le cas d&#8217;un conflit.</p>
</dd>
<dt class="hdlist1" id="git-cherry-pick--x"> <a class="anchor" href="#git-cherry-pick--x"></a>-x </dt>
<dd>
<p>Lors de l&#8217;enregistrement du commit, ajouter une ligne qui ajoute "(cherry pick from commit &#8230;&#8203;)" au message de commit original afin d&#8217;indiquer de quel commit ce changement a été picoré. Ceci est fait uniquement pour les picorages sans conflits. N&#8217;utilisez pas cette option si vous faites du picorage depuis votre branche privée car l&#8217;information est inutile pour le destinataire. En revanche, si vous faites du picorage entre deux branches visibles publiquement (par exemple, le rétroportage d&#8217;un correctif dans une branche de maintenance d&#8217;une ancienne version à partir d&#8217;une branche de développement), l&#8217;ajout de cette information peut être utile.</p>
</dd>
<dt class="hdlist1" id="git-cherry-pick--r"> <a class="anchor" href="#git-cherry-pick--r"></a>-r </dt>
<dd>
<p>Avant, la commande faisait par défaut <code>-x</code> comme décrit ci-dessus, et <code>-r</code> permettait de la désactiver. Maintenant, le défaut est de ne pas faire <code>-x</code>, donc cette option est un no-op.</p>
</dd>
<dt class="hdlist1" id="git-cherry-pick--mltnumro-de-parentgt"> <a class="anchor" href="#git-cherry-pick--mltnumro-de-parentgt"></a>-m &lt;numéro-de-parent&gt; </dt>
<dt class="hdlist1" id="git-cherry-pick---mainlineltnumro-de-parentgt"> <a class="anchor" href="#git-cherry-pick---mainlineltnumro-de-parentgt"></a>--mainline &lt;numéro-de-parent&gt; </dt>
<dd>
<p>Habituellement, vous ne pouvez pas picorer une fusion parce que vous ne savez pas quel côté de la fusion doit être considéré comme la ligne principale. Cette option spécifie le numéro du parent (à partir de 1) de la ligne principale et permet à cherry-pick de rejouer la modification par rapport au parent spécifié.</p>
</dd>
<dt class="hdlist1" id="git-cherry-pick--n"> <a class="anchor" href="#git-cherry-pick--n"></a>-n </dt>
<dt class="hdlist1" id="git-cherry-pick---no-commit"> <a class="anchor" href="#git-cherry-pick---no-commit"></a>--no-commit </dt>
<dd>
<p>Habituellement, la commande crée automatiquement une séquence de commits. Cette option applique les changements nécessaires pour sélectionner chaque commit nommé à votre arbre de travail et à l&#8217;index, sans faire aucun commit. De plus, lorsque cette option est utilisée, votre index ne doit pas nécessairement correspondre au commit HEAD. Le picorage est fait par rapport à l&#8217;état initial de votre index.</p>
<div class="paragraph">
<p>Ceci est utile pour picorer l&#8217;effet de plusieurs commits sur votre index à la suite.</p>
</div>
</dd>
<dt class="hdlist1" id="git-cherry-pick--s"> <a class="anchor" href="#git-cherry-pick--s"></a>-s </dt>
<dt class="hdlist1" id="git-cherry-pick---signoff"> <a class="anchor" href="#git-cherry-pick---signoff"></a>--signoff </dt>
<dd>
<p>Ajouter une ligne terminale <code>Signed-off-by</code> au message de commit. Référez-vous à l&#8217;option de contre-signature dans <a href='{{< relurl "docs/git-commit/fr" >}}'>git-commit[1]</a> pour plus d&#8217;information.</p>
</dd>
<dt class="hdlist1" id="git-cherry-pick--Sltidclgt"> <a class="anchor" href="#git-cherry-pick--Sltidclgt"></a>-S[&lt;idclé&gt;] </dt>
<dt class="hdlist1" id="git-cherry-pick---gpg-signltidclgt"> <a class="anchor" href="#git-cherry-pick---gpg-signltidclgt"></a>--gpg-sign[=&lt;idclé&gt;] </dt>
<dt class="hdlist1" id="git-cherry-pick---no-gpg-sign"> <a class="anchor" href="#git-cherry-pick---no-gpg-sign"></a>--no-gpg-sign </dt>
<dd>
<p>Signer les commits avec GPG. L&#8217;argument <code>idclé</code> est optionnel avec par défaut l&#8217;identité du validateur ; si spécifiée, elle doit être collée à l&#8217;option sans aucun espace. <code>--no-gpg-sign</code> est utile pour annuler l&#8217;effet de la variable de configuration <code>commit.gpgSign</code> ainsi que tout <code>--gpg-sign</code> précédent.</p>
</dd>
<dt class="hdlist1" id="git-cherry-pick---ff"> <a class="anchor" href="#git-cherry-pick---ff"></a>--ff </dt>
<dd>
<p>Si le HEAD actuel est le même que le parent du commit picoré, alors une avance rapide sur ce commit sera effectuée.</p>
</dd>
<dt class="hdlist1" id="git-cherry-pick---allow-empty"> <a class="anchor" href="#git-cherry-pick---allow-empty"></a>--allow-empty </dt>
<dd>
<p>Par défaut, le picorage d&#8217;un commit vide échouera, indiquant qu&#8217;une invocation explicite de <code>git commit --allow-empty</code> est nécessaire. Cette option surcharge ce comportement, permettant aux commits vides d&#8217;être préservés automatiquement dans un picorage. Notez que lorsque "--ff" est en vigueur, les commits vides qui répondent à l&#8217;exigence d'"avance rapide" seront conservés même sans cette option. Notez également que l&#8217;utilisation de cette option ne conserve que les commits qui étaient initialement vides (c&#8217;est-à-dire que le commit a enregistré le même arbre que son parent). Les commits qui sont rendus vides à cause d&#8217;un commit précédent feront échouer le picorage. Pour forcer l&#8217;inclusion de ces commits, utilisez <code>--empty=keep</code>.</p>
</dd>
<dt class="hdlist1" id="git-cherry-pick---allow-empty-message"> <a class="anchor" href="#git-cherry-pick---allow-empty-message"></a>--allow-empty-message </dt>
<dd>
<p>Par défaut, le picorage d&#8217;un commit avec un message vide échouera. Cette option annule ce comportement, permettant aux commits avec des messages vides d&#8217;être picorés.</p>
</dd>
<dt class="hdlist1" id="git-cherry-pick---emptydropkeepstop"> <a class="anchor" href="#git-cherry-pick---emptydropkeepstop"></a>--empty=(drop|keep|stop) </dt>
<dd>
<p>Comment manipuler les commits picorés qui sont redondants avec les modifications déjà dans l&#8217;historique actuel.</p>
<div class="openblock">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-cherry-pick-codedropcode"> <a class="anchor" href="#git-cherry-pick-codedropcode"></a><code>drop</code> </dt>
<dd>
<p>Le commit sera abandonné.</p>
</dd>
<dt class="hdlist1" id="git-cherry-pick-codekeepcode"> <a class="anchor" href="#git-cherry-pick-codekeepcode"></a><code>keep</code> </dt>
<dd>
<p>Le commit sera gardé. Implique <code>--allow-empty</code>.</p>
</dd>
<dt class="hdlist1" id="git-cherry-pick-codestopcode"> <a class="anchor" href="#git-cherry-pick-codestopcode"></a><code>stop</code> </dt>
<dd>
<p>La picorage s&#8217;arrêtera lorsque le commit sera appliqué, vous permettant d&#8217;examiner le commit. C&#8217;est le comportement par défaut.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>Notez que <code>--empty=drop</code> et <code>--empty=stop</code> spécifient seulement comment manipuler un commit qui n&#8217;était pas initialement vide, mais est devenu vide en raison d&#8217;un commit précédent. Les commits qui étaient initialement vides causeront encore l&#8217;échec du picorage à moins que <code>--empty=keep</code> ou <code>--allow-empty</code> ne soient spécifiés.</p>
</div>
</dd>
<dt class="hdlist1" id="git-cherry-pick---keep-redundant-commits"> <a class="anchor" href="#git-cherry-pick---keep-redundant-commits"></a>--keep-redundant-commits </dt>
<dd>
<p>Synonyme obsolète pour <code>--empty=keep</code>.</p>
</dd>
<dt class="hdlist1" id="git-cherry-pick---strategyltstrategiegt"> <a class="anchor" href="#git-cherry-pick---strategyltstrategiegt"></a>--strategy=&lt;strategie&gt; </dt>
<dd>
<p>Utilise la stratégie de fusion donnée. Ne devrait être utilisée qu&#8217;une seule fois. Voir la section STRATÉGIES DE FUSION dans <a href='{{< relurl "docs/git-merge/fr" >}}'>git-merge[1]</a> pour plus de détails.</p>
</dd>
<dt class="hdlist1" id="git-cherry-pick--Xltoptiongt"> <a class="anchor" href="#git-cherry-pick--Xltoptiongt"></a>-X&lt;option&gt; </dt>
<dt class="hdlist1" id="git-cherry-pick---strategy-optionltoptiongt"> <a class="anchor" href="#git-cherry-pick---strategy-optionltoptiongt"></a>--strategy-option=&lt;option&gt; </dt>
<dd>
<p>Passer l&#8217;option spécifique de stratégie de fusion à la stratégie de fusion. Voir <a href='{{< relurl "docs/git-merge/fr" >}}'>git-merge[1]</a> pour plus de détails.</p>
</dd>
<dt class="hdlist1" id="git-cherry-pick---rerere-autoupdate"> <a class="anchor" href="#git-cherry-pick---rerere-autoupdate"></a>--rerere-autoupdate </dt>
<dt class="hdlist1" id="git-cherry-pick---no-rerere-autoupdate"> <a class="anchor" href="#git-cherry-pick---no-rerere-autoupdate"></a>--no-rerere-autoupdate </dt>
<dd>
<p>Après que le mécanisme rerere réutilise une résolution enregistrée sur le conflit actuel pour mettre à jour les fichiers dans l&#8217;arbre de travail, lui permettre de mettre également à jour l&#8217;index avec le résultat de la résolution. <code>--no-rerere-autoupdate</code> est un bon moyen de revérifier ce que <code>rerere</code> a fait et de détecter des erreurs de fusion potentielles, avant de valider le résultat dans l&#8217;index avec un <code>git add</code> séparé.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sous_commandes_du_séquenceur"><a class="anchor" href="#_sous_commandes_du_séquenceur"></a>SOUS-COMMANDES DU SÉQUENCEUR</h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Missing <code>fr/sequencer.txt</code></p>
</div>
<div class="paragraph">
<p>See original version for this content.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_exemples"><a class="anchor" href="#_exemples"></a>EXEMPLES</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-cherry-pick-codegitcherry-pickmastercode"> <a class="anchor" href="#git-cherry-pick-codegitcherry-pickmastercode"></a><code>git cherry-pick master</code> </dt>
<dd>
<p>Applique la modification introduite par le commit au sommet de la branche master et créer un nouveau commit avec cette modification.</p>
</dd>
<dt class="hdlist1" id="git-cherry-pick-codegitcherry-pickmastercode-1"> <a class="anchor" href="#git-cherry-pick-codegitcherry-pickmastercode-1"></a><code>git cherry-pick ..master</code> </dt>
<dt class="hdlist1" id="git-cherry-pick-codegitcherry-pickHEADmastercode"> <a class="anchor" href="#git-cherry-pick-codegitcherry-pickHEADmastercode"></a><code>git cherry-pick ^HEAD master</code> </dt>
<dd>
<p>Applique les modifications introduites par tous les commits qui sont des ancêtres de master mais pas de HEAD pour produire de nouveaux commits.</p>
</dd>
<dt class="hdlist1" id="git-cherry-pick-codegitcherry-pickmaintnextmastercode"> <a class="anchor" href="#git-cherry-pick-codegitcherry-pickmaintnextmastercode"></a><code>git cherry-pick maint next ^master</code> </dt>
<dt class="hdlist1" id="git-cherry-pick-codegitcherry-pickmaintmasternextcode"> <a class="anchor" href="#git-cherry-pick-codegitcherry-pickmaintmasternextcode"></a><code>git cherry-pick maint master..next</code> </dt>
<dd>
<p>Applique les modifications introduites par tous les commits qui sont des ancêtres de maint ou next, mais pas master ni aucun de ses ancêtres. Notez que ce dernier ne signifie pas <code>maint</code> et tout ce qui se trouve entre <code>master</code> et <code>next</code> ; spécifiquement, <code>maint</code> ne sera pas utilisé s&#8217;il est inclus dans <code>master</code>.</p>
</dd>
<dt class="hdlist1" id="git-cherry-pick-codegitcherry-pickmaster4master2code"> <a class="anchor" href="#git-cherry-pick-codegitcherry-pickmaster4master2code"></a><code>git cherry-pick master~4 master~2</code> </dt>
<dd>
<p>Applique les modifications introduites par les cinquième et troisième derniers commits pointés par master et crée 2 nouveaux commits avec ces modifications.</p>
</dd>
<dt class="hdlist1" id="git-cherry-pick-codegitcherry-pick-nmaster1nextcode"> <a class="anchor" href="#git-cherry-pick-codegitcherry-pick-nmaster1nextcode"></a><code>git cherry-pick -n master~1 next</code> </dt>
<dd>
<p>Applique à l&#8217;arbre de travail et à l&#8217;index les modifications introduites par l&#8217;avant-dernier commit pointé par master et par le dernier commit pointé par next, mais ne crée aucun commit avec ces modifications.</p>
</dd>
<dt class="hdlist1" id="git-cherry-pick-codegitcherry-pick--ffnextcode"> <a class="anchor" href="#git-cherry-pick-codegitcherry-pick--ffnextcode"></a><code>git cherry-pick --ff ..next</code> </dt>
<dd>
<p>Si l&#8217;historique est linéaire et que HEAD est un ancêtre de next, met à jour l&#8217;arbre de travail et avance le pointeur HEAD pour qu&#8217;il corresponde à next. Sinon, applique les modifications introduites par les commits qui sont dans next mais pas HEAD à la branche courante, en créant un nouveau commit pour chaque nouvelle modification.</p>
</dd>
<dt class="hdlist1" id="git-cherry-pick-codegitrev-list--reversemaster--READMEgitcherry-pick-n--stdincode"> <a class="anchor" href="#git-cherry-pick-codegitrev-list--reversemaster--READMEgitcherry-pick-n--stdincode"></a><code>git rev-list --reverse master -- README | git cherry-pick -n --stdin</code> </dt>
<dd>
<p>Applique les modifications introduites par tous les commits de la branche master qui ont touché README, à l&#8217;arbre de travail et à l&#8217;index, afin que le résultat puisse être inspecté et transformé en un seul nouveau commit si cela convient.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>La séquence suivante tente de rétro-porter une rustine, échoue parce que le code auquel la rustine s&#8217;applique a trop changé, puis réessaie, cette fois en faisant plus attention à la correspondance des lignes de contexte.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git cherry-pick topic^             <b class="conum">(1)</b>
$ git diff                           <b class="conum">(2)</b>
$ git cherry-pick --abort            <b class="conum">(3)</b>
$ git cherry-pick -Xpatience topic^  <b class="conum">(4)</b></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>applique la modification qui serait montrée par <code>git show topic^</code>. Dans cet exemple, la rustine ne s&#8217;applique pas proprement, donc l&#8217;information sur le conflit est écrite dans l&#8217;index et l&#8217;arbre de travail et aucun nouveau commit n&#8217;en résulte.</p>
</li>
<li>
<p>résume les modifications à réconcilier</p>
</li>
<li>
<p>annule le picorage. En d&#8217;autres termes, retourne à l&#8217;état antérieur à l&#8217;extraction, en préservant toutes les modifications locales précédentes dans l&#8217;arbre de travail.</p>
</li>
<li>
<p>essaie d&#8217;appliquer à nouveau la modification introduite par <code>topic^</code>, en passant du temps supplémentaire pour éviter les erreurs basées sur des lignes de contexte déterminées incorrectement.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_voir_aussi"><a class="anchor" href="#_voir_aussi"></a>VOIR AUSSI</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href='{{< relurl "docs/git-revert/fr" >}}'>git-revert[1]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Fait partie de la suite <a href='{{< relurl "docs/git/fr" >}}'>git[1]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_traduction"><a class="anchor" href="#_traduction"></a>TRADUCTION</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Cette  page de manuel a été traduite par Jean-Noël Avila &lt;jn.avila AT free DOT fr&gt; et les membres du projet git-manpages-l10n. Veuillez signaler toute erreur de traduction par un rapport de bogue sur le site <a href="https://github.com/jnavila/git-manpages-l10n" class="bare">https://github.com/jnavila/git-manpages-l10n</a> .</p>
</div>
</div>
</div>