---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-update-index Documentation
docname: git-update-index
lang: pt_BR
aliases:
- "/docs/git-update-index/pt_BR/index.html"
---
<div class="sect1">
<h2 id="_nome"><a class="anchor" href="#_nome"></a>NOME</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-update-index - Registra o conteúdo do arquivo no índice da árvore de trabalho</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resumo"><a class="anchor" href="#_resumo"></a>RESUMO</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git update-index</em>
	     [--add] [--remove | --force-remove] [--replace]
	     [--refresh] [-q] [--unmerged] [--ignore-missing]
	     [(--cacheinfo &lt;mode&gt;,&lt;object&gt;,&lt;file&gt;)&#8230;&#8203;]
	     [--chmod=(+|-)x]
	     [--[no-]assume-unchanged]
	     [--[no-]skip-worktree]
	     [--[no-]ignore-skip-worktree-entries]
	     [--[no-]fsmonitor-valid]
	     [--ignore-submodules]
	     [--[no-]split-index]
	     [--[no-|test-|force-]untracked-cache]
	     [--[no-]fsmonitor]
	     [--really-refresh] [--unresolve] [--again | -g]
	     [--info-only] [--index-info]
	     [-z] [--stdin] [--index-version &lt;n&gt;]
	     [--show-index-version]
	     [--verbose]
	     [--] [&lt;file&gt;&#8230;&#8203;]</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_descrição"><a class="anchor" href="#_descrição"></a>DESCRIÇÃO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Modifica o índice. Cada arquivo mencionado é atualizado no índice e em qualquer estado <em>não mesclado</em> ou que <em>precise ser atualizado</em> será limpo.</p>
</div>
<div class="paragraph">
<p>Consulte também <a href='{{< relurl "docs/git-add/pt_BR" >}}'>git-add[1]</a> para conhecer uma maneira mais amigável ao usuário de executar algumas das operações mais comuns no índice.</p>
</div>
<div class="paragraph">
<p>A maneira como o <em>git update-index</em> trata os arquivos mencionados pode ser alterada utilizando as várias opções:</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_opções"><a class="anchor" href="#_opções"></a>OPÇÕES</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-update-index---add"> <a class="anchor" href="#git-update-index---add"></a>--add </dt>
<dd>
<p>Caso um arquivo especificado ainda não esteja no índice, ele será adicionado. O comportamento predefinido é ignorar os novos arquivos.</p>
</dd>
<dt class="hdlist1" id="git-update-index---remove"> <a class="anchor" href="#git-update-index---remove"></a>--remove </dt>
<dd>
<p>Caso um arquivo especificado estiver no índice, mas estiver ausente, ele será removido. O comportamento predefinido é ignorar os arquivos removidos.</p>
</dd>
<dt class="hdlist1" id="git-update-index---refresh"> <a class="anchor" href="#git-update-index---refresh"></a>--refresh </dt>
<dd>
<p>Examina o índice atual e verifica se as mesclagens são necessárias ou atualizações, verificando as informações do stat().</p>
</dd>
<dt class="hdlist1" id="git-update-index--q"> <a class="anchor" href="#git-update-index--q"></a>-q </dt>
<dd>
<p>Silêncio. Se a opção <code>--refresh</code> descobrir que o índice precisa de uma atualização, o comportamento predefinido será gerar um erro. Esta opção faz com que o comando <em>git update-index</em> sempre continue.</p>
</dd>
<dt class="hdlist1" id="git-update-index---ignore-submodules"> <a class="anchor" href="#git-update-index---ignore-submodules"></a>--ignore-submodules </dt>
<dd>
<p>Não tente atualizar os submódulos. Esta opção só é respeitada quando passada antes da opção <code>--refresh</code>.</p>
</dd>
<dt class="hdlist1" id="git-update-index---unmerged"> <a class="anchor" href="#git-update-index---unmerged"></a>--unmerged </dt>
<dd>
<p>Se opção <code>--refresh</code> encontrar alterações não mescladas no índice, o comportamento predefinido será gerar um erro. Esta opção faz com que o comando <em>git update-index</em> sempre continue.</p>
</dd>
<dt class="hdlist1" id="git-update-index---ignore-missing"> <a class="anchor" href="#git-update-index---ignore-missing"></a>--ignore-missing </dt>
<dd>
<p>Ignora os arquivos ausentes durante um <code>--refresh</code></p>
</dd>
<dt class="hdlist1" id="git-update-index---cacheinfoltmodogtltobjetogtltcaminhogt"> <a class="anchor" href="#git-update-index---cacheinfoltmodogtltobjetogtltcaminhogt"></a>--cacheinfo &lt;modo&gt;,&lt;objeto&gt;,&lt;caminho&gt; </dt>
<dt class="hdlist1" id="git-update-index---cacheinfoltmodogtltobjetogtltcaminhogt-1"> <a class="anchor" href="#git-update-index---cacheinfoltmodogtltobjetogtltcaminhogt-1"></a>--cacheinfo &lt;modo&gt; &lt;objeto&gt; &lt;caminho&gt; </dt>
<dd>
<p>Insere diretamente as informações especificadas no índice. Para compatibilidade com versões anteriores, também é possível usar estes três argumentos como três parâmetros separados, mas os novos usuários são incentivados a usar uma forma única de parâmetro.</p>
</dd>
<dt class="hdlist1" id="git-update-index---index-info"> <a class="anchor" href="#git-update-index---index-info"></a>--index-info </dt>
<dd>
<p>Leia a informação do índice a partir do stdin.</p>
</dd>
<dt class="hdlist1" id="git-update-index---chmod-x"> <a class="anchor" href="#git-update-index---chmod-x"></a>--chmod=(+|-)x </dt>
<dd>
<p>Defina as permissões de execução nos arquivos atualizados.</p>
</dd>
<dt class="hdlist1" id="git-update-index---no-assume-unchanged"> <a class="anchor" href="#git-update-index---no-assume-unchanged"></a>--[no-]assume-unchanged </dt>
<dd>
<p>Quando esta opção é especificada, os nomes registrados dos objetos para os caminhos não são atualizados. Em vez disso, esta opção define ou desativa o bit "assume unchanged" (assumir como inalterado) para os caminhos. Quando o bit "assume unchanged" (assumir como inalterado) está ativado, o usuário promete não alterar o arquivo e permite que o Git assuma que o arquivo da árvore de trabalho corresponda ao que está registrado no índice. Caso queira alterar o arquivo da árvore de trabalho, será precisa desativar o bit para informar ao Git. Isso às vezes é útil quando se trabalha com um grande projeto num sistema de arquivos que tem uma chamada de sistema lstat(2) muito lenta (cifs por exemplo).</p>
<div class="paragraph">
<p>O Git falhará (de forma elegante) caso precise modificar este arquivo no índice, quando for mesclar em um commit por exemplo; portanto, caso o arquivo assumido não monitorado seja alterado na upstream, você precisará lidar com a situação de forma manual.</p>
</div>
</dd>
<dt class="hdlist1" id="git-update-index---really-refresh"> <a class="anchor" href="#git-update-index---really-refresh"></a>--really-refresh </dt>
<dd>
<p>Como a opção <code>--refresh</code>, porém verifica as informações das estatísticas incondicionalmente, sem considerar a configuração "assuma como inalterado".</p>
</dd>
<dt class="hdlist1" id="git-update-index---no-skip-worktree"> <a class="anchor" href="#git-update-index---no-skip-worktree"></a>--[no-]skip-worktree </dt>
<dd>
<p>Quando uma destas opções é utilizada, os nomes dos objetos registrados nos caminhos não são atualizados. Em vez disso, estas opções definem e desabilitam o bit "skip-worktree" (ignore a árvore de trabalho) dos caminhos. Para mais informações, consulte a seção "Skip-worktree bit" abaixo.</p>
</dd>
<dt class="hdlist1" id="git-update-index---no-ignore-skip-worktree-entries"> <a class="anchor" href="#git-update-index---no-ignore-skip-worktree-entries"></a>--[no-]ignore-skip-worktree-entries </dt>
<dd>
<p>Não remova o <em>skip-worktree</em> (também informado como "index-only"), mesmo quando a opção <code>--remove</code> for utilizada.</p>
</dd>
<dt class="hdlist1" id="git-update-index---no-fsmonitor-valid"> <a class="anchor" href="#git-update-index---no-fsmonitor-valid"></a>--[no-]fsmonitor-valid </dt>
<dd>
<p>Quando uma destas opções é utilizada, os nomes dos objetos registrados nos caminhos não são atualizados. Em vez disso, essas opções definem e desabilitam o bit "fsmonitor valid" (fsmonitor válido) para os caminhos. Para mais informações, consulte a seção "Monitor do Sistema de Arquivos" abaixo.</p>
</dd>
<dt class="hdlist1" id="git-update-index--g"> <a class="anchor" href="#git-update-index--g"></a>-g </dt>
<dt class="hdlist1" id="git-update-index---again"> <a class="anchor" href="#git-update-index---again"></a>--again </dt>
<dd>
<p>Executa o próprio comando <em>git update-index</em> nos caminhos cujas entradas do índice sejam diferentes daquelas do commit <code>HEAD</code>.</p>
</dd>
<dt class="hdlist1" id="git-update-index---unresolve"> <a class="anchor" href="#git-update-index---unresolve"></a>--unresolve </dt>
<dd>
<p>Restaura a condição <em>unmerged</em> (não mesclado) ou <em>needs updating</em> (precisa ser atualizado) de um arquivo, durante uma mesclagem caso ele tenha sudo eliminado por engano.</p>
</dd>
<dt class="hdlist1" id="git-update-index---info-only"> <a class="anchor" href="#git-update-index---info-only"></a>--info-only </dt>
<dd>
<p>Não crie os objetos no banco de dados dos objetos para todos os argumentos &lt;arquivo&gt; que seguem esta opção; basta inserir os seus IDs do objeto no índice.</p>
</dd>
<dt class="hdlist1" id="git-update-index---force-remove"> <a class="anchor" href="#git-update-index---force-remove"></a>--force-remove </dt>
<dd>
<p>Remova o arquivo do índice, mesmo quando o diretório ativo ainda tenha tal arquivo. (Implica no uso da opção <code>--remove</code>.)</p>
</dd>
<dt class="hdlist1" id="git-update-index---replace"> <a class="anchor" href="#git-update-index---replace"></a>--replace </dt>
<dd>
<p>É predefinido que quando um arquivo <code>path</code> (caminho) existe no índice, o <em>git update-index</em> recusa uma tentativa de adicionar <code>caminho/arquivo</code>. Da mesma maneira, se um arquivo <code>caminho/arquivo</code> existir, um arquivo <code>path</code> (caminho) não poderá ser adicionado. Com o sinalizador <code>--replace</code>, as entradas existentes que entram em conflito com a entrada que está sendo adicionada são removidas automaticamente com mensagens de aviso.</p>
</dd>
<dt class="hdlist1" id="git-update-index---stdin"> <a class="anchor" href="#git-update-index---stdin"></a>--stdin </dt>
<dd>
<p>Em vez de obter uma lista dos caminhos da linha de comando, leia uma lista de caminhos da entrada predefinida. É predefinido que os caminhos sejam separados por <em>LF</em> (ou seja, um caminho por linha).</p>
</dd>
<dt class="hdlist1" id="git-update-index---verbose"> <a class="anchor" href="#git-update-index---verbose"></a>--verbose </dt>
<dd>
<p>Relate o que está sendo adicionado e removido do índice.</p>
</dd>
<dt class="hdlist1" id="git-update-index---index-versionltngt"> <a class="anchor" href="#git-update-index---index-versionltngt"></a>--index-version &lt;n&gt; </dt>
<dd>
<p>Grava o índice resultante no formato da versão mencionada em disco. As versões compatíveis são <em>2</em>, <em>3</em> e <em>4</em>. A versão atual é a <em>2</em> ou <em>3</em>, dependendo do uso dos recursos extras, como o <code>git add -N</code>. Usando a opção <code>--verbose</code>, informe também a versão que o arquivo do índice usa antes e após este comando.</p>
<div class="paragraph">
<p>A versão <em>4</em> executa uma compactação simples de nome de caminho que reduz o tamanho do índice em 30% a 50% em repositórios grandes, o que resulta num tempo de carregamento mais rápido. O Git oferece suporte a ele desde a versão 1.8.0, lançada em outubro de 2012, e o suporte a ele foi adicionado ao libgit2 em 2016 e ao JGit em 2020. Versões mais antigas desta página do manual a chamavam de "relativamente nova", mas atualmente ela deve ser considerada uma tecnologia madura.</p>
</div>
</dd>
<dt class="hdlist1" id="git-update-index---show-index-version"> <a class="anchor" href="#git-update-index---show-index-version"></a>--show-index-version </dt>
<dd>
<p>Relata a versão do formato do índice usado pelo arquivo de índice em disco. Consulte a opção <code>--index-version</code> acima.</p>
</dd>
<dt class="hdlist1" id="git-update-index--z"> <a class="anchor" href="#git-update-index--z"></a>-z </dt>
<dd>
<p>Só faz algum sentido se for utilizado com <code>--stdin</code> or <code>--index-info</code>; os caminhos são separados com caracteres <code>NUL</code> em vez de <code>LF</code>.</p>
</dd>
<dt class="hdlist1" id="git-update-index---split-index"> <a class="anchor" href="#git-update-index---split-index"></a>--split-index </dt>
<dt class="hdlist1" id="git-update-index---no-split-index"> <a class="anchor" href="#git-update-index---no-split-index"></a>--no-split-index </dt>
<dd>
<p>Ativar ou desativar o modo com o índice dividido. Se o modo com índice dividido já estiver ativado e a opção <code>--split-index</code> for utilizada novamente, todas as alterações no <code>$GIT_DIR/index</code> serão retornadas ao arquivo do índice compartilhado.</p>
<div class="paragraph">
<p>Estas opções entram em vigor independente de quer configuração da variável existente no <code>core.splitIndex</code> (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>). Porém um aviso é emitido quando a alteração vai contra o valor configurado pois o valor configurado apenas entrará em vigor na próxima vez que o índice for lido, removendo o efeito pretendido da opção.</p>
</div>
</dd>
<dt class="hdlist1" id="git-update-index---untracked-cache"> <a class="anchor" href="#git-update-index---untracked-cache"></a>--untracked-cache </dt>
<dt class="hdlist1" id="git-update-index---no-untracked-cache"> <a class="anchor" href="#git-update-index---no-untracked-cache"></a>--no-untracked-cache </dt>
<dd>
<p>Ative ou desative o recurso de cache não rastreado. Antes de ativar utilize <code>--test-untracked-cache</code>.</p>
<div class="paragraph">
<p>Estas opções entram em vigor independente de quer configuração da variável existente no <code>core.untrackedCache</code> (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>). Porém um aviso é emitido quando a alteração vai contra o valor configurado pois o valor configurado apenas entrará em vigor na próxima vez que o índice for lido, removendo o efeito pretendido da opção.</p>
</div>
</dd>
<dt class="hdlist1" id="git-update-index---test-untracked-cache"> <a class="anchor" href="#git-update-index---test-untracked-cache"></a>--test-untracked-cache </dt>
<dd>
<p>Execute apenas os testes no diretório ativo para garantir que o cache não monitorado possa ser utilizado. Você deve habilitar manualmente o cache não monitorado utilizando a opção <code>--untracked-cache</code> ou <code>--force-untracked-cache</code> ou a variável de configuração <code>core.untrackedCache</code> posteriormente, caso realmente queira utilizá-lo. Caso um teste falhe, o código de encerramento gerado é <em>1</em> e uma mensagem explica o que não está funcionando, conforme necessário, caso contrário, o código de encerramento é <em>0</em> e um <em>OK</em> é impresso.</p>
</dd>
<dt class="hdlist1" id="git-update-index---force-untracked-cache"> <a class="anchor" href="#git-update-index---force-untracked-cache"></a>--force-untracked-cache </dt>
<dd>
<p>O mesmo que <code>--untracked-cache</code>. Fornece compatibilidade retroativa com as versões mais antigas do Git, onde <code>--untracked-cache</code> costumava implicar com a opção <code>--test-untracked-cache</code>, porém esta opção ativaria a extensão incondicionalmente.</p>
</dd>
<dt class="hdlist1" id="git-update-index---fsmonitor"> <a class="anchor" href="#git-update-index---fsmonitor"></a>--fsmonitor </dt>
<dt class="hdlist1" id="git-update-index---no-fsmonitor"> <a class="anchor" href="#git-update-index---no-fsmonitor"></a>--no-fsmonitor </dt>
<dd>
<p>Ativar ou desativar o recurso de monitoramento do sistema de arquivos. Estas opções entram em vigor independente de quer configuração da variável existente no <code>core.fsmonitor</code> (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>). Porém um aviso é emitido quando a alteração vai contra o valor configurado pois o valor configurado apenas entrará em vigor na próxima vez que o índice for lido, removendo o efeito pretendido da opção.</p>
</dd>
<dt class="hdlist1" id="git-update-index---"> <a class="anchor" href="#git-update-index---"></a>-- </dt>
<dd>
<p>Não interprete mais argumentos como opções.</p>
</dd>
<dt class="hdlist1" id="git-update-index-ltarquivogt"> <a class="anchor" href="#git-update-index-ltarquivogt"></a>&lt;arquivo&gt; </dt>
<dd>
<p>Arquivos a serem processados. Observe que os arquivos que começam com "." são descartados. Isso inclui o <code>./file</code> e o <code>dir/./file</code>. Caso não queira isso, use nomes mais claros. O mesmo se aplica aos diretórios que terminam em <em>/</em> e os caminhos com <em>//</em></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_usando_a_opção_refresh"><a class="anchor" href="#_usando_a_opção_refresh"></a>USANDO A OPÇÃO --REFRESH</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A opção <code>--refresh</code> não calcula um novo arquivo sha1 ou atualiza o índice para as alterações do modo/conteúdo. Porém o que é <strong>feito</strong> é "repetir a coincidência" das informações estatísticas de um arquivo ao índice, para que você possa atualizar o índice de um arquivo que não foi alterado, porém onde a entrada da estatísticas esteja desatualizada.</p>
</div>
<div class="paragraph">
<p>Como por exemplo, você gostaria de fazer isso após fazer um comando <code>git read-tree</code>, para vincular os detalhes do índice estatístico aos arquivos adequados.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_usando_as_opções_cacheinfo_ou_info_only"><a class="anchor" href="#_usando_as_opções_cacheinfo_ou_info_only"></a>USANDO AS OPÇÕES --CACHEINFO OU --INFO-ONLY</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A opção <code>--cacheinfo</code> é usada para registrar um arquivo que não está no diretório atual de trabalho. Isso é útil para a verificação mínima da mesclagem.</p>
</div>
<div class="paragraph">
<p>Para fingir que você tem um arquivo no caminho com modo e o sha1, use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git update-index --add --cacheinfo &lt;modo&gt;,&lt;sha1&gt;,&lt;caminho&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>A opção <code>--info-only</code> é usada para registrar os arquivos sem colocá-los no banco de dados de objetos. Isso é útil para repositórios "status-only".</p>
</div>
<div class="paragraph">
<p>Tanto a opção <code>--cacheinfo</code> quanto a <code>--info-only</code> se comportam de maneira semelhante: o índice é atualizado, mas o banco de dados dos objetos não. A opção <code>--cacheinfo</code> é útil quando o objeto está no banco de dados, mas o arquivo não está localmente disponível. A opção <code>--info-only</code> é útil quando o arquivo está disponível, mas você não quer atualizar o banco de dados dos objetos.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_usando_a_opção_index_info"><a class="anchor" href="#_usando_a_opção_index_info"></a>USANDO A OPÇÃO --INDEX-INFO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A opção <code>--index-info</code> é um mecanismo mais avançado que permite alimentar várias definições da entrada a partir da entrada predefinida e foi projetado especificamente para scripts. Ele aceita três tipos de formatos:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>O modo SP tipo SP sha1 TAB caminho</p>
<div class="paragraph">
<p>Este formato serve para colocar a saída <code>git ls-tree</code> no índice.</p>
</div>
</li>
<li>
<p>O modo SP sha1 SP estágio TAB caminho</p>
<div class="paragraph">
<p>Este formato serve para colocar os estágios na ordem superior do arquivo no índice e coincide à saída do <code>git ls-files --stage</code>.</p>
</div>
</li>
<li>
<p>O modo SP sha1 TAB caminho</p>
<div class="paragraph">
<p>Este formato não é mais gerado por nenhum comando Git, mas é e continuará sendo compatível através do comando <code>update-index --index-info</code>.</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>Para colocar um estágio de lançamento com prioridade mais alta ao índice, o caminho primeiro deve ser removido ao utilizar <code>mode=0</code> para o caminho e em seguida alimentando as linhas necessárias da entrada ao terceiro formato.</p>
</div>
<div class="paragraph">
<p>Como por exemplo, começando com este índice:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git ls-files -s
100644 8a1218a1024a212bb3db30becd860315f9f3ac52 0       frotz</pre>
</div>
</div>
<div class="paragraph">
<p>você pode alimentar a seguinte entrada para <code>--index-info</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git update-index --index-info
0 0000000000000000000000000000000000000000	frotz
100644 8a1218a1024a212bb3db30becd860315f9f3ac52 1	frotz
100755 8a1218a1024a212bb3db30becd860315f9f3ac52 2	frotz</pre>
</div>
</div>
<div class="paragraph">
<p>A primeira linha da entrada alimenta 0 como o modo para remover o caminho; o SHA-1 não importa, desde que esteja bem formatado. Em seguida, a segunda e a terceira linha alimentam as entradas do estágio 1 e do estágio 2 para este caminho. Após o procedimento acima, o resultado seria o seguinte:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git ls-files -s
100644 8a1218a1024a212bb3db30becd860315f9f3ac52 1	frotz
100755 8a1218a1024a212bb3db30becd860315f9f3ac52 2	frotz</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_utilizando_o_bit_assume_unchanged"><a class="anchor" href="#_utilizando_o_bit_assume_unchanged"></a>UTILIZANDO O BIT &#8220;ASSUME UNCHANGED&#8221;</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Muitas operações no Git dependem do seu sistema de arquivos para ter uma implementação eficiente do <code>lstat(2)</code>, de maneira que as informações do <code>st_mtime</code> para os arquivos da árvore de trabalho possam ser verificadas de maneira econômica para ver se o conteúdo do arquivo foi alterado em relação à versão registrada no arquivo de índice. Infelizmente, alguns sistemas de arquivos têm um <code>lstat(2)</code> ineficiente. Se o seu sistema de arquivos for um deles, você pode definir o bit "assume unchanged" para os caminhos que não foram alterados para que o Git não faça esta verificação. Observe que a configuração deste bit num caminho não significa que o Git verificará o conteúdo do arquivo para ver se ele foi alterado - ele faz com que o Git omita qualquer verificação e assuma que ele <strong>não</strong> foi alterado. Quando você faz alterações nos arquivos da árvore de trabalho, é necessário informar explicitamente ao Git sobre isso, eliminando o bit "assume unchanged", antes ou após a sua alteração.</p>
</div>
<div class="paragraph">
<p>Para definir o bit "assume unchanged", use a opção <code>--assume-unchanged</code>. Para remover, use <code>--no-assume-unchanged</code>. Para ver quais os arquivos têm o bit "assume unchanged" definido, use o comando <code>git ls-files -v</code> (consulte <a href='{{< relurl "docs/git-ls-files/pt_BR" >}}'>git-ls-files[1]</a>).</p>
</div>
<div class="paragraph">
<p>O comando examina a variável de configuração <code>core.ignorestat</code>. Quando isso for verdadeiro, os caminhos atualizados com o comando <code>git update-index paths...</code> e os caminhos atualizados com outros comandos do Git que atualizam o índice e a árvore de trabalho (<em>git apply --index</em>, <em>git checkout-index -u</em> e <em>git read-tree -u</em> por exemplo) são automaticamente marcados como "assume unchanged". Observe que o bit "assume unchanged" <strong>não</strong> é definido quando o comando <code>git update-index --refresh</code> encontrar o arquivo correspondente no índice da árvore de trabalho (use o comando <code>git update-index --really-refresh</code> se quiser marcá-los como "assume unchanged").</p>
</div>
<div class="paragraph">
<p>Às vezes, os usuários confundem o bit "assume unchanged" com o bit "skip-worktree" (ignorar árvore de trabalho). Consulte o parágrafo final da seção "Skip-worktree bit" abaixo para obter uma explicação das diferenças.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_exemplos"><a class="anchor" href="#_exemplos"></a>EXEMPLOS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Para atualizar e renovar apenas os arquivos já averiguados:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git checkout-index -n -f -a &amp;&amp; git update-index --ignore-missing --refresh</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-update-index-Emumsistemadearquivosineficientecomoaopodaconfiguraocodecoreignorestatcodedefinida"> <a class="anchor" href="#git-update-index-Emumsistemadearquivosineficientecomoaopodaconfiguraocodecoreignorestatcodedefinida"></a>Em um sistema de arquivos ineficiente com o a opção da configuração <code>core.ignorestat</code> definida </dt>
<dd>
<div class="listingblock">
<div class="content">
<pre>$ git update-index --really-refresh              <b class="conum">(1)</b>
$ git update-index --no-assume-unchanged foo.c   <b class="conum">(2)</b>
$ git diff --name-only                           <b class="conum">(3)</b>
$ edit foo.c
$ git diff --name-only                           <b class="conum">(4)</b>
M foo.c
$ git update-index foo.c                         <b class="conum">(5)</b>
$ git diff --name-only                           <b class="conum">(6)</b>
$ edit foo.c
$ git diff --name-only                           <b class="conum">(7)</b>
$ git update-index --no-assume-unchanged foo.c   <b class="conum">(8)</b>
$ git diff --name-only                           <b class="conum">(9)</b>
M foo.c</pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>impõem ao lstat(2) que defina os bits "assuma como inalterado" para os caminhos que coincidam com o índice.</p>
</li>
<li>
<p>marque o caminho que será editado.</p>
</li>
<li>
<p>assim faz o lstat(1) e encontra o índice que coincida com o caminho.</p>
</li>
<li>
<p>assim faz o lstat(2) e encontra o índice que <strong>não</strong> coincida com o caminho.</p>
</li>
<li>
<p>registrando uma nova versão nos conjuntos dos índices do bit "assuma como inalterado".</p>
</li>
<li>
<p>e é assumido como inalterado.</p>
</li>
<li>
<p>mesmo depois que você o edite.</p>
</li>
<li>
<p>você pode contar sobre a alteração após o fato.</p>
</li>
<li>
<p>agora verifica com lstat(2) e descobre o que foi alterado.</p>
</li>
</ol>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_skip_worktree_bit"><a class="anchor" href="#_skip_worktree_bit"></a>SKIP-WORKTREE BIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O bit do Skip-worktree pode ser definido numa (longa) frase: Diga ao git para evitar escrever o arquivo no diretório de trabalho quando for razoavelmente possível, e trate o arquivo como inalterado quando ele não estiver presente no diretório de trabalho.</p>
</div>
<div class="paragraph">
<p>Note que nem todos os comandos do git prestarão atenção a este bit, e alguns, só são parcialmente compatíveis.</p>
</div>
<div class="paragraph">
<p>Os sinalizadores "update-index" e os recursos "read-tree" relacionados ao bit "skip-worktree" são anteriores à introdução do comando <a href='{{< relurl "docs/git-sparse-checkout/pt_BR" >}}'>git-sparse-checkout[1]</a>, que fornece uma maneira muito mais fácil de configurar e manipular os bits "skip-worktree". Caso queira reduzir a sua árvore de trabalho para lidar apenas com um subconjunto dos arquivos no repositório, recomendamos enfaticamente o uso do <a href='{{< relurl "docs/git-sparse-checkout/pt_BR" >}}'>git-sparse-checkout[1]</a> em vez dos comandos de baixo nível <em>update-index</em> e <em>read-tree</em>.</p>
</div>
<div class="paragraph">
<p>O objetivo principal do bit <em>skip-worktree</em> é permitir <em>checkouts</em> esparsos, ou seja, ter diretórios de trabalho com apenas um subconjunto de caminhos presentes. Quando o bit <em>skip-worktree</em> estiver definido, os comandos do Git (como o <code>switch</code>, o <code>pull</code> e o <code>merge</code>) evitarão a gravação destes arquivos. No entanto, estes comandos às vezes gravam estes arquivos de qualquer maneira em casos importantes, como conflitos durante uma mesclagem ou um rebase. Os comandos do Git também evitarão tratar a falta desses arquivos como uma exclusão intencional; por exemplo, o comando <code>git add -u</code> não fará uma exclusão desses arquivos e o comando <code>git commit -a</code> também não fará um commit para excluí-los.</p>
</div>
<div class="paragraph">
<p>Embora este bit seja parecido com o bit assumido e alterado, seu objetivo é diferente. O bit <em>assume-unchanged</em> serve para deixar o arquivo na árvore de trabalho, mas fazer com que o Git omita a verificação de alterações e presuma que o arquivo não foi alterado (embora, se ele puder determinar, sem declarar o arquivo, que ele foi alterado, ele estará livre para fazer o registro das alterações). O <em>skip-worktree</em> diz ao Git para ignorar a ausência do arquivo, evitar atualizá-lo quando possível com comandos que normalmente atualizam grande parte do diretório de trabalho (por exemplo, <code>checkout</code>, <code>switch</code>, <code>pull</code>, etc.) e não deixar que a sua ausência seja registrada nos commits. Observe que nas verificações esparsas (configuradas por <code>git sparse-checkout</code> ou configurando <code>core.sparseCheckout</code> como <em>true</em>), se um arquivo estiver marcado como <em>skip-worktree</em> no índice, mas for encontrado na árvore de trabalho, o Git limpará o bit <em>skip-worktree</em> deste arquivo.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_índice_dividido"><a class="anchor" href="#_índice_dividido"></a>ÍNDICE DIVIDIDO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este modo é projetado para repositórios com índices muito grandes e visa reduzir o tempo necessário para gravar repetidamente tais índices.</p>
</div>
<div class="paragraph">
<p>Nesse modo, o índice é dividido em dois arquivos, <code>$GIT_DIR/index</code> e <code>$GIT_DIR/sharedindex.&lt;SHA-1&gt;</code>. As alterações são acumuladas no <code>$GIT_DIR/index</code>, o índice dividido, enquanto o arquivo do índice compartilhado contém todas os lançamentos no índice e permanece inalterado.</p>
</div>
<div class="paragraph">
<p>Todas as alterações feitas índice que foi dividido são retornadas ao arquivo do índice compartilhado quando a quantidade de entradas no índice atinge um nível especificado através da variável de configuração <code>splitIndex.maxPercentChange</code> (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>).</p>
</div>
<div class="paragraph">
<p>Sempre que um novo arquivo do índice compartilhado for criado, os arquivos do índice antigos que foram compartilhados são excluídos caso o tempo de alteração seja mais antigo do que o definido pela variável de configuração <code>splitIndex.sharedIndexExpire</code> (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>).</p>
</div>
<div class="paragraph">
<p>Para evitar a exclusão de um arquivo do índice compartilhado que ainda esteja em uso, o seu horário de modificação é atualizado para o horário atual sempre que um novo índice dividido tiver como base o arquivo do índice compartilhado seja criado ou lido.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_cache_não_monitorado"><a class="anchor" href="#_cache_não_monitorado"></a>CACHE NÃO MONITORADO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Esse cache destina-se a acelerar os comandos que envolvem a determinação dos arquivos não monitorados, como o <code>git status</code>.</p>
</div>
<div class="paragraph">
<p>Esse recurso funciona gravando o <em>mtime</em> dos diretórios da árvore de trabalho e em seguida, omitindo a leitura dos diretórios e as chamadas da condição nos arquivos dos diretórios cujo <em>mtime</em> não tenha sido alterado. Para que isso funcione, o sistema operacional e o sistema de arquivos subjacentes devem alterar o campo do diretório <code>st_mtime</code> caso os arquivos no diretório forem adicionados, modificados ou excluídos.</p>
</div>
<div class="paragraph">
<p>Você pode testar se o sistema de arquivos é compatível com a opção <code>--test-untracked-cache</code>. A opção <code>--untracked-cache</code> usada para executar este teste de forma implícita nas versões mais antigas do Git, porém este não é mais o caso.</p>
</div>
<div class="paragraph">
<p>Caso queira ativar (ou desativar) este recurso, é mais fácil utilizar a variável de configuração <code>core.untrackedCache</code> (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>) do que utilizar a opção <code>--untracked-cache</code> para o comando <code>git update-index</code> em cada repositório, especialmente se você quiser fazê-lo em todos os repositórios que você utiliza, pois é possível definir a variável de configuração como <code>true</code> (ou <code>false</code>) no seu <code>$HOME/.gitconfig</code> apenas uma vez e afetar todos os repositórios que você toque.</p>
</div>
<div class="paragraph">
<p>Quando a variável de configuração <code>core.untrackedCache</code> é alterada, o cache não monitorado é adicionado ou removido do índice da próxima vez que um comando lê o índice; enquanto quando <code>--[no-|force-]untracked-cache</code> são utilizados, o cache não monitorado é imediatamente adicionado ou removido do índice.</p>
</div>
<div class="paragraph">
<p>Antes da versão 2.17, o cache não monitorado apresentava um erro, ao substituir um diretório por um link simbólico para outro diretório, fazendo com que ele mostrasse de forma incorreta os arquivos monitorados pelo git como não monitorados. Consulte o "status: adicione um teste com falha mostrando um bug core.untrackedCache" commit com git.git. Uma solução alternativa para isso é (e isso pode funcionar para os outros erros que ainda não foram descobertos no futuro):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git -c core.untrackedCache=false status</pre>
</div>
</div>
<div class="paragraph">
<p>Também foi demonstrado que este <em>bug</em> afeta os casos sem um link simbólico na reposição de um diretório por um arquivo quando se trata das estruturas internas do cache não monitorado, porém nenhum caso foi relatado onde isso tenha resultado na saída incorreta do comando "git status".</p>
</div>
<div class="paragraph">
<p>Também existem os casos onde os índices existentes escritos pelas versões do git anteriores a versão 2.17 referenciarem os diretórios que não existem mais, potencialmente fazendo com que muitos avisos de "não foi possível abrir o diretório" sejam impressos durante a execução do comando "git status". Estes são os novos avisos para problemas existentes que foram descartados anteriormente sem qualquer aviso prévio.</p>
</div>
<div class="paragraph">
<p>Assim como no bug descrito acima, a solução é executar um "status git" único com <code>core.untrackedCache=false</code> para liberar os dados ruins restantes.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_monitor_do_sistema_de_arquivos"><a class="anchor" href="#_monitor_do_sistema_de_arquivos"></a>MONITOR DO SISTEMA DE ARQUIVOS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este recurso visa acelerar as operações do git para os repositórios que possuem grandes diretórios de trabalho.</p>
</div>
<div class="paragraph">
<p>Ele permite que o git trabalhe em conjunto com um monitor do sistema de arquivos (consulte <a href='{{< relurl "docs/git-fsmonitor--daemon/pt_BR" >}}'>git-fsmonitor&#x2d;&#x2d;daemon[1]</a> e a seção "fsmonitor-watchman" do <a href='{{< relurl "docs/githooks/pt_BR" >}}'>githooks[5]</a>) que pode informá-lo sobre quais os arquivos foram alterados. Isso permite que o git evite ter que fazer um <em>lstat()</em> em todo arquivo para localizar quais os arquivos que foram alterados.</p>
</div>
<div class="paragraph">
<p>Quando usado em conjunto com o cache não monitorado, pode melhorar ainda mais o desempenho, evitando o custo de varrer todo o diretório ativo à procura de novos arquivos.</p>
</div>
<div class="paragraph">
<p>Caso queira ativar (ou desativar) este recurso, é mais fácil utilizar a variável de configuração <code>core.fsmonitor</code> (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>) do que utilizar a opção <code>--fsmonitor</code> para o comando <code>git update-index</code> em cada repositório, especialmente se você quiser fazê-lo em todos os repositórios que você utiliza, pois é possível definir a variável de configuração no seu <code>$HOME/.gitconfig</code> apenas uma vez e afetar todos os repositórios que você toque.</p>
</div>
<div class="paragraph">
<p>Quando a variável de configuração <code>core.fsmonitor</code> é alterada, o monitor do sistema de arquivos é adicionado ou removido do índice na próxima vez que um comando leia o índice. Quando <code>--[no-]fsmonitor</code> é usado, o monitor do sistema de arquivos é imediatamente adicionado ou removido do índice.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_configuração"><a class="anchor" href="#_configuração"></a>CONFIGURAÇÃO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O comando honra a variável de configuração <code>core.filemode</code>. Se o seu repositório estiver num sistema de arquivos cujos bits executáveis não são confiáveis, isso deve ser definido como <em>false</em> (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>). Isso faz com que o comando ignore as diferenças nos modos de arquivo registrados no índice e o modo de arquivo no sistema de arquivos se eles diferirem apenas no bit executável. Num sistema de arquivos tão infeliz, talvez seja necessário usar <em>git update-index --chmod=</em>.</p>
</div>
<div class="paragraph">
<p>De maneira semelhante, caso a variável de configuração <code>core.symlinks</code> esteja definida como <em>false</em> (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>) os links simbólicos serão verificados como arquivos simples e esse comando não modificará o modo de gravação do arquivo vindo de link simbólico para um arquivo regular.</p>
</div>
<div class="paragraph">
<p>O comando examina a variável de configuração <code>core.ignorestat</code>. Consulte a seção <em>Uso do bit "assuma como inalterado"</em> acima.</p>
</div>
<div class="paragraph">
<p>O comando também examina a variável de configuração <code>core.trustctime</code>. Pode ser útil quando o tempo de alteração do inode é modificado regularmente por algo fora do Git (os rastreadores do sistema de arquivos e os sistemas de backup usam o ctime para marcar os arquivos processados) (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>).</p>
</div>
<div class="paragraph">
<p>A extensão do cache não rastreado pode ser ativado através da configuração de variável <code>core.untrackedCache</code> (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_observações"><a class="anchor" href="#_observações"></a>OBSERVAÇÕES</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Os usuários geralmente tentam usar os bits <em>assume-unchanged</em> e <em>skip-worktree</em> para dizer ao Git para ignorar as alterações nos arquivos que são rastreados. Isso não funciona como esperado, pois o Git ainda pode verificar os arquivos da árvore de trabalho em relação ao índice ao executar determinadas operações. Em geral, o Git não oferece uma maneira de ignorar as alterações nos arquivos rastreados, portanto, recomenda-se o uso de soluções alternativas.</p>
</div>
<div class="paragraph">
<p>Por exemplo, se o arquivo que você deseja alterar for algum tipo de arquivo de configuração, o repositório poderá incluir um arquivo de configuração de amostra que poderá ser copiado para o nome ignorado e modificado. O repositório pode até incluir um script para tratar o arquivo de amostra como um modelo, modificando-o e copiando-o automaticamente.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_veja_também"><a class="anchor" href="#_veja_também"></a>VEJA TAMBÉM</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>, <a href='{{< relurl "docs/git-add/pt_BR" >}}'>git-add[1]</a>, <a href='{{< relurl "docs/git-ls-files/pt_BR" >}}'>git-ls-files[1]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Parte do conjunto <a href='{{< relurl "docs/git/pt_BR" >}}'>git[1]</a></p>
</div>
</div>
</div>