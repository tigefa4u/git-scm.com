---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-merge-base Documentation
docname: git-merge-base
lang: pt_BR
aliases:
- "/docs/git-merge-base/pt_BR/index.html"
---
<div class="sect1">
<h2 id="_nome"><a class="anchor" href="#_nome"></a>NOME</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-merge-base - Encontre o melhor ancestral comum possível para uma mesclagem</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resumo"><a class="anchor" href="#_resumo"></a>RESUMO</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git merge-base</em> [-a | --all] &lt;commit&gt; &lt;commit&gt;&#8230;&#8203;
<em>git merge-base</em> [-a | --all] --octopus &lt;commit&gt;&#8230;&#8203;
<em>git merge-base</em> --is-ancestor &lt;commit&gt; &lt;commit&gt;
<em>git merge-base</em> --independent &lt;commit&gt;&#8230;&#8203;
<em>git merge-base</em> --fork-point &lt;ref&gt; [&lt;commit&gt;]</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_descrição"><a class="anchor" href="#_descrição"></a>DESCRIÇÃO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O comando <em>git merge-base</em> encontra o(s) melhor(es) ancestral(is) comum(is) entre dois commits para usar numa mesclagem de três vias. Um ancestral comum é <em>melhor</em> do que outro ancestral comum se o último for um ancestral do primeiro. Um ancestral comum que não tem nenhum ancestral comum melhor é um <em>melhor ancestral comum</em>, ou seja, uma <em>mesclagem da base</em>. Observe que pode haver mais de uma mesclagem da base para um par de commits.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_modos_de_operação"><a class="anchor" href="#_modos_de_operação"></a>MODOS DE OPERAÇÃO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>No caso especial mais comum, utilizar apenas dois commits na linha de comando significa calcular a base de mesclagem entre os dois commits informados.</p>
</div>
<div class="paragraph">
<p>De maneira mais geral, entre os dois commits para fazer cálculo na base de mesclagem, um é definido pelo primeiro argumento do commit na linha de comando; o outro commit é um commit (possivelmente hipotético) que é uma mesclagem entre todos os demais commits na linha de comando.</p>
</div>
<div class="paragraph">
<p>Como consequência, o <em>merge base</em> (a base da mesclagem) não está necessariamente contida em cada uma das opções do commit caso mais de dois commits forem informadas. Isso é diferente do <a href='{{< relurl "docs/git-show-branch/pt_BR" >}}'>git-show-branch[1]</a> quando utilizado com a opção <code>--merge-base</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-merge-base---octopus"> <a class="anchor" href="#git-merge-base---octopus"></a>--octopus </dt>
<dd>
<p>Calcule os melhores ancestrais comuns de todos os commits informados, em preparação para uma mesclagem de n vias. Isso imita o comportamento do comando <em>git show-branch --merge-base</em>.</p>
</dd>
<dt class="hdlist1" id="git-merge-base---independent"> <a class="anchor" href="#git-merge-base---independent"></a>--independent </dt>
<dd>
<p>Em vez de imprimir a mesclagem das bases, imprima um subconjunto mínimo dos commits informados que possuam os mesmos ancestrais. Em outras palavras, entre os commits informados, liste aqueles que não podem ser acessados de nenhuma outra maneira. Isso imita o comportamento do comando <em>git show-branch --independent</em>.</p>
</dd>
<dt class="hdlist1" id="git-merge-base---is-ancestor"> <a class="anchor" href="#git-merge-base---is-ancestor"></a>--is-ancestor </dt>
<dd>
<p>Verifica se o primeiro <code>&lt;commit&gt;</code> é um ancestral do segundo <code>&lt;commit&gt;</code> e sai com o status 0, se for verdadeiro, ou com o status 1, se não for. Os erros são sinalizados por uma condição diferente de zero que não seja 1.</p>
</dd>
<dt class="hdlist1" id="git-merge-base---fork-point"> <a class="anchor" href="#git-merge-base---fork-point"></a>--fork-point </dt>
<dd>
<p>Localize o ponto onde uma ramificação (ou qualquer histórico que leve a <code>&lt;commit&gt;</code>) foi bifurcada de outra ramificação (ou qualquer referência) <code>&lt;ref&gt;</code>. Isso não apenas procura pelo ancestral comum dos dois commits, mas também leva em consideração o reflog de <code>&lt;ref&gt;</code> para ver se o histórico que leva ao <code>&lt;commit&gt;</code> foi bifurcado de uma encarnação anterior do ramo <code>&lt;ref&gt;</code> (consulte a discussão deste modo logo abaixo).</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_opções"><a class="anchor" href="#_opções"></a>OPÇÕES</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-merge-base--a"> <a class="anchor" href="#git-merge-base--a"></a>-a </dt>
<dt class="hdlist1" id="git-merge-base---all"> <a class="anchor" href="#git-merge-base---all"></a>--all </dt>
<dd>
<p>Gere todas as bases da mesclagem para os commits em vez de apenas um.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_discussão"><a class="anchor" href="#_discussão"></a>DISCUSSÃO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Dado dois commits <em>A</em> e <em>B</em>, o <code>git merge-base A B</code> produzirá um commit que pode ser acessado a partir de <em>A</em> e <em>B</em> através do relacionamento com a origem.</p>
</div>
<div class="paragraph">
<p>Por exemplo, com esta topologia:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>	 o---o---o---B
	/
---o---1---o---o---o---A</pre>
</div>
</div>
<div class="paragraph">
<p>a base de mesclagem entre <em>A</em> e <em>B</em> é <em>1</em>.</p>
</div>
<div class="paragraph">
<p>Dados três commits <em>A</em>, <em>B</em> e <em>C</em>, o <code>git merge-base A B C</code> calculará a base de mesclagem entre <em>A</em> e um commit hipotético <em>M</em>, que é uma mesclagem entre <em>B</em> e <em>C</em>. Por exemplo, com esta topologia:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>       o---o---o---o---C
      /
     /   o---o---o---B
    /   /
---2---1---o---o---o---A</pre>
</div>
</div>
<div class="paragraph">
<p>O resultado do comando <code>git merge-base A B C</code> é <em>1</em>. Isso ocorre porque a topologia equivalente com um commit mesclado "M" entre "B" e "C" é:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>       o---o---o---o---o
      /                 \
     /   o---o---o---o---M
    /   /
---2---1---o---o---o---A</pre>
</div>
</div>
<div class="paragraph">
<p>E o resultado do comando <code>git merge-base A M</code> é <em>1</em>. O commit <em>2</em> também é um ancestral comum entre <em>A</em> e <em>M</em>, mas <em>1</em> é um ancestral comum melhor, porque <em>2</em> é um ancestral de <em>1</em>. Aassim, <em>2</em> não é a base de mesclagem.</p>
</div>
<div class="paragraph">
<p>O resultado do <code>git merge-base --octopus A B C</code> é <em>2</em>, porque <em>2</em> é o melhor ancestral comum de todos os commits.</p>
</div>
<div class="paragraph">
<p>Quando o histórico envolve mesclagens cruzadas, pode haver mais de um "melhor" ancestral comum para os dois commits. Por exemplo, com esta topologia:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>---1---o---A
    \ /
     X
    / \
---2---o---o---B</pre>
</div>
</div>
<div class="paragraph">
<p>Tanto <em>1</em> quanto <em>2</em> são bases de mesclagem de A e B. Nenhuma delas é melhor que a outra (ambas são as "melhores" bases de mesclagem). Quando a opção <code>--all</code> não é usada, não é especificado qual é o melhor resultado.</p>
</div>
<div class="paragraph">
<p>Uma linguagem comum para verificar o "avanço rápido" entre dois commits A e B é (ou pelo menos costumava ser) computar a base de mesclagem entre A e B e verificar se ela é igual a A; nesse caso, A é um ancestral de B. Você verá essa linguagem usada com frequência em scripts mais antigos.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A=$(git rev-parse --verify A)
if test "$A" = "$(git merge-base A B)"
then
	... A é um ancestral do B ...
fi</pre>
</div>
</div>
<div class="paragraph">
<p>No git moderno, você pode dizer isso de uma maneira mais direta:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>if git merge-base --is-ancestor A B
then
	... A é um ancestral do B ...
fi</pre>
</div>
</div>
<div class="paragraph">
<p>em vez disso.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_discussão_sobre_o_modo_do_ponto_de_forquilha"><a class="anchor" href="#_discussão_sobre_o_modo_do_ponto_de_forquilha"></a>Discussão sobre o modo do ponto de forquilha</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Depois de trabalhar no ramo <code>topic</code> criado com o comando <code>git switch -c topic origin/master</code>, o histórico do ramo monitorado remotamente <code>origin/master</code> pode ter sido retrocedido e reconstruído, levando a um histórico desta forma:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>		 o---B2
		/
---o---o---B1--o---o---o---B (origin/master)
	\
	 B0
	  \
	   D0---D1---D (topic)</pre>
</div>
</div>
<div class="paragraph">
<p>Onde <code>origin/master</code> costumava apontar para os commits B0, B1, B2 e agora aponta para B, e seu ramo <code>topic</code> foi iniciado sobre ele quando <code>origin/master</code> estava em B0, e você construiu três commits, D0, D1 e D, sobre ele. Imagine que agora você queira fazer o rebase do trabalho que fez no tópico sobre a origem/mestre atualizada.</p>
</div>
<div class="paragraph">
<p>Nesse caso o comando &#8216;git merge-base origin/master topic&#8217; retornaria a inicial do <em>B0</em> na imagem acima, porém <em>B0^..D</em> <strong>não é</strong> o intervalo dos commits que você deseja reproduzir em cima do <em>B</em> ( inclui <em>B0</em>, que não é o que você escreveu; é um commit que o outro lado descartou quando mudou o seu cume de <em>B0</em> para <em>B1</em>).</p>
</div>
<div class="paragraph">
<p>O <code>git merge-base --fork-point origin/master topic</code> foi projetado para ajudar nesse caso. Ele leva em conta não apenas B, mas também B0, B1 e B2 (ou seja, dicas antigas das ramificações de rastreamento remoto que o reflog do seu repositório conhece) para ver em qual commit a ramificação do seu tópico foi criada e encontra B0, permitindo que você reproduza apenas os commits no seu tópico, excluindo os commits que o outro lado descartou posteriormente.</p>
</div>
<div class="paragraph">
<p>Consequentemente</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ fork_point=$(git merge-base --fork-point origin/master topic)</pre>
</div>
</div>
<div class="paragraph">
<p>irá encontrar <em>B0</em> e</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ git rebase --onto origin/master $fork_point topic</pre>
</div>
</div>
<div class="paragraph">
<p>repetirá <em>D0</em>, <em>D1</em> e <em>D</em> em cima do <em>B</em> para criar um novo histórico dessa forma:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>		 o---B2
		/
---o---o---B1--o---o---o---B (origin/master)
	\                   \
	 B0                  D0'--D1'--D' (topic - updated)
	  \
	   D0---D1---D (topic - old)</pre>
</div>
</div>
<div class="paragraph">
<p>Uma ressalva é que as entradas de reflog mais antigas em seu repositório podem ser expiradas pelo <code>git gc</code>. Se o B0 não aparecer mais no reflog do ramo de rastreamento remoto <code>origin/master</code>, o modo <code>--fork-point</code> obviamente não conseguirá encontrá-lo e falhará, evitando fornecer um resultado aleatório e inútil (como o pai do B0, como o mesmo comando sem a opção <code>--fork-point</code> fornece).</p>
</div>
<div class="paragraph">
<p>Além disso, o ramo rastreado remotamente onde você usa o modo <code>--fork-point</code> deve ser aquele onde o tópico foi bifurcado a partir do cume. Se você bifurcou a partir de um commit mais antigo do que o cume, esse modo não encontrará o ponto de bifurcação (imagine que no exemplo de histórico acima, B0 não existia, origin/master começou em B1, mudou-se para B2 e depois B, e você bifurcou em origin/master^ quando origin/master era B1; a forma do histórico seria a mesma que a anterior, sem B0, e o pai de B1 é o que o <code>git merge-base origin/master topic</code> encontra corretamente, mas o modo <code>--fork-point</code> não, porque não é um dos commits que costumava estar na ponta do origin/master).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_consulte_também"><a class="anchor" href="#_consulte_também"></a>Consulte também</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href='{{< relurl "docs/git-rev-list/pt_BR" >}}'>git-rev-list[1]</a>, <a href='{{< relurl "docs/git-show-branch/pt_BR" >}}'>git-show-branch[1]</a>, <a href='{{< relurl "docs/git-merge/pt_BR" >}}'>git-merge[1]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Parte do conjunto <a href='{{< relurl "docs/git/pt_BR" >}}'>git[1]</a></p>
</div>
</div>
</div>