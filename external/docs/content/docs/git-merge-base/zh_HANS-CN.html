---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-merge-base Documentation
docname: git-merge-base
lang: zh_HANS-CN
aliases:
- "/docs/git-merge-base/zh_HANS-CN/index.html"
---
<div class="sect1">
<h2 id="_名称"><a class="anchor" href="#_名称"></a>名称</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-merge-base - 为合并找到尽可能好的共同祖先</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_概述"><a class="anchor" href="#_概述"></a>概述</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git merge-base</em> [-a | --all] &lt;提交&gt; &lt;提交&gt;&#8230;&#8203;
<em>git merge-base</em> [-a | --all] --octopus &lt;提交&gt;&#8230;&#8203;
<em>git merge-base</em> --is-ancestor &lt;提交&gt; &lt;提交&gt;
<em>git merge-base</em> --independent &lt;提交&gt;&#8230;&#8203;
<em>git merge-base</em> --fork-point &lt;引用&gt; [&lt;提交&gt;]</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_描述"><a class="anchor" href="#_描述"></a>描述</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>git merge-base</em> 会找出两个提交之间的最佳共同祖先，用于三方合并。 如果一个公共祖先是另一个公共祖先的祖先，那么后者就比前者 “更好”。 没有更好的共同祖先的共同祖先就是 “最佳共同祖先”，即 “合并基础”。 请注意，一对提交可以有多个合并基础。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_运行模式"><a class="anchor" href="#_运行模式"></a>运行模式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在最常见的特殊情况下，在命令行中只指定两个提交，意味着要计算给定的两个提交之间的合并基数。</p>
</div>
<div class="paragraph">
<p>一般来说，在计算合并基础的两个提交中，一个由命令行上的第一个提交参数指定；另一个提交是一个（可能是假设的）提交，是命令行上所有剩余提交的合并。</p>
</div>
<div class="paragraph">
<p>因此，如果指定了两个以上的提交，‘合并基础’ 并不一定包含在每个提交参数中。当使用 <code>--merge-base</code> 选项的时候，这不同于 <a href='{{< relurl "docs/git-show-branch/zh_HANS-CN" >}}'>git-show-branch[1]</a>。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-merge-base---octopus"> <a class="anchor" href="#git-merge-base---octopus"></a>--octopus </dt>
<dd>
<p>计算所有提交的最佳公共祖先，为 n 次合并做准备。 这模仿了 <em>git show-branch --merge-base</em> 的行为。</p>
</dd>
<dt class="hdlist1" id="git-merge-base---independent"> <a class="anchor" href="#git-merge-base---independent"></a>--independent </dt>
<dd>
<p>与其打印合并库，不如打印所提供的具有相同祖先的提交的最小子集。 换句话说，在给出的提交中，列出那些无法从其他提交到达的提交。 这模仿了 <em>git show-branch&#8212;&#8203;independent</em> 的行为。</p>
</dd>
<dt class="hdlist1" id="git-merge-base---is-ancestor"> <a class="anchor" href="#git-merge-base---is-ancestor"></a>--is-ancestor </dt>
<dd>
<p>检查第一个 &lt;提交&gt; 是否是第二个 &lt;提交&gt; 的祖先，如果是，则以状态 0 退出；如果不是，则以状态 1 退出。 如果状态不是 0，则表示出错。</p>
</dd>
<dt class="hdlist1" id="git-merge-base---fork-point"> <a class="anchor" href="#git-merge-base---fork-point"></a>--fork-point </dt>
<dd>
<p>查找一个分支（或导致 &lt;提交&gt; 的任何历史）从另一个分支（或任何引用）&lt;引用&gt; 分支出去的时间点。这不仅仅是查找两个提交的共同祖先，而且还要考虑 &lt;引用&gt; 的引用日志，以查看导致 &lt;提交&gt; 的历史是否从分支 &lt;引用&gt; 的早期化身分叉而来（请参阅下文对该模式的讨论）。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_选项"><a class="anchor" href="#_选项"></a>选项</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-merge-base--a"> <a class="anchor" href="#git-merge-base--a"></a>-a </dt>
<dt class="hdlist1" id="git-merge-base---all"> <a class="anchor" href="#git-merge-base---all"></a>--all </dt>
<dd>
<p>输出提交的所有合并基础，而不是只有一个。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_讨论"><a class="anchor" href="#_讨论"></a>讨论</h2>
<div class="sectionbody">
<div class="paragraph">
<p>给定两个提交 <em>A</em> 和 <em>B</em>，<code>git merge-base A B</code> 会输出一个通过父级关系从 <em>A</em> 和 <em>B</em> 都能到达的提交。</p>
</div>
<div class="paragraph">
<p>例如，采用这种拓扑结构：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>	 o---o---o---B
	/
---o---1---o---o---o---A</pre>
</div>
</div>
<div class="paragraph">
<p><em>A</em> 和 <em>B</em> 之间的合并基数为 <em>1</em>。</p>
</div>
<div class="paragraph">
<p>给定三个提交 <em>A</em> 、<em>B</em> 和 <em>C</em>， <code>git merge-base A B C</code> 会计算 <em>A</em> 和假设提交 <em>M</em> 之间的合并基础，<em>M</em> 是 <em>B</em> 和 <em>C</em> 之间的合并。 例如这个拓扑：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>       o---o---o---o---C
      /
     /   o---o---o---B
    /   /
---2---1---o---o---o---A</pre>
</div>
</div>
<div class="paragraph">
<p><code>git merge-base A B C</code> 的结果是 <em>1</em>。 这是因为 <em>B</em> 和 <em>C</em> 之间有一个合并提交 <em>M</em> 的等效拓扑结构是：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>       o---o---o---o---o
      /                 \
     /   o---o---o---o---M
    /   /
---2---1---o---o---o---A</pre>
</div>
</div>
<div class="paragraph">
<p>和 <code>git merge-base A M</code> 的结果是 <em>1</em> 。 提交 <em>2</em> 也是 <em>A</em> 和 <em>M</em> 的共同祖先，但 <em>1</em> 是更好的共同祖先，因为 <em>2</em> 是 <em>1</em> 的祖先。 因此，<em>2</em> 不是合并基础。</p>
</div>
<div class="paragraph">
<p><code>git merge-base --octopus A B C</code> 的结果是 <em>2</em> ，因为 <em>2</em> 是所有提交的最佳共同祖先。</p>
</div>
<div class="paragraph">
<p>当历史涉及交叉合并时，两个提交的 ‘最佳’ 共同祖先可能不止一个。 例如这个拓扑：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>---1---o---A
    \ /
     X
    / \
---2---o---o---B</pre>
</div>
</div>
<div class="paragraph">
<p><em>1</em> 和 <em>2</em> 都是 A 和 B 的合并基础。 如果没有给出 <code>--all</code> 选项，则不会指定输出哪个是最好的。</p>
</div>
<div class="paragraph">
<p>检查两个提交 A 和 B 之间的 “快进性” 的一个常见习语是（或至少曾经是）计算 A 和 B 之间的合并基数，并检查它是否与 A 相同，在这种情况下，A 就是 B 的祖先。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>A=$(git rev-parse --verify A)
if test "$A" = "$(git merge-base A B)"
then
	... A 是 B 的一个祖先 ...
fi</pre>
</div>
</div>
<div class="paragraph">
<p>在现代 Git 中，可以用更直接的方式来表达：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>if git merge-base --is-ancestor A B
then
	... A 是 B 的一个祖先 ...
fi</pre>
</div>
</div>
<div class="paragraph">
<p>代替。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_关于叉点模式的讨论"><a class="anchor" href="#_关于叉点模式的讨论"></a>关于叉点模式的讨论</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在使用 <code>git switch -c topic origin/master</code> 创建的 <code>topic</code> 分支上工作后，远程跟踪分支 <code>origin/master</code> 的历史可能会被倒带和重建，从而导致出现这种形状的历史：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>		 o---B2
		/
---o---o---B1--o---o---o---B (origin/master)
	\
	 B0
	  \
	   D0---D1---D (topic)</pre>
</div>
</div>
<div class="paragraph">
<p>其中，<code>origin/master</code> 曾指向 B0、B1 和 B2 提交，现在则指向 B，而您的 <code>topic</code> 分支是在 <code>origin/master</code> 指向 B0 时在其上创建的，您在其上创建了 D0、D1 和 D 三个提交。 想象一下，你现在想在更新后的 origin/master 分支上重建你在主题上所做的工作。</p>
</div>
<div class="paragraph">
<p>在这种情况下，<code>git merge-base origin/master topic</code> 会返回上图中 B0 的父提交，但 B0^..D 并 <strong>不是</strong> 你想在 B 上重放的提交范围（它包括 B0，而 B0 并不是你写的内容；它是另一个提交从 B0 移到 B1 时丢弃的提交）。</p>
</div>
<div class="paragraph">
<p><code>git merge-base --fork-point origin/master topic</code> 就是为这种情况而设计的。 它不仅会考虑 B，还会考虑 B0、B1 和 B2（即仓库的引用日志所知道的远程跟踪分支的旧提示），以查看你的特性分支是在哪个提交上建立的，并找到 B0，从而只重放你的特性上的提交，而不包括对方后来丢弃的提交。</p>
</div>
<div class="paragraph">
<p>因此</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ fork_point=$(git merge-base --fork-point origin/master topic)</pre>
</div>
</div>
<div class="paragraph">
<p>会发现 B0，而</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ git rebase --onto origin/master $fork_point topic</pre>
</div>
</div>
<div class="paragraph">
<p>将在 B 的基础上重放 D0、D1 和 D，以创建该形状的新历史：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>		 o---B2
		/
---o---o---B1--o---o---o---B (origin/master)
	\                   \
	 B0                  D0'--D1'--D' (topic - updated)
	  \
	   D0---D1---D (topic - old)</pre>
</div>
</div>
<div class="paragraph">
<p>需要注意的是，仓库中较早的引用日志条目可能会被 <code>git gc</code> 过期。 如果 B0 不再出现在远程跟踪分支 <code>origin/master</code> 的引用日志中，<code>--fork-point</code> 模式显然就找不到它，并会失败，从而避免给出一个随机而无用的结果（例如 B0 的父分支，就像不使用 <code>--fork-point</code> 选项的同一命令给出的结果一样）。</p>
</div>
<div class="paragraph">
<p>另外，使用 <code>--fork-point</code>（分叉点）"模式的远程跟踪分支必须是你的主题从其顶点分叉出来的分支。 如果你从比顶端更早的提交中分叉，该模式将无法找到分叉点（想象一下，在上面的示例历史中，B0 并不存在，origin/master 从 B1 开始，移动到 B2，然后是 B，而你在 origin/master^ 分叉你的主题时，origin/master 是 B1；B1 的父提交会被 <code>git merge-base origin/master topic</code> 正确找到，但在 `-fork-point`模式下不会，因为它不是 origin/master 最前沿的提交之一）。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_另见"><a class="anchor" href="#_另见"></a>另见</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href='{{< relurl "docs/git-rev-list/zh_HANS-CN" >}}'>git-rev-list[1]</a>, <a href='{{< relurl "docs/git-show-branch/zh_HANS-CN" >}}'>git-show-branch[1]</a>, <a href='{{< relurl "docs/git-merge/zh_HANS-CN" >}}'>git-merge[1]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>属于 <a href='{{< relurl "docs/git/zh_HANS-CN" >}}'>git[1]</a> 文档</p>
</div>
</div>
</div>