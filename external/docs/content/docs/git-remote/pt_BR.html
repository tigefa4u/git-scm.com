---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-remote Documentation
docname: git-remote
lang: pt_BR
aliases:
- "/docs/git-remote/pt_BR/index.html"
---
<div class="sect1">
<h2 id="_nome"><a class="anchor" href="#_nome"></a>NOME</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-remote - Gerencie o conjunto dos repositórios monitorados</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resumo"><a class="anchor" href="#_resumo"></a>RESUMO</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git remote</em> [-v | --verbose]
<em>git remote add</em> [-t &lt;branch&gt;] [-m &lt;master&gt;] [-f] [--[no-]tags] [--mirror=(fetch|push)] &lt;name&gt; &lt;URL&gt;
<em>git remote rename</em> [--[no-]progress] &lt;antigo&gt; &lt;novo&gt;
<em>git remote remove</em> &lt;nome&gt;
<em>git remote set-head</em> &lt;nome&gt; (-a | --auto | -d | --delete | &lt;ramo&gt;)
<em>git remote set-branches</em> [--add] &lt;nome&gt; &lt;ramo&gt;&#8230;&#8203;
<em>git remote get-url</em> [--push] [--all] &lt;nome&gt;
<em>git remote set-url</em> [--push] &lt;nome&gt; &lt;newurl&gt; [&lt;oldurl&gt;]
<em>git remote set-url --add</em> [--push] &lt;nome&gt; &lt;newurl&gt;
<em>git remote set-url --delete</em> [--push] &lt;nome&gt; &lt;URL&gt;
<em>git remote</em> [-v | --verbose] <em>show</em> [-n] &lt;nome&gt;&#8230;&#8203;
<em>git remote prune</em> [-n | --dry-run] &lt;nome&gt;&#8230;&#8203;
<em>git remote</em> [-v | --verbose] <em>update</em> [-p | --prune] [(&lt;grupo&gt; | &lt;remoto&gt;)&#8230;&#8203;]</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_descrição"><a class="anchor" href="#_descrição"></a>DESCRIÇÃO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Gerencie o conjunto de repositórios ("remotos") cujos ramos você monitora.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_opções"><a class="anchor" href="#_opções"></a>OPÇÕES</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-remote--v"> <a class="anchor" href="#git-remote--v"></a>-v </dt>
<dt class="hdlist1" id="git-remote---verbose"> <a class="anchor" href="#git-remote---verbose"></a>--verbose </dt>
<dd>
<p>Be a little more verbose and show remote url after name. For promisor remotes, also show which filters (<code>blob:none</code> etc.) are configured. NOTE: This must be placed between <code>remote</code> and subcommand.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comandos"><a class="anchor" href="#_comandos"></a>COMANDOS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sem argumentos, mostra uma lista de controles remotos existentes. Vários subcomandos estão disponíveis para realizar operações nos servidores remotos.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-remote-emaddem"> <a class="anchor" href="#git-remote-emaddem"></a><em>add</em> </dt>
<dd>
<p>Adicione um servidor remoto chamado &lt;nome&gt; para o repositório na &lt;URL&gt;. O comando <code>git fetch &lt;nome&gt;</code> pode então ser usado para criar e para atualizar as ramificações rastreadas remotamente &lt;nome&gt;/&lt;ramo&gt;.</p>
<div class="paragraph">
<p>Com a opção <code>-f</code>, o comando <code>git fetch &lt;nome&gt;</code> é executado imediatamente a informação remota seja configurada.</p>
</div>
<div class="paragraph">
<p>Com a opção <code>--tags</code>, o <code>git fetch &lt;nome&gt;</code> importa cada tag do repositório remoto.</p>
</div>
<div class="paragraph">
<p>Com a opção <code>--no-tags</code>, o <code>git fetch &lt;nome&gt;</code> não importa as tags do repositório remoto.</p>
</div>
<div class="paragraph">
<p>É predefinido que apenas as tags recolhidas dos ramos são importadas (consulte <a href='{{< relurl "docs/git-fetch/pt_BR" >}}'>git-fetch[1]</a>).</p>
</div>
<div class="paragraph">
<p>Com a opção <code>-t &lt;ramo&gt;</code>, em vez da bolha refspec predefinida para o servidor remoto de todas as ramificações no namespace <code>refs/remotes/&lt;nome&gt;/</code>, é criado um refspec para controlar apenas o <code>&lt;ramo&gt;</code>. Você pode fornecer mais de um <code>-t &lt;ramo&gt;</code> para rastrear várias ramificações sem obter todas elas.</p>
</div>
<div class="paragraph">
<p>Com a opção <code>-m &lt;master&gt;</code>, uma "ref" simbólica <code>refs/remotes/&lt;nome&gt;/HEAD</code> é configurado para apontar para o ramo <code>&lt;master&gt;</code> do ramo remoto. Veja também o comando <code>set-head</code>.</p>
</div>
<div class="paragraph">
<p>Quando um espelho de busca é criado com a opção <code>--mirror=fetch</code>, as refs não serão armazenados no espaço de nomes <em>refs/remotes/</em>, porém tudo nas <em>refs/</em> no ramo remoto será espelhado diretamente na <em>refs/</em> em o repositório local. Esta opção faz sentido apenas nos repositórios vazios, porque uma busca substituirá quaisquer commits locais.</p>
</div>
<div class="paragraph">
<p>Quando um espelho "push" é criado com a opção <code>--mirror=push</code>, então o comando <code>git push</code> sempre se comportará como se o <code>--mirror</code> fosse utilizado.</p>
</div>
</dd>
<dt class="hdlist1" id="git-remote-emrenameem"> <a class="anchor" href="#git-remote-emrenameem"></a><em>rename</em> </dt>
<dd>
<p>Renomeie o ramo remoto chamado <code>&lt;old&gt;</code> para <code>&lt;novo&gt;</code>. Todos os ramos monitorados remotamente e as suas definições de configuração para o ramo remoto são atualizados.</p>
<div class="paragraph">
<p>Caso &lt;antigo&gt; e &lt;novo&gt; sejam iguais, e &lt;old&gt; seja um arquivo existente no <code>$GIT_DIR/remotes</code> ou <code>$GIT_DIR/branches</code>, o ramo remoto será convertido para o formato do arquivo de configuração.</p>
</div>
</dd>
<dt class="hdlist1" id="git-remote-emremoveem"> <a class="anchor" href="#git-remote-emremoveem"></a><em>remove</em> </dt>
<dt class="hdlist1" id="git-remote-emrmem"> <a class="anchor" href="#git-remote-emrmem"></a><em>rm</em> </dt>
<dd>
<p>Remova o ramo remoto chamado <code>&lt;nome&gt;</code>. Todos os ramos monitorados remotamente e as suas definições de configuração para o ramo remoto são atualizados.</p>
</dd>
<dt class="hdlist1" id="git-remote-emset-headem"> <a class="anchor" href="#git-remote-emset-headem"></a><em>set-head</em> </dt>
<dd>
<p>Define ou exclui o ramo predefinido (ou seja, o destino da ref simbólica <code>refs/remotes/&lt;nome&gt;/HEAD</code>) do ramo remoto informado. Não é necessário ter um ramo remoto predefinido para o ramo remoto, porém permite que o nome do ramo remoto seja utilizado no lugar de um ramo específico. Como por exemplo, caso o ramo predefinido para <code>origin</code> estiver definido como <code>master</code>, então <code>origin</code> poderá ser definido onde quer que você normalmente definiria <code>origin/master</code>.</p>
<div class="paragraph">
<p>Com <code>-d</code> ou <code>--delete</code>, a referência simbólica <code>refs/remotes/&lt;nome&gt;/HEAD</code> é excluída.</p>
</div>
<div class="paragraph">
<p>Com <code>-a</code> ou <code>--auto</code>, o ramo remoto é consultado para determinar o seu <code>HEAD</code>, então a referência simbólica <code>refs/remotes/&lt;nome&gt;/HEAD</code> é definida no mesmo ramo. Como por exemplo, caso o <code>HEAD</code> remoto aponte para <code>next</code>, o comando <code>git remote set-head origin -a</code> definirá a referência remota <code>refs/remotes/origin/HEAD</code> para <code>refs/remotes/origin/next</code>. Isso só funcionará caso o <code>refs/remotes/origin/next</code> já existir; caso contrário, deve ser buscado (fetched) primeiro.</p>
</div>
<div class="paragraph">
<p>Utilize o <code>&lt;ramo&gt;</code> para definir explicitamente a referência simbólica <code>refs/remotes/&lt;nome&gt;/HEAD</code>. Como por exemplo, o comando <code>git remote set-head origin master</code> definirá a referência remota <code>refs/remotes/origin/HEAD</code> para <code>refs/remotes/origin/master</code>. Isso só funcionará caso o <code>refs/remotes/origin/master</code> já existir; caso contrário, deve ser buscado (fetched) primeiro.</p>
</div>
</dd>
<dt class="hdlist1" id="git-remote-emset-branchesem"> <a class="anchor" href="#git-remote-emset-branchesem"></a><em>set-branches</em> </dt>
<dd>
<p>Altera a lista das ramificações rastreadas pelo servidor remoto informado. Isso pode ser usado para rastrear um subconjunto das ramificações remotas disponíveis após a configuração inicial de um servidor remoto.</p>
<div class="paragraph">
<p>Os ramos informados serão interpretados como se fossem definidos com a opção <code>-t</code> na linha de comando <code>git remote add</code>.</p>
</div>
<div class="paragraph">
<p>Com <code>--add</code>, em vez de substituir a lista das ramificações monitoradas no momento, será adicionada a lista.</p>
</div>
</dd>
<dt class="hdlist1" id="git-remote-emget-urlem"> <a class="anchor" href="#git-remote-emget-urlem"></a><em>get-url</em> </dt>
<dd>
<p>Recupera as URLs para um ramo remoto. As configurações para o <code>ratherOf</code> e <code>pushInsteadOf</code> são expandidas aqui. É predefinido que, apenas a primeira URL é listada.</p>
<div class="paragraph">
<p>Com o <code>--push</code>, as URLs <em>push</em> são apenas consultadas em vez de buscar as URLs.</p>
</div>
<div class="paragraph">
<p>Com <code>--all</code>, todas as URLs para o ramo remoto serão listadas.</p>
</div>
</dd>
<dt class="hdlist1" id="git-remote-emset-urlem"> <a class="anchor" href="#git-remote-emset-urlem"></a><em>set-url</em> </dt>
<dd>
<p>Altera as URLs para o ramo remoto. Define a primeira URL para o &lt;nome&gt; remoto que coincida com à regex &lt;oldurl&gt; (primeira URL caso nenhuma &lt;oldurl&gt; seja informada) como &lt;newurl&gt;. Caso &lt;oldurl&gt; não coincida com nenhuma URL, ocorrerá um erro e nada será alterado.</p>
<div class="paragraph">
<p>Com o <code>--push</code>, as URLs <em>push</em> são manipuladas em vez de buscar as URLs.</p>
</div>
<div class="paragraph">
<p>Com <code>--add</code>, em vez de alterar as URLs existentes, uma nova URL é adicionada.</p>
</div>
<div class="paragraph">
<p>Com a opção <code>--delete</code>, em vez de alterar as URLs já existentes, todas as URLs que correspondem ao regex &lt;URL&gt; são excluídas para o &lt;nome&gt; remoto. É um erro a tentativa de excluir todos os URLs que não sejam do <code>push</code>.</p>
</div>
<div class="paragraph">
<p>Observe que a URL de envio e a URL de busca, mesmo que possam ser definidos de maneiras diferente, ainda devem se referir ao mesmo local. O que você enviou para a URL de envio deve ser o que você veria se obtivesse imediatamente a partir da URL obtida. Se estiver tentando obter de um lugar (do seu "upstream" por exemplo) e enviar para outro (o seu repositório de publicação por exemplo), use dois servidores remotos separados.</p>
</div>
</dd>
<dt class="hdlist1" id="git-remote-emshowem"> <a class="anchor" href="#git-remote-emshowem"></a><em>show</em> </dt>
<dd>
<p>Fornece algumas informações sobre o ramo remoto &lt;nome&gt;.</p>
<div class="paragraph">
<p>Com a opção <code>-n</code>, os cabeçalhos remotos não são consultadas primeiro com o comando <code>git ls-remote &lt;nome&gt;</code>; em vez disso são utilizadas as informações em cache.</p>
</div>
</dd>
<dt class="hdlist1" id="git-remote-empruneem"> <a class="anchor" href="#git-remote-empruneem"></a><em>prune</em> </dt>
<dd>
<p>Exclui as referências antigas associadas com &lt;nome&gt;. É predefinido que as ramificações antigas monitoradas remotamente sob &lt;nome&gt; são excluídas, porém, dependendo da configuração global e da configuração do ramo remoto, podemos até remover as tags locais que não foram enviadas para lá. É o equivalente ao comando <code>git fetch --prune &lt;nome&gt;</code>, exceto que nenhuma nova referência será buscada.</p>
<div class="paragraph">
<p>Veja a seção <em>PRUNING</em> do <a href='{{< relurl "docs/git-fetch/pt_BR" >}}'>git-fetch[1]</a> para saber o que será removido dependendo das várias configurações.</p>
</div>
<div class="paragraph">
<p>Com a opção <code>--dry-run</code>, relate quais os ramos poderão ser eliminados, mas na verdade não os eliminem.</p>
</div>
</dd>
<dt class="hdlist1" id="git-remote-emupdateem"> <a class="anchor" href="#git-remote-emupdateem"></a><em>update</em> </dt>
<dd>
<p>Traga as atualizações para os servidores remotos ou os grupos remotos no repositório, conforme for definido por <code>remotes.&lt;grupo&gt;</code>. Se nem o grupo nem o servidor remoto forem especificados na linha de comando, o parâmetro de configuração <code>remotes.default</code> será utilizado; se <code>remotes.default</code> não for definido, todos os servidores remotos que não tiverem o parâmetro de configuração <code>remote.&lt;nome&gt;.skipDefaultUpdate</code> definido como <code>true</code> serão atualizados. (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>).</p>
<div class="paragraph">
<p>Com a opção <code>--prune</code>, execute a poda em todos os ramos remotos que estão atualizados.</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_discussão"><a class="anchor" href="#_discussão"></a>DISCUSSÃO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A configuração remota é obtida usando as variáveis de configuração <code>remote.origin.url</code> e <code>remote.origin.fetch</code>. (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_condição_de_encerramento"><a class="anchor" href="#_condição_de_encerramento"></a>CONDIÇÃO DE ENCERRAMENTO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Em casos bem sucedidos o estatus de saída é <code>0</code>.</p>
</div>
<div class="paragraph">
<p>Quando subcomandos como <em>add</em>, <em>rename</em>, e <em>remove</em> não conseguem encontrar o ramo remoto em questão, o status encerra com <code>2</code>. Quando o ramo remoto já existir, encerra com <code>3</code>.</p>
</div>
<div class="paragraph">
<p>Com qualquer outro erro, o estado da saída pode ser qualquer outro valor diferente de zero.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_exemplos"><a class="anchor" href="#_exemplos"></a>EXEMPLOS</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Adicione um novo ramo remoto, busque e averigue um ramo dele</p>
<div class="listingblock">
<div class="content">
<pre>$ git remote
origin
$ git branch -r
  origin/HEAD -&gt; origin/master
  origin/master
$ git remote add staging git://git.kernel.org/.../gregkh/staging.git
$ git remote
origin
staging
$ git fetch staging
...
Do git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/staging
 * [new branch]      master     -&gt; staging/master
 * [new branch]      staging-linus -&gt; staging/staging-linus
 * [new branch]      staging-next -&gt; staging/staging-next
$ git branch -r
  origin/HEAD -&gt; origin/master
  origin/master
  staging/master
  staging/staging-linus
  staging/staging-next
$ git switch -c staging staging/master
...</pre>
</div>
</div>
</li>
<li>
<p>Imite o comando <code>git clone</code>, porém monitore apenas os ramos selecionados</p>
<div class="listingblock">
<div class="content">
<pre>$ mkdir project.git
$ cd project.git
$ git init
$ git remote add -f -t master -m master origin git://example.com/git.git/
$ git merge origin</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_veja_também"><a class="anchor" href="#_veja_também"></a>VEJA TAMBÉM</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href='{{< relurl "docs/git-fetch/pt_BR" >}}'>git-fetch[1]</a> <a href='{{< relurl "docs/git-branch/pt_BR" >}}'>git-branch[1]</a> <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Parte do conjunto <a href='{{< relurl "docs/git/pt_BR" >}}'>git[1]</a></p>
</div>
</div>
</div>