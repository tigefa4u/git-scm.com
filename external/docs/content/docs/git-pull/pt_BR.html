---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-pull Documentation
docname: git-pull
lang: pt_BR
aliases:
- "/docs/git-pull/pt_BR/index.html"
---
<div class="sect1">
<h2 id="_nome"><a class="anchor" href="#_nome"></a>NOME</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-pull - Busque e integre-se a outro repositório ou num ramo local</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resumo"><a class="anchor" href="#_resumo"></a>RESUMO</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git pull</em> [&lt;opções&gt;] [&lt;repositório&gt; [&lt;refspec&gt;&#8230;&#8203;]]</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_descrição"><a class="anchor" href="#_descrição"></a>DESCRIÇÃO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Incorpora alterações de um repositório remoto no ramo atual. Se o ramo atual estiver atrás do ramo remoto, então, é predefinido que, ele avançará rapidamente o ramo atual para que corresponda ao ramo remoto. Se o ramo atual e o ramo remoto tiverem divergências, o usuário precisará especificar como reconciliar os ramos divergentes com as opções <code>--rebase</code> ou <code>--no-rebase</code> (ou a opção de configuração correspondente em <code>pull.rebase</code>).</p>
</div>
<div class="paragraph">
<p>Mais precisamente, o comando <code>git pull</code> executa <code>git fetch</code> com os parâmetros determinados e em seguida, dependendo das opções de configuração ou das sinalizações da linha de comando, invocará o comando <code>git rebase</code> ou <code>git merge</code> para conciliar os ramos divergentes.</p>
</div>
<div class="paragraph">
<p>O &lt;repositório&gt; deve ser o nome de um repositório remoto conforme é repassado para <a href='{{< relurl "docs/git-fetch/pt_BR" >}}'>git-fetch[1]</a>. O &lt;refspec&gt; pode nomear uma referência remota arbitrária (o nome de uma etiqueta por exemplo) ou até mesmo uma coleção de referências com ramificações correspondentes rastreadas remotamente (refs/heads/*:refs/remotes/origin/* por exemplo), mas geralmente é o nome de uma ramificação no repositório remoto.</p>
</div>
<div class="paragraph">
<p>Os valores predefinidos para o &lt;repositório&gt; e o &lt;ramo&gt; eles são lidos na configuração "remote" e "merge" do ramo atual, conforme for definido pelo <a href='{{< relurl "docs/git-branch/pt_BR" >}}'>git-branch[1]</a> <code>--track</code>.</p>
</div>
<div class="paragraph">
<p>Suponha que exista o seguinte histórico e o ramo atual seja <code>master</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	  A---B---C master on origin
	 /
    D---E---F---G master
	^
	origin/master no seu repositório</pre>
</div>
</div>
<div class="paragraph">
<p>Em seguida, o comando "<code>git pull</code>" buscará e reproduzirá as alterações do ramo remoto <code>master</code> a partir do momento que divergiu do <code>master</code> local (ou seja, <code>E</code>) até o commit atual (<code>C</code>) no topo do <code>master</code> e registrará o resultado num novo commit, juntamente com os nomes dos dois commits principais e uma mensagem de registro log do usuário descrevendo as alterações.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	  A---B---C origin/master
	 /         \
    D---E---F---G---H master</pre>
</div>
</div>
<div class="paragraph">
<p>Para mais detalhes incluindo informações de como os conflitos são gerenciados e como eles são exibidos, consulte <a href='{{< relurl "docs/git-merge/pt_BR" >}}'>git-merge[1]</a>.</p>
</div>
<div class="paragraph">
<p>No Git 1.7.0 ou posterior, para cancelar uma mesclagem conflitante, use o comando <code>git reset --merge</code>. <strong>Aviso</strong>: Nas versões mais antigas do Git, não é recomendável executar o comando <em>git pull</em> com alterações onde o commit não tenha sido feito: embora seja possível, isso o deixa num estado onde pode ser difícil sair em casos de conflitos.</p>
</div>
<div class="paragraph">
<p>Se alguma das alterações remotas se sobrepuser às alterações locais onde o commit não tenha sido feito, a mesclagem será automaticamente cancelada e a árvore de trabalho permanecerá intacta. Em geral, é melhor colocar todas as alterações locais em ordem de funcionamento antes de retirá-las ou armazená-las com <a href='{{< relurl "docs/git-stash/pt_BR" >}}'>git-stash[1]</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_opções"><a class="anchor" href="#_opções"></a>OPÇÕES</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-pull--q"> <a class="anchor" href="#git-pull--q"></a>-q </dt>
<dt class="hdlist1" id="git-pull---quiet"> <a class="anchor" href="#git-pull---quiet"></a>--quiet </dt>
<dd>
<p>Isso é passado para ambos os comandos subjacentes do <code>git-fetch</code> para abafar o relatório do processo durante a transferência assim como do git-merge silenciando sua saída durante a mesclagem.</p>
</dd>
<dt class="hdlist1" id="git-pull--v"> <a class="anchor" href="#git-pull--v"></a>-v </dt>
<dt class="hdlist1" id="git-pull---verbose"> <a class="anchor" href="#git-pull---verbose"></a>--verbose </dt>
<dd>
<p>Encaminhe a opção --verbose para o <em>git-fetch</em> e <em>git-merge</em>.</p>
</dd>
<dt class="hdlist1" id="git-pull---no-recurse-submodulesyeson-demandno"> <a class="anchor" href="#git-pull---no-recurse-submodulesyeson-demandno"></a>--[no-]recurse-submodules[=(yes|on-demand|no)] </dt>
<dd>
<p>Esta opção controla se os novos commits dos submódulos populados devem ser buscados ou não e se as árvore de trabalho dos submódulos ativos devem ser atualizados também (consulte <a href='{{< relurl "docs/git-fetch/pt_BR" >}}'>git-fetch[1]</a>, <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a> e <a href='{{< relurl "docs/gitmodules/pt_BR" >}}'>gitmodules[5]</a>).</p>
<div class="paragraph">
<p>Caso a averiguação seja feita através da reconstrução "rebase", os commits do submódulo local também serão refeitas.</p>
</div>
<div class="paragraph">
<p>Caso a atualização seja feita através de uma mesclagem, os conflitos do sub-módulo serão resolvidos e retirados.</p>
</div>
</dd>
</dl>
</div>
<div class="sect2">
<h3 id="_opções_relacionadas_a_mesclagem"><a class="anchor" href="#_opções_relacionadas_a_mesclagem"></a>Opções relacionadas a mesclagem</h3>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-pull---commit"> <a class="anchor" href="#git-pull---commit"></a>--commit </dt>
<dt class="hdlist1" id="git-pull---no-commit"> <a class="anchor" href="#git-pull---no-commit"></a>--no-commit </dt>
<dd>
<p>Execute a mesclagem e faça o commit com o resultado. Esta opção pode ser usada para substituir a opção <code>--no-commit</code>.
Útil apenas quando for mesclar.</p>
<div class="paragraph">
<p>Com a opção <code>--no-commit</code>, executa a mesclagem e para imediatamente antes de criar a mesclagem de um commit, para dar ao usuário a chance de inspecionar e ajustar ainda mais o resultado da mesclagem antes de fazer o commit.</p>
</div>
<div class="paragraph">
<p>Observe que as atualizações de avanço rápido não criam a mesclagem de um commit e, portanto, não há como interromper estas mesclagens com a opção <code>--no-commit</code>. Portanto, se você quiser garantir que o seu ramo não seja alterado ou atualizado pelo comando de mesclagem, use a opção <code>--no-ff</code> com <code>--no-commit</code>.</p>
</div>
</dd>
<dt class="hdlist1" id="git-pull---edit"> <a class="anchor" href="#git-pull---edit"></a>--edit </dt>
<dt class="hdlist1" id="git-pull--e"> <a class="anchor" href="#git-pull--e"></a>-e </dt>
<dt class="hdlist1" id="git-pull---no-edit"> <a class="anchor" href="#git-pull---no-edit"></a>--no-edit </dt>
<dd>
<p>Chame um editor antes de fazer a mesclagem mecânica de um commit bem sucedido para editar ainda mais a mensagem da mesclagem que foi gerada automaticamente, para que o usuário possa explicar e justificar a mesclagem. A opção <code>--no-edit</code> pode ser utilizada para aceitar a mensagem que foi gerada automaticamente (em geral isso é desencorajado).</p>
<div class="paragraph">
<p>Os scripts mais antigos podem depender do comportamento histórico de não permitir que o usuário edite a mensagem do registro log da mesclagem. Eles verão um editor aberto quando executar o <code>git merge</code>. Para facilitar o ajuste destes scripts para o comportamento que foi atualizado, a variável de ambiente <code>GIT_MERGE_AUTOEDIT</code> pode ser definido como <code>no</code> no início deles.</p>
</div>
</dd>
<dt class="hdlist1" id="git-pull---cleanupltmodogt"> <a class="anchor" href="#git-pull---cleanupltmodogt"></a>--cleanup=&lt;modo&gt; </dt>
<dd>
<p>Esta opção determina como a mensagem da mesclagem será limpa antes da confirmação. Para mais detalhes consulte <a href='{{< relurl "docs/git-commit/pt_BR" >}}'>git-commit[1]</a>. Além disso, caso o valor de <code>scissors</code> seja dado ao <em>&lt;mode&gt;</em> , o <code>scissors</code> (tesouras) será anexada ao <code>MERGE_MSG</code> antes de ser repassada para o mecanismo de commit caso exista mesclagens conflitantes.</p>
</dd>
<dt class="hdlist1" id="git-pull---ff-only"> <a class="anchor" href="#git-pull---ff-only"></a>--ff-only </dt>
<dd>
<p>Apenas atualize para o novo histórico se não houver um histórico divergente local. Esta é a predefinição quando nenhum método de reconciliação dos históricos divergentes for fornecido (através das opções <code>--rebase=*</code>).</p>
</dd>
<dt class="hdlist1" id="git-pull---ff"> <a class="anchor" href="#git-pull---ff"></a>--ff </dt>
<dt class="hdlist1" id="git-pull---no-ff"> <a class="anchor" href="#git-pull---no-ff"></a>--no-ff </dt>
<dd>
<p>Ao fazer a mesclagem em vez do rebase, especifica como uma mesclagem é tratada quando o histórico que foi mesclado já for um descendente do histórico atual. Se a mesclagem for solicitada, a opção <code>--ff</code> é o padrão, a menos que a uma etiqueta mesclada esteja anotada (e possivelmente assinada) e que não esteja armazenada em seu lugar natural na hierarquia <code>refs/tags/</code>, caso onde se assume que a opção <code>--no-ff</code> tenha sido usada.</p>
<div class="paragraph">
<p>Com a opção <code>--ff</code>, quando for possível, resolve a mesclagem como um avanço rápido (atualize apenas o ponteiro do ramo para corresponder ao ramo mesclado; e não cria a mesclagem de um commit). Quando não for possível (quando o histórico mesclado não for um descendente do histórico atual), cria a mesclagem de um commit.</p>
</div>
<div class="paragraph">
<p>Com <code>--no-ff</code>, crie um commit da mesclagem em todos os casos, mesmo quando a mesclagem puder ser resolvida como um avanço rápido.</p>
</div>
</dd>
<dt class="hdlist1" id="git-pull--Sltkeyidgt"> <a class="anchor" href="#git-pull--Sltkeyidgt"></a>-S[&lt;keyid&gt;] </dt>
<dt class="hdlist1" id="git-pull---gpg-signltkeyidgt"> <a class="anchor" href="#git-pull---gpg-signltkeyidgt"></a>--gpg-sign[=&lt;keyid&gt;] </dt>
<dt class="hdlist1" id="git-pull---no-gpg-sign"> <a class="anchor" href="#git-pull---no-gpg-sign"></a>--no-gpg-sign </dt>
<dd>
<p>Assine a mesclagem resultante do commit com o GPG. O argumento <code>keyid</code> é opcional e a predefinição retorna para a identidade de quem fez o commit; se utilizado, deve estar anexado a opção sem espaço. A opção <code>--no-gpg-sign</code> é útil para revogar a variável de configuração <code>commit.gpgSign</code> e a anterior <code>--gpg-sign</code>.</p>
</dd>
<dt class="hdlist1" id="git-pull---logltngt"> <a class="anchor" href="#git-pull---logltngt"></a>--log[=&lt;n&gt;] </dt>
<dt class="hdlist1" id="git-pull---no-log"> <a class="anchor" href="#git-pull---no-log"></a>--no-log </dt>
<dd>
<p>Além dos nomes dos ramos, preencha a mensagem do registro log com descrições de uma linha com no máximo &lt;n&gt; commits atuais que estão sendo mesclados. Consulte também <a href='{{< relurl "docs/git-fmt-merge-msg/pt_BR" >}}'>git-fmt-merge-msg[1]</a>.
Útil apenas quando for mesclar.</p>
<div class="paragraph">
<p>Com <em>--no-log</em>, não liste as descrições de uma linha vindas do commits que estão atualmente sendo mescladas.</p>
</div>
</dd>
<dt class="hdlist1" id="git-pull---signoff"> <a class="anchor" href="#git-pull---signoff"></a>--signoff </dt>
<dt class="hdlist1" id="git-pull---no-signoff"> <a class="anchor" href="#git-pull---no-signoff"></a>--no-signoff </dt>
<dd>
<p>Adicione uma linha <code>Signed-off-by</code> de quem fez o commit no final da mensagem de registro do commit. O significado de uma aprovação depende do projeto onde você está fazendo o commit. Por exemplo, ele pode certificar que quem fez o commit tem o direito de enviar o trabalho sob a licença do projeto ou concorda com alguma representação do contribuinte, como um certificado de origem do desenvolvedor. (Consulte <a href="https://developercertificate.org" class="bare">https://developercertificate.org</a> para saber qual é a usada pelo kernel do Linux e pelos projetos Git). Consulte a documentação ou a liderança do projeto para onde está contribuindo para compreender como as assinaturas são usadas nesse projeto.</p>
<div class="paragraph">
<p>A opção --no-signoff pode ser usada para contra-ordenar uma opção --signoff anterior na linha de comando.</p>
</div>
</dd>
</dl>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-pull---stat"> <a class="anchor" href="#git-pull---stat"></a>--stat </dt>
<dt class="hdlist1" id="git-pull--n"> <a class="anchor" href="#git-pull--n"></a>-n </dt>
<dt class="hdlist1" id="git-pull---no-stat"> <a class="anchor" href="#git-pull---no-stat"></a>--no-stat </dt>
<dd>
<p>Exiba um "diffstat" no final da mesclagem. O <em>diffstat</em> também é controlado pela opção da configuração merge.stat.</p>
<div class="paragraph">
<p>Com <code>-n</code> ou <code>--no-stat</code>, não mostre o <em>diffstat</em> no final da mesclagem.</p>
</div>
</dd>
<dt class="hdlist1" id="git-pull---squash"> <a class="anchor" href="#git-pull---squash"></a>--squash </dt>
<dt class="hdlist1" id="git-pull---no-squash"> <a class="anchor" href="#git-pull---no-squash"></a>--no-squash </dt>
<dd>
<p>Produz a árvore de trabalho e condição do índice como se uma mesclagem real tivesse acontecido (exceto pelas informações da mesclagem), mas não faz um commit, move o <code>HEAD</code> ou registra o <code>$GIT_DIR/MERGE_HEAD</code> (para fazer com que o próximo comando <code>git commit</code> crie a mesclagem de um commit). Isso permite que você crie um único commit sobre o ramo atual, cujo efeito é o mesmo que mesclar um outro ramo (ou mais, no caso de um "octopus").</p>
<div class="paragraph">
<p>Com a opção <code>--no-squash</code>, execute a mesclagem e faça o commit com o resultado. Esta opção pode ser usada para substituir a opção <code>--squash</code>.</p>
</div>
<div class="paragraph">
<p>Com a opção <code>--squash</code>, a opção <code>--commit</code> não é permitida e irá falhar.</p>
</div>
<div class="paragraph">
<p>Útil apenas quando for mesclar.</p>
</div>
</dd>
<dt class="hdlist1" id="git-pull---no-verify"> <a class="anchor" href="#git-pull---no-verify"></a>--[no-]verify </dt>
<dd>
<p>É predefinido que os ganchos <em>pre-merge</em> e <em>commit-msg</em> sejam executados. Quando a opção <code>--no-verify</code> é usada, isso é ignorado. Consulte também <a href='{{< relurl "docs/githooks/pt_BR" >}}'>githooks[5]</a>.
Útil apenas quando for mesclar.</p>
</dd>
<dt class="hdlist1" id="git-pull--sltestratgiagt"> <a class="anchor" href="#git-pull--sltestratgiagt"></a>-s &lt;estratégia&gt; </dt>
<dt class="hdlist1" id="git-pull---strategyltestratgiagt"> <a class="anchor" href="#git-pull---strategyltestratgiagt"></a>--strategy=&lt;estratégia&gt; </dt>
<dd>
<p>Use a estratégia fornecida de mesclagem; mais de uma pode ser fornecida mais de uma vez para especificá-las na ordem em que devem ser testadas. Se não houver a opção <code>-s</code>, uma lista integrada de estratégias será usada em seu lugar (<code>ort</code> ao mesclar um único <code>HEAD</code>, caso contrário, <code>octopus</code>).</p>
</dd>
<dt class="hdlist1" id="git-pull--Xltopogt"> <a class="anchor" href="#git-pull--Xltopogt"></a>-X &lt;opção&gt; </dt>
<dt class="hdlist1" id="git-pull---strategy-optionltopogt"> <a class="anchor" href="#git-pull---strategy-optionltopogt"></a>--strategy-option=&lt;opção&gt; </dt>
<dd>
<p>Passe a opção específica da estratégia através da estratégia de mesclagem.</p>
</dd>
<dt class="hdlist1" id="git-pull---verify-signatures"> <a class="anchor" href="#git-pull---verify-signatures"></a>--verify-signatures </dt>
<dt class="hdlist1" id="git-pull---no-verify-signatures"> <a class="anchor" href="#git-pull---no-verify-signatures"></a>--no-verify-signatures </dt>
<dd>
<p>Verifique se o commit do cume do ramo lateral que está sendo mesclado está assinado com uma chave válida, ou seja, uma chave que tenha uma UID válida: no modelo de confiança predefinido, isso significa que a chave da assinatura foi assinada por uma chave confiável. Se o commit do cume do ramo secundário não for assinado com uma chave válida, a mesclagem será abortada.</p>
<div class="paragraph">
<p>Útil apenas quando for mesclar.</p>
</div>
</dd>
<dt class="hdlist1" id="git-pull---summary"> <a class="anchor" href="#git-pull---summary"></a>--summary </dt>
<dt class="hdlist1" id="git-pull---no-summary"> <a class="anchor" href="#git-pull---no-summary"></a>--no-summary </dt>
<dd>
<p>É um sinônimos para <code>--stat</code> e <code>--no-stat</code>; estas opções foram descontinuadas e serão removidas no futuro.</p>
</dd>
<dt class="hdlist1" id="git-pull---autostash"> <a class="anchor" href="#git-pull---autostash"></a>--autostash </dt>
<dt class="hdlist1" id="git-pull---no-autostash"> <a class="anchor" href="#git-pull---no-autostash"></a>--no-autostash </dt>
<dd>
<p>Crie automaticamente uma entrada temporária de armazenamento antes do início da operação, registre-a na <em>ref</em> <code>MERGE_AUTOSTASH</code> e aplique-a ao concluir a operação. Isso significa que você pode executar a operação numa árvore de trabalho suja. No entanto, use-o com cuidado: o aplicativo de armazenamento final após uma mesclagem bem-sucedida pode resultar em conflitos não triviais.</p>
</dd>
<dt class="hdlist1" id="git-pull---allow-unrelated-histories"> <a class="anchor" href="#git-pull---allow-unrelated-histories"></a>--allow-unrelated-histories </dt>
<dd>
<p>É predefinido que o comando <code>git merge</code> se recuse a mesclar os históricos que não compartilham de um ancestral comum. Esta opção pode ser usada para substituir este tipo de segurança ao mesclar os históricos de dois projetos que começaram suas vidas de forma independente. Como essa é uma ocasião muito rara, não existe nenhuma variável de configuração para ativar isso por padrão e ela também não será adicionada.</p>
<div class="paragraph">
<p>Útil apenas quando for mesclar.</p>
</div>
</dd>
</dl>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-pull--r"> <a class="anchor" href="#git-pull--r"></a>-r </dt>
<dt class="hdlist1" id="git-pull---rebasefalsetruemergesinteractive"> <a class="anchor" href="#git-pull---rebasefalsetruemergesinteractive"></a>--rebase[=(false|true|merges|interactive)] </dt>
<dd>
<p>Quando for verdadeiro, reorganize a fundação do ramo atual no topo da ramificação upstream após a busca. Caso haja uma ramificação monitorado remotamente correspondente à ramificação upstream e a ramificação upstream foi reconstruído desde a última busca, a reconstrução da fundação utilizará estas informações para evitar reconstruir as alterações que não fora locais.</p>
<div class="paragraph">
<p>Quando definido como <code>merges</code>, a reconstrução da fundação (rebase) utilizando o comando <code>git rebase --rebase-merges</code> para que as mesclagem dos commits locais sejam incluídas na reconstrução (para mais detalhes, consulte <a href='{{< relurl "docs/git-rebase/pt_BR" >}}'>git-rebase[1]</a>).</p>
</div>
<div class="paragraph">
<p>Quando for falso, mescle a ramificação upstream na ramificação atual.</p>
</div>
<div class="paragraph">
<p>Quando <code>interactive</code> (interativo) , ative o modo interativo da reconstrução da fundação.</p>
</div>
<div class="paragraph">
<p>Consulte <code>pull.rebase</code>, <code>branch.&lt;nome&gt;.rebase</code> e <code>branch.autoSetupRebase</code> no <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a> caso queira fazer o <code>git pull</code>, sempre utilize o comando <code>--rebase</code> em vez de mesclar .</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Este é um modo de operação potencialmente <em>perigoso</em>. Ele reescreve o histórico, o que não é um bom presságio quando você já o publicou. <strong>Não</strong> use esta opção a menos que você tenha lido <a href='{{< relurl "docs/git-rebase/pt_BR" >}}'>git-rebase[1]</a> atentamente.
</td>
</tr>
</table>
</div>
</dd>
<dt class="hdlist1" id="git-pull---no-rebase"> <a class="anchor" href="#git-pull---no-rebase"></a>--no-rebase </dt>
<dd>
<p>Este é um atalho para a opção --rebase=false.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_opções_relacionadas_à_busca"><a class="anchor" href="#_opções_relacionadas_à_busca"></a>Opções relacionadas à busca</h3>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-pull---no-all"> <a class="anchor" href="#git-pull---no-all"></a>--[no-]all </dt>
<dd>
<p>Busque todas os <code>refs</code> remotos. Isso substitui a variável de configuração <code>fetch.all</code>.</p>
</dd>
<dt class="hdlist1" id="git-pull--a"> <a class="anchor" href="#git-pull--a"></a>-a </dt>
<dt class="hdlist1" id="git-pull---append"> <a class="anchor" href="#git-pull---append"></a>--append </dt>
<dd>
<p>Acrescenta os nomes das refs e os nomes dos objetos das refs obtidas ao conteúdo existente do <code>.git/FETCH_HEAD</code>. Sem essa opção, os dados antigos em <code>.git/FETCH_HEAD</code> serão substituídos.</p>
</dd>
<dt class="hdlist1" id="git-pull---atomic"> <a class="anchor" href="#git-pull---atomic"></a>--atomic </dt>
<dd>
<p>Utilize uma transação atômica para atualizar as refs locais. Ou todas as refs são atualizadas ou por erro, nenhuma será.</p>
</dd>
<dt class="hdlist1" id="git-pull---depthltprofundidadegt"> <a class="anchor" href="#git-pull---depthltprofundidadegt"></a>--depth=&lt;profundidade&gt; </dt>
<dd>
<p>Limite a captura para uma quantidade específica de commits na ponta do histórico de cada ramificação remota. Caso esteja capturando um repositório <em>shallow</em> (superficial) criado pelo <code>git clone</code> com a opção <code>--depth=&lt;profundidade&gt;</code> (consulte <a href='{{< relurl "docs/git-clone/pt_BR" >}}'>git-clone[1]</a>), aprofunde ou encurte o histórico para a quantidade usada de commits. As tags para os commits aprofundados não são capturados.</p>
</dd>
<dt class="hdlist1" id="git-pull---deepenltprofundidadegt"> <a class="anchor" href="#git-pull---deepenltprofundidadegt"></a>--deepen=&lt;profundidade&gt; </dt>
<dd>
<p>Semelhante a opção <code>--depth</code>, exceto que especifica a quantidade de commits do limite raso atual em vez da ponta de cada histórico do ramo remoto.</p>
</dd>
<dt class="hdlist1" id="git-pull---shallow-sinceltdatagt"> <a class="anchor" href="#git-pull---shallow-sinceltdatagt"></a>--shallow-since=&lt;data&gt; </dt>
<dd>
<p>Aprofunde ou encurte o histórico de um repositório raso para incluir todas os commits acessíveis após a &lt;data&gt;.</p>
</dd>
<dt class="hdlist1" id="git-pull---shallow-excludeltrevisogt"> <a class="anchor" href="#git-pull---shallow-excludeltrevisogt"></a>--shallow-exclude=&lt;revisão&gt; </dt>
<dd>
<p>Aprofunde ou reduza o histórico de um repositório superficial para excluir os commits acessíveis a partir de um ramo ou tag remoto informada. Esta opção pode ser utilizada várias vezes.</p>
</dd>
<dt class="hdlist1" id="git-pull---unshallow"> <a class="anchor" href="#git-pull---unshallow"></a>--unshallow </dt>
<dd>
<p>Caso o repositório de origem esteja completo, converta um repositório raso num completo, removendo todas as limitações impostas pelos repositórios rasos.</p>
<div class="paragraph">
<p>Caso o repositório de origem seja superficial, busque o máximo possível para que o repositório atual tenha o mesmo histórico que o repositório de origem.</p>
</div>
</dd>
<dt class="hdlist1" id="git-pull---update-shallow"> <a class="anchor" href="#git-pull---update-shallow"></a>--update-shallow </dt>
<dd>
<p>É predefinido que durante a captura num repositório superficial, o <code>git fetch</code> recuse os refs que exijam a atualização do <code>.git/shallow</code>. Esta opção atualiza o <code>.git/shallow</code> e aceita tais refs.</p>
</dd>
<dt class="hdlist1" id="git-pull---negotiation-tipltcommitglobgt"> <a class="anchor" href="#git-pull---negotiation-tipltcommitglobgt"></a>--negotiation-tip=&lt;commit|glob&gt; </dt>
<dd>
<p>É predefinido que o Git relate ao servidor os commits acessíveis a partir de todas as refs locais para encontrar commits comuns numa tentativa de reduzir o tamanho do pacote dos arquivos que serão recebidos. Se for especificado, o Git relatará apenas os commits acessíveis a partir das dicas fornecidas. Isso é útil para acelerar as obtenções quando o usuário sabe qual ref local provavelmente terá commits em comum com a ref upstream que está sendo buscada.</p>
<div class="paragraph">
<p>Esta opção pode ser utilizada mais de uma vez; Se assim for, o Git irá reportar os commits de qualquer um dos commits informados.</p>
</div>
<div class="paragraph">
<p>O argumento para esta opção pode ser um "ref" aos nomes de referência, uma referência ou o (possivelmente abreviado) SHA-1 de um commit. Especificar um agrupamento é o equivalente a utilizar esta opção várias vezes, uma para cada nome "ref" coincidente.</p>
</div>
<div class="paragraph">
<p>Consulte também a variável de configuração <code>fetch.negotiationAlgorithm</code> e <code>push.negotiate</code> documentada em <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a> e na opção <code>--negotiate-only</code> abaixo.</p>
</div>
</dd>
<dt class="hdlist1" id="git-pull---negotiate-only"> <a class="anchor" href="#git-pull---negotiate-only"></a>--negotiate-only </dt>
<dd>
<p>Não busque nada do servidor e imprima os argumentos <code>--negotiation-tip=*</code> fornecidos anteriormente e que nós temos em comum com o servidor.</p>
<div class="paragraph">
<p>Isso é incompatível com <code>--recurse-submodules=[yes|on-demand]</code>. Internamente, isso é usado para implementar a opção <code>push.negotiate</code>, para mais detalhes consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>.</p>
</div>
</dd>
<dt class="hdlist1" id="git-pull---dry-run"> <a class="anchor" href="#git-pull---dry-run"></a>--dry-run </dt>
<dd>
<p>Exiba apenas o que seria feito, sem fazer quaisquer alterações.</p>
</dd>
<dt class="hdlist1" id="git-pull---porcelain"> <a class="anchor" href="#git-pull---porcelain"></a>--porcelain </dt>
<dd>
<p>Imprima na saída padrão num formato fácil para scripts. Consulte a seção OUTPUT em <a href='{{< relurl "docs/git-fetch/pt_BR" >}}'>git-fetch[1]</a> para obter mais detalhes.</p>
<div class="paragraph">
<p>Isso é compatível com a opção <code>--recurse-submodules=[yes|on-demand]</code> e tem precedência sobre a opção de configuração <code>fetch.output</code>.</p>
</div>
</dd>
<dt class="hdlist1" id="git-pull--f"> <a class="anchor" href="#git-pull--f"></a>-f </dt>
<dt class="hdlist1" id="git-pull---force"> <a class="anchor" href="#git-pull---force"></a>--force </dt>
<dd>
<p>Quando <em>git fetch</em> é utilizado com <code>&lt;src&gt;:&lt;dst&gt;</code> "refspec", ele pode se recusar a atualizar o ramo local como discutido
na parte <code>&lt;refspec&gt;</code> da documentação do
<a href='{{< relurl "docs/git-fetch/pt_BR" >}}'>git-fetch[1]</a>.
Esta opção sobrescreve esta verificação.</p>
</dd>
<dt class="hdlist1" id="git-pull--k"> <a class="anchor" href="#git-pull--k"></a>-k </dt>
<dt class="hdlist1" id="git-pull---keep"> <a class="anchor" href="#git-pull---keep"></a>--keep </dt>
<dd>
<p>Mantenha o pacote que foi baixado.</p>
</dd>
<dt class="hdlist1" id="git-pull---prefetch"> <a class="anchor" href="#git-pull---prefetch"></a>--prefetch </dt>
<dd>
<p>Altere o refspec configurado para colocar todos os refs no namespace <code>refs/prefetch/</code>. Consulte a tarefa <code>prefetch</code> em <a href='{{< relurl "docs/git-maintenance/pt_BR" >}}'>git-maintenance[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-pull--p"> <a class="anchor" href="#git-pull--p"></a>-p </dt>
<dt class="hdlist1" id="git-pull---prune"> <a class="anchor" href="#git-pull---prune"></a>--prune </dt>
<dd>
<p>Antes de obter, remova todas as referências de rastreamento remoto que não existam mais no ramo remoto. As tags não estão sujeitas à poda se forem apenas obtidas devido ao acompanhamento automático da tag predefinida ou devido a uma opção <code>--tags</code>. No entanto, se as tags forem obtidas através de uma refspec explícita (na linha de comando ou na configuração remota, por exemplo, se o ramo remoto tiver sido clonado com a opção <code>--mirror</code>), elas também estarão sujeitas à poda. Usar a opção <code>--prune-tags</code> é um atalho para fornecer a tag refspec.</p>
</dd>
<dt class="hdlist1" id="git-pull---no-tags"> <a class="anchor" href="#git-pull---no-tags"></a>--no-tags </dt>
<dd>
<p>É predefinido que as tags que apontam para objetos que são baixados do repositório remoto são obtidas e armazenadas localmente. Essa opção desativa o acompanhamento automático de tags. O comportamento padrão de um ramo remoto pode ser especificado com a configuração remote.&lt;nome&gt;.tagOpt. Consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-pull---refmapltrefspecgt"> <a class="anchor" href="#git-pull---refmapltrefspecgt"></a>--refmap=&lt;refspec&gt; </dt>
<dd>
<p>Ao obter as refs listadas na linha de comando, use o refspec especificado (pode ser usado mais de uma vez) para mapear as refs nas ramificações de rastreamento remoto, em vez dos valores das variáveis de configuração <code>remote.*.fetch</code> do repositório remoto. Fornecer um <code>&lt;refspec&gt;</code> vazio para a opção <code>--refmap</code> faz com que o Git ignore os refspecs configurados e confie inteiramente nos refspecs fornecidos como argumentos da linha de comando. Consulte a seção "Configurações dos Ramos Monitorados Remotamente" para obter detalhes.</p>
</dd>
<dt class="hdlist1" id="git-pull--t"> <a class="anchor" href="#git-pull--t"></a>-t </dt>
<dt class="hdlist1" id="git-pull---tags"> <a class="anchor" href="#git-pull---tags"></a>--tags </dt>
<dd>
<p>Obtém todas as tags do ramo remoto (ou seja, obtém as tags remotas <code>refs/tags/*</code> em tags locais com o mesmo nome), além de tudo o que seria obtido de outra maneira. O uso dessa opção por si só não sujeita as tags à poda, mesmo que a opção --prune seja usada (embora as tags possam ser podadas de qualquer forma se também forem o destino de um "refspec" explícito; consulte <code>--prune</code>).</p>
</dd>
<dt class="hdlist1" id="git-pull--j"> <a class="anchor" href="#git-pull--j"></a>-j </dt>
<dt class="hdlist1" id="git-pull---jobsltngt"> <a class="anchor" href="#git-pull---jobsltngt"></a>--jobs=&lt;n&gt; </dt>
<dd>
<p>A quantidade de processos paralelos que serão utilizados para todas as formas de captura.</p>
<div class="paragraph">
<p>Caso a opção <code>--multiple</code> seja utilizada, os diferentes ramos remotos serão capturados em paralelo. Caso vários submódulos sejam capturados, estes serão capturados em paralelo. Para controlá-los de forma independente, utilize as definições da configuração <code>fetch.parallel</code> e <code>submodule.fetchJobs</code> (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>).</p>
</div>
<div class="paragraph">
<p>Normalmente, as capturas remotas dos múltiplos ramos de forma paralela e recursiva serão mais rápidas. A predefinição é realizar as capturas em sequência e não em paralelo.</p>
</div>
</dd>
<dt class="hdlist1" id="git-pull---set-upstream"> <a class="anchor" href="#git-pull---set-upstream"></a>--set-upstream </dt>
<dd>
<p>Caso a captura remota seja bem sucedida, uma referência de rastreamento <code>add</code> será adicionada ao upstream, utilizado pelo argumento <code>less</code> <a href='{{< relurl "docs/git-pull/pt_BR" >}}'>git-pull[1]</a> e outros comandos. Para mais informações, consulte <code>branch.&lt;nome&gt;.merge</code> e <code>branch.&lt;nome&gt;.remote</code> em <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-pull---upload-packltpacote-para-enviogt"> <a class="anchor" href="#git-pull---upload-packltpacote-para-enviogt"></a>--upload-pack &lt;pacote-para-envio&gt; </dt>
<dd>
<p>Quando o repositório é informado para capturar e que seja manipulado por <em>git fetch-pack</em>, o <code>--exec=&lt;upload-pack&gt;</code> é passado para o comando utilizar um caminho alternativo para o comando executado na outra extremidade.</p>
</dd>
<dt class="hdlist1" id="git-pull---progress"> <a class="anchor" href="#git-pull---progress"></a>--progress </dt>
<dd>
<p>É predefinido que a condição geral do progresso seja relatada no fluxo de erros quando estiver conectado num terminal, a menos que <code>-q</code> seja utilizado. Esta opção impõem a condição geral do progresso, mesmo que o fluxo de erro predefinido não seja direcionado para um terminal.</p>
</dd>
<dt class="hdlist1" id="git-pull--oltopogt"> <a class="anchor" href="#git-pull--oltopogt"></a>-o &lt;opção&gt; </dt>
<dt class="hdlist1" id="git-pull---server-optionltopogt"> <a class="anchor" href="#git-pull---server-optionltopogt"></a>--server-option=&lt;opção&gt; </dt>
<dd>
<p>Transmita a sequência usada para o servidor ao se comunicar utilizando o protocolo versão 2. A sequência informada não deve conter um caractere <code>NUL</code> ou <code>LF</code>. O tratamento das opções do servidor, incluindo os desconhecidos, é específico do servidor. Quando a opção <code>--server-option=&lt;opção&gt;</code> forem utilizadas várias vezes, todos serão enviados para o outro lado na ordem listada na linha de comando.</p>
</dd>
<dt class="hdlist1" id="git-pull---show-forced-updates"> <a class="anchor" href="#git-pull---show-forced-updates"></a>--show-forced-updates </dt>
<dd>
<p>É predefinido que o git verifique se uma ramificação é atualizada à força durante o fetch. Isso pode ser desativado através do fetch.showForcedUpdates, mas a opção <code>--show-forced-updates</code> garante que essa verificação ocorra. Consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-pull---no-show-forced-updates"> <a class="anchor" href="#git-pull---no-show-forced-updates"></a>--no-show-forced-updates </dt>
<dd>
<p>É predefinido que o Git verifique se a atualização do ramo foi imposta durante uma captura. Utilize a opção <code>--no-show-forced-updates</code> ou defina <code>fetch.showForcedUpdates</code> como to <code>false</code> para ignorar esta verificação por questões de desempenho. Se utilizada durante o <code>git-pull</code>, a opção <code>--ff-only</code> ainda verificará quais as atualizações foram impostas antes de tentar uma atualização rápida. Consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-pull--4"> <a class="anchor" href="#git-pull--4"></a>-4 </dt>
<dt class="hdlist1" id="git-pull---ipv4"> <a class="anchor" href="#git-pull---ipv4"></a>--ipv4 </dt>
<dd>
<p>Utilize apenas os endereços IPv4, ignorando os endereços IPv6.</p>
</dd>
<dt class="hdlist1" id="git-pull--6"> <a class="anchor" href="#git-pull--6"></a>-6 </dt>
<dt class="hdlist1" id="git-pull---ipv6"> <a class="anchor" href="#git-pull---ipv6"></a>--ipv6 </dt>
<dd>
<p>Utilize apenas os endereços IPv6, ignorando os endereços IPv4.</p>
</dd>
</dl>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-pull-ltrepositriogt"> <a class="anchor" href="#git-pull-ltrepositriogt"></a>&lt;repositório&gt; </dt>
<dd>
<p>O repositório "remote" é a fonte de uma operação <em>fetch</em> ou <em>pull</em>. Este parâmetro pode ser uma URL (consulte a seção <a href="#URLS">GIT URLS</a> abaixo) ou o nome de um controle remoto (consulte a seção <a href="#REMOTES">RAMOS REMOTOS</a> abaixo).</p>
</dd>
<dt class="hdlist1" id="git-pull-ltrefspecgt"> <a class="anchor" href="#git-pull-ltrefspecgt"></a>&lt;refspec&gt; </dt>
<dd>
<p>Especifica quais as refs que devem ser obtidas via <em>fetch</em> e quais as refs locais devem ser atualizadas. Quando não houver um <code>&lt;refspec&gt;</code> na linha de comando, as refs que serão obtidas com <em>fetch</em> serão lidas a partir das variáveis <code>remote.&lt;repositório&gt;.fetch</code>
(consulte a seção "CONFIGURAÇÕES DOS RAMOS MONITORADOS REMOTAMENTE"
in <a href='{{< relurl "docs/git-fetch/pt_BR" >}}'>git-fetch[1]</a>).</p>
<div class="paragraph">
<p>O formato de um parâmetro <code>&lt;refspec&gt;</code> é um sinal de adição opcional <code>+</code>, seguido pela origem <code>&lt;src&gt;</code>, seguido por dois-pontos <code>:</code>, seguido pela referência de destino <code>&lt;dst&gt;</code>. Os dois-pontos podem ser omitidos quando o valor de <code>&lt;dst&gt;</code> estiver vazio. O valor de <code>&lt;src&gt;</code> normalmente é uma referência, mas também pode ser um nome de um objeto hexadecimal inteiramente escrito.</p>
</div>
<div class="paragraph">
<p>Uma &lt;refspec&gt; pode conter um <code>*</code> na sua origem &lt;src&gt; para indicar uma simples combinação de padrões. Tal "refspec" funciona como um "glob" que combina com qualquer ref de mesmo prefixo. Um padrão &lt;refspec&gt; deve conter um <code>*</code> tanto origem &lt;src&gt; quanto no destino &lt;dst&gt;. Ele irá mapear os reffs para o destino substituindo o <code>*</code> pelo conteúdo correspondente da fonte.</p>
</div>
<div class="paragraph">
<p>Se um <em>refspec</em> for prefixado por <code>^</code>, ele será interpretado como um refspec negativo. Em vez de especificar quais as <em>refs</em> devem ser obtidas com <em>fetch</em> ou quais as refs locais devem ser atualizadas, esta refspec especificará as refs que serão excluídas. Uma ref será considerada compatível se corresponder a pelo menos uma refspec positiva e não corresponder a nenhuma refspec negativa. As refspecs negativas podem ser úteis para restringir o escopo de um padrão refspec para que não inclua refs específicas. As refspecs negativas podem ser refspecs de padrão. No entanto, eles podem conter apenas um <code>&lt;src&gt;</code> e não especificar um <code>&lt;dst&gt;</code>. Também não há suporte para nomes de objetos hexadecimais totalmente mencionados.</p>
</div>
<div class="paragraph">
<p>A <code>tag</code> significa o mesmo que <code>refs/tags/&lt;tag&gt;:refs/tags/&lt;tag&gt;</code>; ele solicita a buscaa de tudo até a tag informada.</p>
</div>
<div class="paragraph">
<p>A "ref" remota que coincida com &lt;src&gt; é buscada e se &lt;dst&gt; não seja uma sequência vazia, é feita uma tentativa de atualizar a referência local que coincida com ela.</p>
</div>
<div class="paragraph">
<p>Caso a atualização seja permitida sem a opção <code>--force</code> depende do espaço de nomes da ref onde está sendo buscada, do tipo do objeto que está sendo buscado e se a atualização é considerada um avanço rápido. Geralmente, as mesmas regras se aplicam à busca e ao impulsionar, consulte a seção <code>&lt;refspec&gt;...</code> do <a href='{{< relurl "docs/git-push/pt_BR" >}}'>git-push[1]</a> para saber o que são. As exceções para estas regras específicas para o comando <em>git fetch</em> são anotadas abaixo.</p>
</div>
<div class="paragraph">
<p>Até a versão 2.20 do Git, e ao contrário do que ocorre quando se faz um push com <a href='{{< relurl "docs/git-push/pt_BR" >}}'>git-push[1]</a>, quaisquer atualizações para <code>refs/tags/*</code> seriam aceitas sem <code>+</code> no refspec (ou a opção <code>--force</code>). Ao fazer a obtenção com <em>fetch</em>, consideramos promiscuamente todas as atualizações das etiquetas de um ramo remoto como sendo um <em>fetch</em> forçado. Desde a versão 2.20 do Git, a busca para atualizar <code>refs/tags/*</code> funciona da mesma forma que o push. Ou seja, todas as atualizações serão rejeitadas sem <code>+</code> no refspec (ou <code>--force</code>).</p>
</div>
<div class="paragraph">
<p>Ao contrário quando impulsionamos com o <a href='{{< relurl "docs/git-push/pt_BR" >}}'>git-push[1]</a>, qualquer atualização fora do <code>refs/{tags,heads}/*</code> será aceito sem o sinal <code>+</code> no refspec (ou <code>--force</code>), seja trocando, por exemplo, um objeto de árvore para uma bolha ou um commit para outro commit que não tenha o commit anterior como ancestral, etc.</p>
</div>
<div class="paragraph">
<p>Ao contrário quando impulsionamos com o <a href='{{< relurl "docs/git-push/pt_BR" >}}'>git-push[1]</a>, não existe uma configuração que corrija estas regras, e nada como um gancho <code>pre-fetch</code> análogo ao gancho <code>pre-receive</code>.</p>
</div>
<div class="paragraph">
<p>Assim como impulsionar com <a href='{{< relurl "docs/git-push/pt_BR" >}}'>git-push[1]</a>, todas as regras descritas acima sobre o que não é permitido como uma atualização pode ser sobrescrito ao adicionar um caractere opcional no "refspec" começando com <code>+</code> (ou ao utilizar a opção <code>--force</code> na linha de comando). A única exceção a isso é que nenhuma quantidade de imposição fará com que o espaço de nomes <code>refs/heads/*</code> aceite um objeto que não seja um commit.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Quando o ramo remoto que você deseja obter com <em>fetch</em> for conhecido por ser rebobinado ter feito um <em>rebase</em> regularmente, espera-se que o novo cume não seja descendente do cume anterior (conforme foi armazenado no último <em>fetch</em> que você fez no ramo rastreado remotamente). Você deve usar o sinal <code>+</code> para indicar que serão necessárias atualizações que não sejam de avanço rápido para estas ramificações. Não há nenhuma maneira de determinar ou declarar que um ramo será disponibilizado num repositório com este comportamento; o usuário que o extrai simplesmente deve saber que esse é o padrão de uso esperado para um ramo.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Há uma diferença entre listar os vários <code>&lt;refspec&gt;</code> diretamente na linha de comando com <em>git pull</em> e ter várias entradas <code>remote.&lt;repositório&gt;.fetch</code> em sua configuração para um <code>&lt;repositório&gt;</code> e executar um comando <em>git pull</em> sem nenhum parâmetro <code>&lt;refspec&gt;</code> explícito. Os <code>&lt;refspec&gt;</code> listados explicitamente na linha de comando são sempre mesclados no ramo atual após um <em>fetch</em>. Em outras palavras, se você listar mais de uma referência remota, o comando "git pull" criará uma mesclagem Octopus. Por outro lado, se você não listar nenhum parâmetro <code>&lt;refspec&gt;</code> explícito na linha de comando, o <em>git pull</em> buscará todos os <code>&lt;refspec&gt;</code> encontrados na configuração <code>remote.&lt;repository&gt;.fetch</code> e mesclará apenas o primeiro <code>&lt;refspec&gt;</code> encontrado no ramo atual. Isso ocorre porque a criação de um "Octopus" a partir de refs remotos raramente é feito, ao passo que manter o controle de vários cabeçalhos remotos de uma só vez, ao obter mais de um com o <em>fetch</em>, isso costuma ser útil.
</td>
</tr>
</table>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git_urls"><a class="anchor" href="#_git_urls"></a>GIT URLS<a id="URLS"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Em geral as URLs contêm informações sobre o protocolo de transporte, o endereço do servidor remoto e o caminho para o repositório. Dependendo do protocolo de transporte, algumas dessas informações podem estar ausentes.</p>
</div>
<div class="paragraph">
<p>O Git suporta os protocolos ssh, git, http e https (além do ftp e ftps podem ser utilizados para captura (feching), porém é ineficiente e obsoleto; não os utilize).</p>
</div>
<div class="paragraph">
<p>O transporte nativo (ou seja, git:// URL) não faz a autenticação e deve ser utilizado com cuidado em redes sem segurança.</p>
</div>
<div class="paragraph">
<p>As seguintes sintaxes podem ser utilizadas com eles:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ssh://[user@]host.xz[:port]/caminho/para/o/repositório.git/</p>
</li>
<li>
<p>git://host.xz[:port]/caminho/para/o/repositório.git/</p>
</li>
<li>
<p>http[s]://host.xz[:port]/caminho/para/o/repositório.git/</p>
</li>
<li>
<p>ftp[s]://host.xz[:port]/caminho/para/o/repositório.git/</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Uma sintaxe alternativa como scp também pode ser utilizada com o protocolo ssh:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>[user@]host.xz:caminho/para/o/repositório.git/</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Essa sintaxe apenas é reconhecida caso não haja barras antes dos primeiros dois pontos. Isso ajuda a diferenciar um caminho local que contém dois pontos. Por exemplo, o caminho local <code>foo:bar</code> pode ser utilizado como um caminho absoluto ou <code>./foo:bar</code> para evitar ser mal interpretado como uma url ssh.</p>
</div>
<div class="paragraph">
<p>Os protocolos ssh e git também oferecem suporte à expansão do ~nome do usuário:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ssh://[user@]host.xz[:port]/~[user]/caminho/para/o/repositório.git/</p>
</li>
<li>
<p>git://host.xz[:port]/~[user]/caminho/para/o/repositório.git/</p>
</li>
<li>
<p>[user@]host.xz:/~[user]/caminho/para/o/repositório.git/</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para os repositórios locais, as seguintes sintaxes podem ser utilizadas que também são compatíveis de forma nativa pelo Git:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>/caminho/para/o/repositório.git/</p>
</li>
<li>
<p>file:///caminho/para/o/repositório.git/</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Estas duas sintaxes são basicamente equivalentes, exceto durante a clonagem, quando a primeira implica no uso da opção <code>--local</code>. Para mais detalhes, consulte <a href='{{< relurl "docs/git-clone/pt_BR" >}}'>git-clone[1]</a>.</p>
</div>
<div class="paragraph">
<p>O <em>git clone</em>, <em>git fetch</em> e <em>git pull</em>, mas não o <em>git push</em>, também aceitarão um arquivo do pacote adequado. Consulte <a href='{{< relurl "docs/git-bundle/pt_BR" >}}'>git-bundle[1]</a>.</p>
</div>
<div class="paragraph">
<p>Quando o Git não sabe como lidar com um determinado protocolo de transporte, quando existe, ele tenta usar o auxiliar <code>remote-&lt;transporte&gt;</code>. Para os repositórios locais, as seguintes sintaxes podem ser utilizadas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>&lt;transporte&gt;::&lt;endereço&gt;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>onde &lt;endereço&gt; pode ser um caminho, um servidor e um caminho ou uma sequência arbitrária semelhante a uma URL reconhecida por um auxiliar remoto em específico que está sendo chamado. Para mais detalhes, consulte <a href='{{< relurl "docs/gitremote-helpers/pt_BR" >}}'>gitremote-helpers[7]</a>.</p>
</div>
<div class="paragraph">
<p>Se houver um grande número de repositórios remotos com nomes semelhantes e caso queira usar um formato diferente para eles (de modo que as URLs utilizadas sejam reescritas nas URLs que funcionam), você poderá criar uma seção de configuração da opção:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	[url "&lt;url-da-base-atual&gt;"]
		insteadOf = &lt;url-da-outra-base&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Por exemplo, com isso:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	[url "git://git.host.xz/"]
		insteadOf = host.xz:/path/to/
		insteadOf = work:</pre>
</div>
</div>
<div class="paragraph">
<p>uma URL como "work:repo.git" ou como "host.xz:/caminho/para/o/repositório.git" será reescrito em qualquer contexto onde a URL seja "git://git.host.xz/repo.git".</p>
</div>
<div class="paragraph">
<p>Caso queira reescrever apenas as URLs para envio por "push" (impulsionamento), é possível criar uma seção de configuração da opção:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	[url "&lt;url da base atual&gt;"]
		pushInsteadOf = &lt;a url da outra base&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Por exemplo, com isso:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	[url "ssh://exemplo.org/"]
		pushInsteadOf = git://exemplo.org/</pre>
</div>
</div>
<div class="paragraph">
<p>uma URL como "git://exemplo.org/caminho/para/o/repositório.git" será reescrito para "ssh://exemplo.org/caminho/para/o/repositório.git" para os "pushes" (impulsionamentos), porém os "pulls" (obtenções) ainda usarão a URL original.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_remotos"><a class="anchor" href="#_remotos"></a>REMOTOS<a id="REMOTES"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>O nome de um dos seguintes pode ser usado em vez de uma URL como argumento do <code>&lt;repositório&gt;</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>um ramo remoto no arquivo de configuração do Git: <code>$GIT_DIR/config</code>,</p>
</li>
<li>
<p>um arquivo no diretório <code>$GIT_DIR/remotes</code> ou</p>
</li>
<li>
<p>um arquivo no diretório <code>$GIT_DIR/branches</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Tudo isso também permite seja omitido o refspec da linha de comando, pois cada um contém um refspec que o git utilizará de maneira predefinida.</p>
</div>
<div class="sect2">
<h3 id="_ramo_remoto_nomeado_no_arquivo_de_configuração"><a class="anchor" href="#_ramo_remoto_nomeado_no_arquivo_de_configuração"></a>Ramo remoto nomeado no arquivo de configuração</h3>
<div class="paragraph">
<p>Você pode optar por mencionar o nome de um ramo remoto que você configurou anteriormente usando o comando <a href='{{< relurl "docs/git-remote/pt_BR" >}}'>git-remote[1]</a>, <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a> ou até mesmo por uma edição manual no arquivo <code>$GIT_DIR/config</code>. A URL deste ramo remoto será usada para acessar o repositório. O "refspec" deste ramo remoto será usado por padrão quando você não fornecer um "refspec" na linha de comando. A entrada no arquivo de configuração teria a seguinte aparência:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	[remote "&lt;nome&gt;"]
		url = &lt;URL&gt;
		pushurl = &lt;pushurl&gt;
		push = &lt;refspec&gt;
		fetch = &lt;refspec&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>O <code>&lt;pushurl&gt;</code> é usado somente para envios. É opcional e o padrão é <code>&lt;URL&gt;</code>. O envio para um controle remoto afeta todos os pushurls definidos ou todos as urls definidas se não houver pushurls definidos. No entanto, o Fetch só buscará a primeira url definida caso haja várias urls definidas.</p>
</div>
</div>
<div class="sect2">
<h3 id="_arquivo_nomeado_no_git_dirremotes"><a class="anchor" href="#_arquivo_nomeado_no_git_dirremotes"></a>Arquivo nomeado no <code>$GIT_DIR/remotes</code></h3>
<div class="paragraph">
<p>Você pode optar por fornecer o nome de um arquivo em <code>$GIT_DIR/remotes</code>. A URL nesse arquivo será usado para acessar o repositório. O "refspec" neste arquivo será usado como padrão quando você não fornecer um "refspec" na linha de comando. Este arquivo deve ter os seguintes formatos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	URL: um dos formatos da URL acima
	Push: &lt;refspec&gt;
	Pull: &lt;refspec&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>As linhas <code>Push:</code> são usadas pelo comando <em>git push</em> e as linhas <code>Pull:</code> são usadas pelo comando <em>git pull</em> e pelo comando <em>git fetch</em>. Várias linhas <code>Push:</code> e <code>Pull:</code> podem ser especificadas para fazer os mapeamentos das ramificações adicionais.</p>
</div>
</div>
<div class="sect2">
<h3 id="_arquivo_informado_em_git_dirbranches"><a class="anchor" href="#_arquivo_informado_em_git_dirbranches"></a>Arquivo informado em <code>$GIT_DIR/branches</code></h3>
<div class="paragraph">
<p>Você pode optar por fornecer o nome de um arquivo em <code>$GIT_DIR/branches</code>. A URL nesse arquivo será usado para acessar o repositório. Este arquivo deve ter os seguintes formatos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	&lt;URL&gt;#&lt;head&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>A <code>&lt;URL&gt;</code> é necessária; <code>#&lt;head&gt;</code> é opcional.</p>
</div>
<div class="paragraph">
<p>Dependendo da operação, o git usará um dos seguintes "refspecs", caso você não forneça um na linha de comando. O <code>&lt;ramo&gt;</code> é o nome desse arquivo em <code>$GIT_DIR/branches</code> e <code>&lt;cabeçalho&gt;</code> tem como <code>master</code> como predefinição.</p>
</div>
<div class="paragraph">
<p>O git fetch usa:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	refs/heads/&lt;head&gt;:refs/heads/&lt;ramo&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>O comando <code>git push</code> usa:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	HEAD:refs/heads/&lt;head&gt;</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_estratégias_de_mesclagem"><a class="anchor" href="#_estratégias_de_mesclagem"></a>ESTRATÉGIAS DE MESCLAGEM</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O mecanismo de mesclagem (os comandos <code>git merge</code> e <code>git pull</code>) permite que as <em>estratégias de mesclagem</em> do backend sejam escolhidas com a opção <code>-s</code>. Algumas estratégias também podem ter as suas próprias opções, que podem ser passadas usando argumentos <code>-X&lt;opção&gt;</code> ao comando <code>git merge</code> e/ou <code>git pull</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-pull-ort"> <a class="anchor" href="#git-pull-ort"></a>ort </dt>
<dd>
<p>Esta é a estratégia de mesclagem predefinida ao extrair ou ao mesclar um ramo. Esta estratégia só pode resolver dois <code>HEADS</code> usando um algoritmo de mesclagem de 3 vias. Quando há mais de um ancestral comum que pode ser usado para a mesclagem de 3 vias, ele cria uma árvore mesclada dos ancestrais comuns e a utiliza como uma árvore de referência para a mesclagem de 3 vias. Foi relatado que isso resulta em menos conflitos de mesclagem sem causar erros de mesclagem através dos testes feitos na mesclagem dos commits reais retirados do histórico de desenvolvimento do kernel do Linux 2.6. Além disso, esta estratégia pode detectar e lidar com as mesclagens que envolvam renomeações. Não faz uso de cópias detectadas. O nome desse algoritmo é um acrônimo ("Ostensibly Recursive&#8217;s Twin") e surgiu do fato de que ele foi escrito como um substituto para o padrão di algoritmo anterior, <code>recursive</code>.</p>
<div class="paragraph">
<p>A estratégia <em>ort</em> pode adotar as seguintes opções:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-pull-ours"> <a class="anchor" href="#git-pull-ours"></a>ours </dt>
<dd>
<p>Esta opção impõem a resolução automática dos conflitos de maneira limpa, favorecendo a <em>nossa</em> versão. As alterações da outra árvore que não entram em conflito com o nosso lado são refletidas no resultado da mesclagem. Para um arquivo binário, todo o conteúdo é retirado a partir do nosso lado.</p>
<div class="paragraph">
<p>Isso não deve ser confundido com a estratégia da <em>nossa</em> mesclagem, que nem sequer analisa o que a outra árvore contém. Ela descarta tudo o que a outra árvore fez, declarando que a <em>nossa</em> história contém tudo o que aconteceu nela.</p>
</div>
</dd>
<dt class="hdlist1" id="git-pull-theirs"> <a class="anchor" href="#git-pull-theirs"></a>theirs </dt>
<dd>
<p>Este é o oposto do <em>nosso</em>; observe que, diferentemente do <em>nosso</em>, não existe uma estratégia de mesclagem <em>deles</em> para confundir esta opção de mesclagem.</p>
</dd>
<dt class="hdlist1" id="git-pull-ignore-space-change"> <a class="anchor" href="#git-pull-ignore-space-change"></a>ignore-space-change </dt>
<dt class="hdlist1" id="git-pull-ignore-all-space"> <a class="anchor" href="#git-pull-ignore-all-space"></a>ignore-all-space </dt>
<dt class="hdlist1" id="git-pull-ignore-space-at-eol"> <a class="anchor" href="#git-pull-ignore-space-at-eol"></a>ignore-space-at-eol </dt>
<dt class="hdlist1" id="git-pull-ignore-cr-at-eol"> <a class="anchor" href="#git-pull-ignore-cr-at-eol"></a>ignore-cr-at-eol </dt>
<dd>
<p>Trata as linhas com o tipo indicado de alteração do espaço em branco como inalteradas para os fins de uma mesclagem de três vias. As alterações do espaço em branco misturadas com as outras alterações numa linha não são ignoradas. Consulte também o comando <a href='{{< relurl "docs/git-diff/pt_BR" >}}'>git-diff[1]</a> <code>-b</code>, <code>-w</code>, <code>--ignore-space-at-eol</code>, e a opção <code>--ignore-cr-at-eol</code>.</p>
<div class="ulist">
<ul>
<li>
<p>Caso a versão <em>their</em> (dele) introduzir apenas as alterações de espaço em uma linha, a <em>our</em> (nossa) versão será utilizada;</p>
</li>
<li>
<p>Caso a <em>our</em> (nossa) versão introduzir alterações nos espaços, porém a versão <em>their</em> (dele) incluir uma alteração substancial, a versão <em>their</em> (dele) será utilizada;</p>
</li>
<li>
<p>Caso contrário, a mesclagem continuará de forma usual.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1" id="git-pull-renormalize"> <a class="anchor" href="#git-pull-renormalize"></a>renormalize </dt>
<dd>
<p>Isso executa um "check-out" e um "check-in" virtual de todos os três estágios de um arquivo ao resolver uma mesclagem de três vias. Esta opção deve ser usada ao mesclar ramificações com diferentes filtros limpos ou com regras de normalização de fim de linha. Para mais detalhes consulte "Mesclando as ramificações com atributos de check-in/check-out diferentes" do comando <a href='{{< relurl "docs/gitattributes/pt_BR" >}}'>gitattributes[5]</a>.</p>
</dd>
<dt class="hdlist1" id="git-pull-no-renormalize"> <a class="anchor" href="#git-pull-no-renormalize"></a>no-renormalize </dt>
<dd>
<p>Desativa a opção <code>renormalize</code>. Isso substitui a variável de configuração <code>merge.renormalize</code>.</p>
</dd>
<dt class="hdlist1" id="git-pull-find-renamesltngt"> <a class="anchor" href="#git-pull-find-renamesltngt"></a>find-renames[=&lt;n&gt;] </dt>
<dd>
<p>Ative a detecção de renomeação, definindo opcionalmente o limite de similaridade. Esta é a predefinição. Isso substitui a variável de configuração <em>merge.renames</em>. Consulte também <a href='{{< relurl "docs/git-diff/pt_BR" >}}'>git-diff[1]</a> <code>--find-renames</code>.</p>
</dd>
<dt class="hdlist1" id="git-pull-rename-thresholdltngt"> <a class="anchor" href="#git-pull-rename-thresholdltngt"></a>rename-threshold=&lt;n&gt; </dt>
<dd>
<p>É um sinônimo obsoleto para <code>find-renames=&lt;n&gt;</code>.</p>
</dd>
<dt class="hdlist1" id="git-pull-subtreeltcaminhogt"> <a class="anchor" href="#git-pull-subtreeltcaminhogt"></a>subtree[=&lt;caminho&gt;] </dt>
<dd>
<p>Esta opção é uma forma mais avançada de estratégia de <em>subárvore</em>, onde a estratégia faz uma estimativa de como as duas árvores devem ser deslocadas para coincidir uma com a outra durante a mesclagem. Em vez disso, o caminho especificado é prefixado (ou retirado do início) para fazer com que a forma das duas árvores coincida.</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1" id="git-pull-recursive"> <a class="anchor" href="#git-pull-recursive"></a>recursive </dt>
<dd>
<p>Isso só pode resolver dois cabeçalhos usando um algoritmo de mesclagem de 3 vias. Quando há mais de um ancestral comum que pode ser usado para a mesclagem de 3 vias, ele cria uma árvore mesclada dos ancestrais comuns e a utiliza como uma árvore de referência para a mesclagem de 3 vias. Foi relatado que isso resulta em menos conflitos de mesclagem sem causar erros de mesclagem através dos testes feitos na mesclagem dos commits reais retirados do histórico de desenvolvimento do kernel do Linux 2.6. Além disso, ele pode detectar e lidar com mesclagens que envolvam renomeações. Não faz uso de cópias detectadas. Essa era a estratégia padrão para resolver dois cabeçalhos do Git v0.99.9k até a v2.33.0.</p>
<div class="paragraph">
<p>A estratégia <em>recursiva</em> usa as mesmas opções que a <em>ort</em>. Entretanto, há três opções adicionais que o <em>ort</em> ignora (não documentadas acima) e que podem ser úteis com a estratégia <em>recursiva</em>:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-pull-patience"> <a class="anchor" href="#git-pull-patience"></a>patience </dt>
<dd>
<p>É um sinônimo obsoleto para <code>diff-algorithm=patience</code>.</p>
</dd>
<dt class="hdlist1" id="git-pull-diff-algorithmpatienceminimalhistogrammyers"> <a class="anchor" href="#git-pull-diff-algorithmpatienceminimalhistogrammyers"></a>diff-algorithm=[patience|minimal|histogram|myers] </dt>
<dd>
<p>Use um algoritmo de comparação diferente durante a mesclagem, o que pode ajudar a evitar mesclagens incorretas que ocorrem devido a linhas correspondentes sem importância (como chaves de funções distintas). Consulte também <a href='{{< relurl "docs/git-diff/pt_BR" >}}'>git-diff[1]</a> <code>--diff-algorithm</code>. Observe que <code>ort</code> usa especificamente <code>diff-algorithm=histogram</code>, enquanto <code>recursive</code> usa como predefinição a configuração <code>diff.algorithm</code>.</p>
</dd>
<dt class="hdlist1" id="git-pull-no-renames"> <a class="anchor" href="#git-pull-no-renames"></a>no-renames </dt>
<dd>
<p>Desativa a detecção de renomeação. Isto sobrepõem a variável de configuração <code>merge.renames</code> configuration. Consulte também <a href='{{< relurl "docs/git-diff/pt_BR" >}}'>git-diff[1]</a> <code>--no-renames</code>.</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1" id="git-pull-resolve"> <a class="anchor" href="#git-pull-resolve"></a>resolve </dt>
<dd>
<p>Isso só pode resolver duas cabeças (ou seja, o ramo atual e outro ramo do qual você retirou) usando um algoritmo de mesclagem de três vias. Ele tenta detectar cuidadosamente as ambiguidades de mesclagem cruzada. Ele não lida com renomeações.</p>
</dd>
<dt class="hdlist1" id="git-pull-octopus"> <a class="anchor" href="#git-pull-octopus"></a>octopus </dt>
<dd>
<p>Isso resolve casos com mais de dois cabeçalhos, mas se recusa a fazer uma mesclagem complexa que precise de uma resolução manual. Seu principal objetivo é ser usado para agrupar os tópicos dos cabeçalhos juntos. Esta é a estratégia de mesclagem predefinida ao obter (fazer um pull) ou ao mesclar um ramo.</p>
</dd>
<dt class="hdlist1" id="git-pull-ours-1"> <a class="anchor" href="#git-pull-ours-1"></a>ours </dt>
<dd>
<p>Isso resolve qualquer quantidade de cabeçalhos, mas a árvore resultante da mesclagem é sempre a do cabeçalho do ramo atual, ignorando efetivamente todas as alterações de todos os outros ramos. Ele deve ser usado para substituir o histórico de desenvolvimento antigo das ramificações paralelas. Observe que isso é diferente da opção <code>-Xours</code> para a estratégia de mesclagem da opção <em>recursive</em>.</p>
</dd>
<dt class="hdlist1" id="git-pull-subtree"> <a class="anchor" href="#git-pull-subtree"></a>subtree </dt>
<dd>
<p>Esta é uma estratégia <code>ort</code> modificada. Ao mesclar as árvores <em>A</em> e <em>B</em>, caso <em>B</em> corresponda a uma subárvore de <em>A</em>, o <em>B</em> será ajustado primeiro para coincidir à estrutura da árvore <em>A</em>, em vez de ler as árvores no mesmo nível. Esse ajuste também é feito na árvore ancestral comum.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Com as estratégias que usam a mesclagem de 3 vias (incluindo a predefinição, <em>ort</em>), se uma alteração for feita em ambos os ramos, mas posteriormente revertida num dos ramos, essa alteração estará presente no resultado da mesclagem; algumas pessoas acham este comportamento confuso. Isto ocorre porque somente os cabeçalhos e a base de mesclagem são considerados ao realizar uma mesclagem, e não os commits individuais. Portanto, o algoritmo de mesclagem considera a alteração revertida como se não houvesse nenhuma alteração e, em vez disso, substitui a versão alterada.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comportamento_predefinido"><a class="anchor" href="#_comportamento_predefinido"></a>COMPORTAMENTO PREDEFINIDO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Muitas vezes, as pessoas usam o comando <code>git pull</code> sem informar nenhum parâmetro. Tradicionalmente, isso é o mesmo que <code>git pull origin</code>. No entanto, quando a configuração <code>branch.&lt;nome&gt;.remote</code> está presente na ramificação <code>&lt;nome&gt;</code>, este valor é usado em vez de <code>origin</code>.</p>
</div>
<div class="paragraph">
<p>Para determinar de qual URL usar, o valor da configuração <code>remote.&lt;origin&gt;.url</code> é consultado e caso não haja nenhuma variável, o valor na linha <code>URL:</code> em <code>$GIT_DIR/remotes/&lt;origin&gt;</code> é utilizado.</p>
</div>
<div class="paragraph">
<p>Para determinar quais ramificações remotas devem ser obtidas (e opcionalmente armazenadas nas ramificações rastreadas remotamente) quando o comando for executado sem nenhum parâmetro <code>refspec</code> na linha de comando, os valores na variável de configuração <code>remote.&lt;origin&gt;.fetch</code> são consultados e, se não houver nenhum, o <code>$GIT_DIR/remotes/&lt;origin&gt;</code> é consultado e suas linhas <code>Pull:</code> são utilizadas. Além dos formatos <code>refspec</code> descritos na seção OPTIONS, você pode ter um <code>refspec globbing</code> parecido com este:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>refs/heads/*:refs/remotes/origin/*</pre>
</div>
</div>
<div class="paragraph">
<p>Um "refspec globbing" deve ter um RHS não vazio (ou seja, deve armazenar o que foi obtido em ramificações de rastreamento remoto), e seu LHS e RHS devem terminar com <code>/*</code>. A instrução acima especifica que todas as ramificações remotas são rastreadas usando as ramificações rastreadas remotamente na hierarquia <code>refs/remotes/origin/</code> com o mesmo nome.</p>
</div>
<div class="paragraph">
<p>A regra para determinar qual a ramificação remota deve ser mesclada após a captura é um pouco complexo, para que não prejudique a compatibilidade com as versões anteriores.</p>
</div>
<div class="paragraph">
<p>Caso "refspecs" explícitos sejam informados para o comando <code>git pull</code>, todos eles são mesclados.</p>
</div>
<div class="paragraph">
<p>Quando nenhuma <code>refspec</code> é usada na linha de comando, o comando <code>git pull</code> usa a <code>refspec</code> da configuração ou o <code>$GIT_DIR/remotes/&lt;origin&gt;</code>. Nesses casos, as seguintes regras se aplicam:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Caso a configuração <code>branch.&lt;nome&gt;.merge</code> para o ramo atual <code>&lt;nome&gt;</code> exista, este é o nome do ramo no site remoto que é mesclado.</p>
</li>
<li>
<p>Caso o refspec seja um caractere curinga, nada será mesclado.</p>
</li>
<li>
<p>Caso contrário, a ramificação remota do primeiro refspec será mesclada.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_exemplos"><a class="anchor" href="#_exemplos"></a>EXEMPLOS</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Atualize as ramificações monitoradas remotamente para o repositório onde a clonagem foi feita e em seguida, mescle uma delas na sua ramificação atual:</p>
<div class="listingblock">
<div class="content">
<pre>$ git pull
$ git pull origin</pre>
</div>
</div>
<div class="paragraph">
<p>Normalmente o ramo mesclado fica no <code>HEAD</code> do repositório remoto, porém a escolha é determinada pelas opções <code>branch.&lt;nome&gt;.remote</code> e <code>branch.&lt;nome&gt;.merge</code>; para mais detalhes consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>.</p>
</div>
</li>
<li>
<p>Mescle na ramificação atual o ramo remoto <code>next</code>:</p>
<div class="listingblock">
<div class="content">
<pre>$ git pull origin next</pre>
</div>
</div>
<div class="paragraph">
<p>Isso deixa uma cópia de <code>next</code> temporariamente em <em>FETCH_HEAD</em> e atualiza o ramo rastreado remotamente <code>origin/next</code>. O mesmo pode ser feito invocando <em>fetch</em> e <em>merge</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git fetch origin
$ git merge origin/next</pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Caso você tente fazer um "pull" que resultou em conflitos complexos e queira recomeçar, a recuperação pode ser feita com o comando <em>git reset</em>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_segurança"><a class="anchor" href="#_segurança"></a>SEGURANÇA</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Os protocolos de busca e envio não foram projetados para impedir que um lado roube os dados do outro repositório que não deveriam ser compartilhado. Caso tenha dados particulares que precisam ser protegidos de um par malicioso, a sua melhor opção é armazená-los em um outro repositório. Isso se aplica aos clientes e aos servidores. Em particular, os espaço de nomes em um servidor não são eficazes para o controle de acesso de leitura; você só deve conceder acesso de leitura a um espaço de nomes para os clientes que você confiaria o acesso de leitura para todo o repositório.</p>
</div>
<div class="paragraph">
<p>Os vetores de ataque informados são os seguintes:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A vítima envia as linhas "have" anunciando as IDs dos objetos que possui, que não são explicitamente planejados para serem compartilhados, porém podem ser usados para otimizar a transferência caso o par também os tenha. O atacante escolhe um ID do objeto <em>X</em> para roubar e envia uma "ref" para <em>X</em>, porém não é necessário enviar o conteúdo do <em>X</em> porque a vítima já o possui. Agora a vítima acredita que o atacante tem o <em>X</em> e depois envia seu conteúdo de volta ao atacante. (Esse ataque é mais simples para um cliente executar em um servidor, criando uma "ref" para <em>X</em> no espaço de nomes onde o cliente tem acesso e em seguida, buscando-o. A maneira mais provável de um servidor executá-lo em um cliente é "mesclar" <em>X</em> em um ramo público e esperar que o usuário faça um trabalho adicional neste ramo, enviá-lo de volta ao servidor sem perceber a mesclagem.)</p>
</li>
<li>
<p>Como no item 1, o invasor escolhe a ID do objeto X para roubar. A vítima envia um objeto Y que o invasor já possui, e o invasor alega falsamente que possui X e não Y, então a vítima envia Y como um delta contra X. O delta revela ao invasor regiões de X que são semelhantes a Y.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_bugs"><a class="anchor" href="#_bugs"></a>BUGS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Com a opção <code>--recurse-submodules</code> só pode buscar novos commits nos submódulos que já foram averiguados no momento. Quando, por exemplo, a "upstream" adicionou um novo submódulo nos commits recém-buscados do superprojeto, o submódulo em si não pode ser buscado, tornando impossível verificar o submódulo sendo necessário fazer uma nova busca mais tarde. Espera-se que isso seja corrigido em uma versão futura do Git.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_veja_também"><a class="anchor" href="#_veja_também"></a>VEJA TAMBÉM</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href='{{< relurl "docs/git-fetch/pt_BR" >}}'>git-fetch[1]</a>, <a href='{{< relurl "docs/git-merge/pt_BR" >}}'>git-merge[1]</a>, <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Parte do conjunto <a href='{{< relurl "docs/git/pt_BR" >}}'>git[1]</a></p>
</div>
</div>
</div>