---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - directory-rename-detection Documentation
docname: directory-rename-detection
version: 2.33.1
aliases:
- "/docs/directory-rename-detection/2.33.1/index.html"
- "/docs/directory-rename-detection/2.33.2/index.html"
- "/docs/directory-rename-detection/2.33.3/index.html"
- "/docs/directory-rename-detection/2.33.4/index.html"
- "/docs/directory-rename-detection/2.33.5/index.html"
- "/docs/directory-rename-detection/2.33.6/index.html"
- "/docs/directory-rename-detection/2.33.7/index.html"
- "/docs/directory-rename-detection/2.33.8/index.html"
- "/docs/directory-rename-detection/2.34.0/index.html"
- "/docs/directory-rename-detection/2.34.1/index.html"
- "/docs/directory-rename-detection/2.34.2/index.html"
- "/docs/directory-rename-detection/2.34.3/index.html"
- "/docs/directory-rename-detection/2.34.4/index.html"
- "/docs/directory-rename-detection/2.34.5/index.html"
- "/docs/directory-rename-detection/2.34.6/index.html"
- "/docs/directory-rename-detection/2.34.7/index.html"
- "/docs/directory-rename-detection/2.34.8/index.html"
- "/docs/directory-rename-detection/2.35.0/index.html"
- "/docs/directory-rename-detection/2.35.1/index.html"
- "/docs/directory-rename-detection/2.35.2/index.html"
- "/docs/directory-rename-detection/2.35.3/index.html"
- "/docs/directory-rename-detection/2.35.4/index.html"
- "/docs/directory-rename-detection/2.35.5/index.html"
- "/docs/directory-rename-detection/2.35.6/index.html"
- "/docs/directory-rename-detection/2.35.7/index.html"
- "/docs/directory-rename-detection/2.35.8/index.html"
- "/docs/directory-rename-detection/2.36.0/index.html"
- "/docs/directory-rename-detection/2.36.1/index.html"
- "/docs/directory-rename-detection/2.36.2/index.html"
- "/docs/directory-rename-detection/2.36.3/index.html"
- "/docs/directory-rename-detection/2.36.4/index.html"
- "/docs/directory-rename-detection/2.36.5/index.html"
- "/docs/directory-rename-detection/2.36.6/index.html"
- "/docs/directory-rename-detection/2.37.0/index.html"
- "/docs/directory-rename-detection/2.37.1/index.html"
- "/docs/directory-rename-detection/2.37.2/index.html"
- "/docs/directory-rename-detection/2.37.3/index.html"
- "/docs/directory-rename-detection/2.37.4/index.html"
- "/docs/directory-rename-detection/2.37.5/index.html"
- "/docs/directory-rename-detection/2.37.6/index.html"
- "/docs/directory-rename-detection/2.37.7/index.html"
- "/docs/directory-rename-detection/2.38.0/index.html"
- "/docs/directory-rename-detection/2.38.1/index.html"
- "/docs/directory-rename-detection/2.38.2/index.html"
- "/docs/directory-rename-detection/2.38.3/index.html"
- "/docs/directory-rename-detection/2.38.4/index.html"
- "/docs/directory-rename-detection/2.38.5/index.html"
- "/docs/directory-rename-detection/2.39.0/index.html"
- "/docs/directory-rename-detection/2.39.1/index.html"
- "/docs/directory-rename-detection/2.39.2/index.html"
- "/docs/directory-rename-detection/2.39.3/index.html"
- "/docs/directory-rename-detection/2.39.4/index.html"
- "/docs/directory-rename-detection/2.39.5/index.html"
- "/docs/directory-rename-detection/2.40.0/index.html"
- "/docs/directory-rename-detection/2.40.1/index.html"
- "/docs/directory-rename-detection/2.40.2/index.html"
- "/docs/directory-rename-detection/2.40.3/index.html"
- "/docs/directory-rename-detection/2.41.0/index.html"
- "/docs/directory-rename-detection/2.41.1/index.html"
- "/docs/directory-rename-detection/2.41.2/index.html"
- "/docs/directory-rename-detection/2.42.0/index.html"
- "/docs/directory-rename-detection/2.42.1/index.html"
- "/docs/directory-rename-detection/2.42.2/index.html"
- "/docs/directory-rename-detection/2.42.3/index.html"
- "/docs/directory-rename-detection/2.43.0/index.html"
- "/docs/directory-rename-detection/2.43.1/index.html"
- "/docs/directory-rename-detection/2.43.2/index.html"
- "/docs/directory-rename-detection/2.43.3/index.html"
- "/docs/directory-rename-detection/2.43.4/index.html"
- "/docs/directory-rename-detection/2.43.5/index.html"
- "/docs/directory-rename-detection/2.44.0/index.html"
- "/docs/directory-rename-detection/2.44.1/index.html"
- "/docs/directory-rename-detection/2.44.2/index.html"
- "/docs/directory-rename-detection/2.45.0/index.html"
- "/docs/directory-rename-detection/2.45.1/index.html"
- "/docs/directory-rename-detection/2.45.2/index.html"
- "/docs/directory-rename-detection/2.46.0/index.html"
- "/docs/directory-rename-detection/2.46.1/index.html"
- "/docs/directory-rename-detection/2.46.2/index.html"
---
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Rename detection logic in diffcore-rename that checks for renames of
individual files is also aggregated there and then analyzed in either
merge-ort or merge-recursive for cases where combinations of renames
indicate that a full directory has been renamed.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_scope_of_abilities"><a class="anchor" href="#_scope_of_abilities"></a>Scope of abilities</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It is perhaps easiest to start with an example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When all of x/a, x/b and x/c have moved to z/a, z/b and z/c, it is
likely that x/d added in the meantime would also want to move to z/d by
taking the hint that the entire directory <em>x</em> moved to <em>z</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>More interesting possibilities exist, though, such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>one side of history renames x &#8594; z, and the other renames some file to
x/e, causing the need for the merge to do a transitive rename so that
the rename ends up at z/e.</p>
</li>
<li>
<p>one side of history renames x &#8594; z, but also renames all files within x.
For example, x/a &#8594; z/alpha, x/b &#8594; z/bravo, etc.</p>
</li>
<li>
<p>both <em>x</em> and <em>y</em> being merged into a single directory <em>z</em>, with a
directory rename being detected for both x&#8594;z and y&#8594;z.</p>
</li>
<li>
<p>not all files in a directory being renamed to the same location;
i.e. perhaps most the files in <em>x</em> are now found under <em>z</em>, but a few
are found under <em>w</em>.</p>
</li>
<li>
<p>a directory being renamed, which also contained a subdirectory that was
renamed to some entirely different location.  (And perhaps the inner
directory itself contained inner directories that were renamed to yet
other locations).</p>
</li>
<li>
<p>combinations of the above; see t/t6423-merge-rename-directories.sh for
various interesting cases.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_limitationsapplicability_of_directory_renames"><a class="anchor" href="#_limitationsapplicability_of_directory_renames"></a>Limitations&#8201;&#8212;&#8201;applicability of directory renames</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In order to prevent edge and corner cases resulting in either conflicts
that cannot be represented in the index or which might be too complex for
users to try to understand and resolve, a couple basic rules limit when
directory rename detection applies:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>1) If a given directory still exists on both sides of a merge, we do
   not consider it to have been renamed.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>2) If a subset of to-be-renamed files have a file or directory in the
   way (or would be in the way of each other), "turn off" the directory
   rename for those specific sub-paths and report the conflict to the
   user.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>3) If the other side of history did a directory rename to a path that
   your side of history renamed away, then ignore that particular
   rename from the other side of history for any implicit directory
   renames (but warn the user).</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_limitationsdetailed_rules_and_testcases"><a class="anchor" href="#_limitationsdetailed_rules_and_testcases"></a>Limitations&#8201;&#8212;&#8201;detailed rules and testcases</h2>
<div class="sectionbody">
<div class="paragraph">
<p>t/t6423-merge-rename-directories.sh contains extensive tests and commentary
which generate and explore the rules listed above.  It also lists a few
additional rules:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>a) If renames split a directory into two or more others, the directory
   with the most renames, "wins".</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>b) Only apply implicit directory renames to directories if the other side
   of history is the one doing the renaming.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>c) Do not perform directory rename detection for directories which had no
   new paths added to them.</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_limitationssupport_in_different_commands"><a class="anchor" href="#_limitationssupport_in_different_commands"></a>Limitations&#8201;&#8212;&#8201;support in different commands</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Directory rename detection is supported by <em>merge</em> and <em>cherry-pick</em>.
Other git commands which users might be surprised to see limited or no
directory rename detection support in:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>diff</p>
<div class="literalblock">
<div class="content">
<pre>Folks have requested in the past that `git diff` detect directory
renames and somehow simplify its output.  It is not clear whether this
would be desirable or how the output should be simplified, so this was
simply not implemented.  Also, while diffcore-rename has most of the
logic for detecting directory renames, some of the logic is still found
within merge-ort and merge-recursive.  Fully supporting directory
rename detection in diffs would require copying or moving the remaining
bits of logic to the diff machinery.</pre>
</div>
</div>
</li>
<li>
<p>am</p>
<div class="literalblock">
<div class="content">
<pre>git-am tries to avoid a full three way merge, instead calling
git-apply.  That prevents us from detecting renames at all, which may
defeat the directory rename detection.  There is a fallback, though; if
the initial git-apply fails and the user has specified the -3 option,
git-am will fall back to a three way merge.  However, git-am lacks the
necessary information to do a "real" three way merge.  Instead, it has
to use build_fake_ancestor() to get a merge base that is missing files
whose rename may have been important to detect for directory rename
detection to function.</pre>
</div>
</div>
</li>
<li>
<p>rebase</p>
<div class="literalblock">
<div class="content">
<pre>Since am-based rebases work by first generating a bunch of patches
(which no longer record what the original commits were and thus don't
have the necessary info from which we can find a real merge-base), and
then calling git-am, this implies that am-based rebases will not always
successfully detect directory renames either (see the 'am' section
above).  merged-based rebases (rebase -m) and cherry-pick-based rebases
(rebase -i) are not affected by this shortcoming, and fully support
directory rename detection.</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>