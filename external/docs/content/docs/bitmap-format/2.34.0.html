---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - bitmap-format Documentation
docname: bitmap-format
version: 2.34.0
aliases:
- "/docs/bitmap-format/2.34.0/index.html"
- "/docs/bitmap-format/2.34.1/index.html"
- "/docs/bitmap-format/2.34.2/index.html"
- "/docs/bitmap-format/2.34.3/index.html"
- "/docs/bitmap-format/2.34.4/index.html"
- "/docs/bitmap-format/2.34.5/index.html"
- "/docs/bitmap-format/2.34.6/index.html"
- "/docs/bitmap-format/2.34.7/index.html"
- "/docs/bitmap-format/2.34.8/index.html"
- "/docs/bitmap-format/2.35.0/index.html"
- "/docs/bitmap-format/2.35.1/index.html"
- "/docs/bitmap-format/2.35.2/index.html"
- "/docs/bitmap-format/2.35.3/index.html"
- "/docs/bitmap-format/2.35.4/index.html"
- "/docs/bitmap-format/2.35.5/index.html"
- "/docs/bitmap-format/2.35.6/index.html"
- "/docs/bitmap-format/2.35.7/index.html"
- "/docs/bitmap-format/2.35.8/index.html"
- "/docs/bitmap-format/2.36.0/index.html"
- "/docs/bitmap-format/2.36.1/index.html"
- "/docs/bitmap-format/2.36.2/index.html"
- "/docs/bitmap-format/2.36.3/index.html"
- "/docs/bitmap-format/2.36.4/index.html"
- "/docs/bitmap-format/2.36.5/index.html"
- "/docs/bitmap-format/2.36.6/index.html"
- "/docs/bitmap-format/2.37.0/index.html"
- "/docs/bitmap-format/2.37.1/index.html"
---
<div class="sect1">
<h2 id="_pack_and_multi_pack_bitmaps"><a class="anchor" href="#_pack_and_multi_pack_bitmaps"></a>Pack and multi-pack bitmaps</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Bitmaps store reachability information about the set of objects in a packfile,
or a multi-pack index (MIDX). The former is defined obviously, and the latter is
defined as the union of objects in packs contained in the MIDX.</p>
</div>
<div class="paragraph">
<p>A bitmap may belong to either one pack, or the repository&#8217;s multi-pack index (if
it exists). A repository may have at most one bitmap.</p>
</div>
<div class="paragraph">
<p>An object is uniquely described by its bit position within a bitmap:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the bitmap belongs to a packfile, the <em>n</em>th bit corresponds to
the <em>n</em>th object in pack order. For a function <code>offset</code> which maps
objects to their byte offset within a pack, pack order is defined as
follows:</p>
<div class="literalblock">
<div class="content">
<pre>o1 &lt;= o2 &lt;==&gt; offset(o1) &lt;= offset(o2)</pre>
</div>
</div>
</li>
<li>
<p>If the bitmap belongs to a MIDX, the <em>n</em>th bit corresponds to the
<em>n</em>th object in MIDX order. With an additional function <code>pack</code> which
maps objects to the pack they were selected from by the MIDX, MIDX order
is defined as follows:</p>
<div class="literalblock">
<div class="content">
<pre>o1 &lt;= o2 &lt;==&gt; pack(o1) &lt;= pack(o2) /\ offset(o1) &lt;= offset(o2)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>The ordering between packs is done according to the MIDX's .rev file.
Notably, the preferred pack sorts ahead of all other packs.</pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The on-disk representation (described below) of a bitmap is the same regardless
of whether or not that bitmap belongs to a packfile or a MIDX. The only
difference is the interpretation of the bits, which is described above.</p>
</div>
<div class="paragraph">
<p>Certain bitmap extensions are supported (see: Appendix B). No extensions are
required for bitmaps corresponding to packfiles. For bitmaps that correspond to
MIDXs, both the bit-cache and rev-cache extensions are required.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_on_disk_format"><a class="anchor" href="#_on_disk_format"></a>On-disk format</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>A header appears at the beginning:</p>
<div class="literalblock">
<div class="content">
<pre>4-byte signature: {'B', 'I', 'T', 'M'}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>2-byte version number (network byte order)
	The current implementation only supports version 1
	of the bitmap index (the same one as JGit).</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>2-byte flags (network byte order)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>The following flags are supported:</pre>
</div>
</div>
</li>
<li>
<p>BITMAP_OPT_FULL_DAG (0x1) REQUIRED
This flag must always be present. It implies that the
bitmap index has been generated for a packfile or
multi-pack index (MIDX) with full closure (i.e. where
every single object in the packfile/MIDX can find its
parent links inside the same packfile/MIDX). This is a
requirement for the bitmap index format, also present in
JGit, that greatly reduces the complexity of the
implementation.</p>
</li>
<li>
<p>BITMAP_OPT_HASH_CACHE (0x4)
If present, the end of the bitmap file contains
<code>N</code> 32-bit name-hash values, one per object in the
pack/MIDX. The format and meaning of the name-hash is
described below.</p>
<div class="literalblock">
<div class="content">
<pre>4-byte entry count (network byte order)</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>The total count of entries (bitmapped commits) in this bitmap index.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>20-byte checksum</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>The SHA1 checksum of the pack/MIDX this bitmap index
belongs to.</pre>
</div>
</div>
</li>
<li>
<p>4 EWAH bitmaps that act as type indexes</p>
<div class="literalblock">
<div class="content">
<pre>Type indexes are serialized after the hash cache in the shape
of four EWAH bitmaps stored consecutively (see Appendix A for
the serialization format of an EWAH bitmap).</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>There is a bitmap for each Git object type, stored in the following
order:</pre>
</div>
</div>
</li>
<li>
<p>Commits</p>
</li>
<li>
<p>Trees</p>
</li>
<li>
<p>Blobs</p>
</li>
<li>
<p>Tags</p>
<div class="literalblock">
<div class="content">
<pre>In each bitmap, the `n`th bit is set to true if the `n`th object
in the packfile or multi-pack index is of that type.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>The obvious consequence is that the OR of all 4 bitmaps will result
in a full set (all bits set), and the AND of all 4 bitmaps will
result in an empty bitmap (no bits set).</pre>
</div>
</div>
</li>
<li>
<p>N entries with compressed bitmaps, one for each indexed commit</p>
<div class="literalblock">
<div class="content">
<pre>Where `N` is the total amount of entries in this bitmap index.
Each entry contains the following:</pre>
</div>
</div>
</li>
<li>
<p>4-byte object position (network byte order)
The position <strong>in the index for the packfile or
multi-pack index</strong> where the bitmap for this commit is
found.</p>
</li>
<li>
<p>1-byte XOR-offset
The xor offset used to compress this bitmap. For an entry
in position <code>x</code>, a XOR offset of <code>y</code> means that the actual
bitmap representing this commit is composed by XORing the
bitmap for this entry with the bitmap in entry <code>x-y</code> (i.e.
the bitmap <code>y</code> entries before this one).</p>
<div class="literalblock">
<div class="content">
<pre>Note that this compression can be recursive. In order to
XOR this entry with a previous one, the previous entry needs
to be decompressed first, and so on.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>The hard-limit for this offset is 160 (an entry can only be
xor'ed against one of the 160 entries preceding it). This
number is always positive, and hence entries are always xor'ed
with **previous** bitmaps, not bitmaps that will come afterwards
in the index.</pre>
</div>
</div>
</li>
<li>
<p>1-byte flags for this bitmap
At the moment the only available flag is <code>0x1</code>, which hints
that this bitmap can be re-used when rebuilding bitmap indexes
for the repository.</p>
</li>
<li>
<p>The compressed bitmap itself, see Appendix A.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_appendix_a_serialization_format_for_an_ewah_bitmap"><a class="anchor" href="#_appendix_a_serialization_format_for_an_ewah_bitmap"></a>Appendix A: Serialization format for an EWAH bitmap</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ewah bitmaps are serialized in the same protocol as the JAVAEWAH
library, making them backwards compatible with the JGit
implementation:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>4-byte number of bits of the resulting UNCOMPRESSED bitmap</p>
</li>
<li>
<p>4-byte number of words of the COMPRESSED bitmap, when stored</p>
</li>
<li>
<p>N x 8-byte words, as specified by the previous field</p>
<div class="literalblock">
<div class="content">
<pre>This is the actual content of the compressed bitmap.</pre>
</div>
</div>
</li>
<li>
<p>4-byte position of the current RLW for the compressed
bitmap</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All words are stored in network byte order for their corresponding
sizes.</p>
</div>
<div class="paragraph">
<p>The compressed bitmap is stored in a form of run-length encoding, as
follows.  It consists of a concatenation of an arbitrary number of
chunks.  Each chunk consists of one or more 64-bit words</p>
</div>
<div class="literalblock">
<div class="content">
<pre>H  L_1  L_2  L_3 .... L_M</pre>
</div>
</div>
<div class="paragraph">
<p>H is called RLW (run length word).  It consists of (from lower to higher
order bits):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>1 bit: the repeated bit B</p>
</li>
<li>
<p>32 bits: repetition count K (unsigned)</p>
</li>
<li>
<p>31 bits: literal word count M (unsigned)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The bitstream represented by the above chunk is then:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>K repetitions of B</p>
</li>
<li>
<p>The bits stored in <code>L_1</code> through <code>L_M</code>.  Within a word, bits at
lower order come earlier in the stream than those at higher
order.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The next word after <code>L_M</code> (if any) must again be a RLW, for the next
chunk.  For efficient appending to the bitstream, the EWAH stores a
pointer to the last RLW in the stream.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_appendix_b_optional_bitmap_sections"><a class="anchor" href="#_appendix_b_optional_bitmap_sections"></a>Appendix B: Optional Bitmap Sections</h2>
<div class="sectionbody">
<div class="paragraph">
<p>These sections may or may not be present in the <code>.bitmap</code> file; their
presence is indicated by the header flags section described above.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_name_hash_cache"><a class="anchor" href="#_name_hash_cache"></a>Name-hash cache</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If the BITMAP_OPT_HASH_CACHE flag is set, the end of the bitmap contains
a cache of 32-bit values, one per object in the pack/MIDX. The value at
position <code>i</code> is the hash of the pathname at which the `i`th object
(counting in index or multi-pack index order) in the pack/MIDX can be found.
This can be fed into the delta heuristics to compare objects with similar
pathnames.</p>
</div>
<div class="paragraph">
<p>The hash algorithm used is:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>hash = 0;
while ((c = *name++))
 if (!isspace(c))
  hash = (hash &gt;&gt; 2) + (c &lt;&lt; 24);</pre>
</div>
</div>
<div class="paragraph">
<p>Note that this hashing scheme is tied to the BITMAP_OPT_HASH_CACHE flag.
If implementations want to choose a different hashing scheme, they are
free to do so, but MUST allocate a new header flag (because comparing
hashes made under two different schemes would be pointless).</p>
</div>
</div>
</div>