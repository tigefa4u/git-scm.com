---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-format-patch Documentation
docname: git-format-patch
lang: zh_HANS-CN
aliases:
- "/docs/git-format-patch/zh_HANS-CN/index.html"
---
<div class="sect1">
<h2 id="_名称"><a class="anchor" href="#_名称"></a>名称</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-format-patch - 为提交电子邮件准备补丁</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_概述"><a class="anchor" href="#_概述"></a>概述</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git format-patch</em> [-k] [(-o|--output-directory) &lt;dir&gt; | --stdout]
		   [--no-thread | --thread[=&lt;style&gt;]]
		   [(--attach|--inline)[=&lt;boundary&gt;] | --no-attach]
		   [-s | --signoff]
		   [--signature=&lt;signature&gt; | --no-signature]
		   [--signature-file=&lt;file&gt;]
		   [-n | --numbered | -N | --no-numbered]
		   [--start-number &lt;n&gt;] [--numbered-files]
		   [--in-reply-to=&lt;message-id&gt;] [--suffix=.&lt;sfx&gt;]
		   [--ignore-if-in-upstream] [--always]
		   [--cover-from-description=&lt;mode&gt;]
		   [--rfc[=&lt;rfc&gt;]] [--subject-prefix=&lt;subject-prefix&gt;]
		   [(--reroll-count|-v) &lt;n&gt;]
		   [--to=&lt;email&gt;] [--cc=&lt;email&gt;]
		   [--[no-]cover-letter] [--quiet]
		   [--[no-]encode-email-headers]
		   [--no-notes | --notes[=&lt;ref&gt;]]
		   [--interdiff=&lt;previous&gt;]
		   [--range-diff=&lt;previous&gt; [--creation-factor=&lt;percent&gt;]]
		   [--filename-max-length=&lt;n&gt;]
		   [--progress]
		   [&lt;common-diff-options&gt;]
		   [ &lt;since&gt; | &lt;revision-range&gt; ]</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_描述"><a class="anchor" href="#_描述"></a>描述</h2>
<div class="sectionbody">
<div class="paragraph">
<p>将每个非合并提交及其 “补丁” 准备在每个提交的一个 “消息” 中，格式类似于 UNIX 邮箱。 这条命令的输出便于提交电子邮件或与 "git am" 一起使用。</p>
</div>
<div class="paragraph">
<p>命令产生的 "信息" 由三部分组成：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个简短的元数据头，以 "From &lt;提交&gt;" 开始，带有固定的 "Mon Sep 17 00:00:00 2001" 的日期，以帮助 "file(1)" 等程序识别该文件是该命令的输出，记录作者身份、作者日期和修改标题的字段（取自提交日志信息的第一段）。</p>
</li>
<li>
<p>提交日志信息的第二段和后续段落。</p>
</li>
<li>
<p>“补丁”，也就是该提交和其父辈之间的 "diff -p --stat" 输出（见 <a href='{{< relurl "docs/git-diff/zh_HANS-CN" >}}'>git-diff[1]</a>）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>日志信息和补丁之间用三条虚线隔开。</p>
</div>
<div class="paragraph">
<p>有两种方法可以指定要对哪些提交进行操作。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>单一的提交，&lt;从&gt;，指定导致当前分支顶端的提交不在导致 &lt;从&gt; 的历史中，要被输出。</p>
</li>
<li>
<p>通用的 &lt;修订范围&gt; 表达式（见 <a href='{{< relurl "docs/gitrevisions/zh_HANS-CN" >}}'>gitrevisions[7]</a>中的 "指定修订" 一节）表示指定范围内的提交。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在只有一个 &lt;提交&gt; 的情况下，第一条规则具有优先权。 要应用第二条规则，即格式化从历史开始到 &lt;提交&gt; 为止的所有内容，使用 <code>--root</code> 选项：<code>git format-patch --root &lt;提交&gt;</code>。 如果你只想格式化 &lt;提交&gt; 本身，你可以用`git format-patch -1 &lt;提交&gt;`来做。</p>
</div>
<div class="paragraph">
<p>默认情况下，每个输出文件从 1 开始依次编号，并使用提交信息的第一行（为保证路径名的安全而进行了调整）作为文件名。使用 <code>--numbered-files</code> 选项，输出文件名将只有数字，而没有附加提交信息的第一行。 除非指定 <code>--stdout</code> 选项，否则输出文件的名称将被打印到标准输出。</p>
</div>
<div class="paragraph">
<p>如果指定了 <code>-o</code>，输出文件将在&lt;目录&gt;创建。 否则，它们将在当前工作目录下创建。默认路径可以通过 <code>format.outputDirectory</code> 配置选项来设置。 <code>-o</code> 选项优先于 <code>format.outputDirectory</code>。 要在当前工作目录下存储补丁，即使 <code>format.outputDirectory</code> 指向其他地方，使用 <code>-o .</code>。所有的目录组件都将被创建。</p>
</div>
<div class="paragraph">
<p>默认情况下，单个补丁的主题是 "[PATCH]"，后面是提交信息到第一个空行的串联（见 <a href='{{< relurl "docs/git-commit/zh_HANS-CN" >}}'>git-commit[1]</a> 的讨论部分）。</p>
</div>
<div class="paragraph">
<p>当输出多个补丁时，主题前缀将改为 "[PATCH n/m] "。 要强制为单个补丁添加 1/1，使用 <code>-n</code>。 要从主题中省略补丁编号，使用 <code>-N</code>。</p>
</div>
<div class="paragraph">
<p>如果给出 <code>--thread</code>，<code>git-format-patch</code> 将生成 <code>In-Reply-To</code> 和 <code>References</code> 头，使第二封和随后的补丁邮件显示为对第一封邮件的回复；这也会生成一个 <code>Message-ID</code> 头供参考。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_选项"><a class="anchor" href="#_选项"></a>选项</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-format-patch--p"> <a class="anchor" href="#git-format-patch--p"></a>-p </dt>
<dt class="hdlist1" id="git-format-patch---no-stat"> <a class="anchor" href="#git-format-patch---no-stat"></a>--no-stat </dt>
<dd>
<p>生成没有任何差异状态 (diffstats) 的普通补丁。</p>
</dd>
<dt class="hdlist1" id="git-format-patch--Ultngt"> <a class="anchor" href="#git-format-patch--Ultngt"></a>-U&lt;n&gt; </dt>
<dt class="hdlist1" id="git-format-patch---unifiedltngt"> <a class="anchor" href="#git-format-patch---unifiedltngt"></a>--unified=&lt;n&gt; </dt>
<dd>
<p>生成带有 &lt;n&gt; 行上下文的差异，而不是通常的 3 行。暗含 <code>--patch</code> 选项。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---outputltgt"> <a class="anchor" href="#git-format-patch---outputltgt"></a>--output=&lt;文件&gt; </dt>
<dd>
<p>输出到一个特定的文件，而不是标准输出。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---output-indicator-newltgt"> <a class="anchor" href="#git-format-patch---output-indicator-newltgt"></a>--output-indicator-new=&lt;字符&gt; </dt>
<dt class="hdlist1" id="git-format-patch---output-indicator-oldltgt"> <a class="anchor" href="#git-format-patch---output-indicator-oldltgt"></a>--output-indicator-old=&lt;字符&gt; </dt>
<dt class="hdlist1" id="git-format-patch---output-indicator-contextltgt"> <a class="anchor" href="#git-format-patch---output-indicator-contextltgt"></a>--output-indicator-context=&lt;字符&gt; </dt>
<dd>
<p>指定在生成的补丁中用来表示新、旧或上下文行的字符。通常它们分别是 <em>+</em>、<em>-</em> 和 ' '（空格）。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---indent-heuristic"> <a class="anchor" href="#git-format-patch---indent-heuristic"></a>--indent-heuristic </dt>
<dd>
<p>启用启发式的缩进区块的方法，使得补丁更易读。这是默认选项。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---no-indent-heuristic"> <a class="anchor" href="#git-format-patch---no-indent-heuristic"></a>--no-indent-heuristic </dt>
<dd>
<p>禁用启发式缩进。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---minimal"> <a class="anchor" href="#git-format-patch---minimal"></a>--minimal </dt>
<dd>
<p>花费额外的时间以确保生成尽可能小的差异。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---patience"> <a class="anchor" href="#git-format-patch---patience"></a>--patience </dt>
<dd>
<p>使用 "patience diff" 算法生成差异。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---histogram"> <a class="anchor" href="#git-format-patch---histogram"></a>--histogram </dt>
<dd>
<p>使用 "histogram diff" 算法生成差异。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---anchoredltgt"> <a class="anchor" href="#git-format-patch---anchoredltgt"></a>--anchored=&lt;文本&gt; </dt>
<dd>
<p>使用 "anchored diff" 算法生成差异。</p>
<div class="paragraph">
<p>这个选项可以被指定多次。</p>
</div>
<div class="paragraph">
<p>如果某一个行同时存在于来源和目标中，各只出现一次，以这个文本开头，这个算法试图防止它在输出中以删除或添加的形式出现。它在内部使用了 "patience diff" 算法。</p>
</div>
</dd>
<dt class="hdlist1" id="git-format-patch---diff-algorithmpatienceminimalhistogrammyers"> <a class="anchor" href="#git-format-patch---diff-algorithmpatienceminimalhistogrammyers"></a>--diff-algorithm={patience|minimal|histogram|myers} </dt>
<dd>
<p>选择差异算法。有如下可选项：</p>
<div class="openblock">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-format-patch-codedefaultcodecodemyerscode"> <a class="anchor" href="#git-format-patch-codedefaultcodecodemyerscode"></a><code>default</code>, <code>myers</code> </dt>
<dd>
<p>基本的贪婪差异算法。当前是默认设置。</p>
</dd>
<dt class="hdlist1" id="git-format-patch-codeminimalcode"> <a class="anchor" href="#git-format-patch-codeminimalcode"></a><code>minimal</code> </dt>
<dd>
<p>花费额外的时间以确保生成尽可能小的差异。</p>
</dd>
<dt class="hdlist1" id="git-format-patch-codepatiencecode"> <a class="anchor" href="#git-format-patch-codepatiencecode"></a><code>patience</code> </dt>
<dd>
<p>使用 "patience diff" 算法时产生的补丁。</p>
</dd>
<dt class="hdlist1" id="git-format-patch-codehistogramcode"> <a class="anchor" href="#git-format-patch-codehistogramcode"></a><code>histogram</code> </dt>
<dd>
<p>该算法将耐心算法扩展为 “支持低发生率的常见元素”。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>例如，如果你将 <code>diff.algorithm</code> 变量配置为非默认值，但希望使用默认值，那么你必须使用 <code>--diff-algorithm=default</code> 选项。</p>
</div>
</dd>
<dt class="hdlist1" id="git-format-patch---statltgtltgtltgt"> <a class="anchor" href="#git-format-patch---statltgtltgtltgt"></a>--stat[=&lt;宽度&gt;[,&lt;名称宽度&gt;[,&lt;数值&gt;]]] </dt>
<dd>
<p>生成差异统计（diffstat）。默认情况下，文件名部分将使用尽可能多的空间，其余空间用于图表部分。最大宽度默认为终端宽度，如果未连接终端，则为 80 列，可以用 <code>&lt;最大宽度&gt;`覆盖。文件名部分的宽度可以通过在逗号后另加宽度 `&lt;文件名宽度&gt;`或设置 `diff.statNameWidth=&lt;文件名宽度&gt;`来限制。图形部分的宽度可以通过使用 `--stat-graph-width=&lt;图形宽度&gt;`或设置 `diff.statGraphWidth=&lt;图像宽度&gt;</code> 来限制。使用 <code>--stat</code> 或 <code>--stat-graph-width</code> 选项会影响所有生成统计图的命令，而设置 <code>diff.statNameWidth</code> 或 <code>diff.statGraphWidth</code> 则不会影响 <code>git format-patch</code>。 通过给出第三个参数 <code>&lt;行数&gt;</code>，可以将输出限制在前 <code>&lt;行数&gt;`行，如果行数更多，则在后面加上 `...</code>。</p>
<div class="paragraph">
<p>这些参数也可以用 <code>--stat-width=&lt;宽度&gt;</code>，<code>--stat-name-width=&lt;名称宽度&gt;</code> 和 <code>--stat-count=&lt;数量&gt;</code> 单独设置。</p>
</div>
</dd>
<dt class="hdlist1" id="git-format-patch---compact-summary"> <a class="anchor" href="#git-format-patch---compact-summary"></a>--compact-summary </dt>
<dd>
<p>在差异状态中输出扩展头信息的压缩摘要，如文件的创建或删除（"new" 或 "good"。如果是符号链接，则为 "+l"）和模式变化（"+x" 或 "-x" 分别用于添加或删除可执行位）。这些信息被放在文件名部分和图形部分之间。暗含 <code>--stat</code> 选项。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---numstat"> <a class="anchor" href="#git-format-patch---numstat"></a>--numstat </dt>
<dd>
<p>类似于 <code>--stat</code>，但是使用小数点和不含缩写的路径名显示添加和删除的行数，使其对程序更友好。对于二进制文件，输出两个 <code>-</code>，而不是 <code>0 0</code>。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---shortstat"> <a class="anchor" href="#git-format-patch---shortstat"></a>--shortstat </dt>
<dd>
<p>只输出使用 <code>--stat</code> 选项输出的最后一行，包含修改的文件总数，添加和删除的行数。</p>
</dd>
<dt class="hdlist1" id="git-format-patch--Xlt1282308203gt"> <a class="anchor" href="#git-format-patch--Xlt1282308203gt"></a>-X[&lt;参数1,参数2,&#8230;&#8203;&gt;] </dt>
<dt class="hdlist1" id="git-format-patch---dirstatlt1282308203gt"> <a class="anchor" href="#git-format-patch---dirstatlt1282308203gt"></a>--dirstat[=&lt;参数1,参数2,&#8230;&#8203;&gt;] </dt>
<dd>
<p>输出每个子目录的相对变化量的分布。<code>--dirstat</code> 的行为可以通过传递一个以逗号分隔的参数列表来自定义。默认值由`diff.dirstat` 配置变量控制 (参见 <a href='{{< relurl "docs/git-config/zh_HANS-CN" >}}'>git-config[1]</a>)。以下是可用的参数：</p>
<div class="openblock">
<div class="content">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-format-patch-codechangescode"> <a class="anchor" href="#git-format-patch-codechangescode"></a><code>changes</code> </dt>
<dd>
<p>通过计算从源文件中删除的行数或添加到目标文件中的行数来计算分布状态的数字。这忽略了文件内的代码移动行为。也就是说，在文件中重新排列的行不会像其他变化一样被计算在内。这是在没有给出参数时的默认行为。</p>
</dd>
<dt class="hdlist1" id="git-format-patch-codelinescode"> <a class="anchor" href="#git-format-patch-codelinescode"></a><code>lines</code> </dt>
<dd>
<p>通过做常规基于行的差异分析，计算分布状态的数字，并将删除/添加的行数相加。(对于二进制文件，用 64 字节的块来计算，因为二进制文件没有行的概念)。在使用 <code>--dirstat</code> 时这个选项的行为开销比 <code>changes</code> 更大，但会对文件中重新排列的行进行计数。其得到的输出结果与其他的 <code>--*stat</code> 选项一致。</p>
</dd>
<dt class="hdlist1" id="git-format-patch-codefilescode"> <a class="anchor" href="#git-format-patch-codefilescode"></a><code>files</code> </dt>
<dd>
<p>通过计算被改变的文件数量来计算分布状态的数字。在分布状态分析中，每一个被改变的文件都会被平等地计算。这是计算上开销最小的 <code>--dirstat</code> 行为，因为它无需查看文件内容。</p>
</dd>
<dt class="hdlist1" id="git-format-patch-codecumulativecode"> <a class="anchor" href="#git-format-patch-codecumulativecode"></a><code>cumulative</code> </dt>
<dd>
<p>子目录中的变化计算到父目录中。 注意，当使用 <code>cumulative</code> 选项时，报告的百分比之和可能超过 100%。默认的（非累积）行为可以用 <code>noncumulative</code> 参数指定。</p>
</dd>
<dt class="hdlist1" id="git-format-patch-ltlimitgt"> <a class="anchor" href="#git-format-patch-ltlimitgt"></a>&lt;limit&gt; </dt>
<dd>
<p>一个整数参数，其指定一个截止百分比（默认为 3%）。贡献值小于这个百分比的目录不显示在输出中。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="paragraph">
<p>例如：下面的参数会统计更改的文件，同时忽略占更改文件总数 10% 以下的目录，并累积父目录中的子目录计数：<code>--dirstat=files,10,cumulative</code>。</p>
</div>
</dd>
<dt class="hdlist1" id="git-format-patch---cumulative"> <a class="anchor" href="#git-format-patch---cumulative"></a>--cumulative </dt>
<dd>
<p>--dirstat=cumulative 同义</p>
</dd>
<dt class="hdlist1" id="git-format-patch---dirstat-by-filelt12gt82308203"> <a class="anchor" href="#git-format-patch---dirstat-by-filelt12gt82308203"></a>--dirstat-by-file[=&lt;参数1,参数2&gt;&#8230;&#8203;] </dt>
<dd>
<p>与 --dirstat=files,&lt;参数 1&gt;,&lt;参数 2&gt; 同义</p>
</dd>
<dt class="hdlist1" id="git-format-patch---summary"> <a class="anchor" href="#git-format-patch---summary"></a>--summary </dt>
<dd>
<p>输出扩展头信息，如创建、重命名和模式变化等，的压缩摘要。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---no-renames"> <a class="anchor" href="#git-format-patch---no-renames"></a>--no-renames </dt>
<dd>
<p>关闭重命名检测，即使配置文件给出的默认是这样做。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---no-rename-empty"> <a class="anchor" href="#git-format-patch---no-rename-empty"></a>--[no-]rename-empty </dt>
<dd>
<p>是否使用空的数据对象作为重命名源。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---full-index"> <a class="anchor" href="#git-format-patch---full-index"></a>--full-index </dt>
<dd>
<p>在生成补丁格式输出时，在 <code>index</code>（索引）行上显示完整的图像前和图像后数据对象名称，而不仅是前几个字符。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---binary"> <a class="anchor" href="#git-format-patch---binary"></a>--binary </dt>
<dd>
<p>除了 <code>--full-index</code> 输出的差异之外，输出二进制的差异。其可以用 <code>git-apply</code> 命令来应用。暗含 <code>--patch</code> 选项。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---abbrevltngt"> <a class="anchor" href="#git-format-patch---abbrevltngt"></a>--abbrev[=&lt;n&gt;] </dt>
<dd>
<p>在 diff-raw 格式输出和 diff-tree 头文件行中，不显示完整的 40 字节十六进制对象名称，而是显示唯一指向对象的最短前缀，长度至少为 <em>&lt;n&gt;</em> 位十六进制数字。 在 diff-patch 输出格式中，<code>--full-index</code> 优先，也就是说，如果指定了 <code>--full-index</code>，则无论 <code>--abbrev</code> 如何，都会显示完整的 blob 名称。 可以使用 <code>--abbrev=&lt;n&gt;</code> 指定非默认位数。</p>
</dd>
<dt class="hdlist1" id="git-format-patch--Bltngtltmgt"> <a class="anchor" href="#git-format-patch--Bltngtltmgt"></a>-B[&lt;n&gt;][/&lt;m&gt;] </dt>
<dt class="hdlist1" id="git-format-patch---break-rewritesltngtltmgt"> <a class="anchor" href="#git-format-patch---break-rewritesltngtltmgt"></a>--break-rewrites[=[&lt;n&gt;][/&lt;m&gt;]] </dt>
<dd>
<p>将完整的重写更改切分成删除和创建对（pair）。这有两个目的：</p>
<div class="paragraph">
<p>它会影响决定更改形式的阈值，当单个文件内修改总量达到一定值时，会认为该文件进行了完全重写，而不是将一系列删除和插入操作视为修改。如果视为多个删除和插入修改，修改中的行可能会碰巧在文本上与原文一致，从而被当作上下文。选项中的数字 <code>m</code> 控制 -B 选项的这一方面（默认为 60％）。<code>-B/70％</code> 表示，如果在结果中保留的原始内容少于原始内容的 30％，则 Git 认为它是完全重写的（否则，生成的补丁将是一系列删除和插入，并与上下文行混合在一起）。</p>
</div>
<div class="paragraph">
<p>使用 -M 选项时，一个完全改写的文件也被认为是重命名文件的来源（通常 -M 只考查一个消失文件作为重命名的来源)。选项中的数量 <code>n</code> 控制 -B 选项的这一方面（默认为 50％)。<code>-B20%</code> 表明，当插入与删除比 20％ 的文件大小更多，该文件可作为重命名到另一文件的可能来源。</p>
</div>
</dd>
<dt class="hdlist1" id="git-format-patch--Mltngt"> <a class="anchor" href="#git-format-patch--Mltngt"></a>-M[&lt;n&gt;] </dt>
<dt class="hdlist1" id="git-format-patch---find-renamesltngt"> <a class="anchor" href="#git-format-patch---find-renamesltngt"></a>--find-renames[=&lt;n&gt;] </dt>
<dd>
<p>重命名检测。
如果指定了 <code>n</code>，则其为相似度指数阈值（即相比于文件大小的增/删量）。
例如，<code>-M90％</code> 表示如果文件90％以上的内容没有更改，则 Git 应将删除/添加对视为重命名。
如果没有 <code>％</code> 符号，则该数字应作为小数读取，并在其前面加上小数点。
	即 <code>-M5</code> 变为 0.5，因此与 <code>-M50％</code> 相同。 同样，<code>-M05</code> 与 <code>-M5％</code> 相同。
	要将检测限制为精确的重命名，请使用 <code>-M100％</code>。 默认相似度指数为50％。</p>
</dd>
<dt class="hdlist1" id="git-format-patch--Cltngt"> <a class="anchor" href="#git-format-patch--Cltngt"></a>-C[&lt;n&gt;] </dt>
<dt class="hdlist1" id="git-format-patch---find-copiesltngt"> <a class="anchor" href="#git-format-patch---find-copiesltngt"></a>--find-copies[=&lt;n&gt;] </dt>
<dd>
<p>检测复制与重命名。参见 <code>--find-copies-harder</code>。如果指定了 <code>n</code>，则其与 <code>-M&lt;n&gt;</code> 含义相同。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---find-copies-harder"> <a class="anchor" href="#git-format-patch---find-copies-harder"></a>--find-copies-harder </dt>
<dd>
<p>出于性能考虑，默认情况下，<code>-C</code> 选项只在复制的原始文件在相同的变更集中被修改时才会查找复制。这个标志使命令检查未修改的文件作为复制源的候选文件。 对于大型项目来说，这是一个非常耗时的操作，所以要谨慎使用。 给出一个以上的 <code>-C</code> 选项有同样的效果。</p>
</dd>
<dt class="hdlist1" id="git-format-patch--D"> <a class="anchor" href="#git-format-patch--D"></a>-D </dt>
<dt class="hdlist1" id="git-format-patch---irreversible-delete"> <a class="anchor" href="#git-format-patch---irreversible-delete"></a>--irreversible-delete </dt>
<dd>
<p>删除时省略原内容，即只打印头信息，而不打原内容和 <code>/dev/null</code> 之间的差异。所产生的补丁并不是要用于 <code>patch</code> 或 <code>git apply</code>；这只是为了让人们只专注于审查修改后的文本。此外，输出结果显然缺乏足够的信息来反转，或手动应用这样一个补丁，因此这个选项的名称如此。</p>
<div class="paragraph">
<p>当与 <code>-B</code> 一起使用时，也省略删除/创建对中删除部分的原内容。</p>
</div>
</dd>
<dt class="hdlist1" id="git-format-patch--lltgt"> <a class="anchor" href="#git-format-patch--lltgt"></a>-l&lt;数量&gt; </dt>
<dd>
<p><code>-M</code> 和 <code>-C</code> 选项涉及一些初步步骤，可以廉价地检测重命名/副本的子集，然后是详尽的后备部分，将所有剩余的未配对目的地与所有相关源进行比较。 （对于重命名，只有剩余的未配对源是相关的；对于副本，所有原始源都是相关的。）对于 N 个源和目的地，这个详尽的检查是 O(N^2)。如果涉及的源/目标文件数量超过指定数量，则此选项可防止重命名/复制检测的详尽部分运行。默认为 diff.renameLimit。请注意，值 0 被视为无限制。</p>
</dd>
<dt class="hdlist1" id="git-format-patch--Oltgt"> <a class="anchor" href="#git-format-patch--Oltgt"></a>-O&lt;顺序控制文件&gt; </dt>
<dd>
<p>控制文件在输出中出现的顺序。这将覆盖 <code>diff.orderFile</code> 配置变量（参见 <a href='{{< relurl "docs/git-config/zh_HANS-CN" >}}'>git-config[1]</a>）。要取消 <code>diff.orderFile</code>，请使用 <code>-O/dev/null</code>。</p>
<div class="paragraph">
<p>输出顺序由 &lt;顺序控制文件&gt; 中的 glob 模式的顺序决定。所有路径名与第一个模式匹配的文件首先输出，路径名与第二个模式匹配（但不与第一个模式匹配）的文件其次输出，以此类推。所有路径名与任何模式匹配的文件会最后输出，就像在文件末尾有一个隐含的全部匹配模式。如果多个路径名具有相同的等级（它们匹配相同的模式，但没有匹配先前的模式），它们相对于彼此的输出顺序是正常的。</p>
</div>
<div class="paragraph">
<p>&lt;顺序控制文件&gt; 格式如下：</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>空白行会被忽略，因此可以用它们作为分隔符，以保证可读性。</p>
</li>
<li>
<p>以井号（"<code>#</code>"）开头的行会被忽略，所以它们可以用来做注释。如果模式以井号开头，则需要在模式的开头加上反斜杠（"<code>\</code>"）。</p>
</li>
<li>
<p>每一行都包含一个模式。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>模式的语法和语义与 fnmatch(3) 中使用的相同，不包括 FNM_PATHNAME 标志，但在删除路径名中结尾任意几个成分后匹配的情况下例外。例如，模式 "<code>foo*bar</code>" 匹配 "<code>fooasdfbar</code>" 和 "<code>foo/bar/baz/asdf</code>"，但不匹配 "<code>foobarx</code>"。</p>
</div>
</dd>
<dt class="hdlist1" id="git-format-patch---skip-toltgt"> <a class="anchor" href="#git-format-patch---skip-toltgt"></a>--skip-to=&lt;文件&gt; </dt>
<dt class="hdlist1" id="git-format-patch---rotate-toltgt"> <a class="anchor" href="#git-format-patch---rotate-toltgt"></a>--rotate-to=&lt;文件&gt; </dt>
<dd>
<p>从输出中丢弃命名 &lt;文件&gt; 之前的文件（即 <em>skip to</em>），或将它们移到输出的末尾（即 <em>rotate to</em>）。 这些选项主要是为使用 <code>git difftool</code> 命令而发明的，在其他情况下可能用处不大。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---relativeltgt"> <a class="anchor" href="#git-format-patch---relativeltgt"></a>--relative[=&lt;路径&gt;] </dt>
<dt class="hdlist1" id="git-format-patch---no-relative"> <a class="anchor" href="#git-format-patch---no-relative"></a>--no-relative </dt>
<dd>
<p>当从项目的子目录中运行时，可以排除目录外的变化，并通过这个选项显示相对于它的路径名。当你不在子目录中时（例如在纯仓库中），你可以通过 &lt;路径&gt; 参数来指明要使输出相对于哪个子目录。<code>--no-relative</code> 可以用来取消 <code>diff.relative`配置选项和之前的 `--relative</code> 选项。</p>
</dd>
<dt class="hdlist1" id="git-format-patch--a"> <a class="anchor" href="#git-format-patch--a"></a>-a </dt>
<dt class="hdlist1" id="git-format-patch---text"> <a class="anchor" href="#git-format-patch---text"></a>--text </dt>
<dd>
<p>将一切输入文件视为文本。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---ignore-cr-at-eol"> <a class="anchor" href="#git-format-patch---ignore-cr-at-eol"></a>--ignore-cr-at-eol </dt>
<dd>
<p>在进行比较时，忽略行末的回车。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---ignore-space-at-eol"> <a class="anchor" href="#git-format-patch---ignore-space-at-eol"></a>--ignore-space-at-eol </dt>
<dd>
<p>忽略行尾空格的变化。</p>
</dd>
<dt class="hdlist1" id="git-format-patch--b"> <a class="anchor" href="#git-format-patch--b"></a>-b </dt>
<dt class="hdlist1" id="git-format-patch---ignore-space-change"> <a class="anchor" href="#git-format-patch---ignore-space-change"></a>--ignore-space-change </dt>
<dd>
<p>忽略空格数量的变化。这会忽略行尾的空格，并认为包含一个或多个空格字符的其他序列都是等同的。</p>
</dd>
<dt class="hdlist1" id="git-format-patch--w"> <a class="anchor" href="#git-format-patch--w"></a>-w </dt>
<dt class="hdlist1" id="git-format-patch---ignore-all-space"> <a class="anchor" href="#git-format-patch---ignore-all-space"></a>--ignore-all-space </dt>
<dd>
<p>比较行时忽略空格。即使一行有空格而另一行没有空格，也会忽略差异。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---ignore-blank-lines"> <a class="anchor" href="#git-format-patch---ignore-blank-lines"></a>--ignore-blank-lines </dt>
<dd>
<p>忽略空白行的变化。</p>
</dd>
<dt class="hdlist1" id="git-format-patch--Iltgt"> <a class="anchor" href="#git-format-patch--Iltgt"></a>-I&lt;正则表达式&gt; </dt>
<dt class="hdlist1" id="git-format-patch---ignore-matching-linesltgt"> <a class="anchor" href="#git-format-patch---ignore-matching-linesltgt"></a>--ignore-matching-lines=&lt;正则表达式&gt; </dt>
<dd>
<p>忽略所有行均匹配 &lt;正则表达式&gt; 的更改。 此选项可指定多次。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---inter-hunk-contextltgt"> <a class="anchor" href="#git-format-patch---inter-hunk-contextltgt"></a>--inter-hunk-context=&lt;行数&gt; </dt>
<dd>
<p>显示块差异之间的上下文，最多显示指定的行数，从而合并彼此接近的块。 默认认为 <code>diff.interHunkContext</code>，如果配置选项未设置，则默认为0。</p>
</dd>
<dt class="hdlist1" id="git-format-patch--W"> <a class="anchor" href="#git-format-patch--W"></a>-W </dt>
<dt class="hdlist1" id="git-format-patch---function-context"> <a class="anchor" href="#git-format-patch---function-context"></a>--function-context </dt>
<dd>
<p>在每个修改中的上下文行显示整个函数。函数名称的确定方式与 <code>git diff</code> 计算补丁头的方式相同（参见 <a href='{{< relurl "docs/gitattributes/zh_HANS-CN" >}}'>gitattributes[5]</a> 中的 <em>自定义区块头</em> ）。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---ext-diff"> <a class="anchor" href="#git-format-patch---ext-diff"></a>--ext-diff </dt>
<dd>
<p>允许执行外部差异器。如果你用 <a href='{{< relurl "docs/gitattributes/zh_HANS-CN" >}}'>gitattributes[5]</a> 设置了一个外部差异驱动程序，你需要在 <a href='{{< relurl "docs/git-log/zh_HANS-CN" >}}'>git-log[1]</a> 和相关命令中使用这个选项。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---no-ext-diff"> <a class="anchor" href="#git-format-patch---no-ext-diff"></a>--no-ext-diff </dt>
<dd>
<p>禁止使用外部差异器。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---textconv"> <a class="anchor" href="#git-format-patch---textconv"></a>--textconv </dt>
<dt class="hdlist1" id="git-format-patch---no-textconv"> <a class="anchor" href="#git-format-patch---no-textconv"></a>--no-textconv </dt>
<dd>
<p>允许（或不允许）在比较二进制文件时运行外部文本转换过滤器。详情请参见 <a href='{{< relurl "docs/gitattributes/zh_HANS-CN" >}}'>gitattributes[5]</a> 。由于文本转换过滤器通常是单向转换，因此产生的差异适合人类用户使用，但不能应用（apply）。因此默认情况下，只有 <a href='{{< relurl "docs/git-diff/zh_HANS-CN" >}}'>git-diff[1]</a> 和 <a href='{{< relurl "docs/git-log/zh_HANS-CN" >}}'>git-log[1]</a> 启用文本转换过滤器，而 <a href='{{< relurl "docs/git-format-patch/zh_HANS-CN" >}}'>git-format-patch[1]</a> 或 diff plumbing 命令则不启用。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---ignore-submodulesltwhengt"> <a class="anchor" href="#git-format-patch---ignore-submodulesltwhengt"></a>--ignore-submodules[=&lt;when&gt;] </dt>
<dd>
<p>在生成差异时忽略子模块的修改。&lt;when&gt; 可以是 "none"、"untracked"、"dirty " 或 "all"，"all" 是默认选项。使用 "none" 会在子模块包含未跟踪或修改的文件，或者它的HEAD 与上级项目中记录的提交不同时，认为它被修改了，并且可以用来覆盖 <a href='{{< relurl "docs/git-config/zh_HANS-CN" >}}'>git-config[1]</a> 或 <a href='{{< relurl "docs/gitmodules/zh_HANS-CN" >}}'>gitmodules[5]</a> 中 <em>忽略</em> 选项的设置。当使用 "untracked" 时，当子模块只包含未跟踪的内容时，它们不会被认为是有改动的（但它们仍然会被扫描是否有被修改的内容）。使用 "dirty" 会忽略所有对子模块工作树的修改，只有存储在上级项目中的提交的修改才会被显示出来（这是在1.7.0之前的行为）。使用 "all" 会隐藏所有对子模块的修改。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---src-prefixltgt"> <a class="anchor" href="#git-format-patch---src-prefixltgt"></a>--src-prefix=&lt;前缀&gt; </dt>
<dd>
<p>显示给定的源前缀而不是 "a/"。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---dst-prefixltgt"> <a class="anchor" href="#git-format-patch---dst-prefixltgt"></a>--dst-prefix=&lt;前缀&gt; </dt>
<dd>
<p>显示给定的目标前缀，而不是“b/”。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---no-prefix"> <a class="anchor" href="#git-format-patch---no-prefix"></a>--no-prefix </dt>
<dd>
<p>不显示任何源或目的前缀。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---default-prefix"> <a class="anchor" href="#git-format-patch---default-prefix"></a>--default-prefix </dt>
<dd>
<p>Use the default source and destination prefixes ("a/" and "b/"). This overrides configuration variables such as <code>diff.noprefix</code>, <code>diff.srcPrefix</code>, <code>diff.dstPrefix</code>, and <code>diff.mnemonicPrefix</code> (see <code>git-config</code>(1)).</p>
</dd>
<dt class="hdlist1" id="git-format-patch---line-prefixltprefixgt"> <a class="anchor" href="#git-format-patch---line-prefixltprefixgt"></a>--line-prefix=&lt;prefix&gt; </dt>
<dd>
<p>在每一行输出前加上一个额外的前缀。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---ita-invisible-in-index"> <a class="anchor" href="#git-format-patch---ita-invisible-in-index"></a>--ita-invisible-in-index </dt>
<dd>
<p>默认情况下，通过 "git add -N" 添加的条目在 "git diff" 中显示为现有的空文件，在 "git diff --cached" 中显示为新文件。这个选项使得条目在 "git diff" 中显示为一个新文件，而在 "git diff --cached" 中显示为不存在的文件。这个选项可以用 <code>--ita-visible-in-index</code> 来还原。这两个选项都是试验性的，将来可能会被删除。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>关于这些常用选项的更多解释，请参见 <a href='{{< relurl "docs/gitdiffcore/zh_HANS-CN" >}}'>gitdiffcore[7]</a>。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-format-patch--ltngt"> <a class="anchor" href="#git-format-patch--ltngt"></a>-&lt;n&gt; </dt>
<dd>
<p>从最上面的 &lt;n&gt; 个提交中准备补丁。</p>
</dd>
<dt class="hdlist1" id="git-format-patch--oltgt"> <a class="anchor" href="#git-format-patch--oltgt"></a>-o &lt;目录&gt; </dt>
<dt class="hdlist1" id="git-format-patch---output-directoryltgt"> <a class="anchor" href="#git-format-patch---output-directoryltgt"></a>--output-directory &lt;目录&gt; </dt>
<dd>
<p>使用 &lt;目录&gt; 来存储结果文件，而不是当前工作目录。</p>
</dd>
<dt class="hdlist1" id="git-format-patch--n"> <a class="anchor" href="#git-format-patch--n"></a>-n </dt>
<dt class="hdlist1" id="git-format-patch---numbered"> <a class="anchor" href="#git-format-patch---numbered"></a>--numbered </dt>
<dd>
<p>以 <em>[PATCH n/m]</em> 的格式输出名称，即使只有一个补丁。</p>
</dd>
<dt class="hdlist1" id="git-format-patch--N"> <a class="anchor" href="#git-format-patch--N"></a>-N </dt>
<dt class="hdlist1" id="git-format-patch---no-numbered"> <a class="anchor" href="#git-format-patch---no-numbered"></a>--no-numbered </dt>
<dd>
<p>以 <em>[PATCH]</em> 格式输出名称。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---start-numberltngt"> <a class="anchor" href="#git-format-patch---start-numberltngt"></a>--start-number &lt;n&gt; </dt>
<dd>
<p>从&lt;n&gt;开始个给补丁编号，替代默认从1开始。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---numbered-files"> <a class="anchor" href="#git-format-patch---numbered-files"></a>--numbered-files </dt>
<dd>
<p>输出文件名将是一个简单的数字序列，没有附加默认的第一行提交。</p>
</dd>
<dt class="hdlist1" id="git-format-patch--k"> <a class="anchor" href="#git-format-patch--k"></a>-k </dt>
<dt class="hdlist1" id="git-format-patch---keep-subject"> <a class="anchor" href="#git-format-patch---keep-subject"></a>--keep-subject </dt>
<dd>
<p>不要从提交日志信息的第一行剥离/添加 <em>[PATCH]</em>。</p>
</dd>
<dt class="hdlist1" id="git-format-patch--s"> <a class="anchor" href="#git-format-patch--s"></a>-s </dt>
<dt class="hdlist1" id="git-format-patch---signoff"> <a class="anchor" href="#git-format-patch---signoff"></a>--signoff </dt>
<dd>
<p>在提交信息中加入 <code>Signed-off-by</code> 的尾注，使用自己的提交者身份。 更多信息见 <a href='{{< relurl "docs/git-commit/zh_HANS-CN" >}}'>git-commit[1]</a> 中的 signoff 选项。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---stdout"> <a class="anchor" href="#git-format-patch---stdout"></a>--stdout </dt>
<dd>
<p>以 mbox 格式将所有的提交打印到标准输出，而不是为每个提交创建一个文件。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---attachltgt"> <a class="anchor" href="#git-format-patch---attachltgt"></a>--attach[=&lt;边界&gt;] </dt>
<dd>
<p>创建多部分/混合附件，第一部分是提交信息，第二部分是补丁本身，<code>Content-Disposition: attachment</code>。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---no-attach"> <a class="anchor" href="#git-format-patch---no-attach"></a>--no-attach </dt>
<dd>
<p>禁用附件的创建，覆盖配置设置。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---inlineltgt"> <a class="anchor" href="#git-format-patch---inlineltgt"></a>--inline[=&lt;边界&gt;] </dt>
<dd>
<p>创建 multipart/mixed 附件，第一部分是提交信息，第二部分是补丁本身，使用 <code>Content-Disposition: inline</code>。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---threadltgt"> <a class="anchor" href="#git-format-patch---threadltgt"></a>--thread[=&lt;样式&gt;] </dt>
<dt class="hdlist1" id="git-format-patch---no-thread"> <a class="anchor" href="#git-format-patch---no-thread"></a>--no-thread </dt>
<dd>
<p>控制添加 <code>In-Reply-To</code> 和 <code>References</code> 标头，使第二封及以后的邮件显示为对第一封邮件的回复。 还控制生成 <code>Message-ID</code> 头，以便参考。</p>
<div class="paragraph">
<p>可选的 &lt;风格&gt; 参数可以是 <code>shallow</code> 或 <code>deep</code>。 ‘浅’ 线程使每封邮件都是对该系列的头的回复，其中头是从封面信、<code>--in-reply-to</code> 和第一个补丁邮件中选择的，按这个顺序。 ‘深’ 线程使每封邮件都是对前一封的回复。</p>
</div>
<div class="paragraph">
<p>默认是 <code>--no-thread</code>，除非设置了 <code>format.thread</code> 配置。 没有参数的 <code>--thread</code> 等同于 <code>--thread=shallow</code>。</p>
</div>
<div class="paragraph">
<p>请注意，<em>git send-email</em> 的默认设置是对邮件本身进行线程处理。 如果你想让 <code>git format-patch</code> 负责线程，你要确保 <code>git send-email</code> 的线程被禁用。</p>
</div>
</dd>
<dt class="hdlist1" id="git-format-patch---in-reply-toltIDgt"> <a class="anchor" href="#git-format-patch---in-reply-toltIDgt"></a>--in-reply-to=&lt;消息 ID&gt; </dt>
<dd>
<p>使第一封邮件（或所有带有 <code>--no-thread</code> 的邮件）作为给定的 &lt;消息 id&gt; 的回复出现，这可以避免破坏线程以提供一个新的补丁系列。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---ignore-if-in-upstream"> <a class="anchor" href="#git-format-patch---ignore-if-in-upstream"></a>--ignore-if-in-upstream </dt>
<dd>
<p>不包括与 &lt;until&gt;&#8230;&#8203;&lt;since&gt; 中的提交相匹配的补丁。 这将检查所有可从 &lt;since&gt; 到达但不在 &lt;until&gt; 的补丁，并将它们与正在生成的补丁进行比较，任何匹配的补丁都将被忽略。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---always"> <a class="anchor" href="#git-format-patch---always"></a>--always </dt>
<dd>
<p>包括那些没有引入任何变化的提交的补丁，这些补丁默认是省略的。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---cover-from-descriptionltgt"> <a class="anchor" href="#git-format-patch---cover-from-descriptionltgt"></a>--cover-from-description=&lt;模式&gt; </dt>
<dd>
<p>控制求职信的哪些部分将使用分支机构的描述自动填充。</p>
<div class="paragraph">
<p>如果 <code>&lt;模式&gt;</code> 是 <code>message</code> 或 <code>default</code>，求职信的主题将被填充为占位符文本。信函的正文将被填入分支的描述。这是没有指定配置或命令行选项时的默认模式。</p>
</div>
<div class="paragraph">
<p>如果 <code>&lt;模式&gt;</code> 是 <code>subject</code>，分支描述的第一段将填入求职信的主题。描述的其余部分将填充到求职信的正文中。</p>
</div>
<div class="paragraph">
<p>如果 <code>&lt;模式&gt;</code> 是 <code>auto</code>，如果分支描述的第一段大于100字节，那么模式将是 <code>message</code>，否则将使用 <code>subject</code>。</p>
</div>
<div class="paragraph">
<p>如果 <code>&lt;模式&gt;</code> 为 <code>none</code>，求职信的主题和正文都将被填充为占位符文本。</p>
</div>
</dd>
<dt class="hdlist1" id="git-format-patch---description-fileltgt"> <a class="anchor" href="#git-format-patch---description-fileltgt"></a>--description-file=&lt;文件&gt; </dt>
<dd>
<p>使用 &lt;文件&gt; 的内容而不是分支说明来生成求职信。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---subject-prefixltgt"> <a class="anchor" href="#git-format-patch---subject-prefixltgt"></a>--subject-prefix=&lt;主题前缀&gt; </dt>
<dd>
<p>在主题行中不要使用标准的 <em>[PATCH]</em> 前缀，而应使用 <em>[&lt;主题前缀&gt;]</em>。这可用于命名补丁系列，并可与 <code>--numbered</code> 选项结合使用。</p>
<div class="paragraph">
<p>配置变量 <code>format.subjectPrefix</code> 也可用于配置主题前缀，以适用于指定仓库的所有补丁。这在接收多个仓库补丁的邮件列表中通常很有用，可用于消除补丁的歧义（例如值为 "PATCH my-project"）。</p>
</div>
</dd>
<dt class="hdlist1" id="git-format-patch---filename-max-lengthltngt"> <a class="anchor" href="#git-format-patch---filename-max-lengthltngt"></a>--filename-max-length=&lt;n&gt; </dt>
<dd>
<p>代替标准的 64 字节，将生成的输出文件名压缩到 <em>&lt;n&gt;</em> 字节左右（太短的值会被默默提升到合理的长度）。 默认为 <code>format.filenameMaxLength</code> 配置变量的值，如果没有配置，则为 64。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---rfcltrfcgt"> <a class="anchor" href="#git-format-patch---rfcltrfcgt"></a>--rfc[=&lt;rfc&gt;] </dt>
<dd>
<p>在主题前缀前面加上字符串 <em>&lt;rfc&gt;</em>（默认为 "RFC"）。由于主题前缀默认为 "PATCH"，默认情况下您将得到 "RFC PATCH"。</p>
<div class="paragraph">
<p>RFC 意味着“请求评论”（Request For Comments）；在发送一个用于讨论而非应用的实验性补丁时使用这个。使用 "--rfc=WIP" 也可能是一个有用的方式来表明一个补丁尚未完成（"WIP" 代表 "Work In Progress"）。</p>
</div>
<div class="paragraph">
<p>如果接收社区的惯例是将特定的额外字符串放在主题前缀 <em>之后</em>，可以在字符串 <em>&lt;rfc&gt;</em> 前加上一个破折号（"<code>-</code>"）来表示 <em>&lt;rfc&gt;</em> 字符串的其余部分应该附加到主题前缀之后，例如，<code>--rfc='-(WIP)'</code> 的结果将是 "PATCH (WIP)"。</p>
</div>
</dd>
<dt class="hdlist1" id="git-format-patch--vltngt"> <a class="anchor" href="#git-format-patch--vltngt"></a>-v &lt;n&gt; </dt>
<dt class="hdlist1" id="git-format-patch---reroll-countltngt"> <a class="anchor" href="#git-format-patch---reroll-countltngt"></a>--reroll-count=&lt;n&gt; </dt>
<dd>
<p>将该系列标记为该主题的第 &lt;n&gt; 次迭代。输出的文件名有 <code>v&lt;n&gt;</code>，主题前缀（默认为 "PATCH"，但可通过 <code>--subject-prefix</code> 选项配置）有 <code>v&lt;n&gt;</code> 附加在上面。 例如，<code>--reroll-count=4</code> 可能产生 <code>v4-0001-add-makefile.patch</code> 文件，其中有 "Subject： [PATCH v4 1/20] Add makefile"。 <code>&lt;n&gt;</code> 不一定是整数（例如，"--reroll-count=4.4"，或 "--reroll-count=4rev2 "都可以），但使用这种 reroll-count 的缺点是，与前一版本的 range-diff/interdiff 并没有准确说明新的 interation 是与哪个版本比较。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---tolte-mailgt"> <a class="anchor" href="#git-format-patch---tolte-mailgt"></a>--to=&lt;e-mail&gt; </dt>
<dd>
<p>在邮件标题中增加一个 <code>To: ` 头。这是在任何配置的头信息之外的，可以多次使用。 否定的形式 `--no-to</code> 会丢弃到目前为止添加的所有 <code>To:</code> 头信息（来自配置或命令行）。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---ccltemailgt"> <a class="anchor" href="#git-format-patch---ccltemailgt"></a>--cc=&lt;email&gt; </dt>
<dd>
<p>在邮件标题中添加 <code>Cc: ` 标头。这是在任何配置的头信息之外的，可以多次使用。 否定的形式 `--no-cc</code> 会丢弃到目前为止添加的所有 <code>Cc:</code> 头信息（来自配置或命令行）。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---from"> <a class="anchor" href="#git-format-patch---from"></a>--from </dt>
<dt class="hdlist1" id="git-format-patch---fromltgt"> <a class="anchor" href="#git-format-patch---fromltgt"></a>--from=&lt;身份&gt; </dt>
<dd>
<p>在每封提交邮件的`From:` 标头中使用 <code>ident</code>。如果提交的作者身份与所提供的 <code>ident</code> 在文字上不一致，则在邮件正文中放置一个 <code>From: ` 头，注明原作者。如果没有给出 `ident</code>，则使用提交者的身份。</p>
<div class="paragraph">
<p>注意，这个选项只有在你实际发送邮件时才有用，并且想把你自己确定为发件人，但保留原作者（<code>git am</code> 会正确接收正文头）。还要注意的是，<code>git send-email</code> 已经为你处理了这种转换，如果你将结果反馈给 <code>git send-email</code>，就不应该使用这个选项。</p>
</div>
</dd>
<dt class="hdlist1" id="git-format-patch---no-force-in-body-from"> <a class="anchor" href="#git-format-patch---no-force-in-body-from"></a>--[no-]force-in-body-from </dt>
<dd>
<p>对于通过 <code>--from</code> 选项指定的电子邮件发件人，默认情况下，如果发件人与作者不同，会在提交日志信息的顶部添加一个内文 "From:"，以确定提交的真正作者。 有了这个选项，即使发件人和作者的名字和地址相同，也会在正文中加入 "From："，这在邮件列表软件混淆发件人身份时可能会有帮助。 默认为 <code>format.forceInBodyFrom</code> 配置变量的值。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---add-headerltgt"> <a class="anchor" href="#git-format-patch---add-headerltgt"></a>--add-header=&lt;头部&gt; </dt>
<dd>
<p>在邮件头中添加一个任意的头。 这是在任何配置的头文件之外的，并且可以多次使用。 例如，<code>--add-header="Organization: git-foo"</code>。 否定的形式 <code>--no-add-header</code> 会丢弃 <strong>所有</strong>（<code>To:</code>, <code>Cc:</code>, 和自定义）从配置或命令行添加的头信息。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---no-cover-letter"> <a class="anchor" href="#git-format-patch---no-cover-letter"></a>--[no-]cover-letter </dt>
<dd>
<p>除了补丁之外，还要生成一个包含分支描述、短日志和整体差异状态的封面文件。 你可以在发送之前在文件中填写描述。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---encode-email-headers"> <a class="anchor" href="#git-format-patch---encode-email-headers"></a>--encode-email-headers </dt>
<dt class="hdlist1" id="git-format-patch---no-encode-email-headers"> <a class="anchor" href="#git-format-patch---no-encode-email-headers"></a>--no-encode-email-headers </dt>
<dd>
<p>用 "Q-encoding"（在RFC 2047中描述）对有非 ASCII 字符的邮件头进行编码，而不是逐字输出邮件头。默认为 <code>format.encodeEmailHeaders</code> 配置变量的值。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---interdiffltgt"> <a class="anchor" href="#git-format-patch---interdiffltgt"></a>--interdiff=&lt;以前&gt; </dt>
<dd>
<p>作为审查员的帮助，在封面信中插入一个 interdiff，或者作为1个补丁系列中唯一一个补丁的注释，显示补丁系列的前一个版本与当前被格式化的系列之间的差异。<code>previous</code> 是一个单一的修订，命名了与被格式化的系列有共同基础的前一个系列的提示（例如 <code>git format-patch --cover-letter --interdiff=feature/v1 -3 feature/v2</code>）。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---range-diffltgt"> <a class="anchor" href="#git-format-patch---range-diffltgt"></a>--range-diff=&lt;以前&gt; </dt>
<dd>
<p>作为审查员的辅助工具，在封面信中插入一个 range-diff（见 <a href='{{< relurl "docs/git-range-diff/zh_HANS-CN" >}}'>git-range-diff[1]</a>），或者作为1个补丁系列中唯一一个补丁的注释，显示该补丁系列的前一个版本与当前被格式化的系列之间的差异。 <code>previous</code> 可以是一个单一的修订版，如果它与被格式化的系列有共同的基础，则命名为前一个系列的提示（例如 <code>git format-patch --cover-letter --range-diff=feature/v1 -3 feature/v2</code>），如果两个系列的版本不相干，则是一个修订范围（例如 <code>git format-patch --cover-letter --range-diff=feature/v1~3.feature/v1 -3 feature/v2</code>）。</p>
<div class="paragraph">
<p>请注意，传递给命令的差异选项会影响 <code>format-patch</code> 的主要产品如何生成，它们不会传递给用于生成封面材料的基础 `range-diff ` 机器（这在将来可能会改变）。</p>
</div>
</dd>
<dt class="hdlist1" id="git-format-patch---creation-factorltgt"> <a class="anchor" href="#git-format-patch---creation-factorltgt"></a>--creation-factor=&lt;百分比&gt; </dt>
<dd>
<p>与 <code>--range-diff</code> 一起使用，通过调整创建/删除成本的模糊系数，来调整匹配上一个和当前系列补丁之间提交的启发式方法。详情见 <a href='{{< relurl "docs/git-range-diff/zh_HANS-CN" >}}'>git-range-diff[1]</a>）。</p>
<div class="paragraph">
<p>默认值为 999（<a href='{{< relurl "docs/git-range-diff/zh_HANS-CN" >}}'>git-range-diff[1]</a> 使用 60），因为使用场景是显示与同一主题的旧版本的比较，并且该工具应在两套补丁之间找到更多的对应关系。</p>
</div>
</dd>
<dt class="hdlist1" id="git-format-patch---notesltgt"> <a class="anchor" href="#git-format-patch---notesltgt"></a>--notes[=&lt;引用&gt;] </dt>
<dt class="hdlist1" id="git-format-patch---no-notes"> <a class="anchor" href="#git-format-patch---no-notes"></a>--no-notes </dt>
<dd>
<p>在三折线之后添加该提交的注释（见 <a href='{{< relurl "docs/git-notes/zh_HANS-CN" >}}'>git-notes[1]</a>）。</p>
<div class="paragraph">
<p>预期的用例是为提交编写不属于提交日志信息本身的支持性解释，并将其包含在补丁提交中。虽然我们可以在 <code>format-patch</code> 运行后但在发送前简单地写下这些解释，但将其保留为 Git 笔记，可以在补丁系列的不同版本之间进行维护（但要使用这种工作流程，请参考 <a href='{{< relurl "docs/git-notes/zh_HANS-CN" >}}'>git-notes[1]</a> 中关于`notes.rewrite` 配置选项的讨论）。</p>
</div>
<div class="paragraph">
<p>默认为`--no-notes`，除非设置了 <code>format.notes</code> 配置。</p>
</div>
</dd>
<dt class="hdlist1" id="git-format-patch---no-signatureltgt"> <a class="anchor" href="#git-format-patch---no-signatureltgt"></a>--[no-]signature=&lt;签名&gt; </dt>
<dd>
<p>给每个产生的信息添加一个签名。根据 RFC 3676，签名与正文之间用一行 <em>--</em> 分隔。如果签名选项被省略，则签名默认为 Git 版本号。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---signature-fileltgt"> <a class="anchor" href="#git-format-patch---signature-fileltgt"></a>--signature-file=&lt;文件&gt; </dt>
<dd>
<p>工作原理与 --signature 相同，只是签名是从文件中读取的。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---suffixltgt"> <a class="anchor" href="#git-format-patch---suffixltgt"></a>--suffix=.&lt;后缀&gt; </dt>
<dd>
<p>不使用 <code>.patch</code> 作为生成文件名的后缀，而使用指定的后缀。 一个常见的选择是 <code>--suffix=.txt</code>。 将此留空将删除 <code>.patch</code> 后缀。</p>
<div class="paragraph">
<p>请注意，前导字符不一定是点；例如，你可以使用 <code>--suffix=-patch</code> 来获得 <code>0001-description-of-my-change-patch</code>。</p>
</div>
</dd>
<dt class="hdlist1" id="git-format-patch--q"> <a class="anchor" href="#git-format-patch--q"></a>-q </dt>
<dt class="hdlist1" id="git-format-patch---quiet"> <a class="anchor" href="#git-format-patch---quiet"></a>--quiet </dt>
<dd>
<p>不要将生成的文件名打印到标准输出。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---no-binary"> <a class="anchor" href="#git-format-patch---no-binary"></a>--no-binary </dt>
<dd>
<p>不输出二进制文件中的变化内容，而是显示这些文件变化的通知。 使用该选项生成的补丁不能被正确应用，但它们对代码审查仍然有用。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---zero-commit"> <a class="anchor" href="#git-format-patch---zero-commit"></a>--zero-commit </dt>
<dd>
<p>在每个补丁的 From 头中输出一个全零的哈希值，而不是提交的哈希值。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---no-baseltgt"> <a class="anchor" href="#git-format-patch---no-baseltgt"></a>--[no-]base[=&lt;提交&gt;] </dt>
<dd>
<p>记录基树信息，以确定该补丁系列所适用的状态。 详见下面的基树信息部分。如果 &lt;提交&gt; 是 "auto"，就会自动选择一个基数提交。<code>--no-base</code> 选项会覆盖 <code>format.useAutoBase</code> 配置。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---root"> <a class="anchor" href="#git-format-patch---root"></a>--root </dt>
<dd>
<p>将修订版参数视为 &lt;revision range&gt;，即使它只是一个单一的提交（通常会被视为 &lt;since&gt;）。 注意，包含在指定范围内的根提交总是被格式化为创建补丁，与此标志无关。</p>
</dd>
<dt class="hdlist1" id="git-format-patch---progress"> <a class="anchor" href="#git-format-patch---progress"></a>--progress </dt>
<dd>
<p>在生成补丁时在标准错误流上显示进度报告。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_配置"><a class="anchor" href="#_配置"></a>配置</h2>
<div class="sectionbody">
<div class="paragraph">
<p>你可以指定额外的邮件标题行添加到每封邮件中，主题前缀和文件后缀的默认值，在输出多个补丁时对补丁进行编号，添加 "To: " 或 "Cc: " 标题，配置附件，更改补丁输出目录，以及用配置变量签署补丁。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[format]
	headers = "Organization: git-foo\n"
	subjectPrefix = CHANGE
	suffix = .txt
	numbered = auto
	to = &lt;电子邮箱地址&gt;
	cc = &lt;电子邮箱地址&gt;
	attach [ = mime-boundary-string ]
	signOff = true
	outputDirectory = &lt;目录&gt;
	coverLetter = auto
	coverFromDescription = auto</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_讨论"><a class="anchor" href="#_讨论"></a>讨论</h2>
<div class="sectionbody">
<div class="paragraph">
<p>由 <em>git format-patch</em> 产生的补丁是 UNIX 邮箱格式，有一个固定的 "magic" 时间戳，以表明该文件是由 format-patch 输出的，而不是一个真正的邮箱，像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>From 8f72bad1baf19a53459661343e21d6491c3908d3 Mon Sep 17 00:00:00 2001
From: Tony Luck &lt;tony.luck@intel.com&gt;
Date: Tue, 13 Jul 2010 11:42:54 -0700
Subject: [PATCH] =?UTF-8?q?[IA64]=20Put=20ia64=20config=20files=20on=20the=20?=
 =?UTF-8?q?Uwe=20Kleine-K=C3=B6nig=20diet?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

arch/arm config files were slimmed down using a python script
(见提交 c2330e286f68f1c408b4aa6515ba49d57f05beae 评论)

为 ia64 做同样的事情，这样我们就可以有光滑和修长的外观了。
...</pre>
</div>
</div>
<div class="paragraph">
<p>通常情况下，它会被放在 MUA 的 drafts 文件夹中，被编辑以添加及时的评论，这些评论不应该被放在 changelog 中的三个破折号之后，然后以消息的形式发送，在我们的例子中，其正文以 "arch/arm config files were&#8230;&#8203;" 开始。 在接收端，读者可以将有趣的补丁保存在 UNIX 邮箱中，并通过 <a href='{{< relurl "docs/git-am/zh_HANS-CN" >}}'>git-am[1]</a> 应用它们。</p>
</div>
<div class="paragraph">
<p>当一个补丁是正在进行的讨论的一部分时，由 <em>git format-patch</em> 生成的补丁可以进行调整，以利用 <em>git am --scissors</em> 功能。 在你对讨论的回应之后，有一行只由 "<code>-- &gt;8 --</code>"（剪刀和打孔）组成，后面是去除不必要的头域的补丁：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>...
&gt; 所以，我们应该做这样那样的事情。

对我来说是有意义的。 这个补丁怎么样？

-- &gt;8 --
Subject: [IA64] 将 ia64 配置文件放在 Uwe Kleine-König diet 上

使用 python 脚本对 arch/arm 配置文件进行了精简
...</pre>
</div>
</div>
<div class="paragraph">
<p>当用这种方式发送补丁时，大多数情况下是发送你自己的补丁，所以除了 "<code>From $SHA1 $magic_timestamp</code>" 标记外，你应该从补丁文件中省略 `From: ` 和 `Date: ` 行。 补丁的标题很可能与补丁所回应的讨论主题不同，所以很可能要保留 Subject: 这一行，就像上面的例子一样。</p>
</div>
<div class="sect2">
<h3 id="_检查补丁是否损坏"><a class="anchor" href="#_检查补丁是否损坏"></a>检查补丁是否损坏</h3>
<div class="paragraph">
<p>许多邮件如果设置不当就会破坏空白。 以下是两种常见的损坏类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>没有「任何」空格的空的上下文行。</p>
</li>
<li>
<p>非空的上下文行，在开头有一个额外的空白。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>测试你的 MUA 是否设置正确的一个方法是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将补丁发送给自己，完全按照你的方式，只是在 To: 和 Cc: 行中不包含列表和维护者地址。</p>
</li>
<li>
<p>将该补丁保存为 UNIX 邮箱格式的文件。 称之为 a.patch，例如。</p>
</li>
<li>
<p>应用它：</p>
<div class="literalblock">
<div class="content">
<pre>$ git fetch &lt;project&gt; master:test-apply
$ git switch test-apply
$ git restore --source=HEAD --staged --worktree :/
$ git am a.patch</pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果它不能正确应用，可能有各种原因。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>补丁本身不能干净地应用。 这很糟糕，但与你的 MUA 没有多大关系。 在这种情况下，你可能要先用 <a href='{{< relurl "docs/git-rebase/zh_HANS-CN" >}}'>git-rebase[1]</a> 把补丁重新归位，再重新生成。</p>
</li>
<li>
<p>MUA 损坏了你的补丁；"am" 会抱怨补丁不适用。 查看 .git/rebase-apply/ 子目录，看看 "补丁" 文件包含哪些内容，并检查上面提到的常见损坏模式。</p>
</li>
<li>
<p>同时，还要检查 <em>info</em> 和 <em>final-commit</em> 文件。 如果 <em>final-commit</em> 中的内容与你希望在提交日志信息中看到的不完全一样，那么很可能接收者在应用你的补丁时最终会手工编辑日志信息。 补丁邮件中的 "Hi, this is my first patch.\n" 等内容应该出现在提交信息末尾的三折线之后。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_针对_mua_的提示"><a class="anchor" href="#_针对_mua_的提示"></a>针对 Mua 的提示</h2>
<div class="sectionbody">
<div class="paragraph">
<p>这里有一些关于如何使用各种邮件工具成功地在线提交补丁的提示。</p>
</div>
<div class="sect2">
<h3 id="_gmail"><a class="anchor" href="#_gmail"></a>GMail</h3>
<div class="paragraph">
<p>GMail 没有办法在网页界面上关闭换行，所以它会把你发送的任何邮件弄得一团糟。 然而，你可以使用 "git send-email"，通过 GMail 的 SMTP 服务器发送你的补丁，或者使用任何 IMAP 电子邮件客户端连接到谷歌的 IMAP 服务器，并通过它转发电子邮件。</p>
</div>
<div class="paragraph">
<p>关于使用 <em>git send-email</em> 通过 GMail SMTP 服务器发送补丁的提示，请参见 <a href='{{< relurl "docs/git-send-email/zh_HANS-CN" >}}'>git-send-email[1]</a> 的案例部分。</p>
</div>
<div class="paragraph">
<p>关于使用 IMAP 接口提交的提示，请参见 <a href='{{< relurl "docs/git-imap-send/zh_HANS-CN" >}}'>git-imap-send[1]</a> 的案例部分。</p>
</div>
</div>
<div class="sect2">
<h3 id="_thunderbird"><a class="anchor" href="#_thunderbird"></a>Thunderbird</h3>
<div class="paragraph">
<p>默认情况下，Thunderbird 会将邮件包裹起来，并将其标记为 <em>format=flowed</em>，这两种情况都会使 Git 无法使用这些邮件。</p>
</div>
<div class="paragraph">
<p>有三种不同的方法：使用插件来关闭换行，配置 Thunderbird 使其不纠缠补丁，或者使用外部编辑器来防止 Thunderbird 纠缠补丁。</p>
</div>
<div class="sect3">
<h4 id="_办法1附加的"><a class="anchor" href="#_办法1附加的"></a>办法1（附加的）</h4>
<div class="paragraph">
<p>安装 Toggle Word Wrap 插件，该插件可从 <a href="https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/。它在作曲家的" class="bare">https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/。它在作曲家的</a> "选项" 菜单中增加了一个 "启用换行符" 的菜单项，你可以将其勾掉。现在你可以像其他方式一样编写信息（剪切+粘贴，<em>git format-patch</em>|<em>git imap-send</em>，等等），但你必须在你输入的任何文本中手动插入换行符。</p>
</div>
</div>
<div class="sect3">
<h4 id="_方法2配置"><a class="anchor" href="#_方法2配置"></a>方法#2（配置）</h4>
<div class="paragraph">
<p>三个步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>将你的邮件服务器组成配置为纯文本： 编辑&#8230;&#8203;&#8230;&#8203;账户设置&#8230;&#8203;&#8230;&#8203;组成和地址，取消勾选 "以HTML编写邮件"。</p>
</li>
<li>
<p>配置你的一般组成窗口，使其不被包裹。</p>
<div class="paragraph">
<p>在 Thunderbird 2 中：编辑&#8230;&#8203;偏好&#8230;&#8203;组成，将纯文本信息包在 0 处</p>
</div>
<div class="paragraph">
<p>在 Thunderbird 3 中：编辑&#8230;&#8203;偏好&#8230;&#8203;高级&#8230;&#8203;配置编辑器。 搜索 "mail.wrap_long_lines"。 切换它，确保它被设置为 "false"。另外，搜索 "mailnews.wraplength" 并将其设置为 0。</p>
</div>
</li>
<li>
<p>禁止使用 format=flowed： 编辑&#8230;&#8203;偏好&#8230;&#8203;高级&#8230;&#8203;配置编辑器。 搜索 "mailnews.send_plaintext_flowed"。 拨动它，确保它被设置为 <code>false</code>。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>完成后，你应该能够像其他方式一样编写电子邮件（剪切+粘贴，<em>git format-patch</em> | <em>git imap-send</em>，等等），而且补丁不会被弄乱。</p>
</div>
</div>
<div class="sect3">
<h4 id="_方法三外部编辑"><a class="anchor" href="#_方法三外部编辑"></a>方法三（外部编辑）</h4>
<div class="paragraph">
<p>需要以下 Thunderbird 扩展： <a href="https://mjg.github.io/AboutConfig/" class="bare">https://mjg.github.io/AboutConfig/</a> 中的 AboutConfig 和 <a href="https://globs.org/articles.php?lng=en&amp;pg=8" class="bare">https://globs.org/articles.php?lng=en&amp;pg=8</a> 中的 External Editor</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>用你选择的方法把补丁准备成一个文本文件。</p>
</li>
<li>
<p>在打开撰写窗口之前，使用 Edit&#8594;Account Settingd 取消勾选要用来发送补丁的账户的 "Composition &amp; Addressing" 面板中的 "Compose messages in HTML format" 设置。</p>
</li>
<li>
<p>在 Thunderbird 主窗口中，在你打开补丁的撰写窗口之前，使用 Tools&#8594;about:config 将以下内容设置为指定值：</p>
<div class="listingblock">
<div class="content">
<pre>	mailnews.send_plaintext_flowed  =&gt; false
	mailnews.wraplength             =&gt; 0</pre>
</div>
</div>
</li>
<li>
<p>打开一个作曲窗口，点击外部编辑器图标。</p>
</li>
<li>
<p>在外部编辑器窗口，读入补丁文件并正常退出编辑器。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>题外话：也许可以用 about:config 和以下设置来完成第二步，但还没有人试过。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	mail.html_compose                       =&gt; false
	mail.identity.default.compose_html      =&gt; false
	mail.identity.id?.compose_html          =&gt; false</pre>
</div>
</div>
<div class="paragraph">
<p>contrib/thunderbird-patch-inline 中有一个脚本，可以帮助你以一种简单的方式将补丁加入 Thunderbird。要使用它，请执行上面的步骤，然后使用该脚本作为外部编辑器。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_kmail"><a class="anchor" href="#_kmail"></a>KMail</h3>
<div class="paragraph">
<p>这应该有助于你使用 KMail 在线提交补丁。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>把补丁准备成一个文本文件。</p>
</li>
<li>
<p>点击 "New Mail"。</p>
</li>
<li>
<p>在合成器窗口的 "Otions" 下，确保没有设置 "Word warp"。</p>
</li>
<li>
<p>Use Message &#8594; Insert file&#8230;&#8203; 并插入补丁。</p>
</li>
<li>
<p>回到撰写窗口：在信息中添加你想要的任何其他文本，完成地址和主题字段，然后按发送。</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_基准树信息"><a class="anchor" href="#_基准树信息"></a>基准树信息</h2>
<div class="sectionbody">
<div class="paragraph">
<p>基准树信息块用于维护者或第三方测试人员了解补丁系列所适用的确切状态。它由 ‘基本提交’ 和零个或多个 ‘前提补丁’ 组成，前者是众所周知的提交，是项目历史中稳定部分的一部分，而后者是正在运行的知名补丁，还不是 ‘基本提交’ 的一部分，在应用这些补丁之前需要在 ‘基本提交’ 之上按拓扑顺序应用。</p>
</div>
<div class="paragraph">
<p>‘基本提交’ 显示为 "base-commit: "，后面是提交对象名称的 40-hex。 ‘先决补丁’ 显示为 "prerequisite-patch-id: "，后面是 40-hex 的 “补丁ID”，这个 ID 可以通过 <code>git patch-id --stable</code> 命令来获得。</p>
</div>
<div class="paragraph">
<p>想象一下，在公开提交的 P 之上，你应用了别人的知名补丁 X、Y 和 Z，然后建立了你的三套补丁系列 A、B、C，历史会是这样：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>---P---X---Y---Z---A---B---C</pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>git format-patch --base=P -3 C</code>（或其变体，例如使用 <code>--cover-letter</code> 或使用 <code>Z...C</code> 代替 <code>-3 C</code> 来指定范围），基础树信息块会显示在命令输出的第一个信息（第一个补丁，或封面信）的末尾，像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>base-commit: P
prerequisite-patch-id: X
prerequisite-patch-id: Y
prerequisite-patch-id: Z</pre>
</div>
</div>
<div class="paragraph">
<p>对于非线性拓扑结构，如</p>
</div>
<div class="literalblock">
<div class="content">
<pre>---P---X---A---M---C
    \         /
     Y---Z---B</pre>
</div>
</div>
<div class="paragraph">
<p>你也可以使用 <code>git format-patch --base=P -3 C</code> 来生成 A、B 和 C 的补丁，P、X、Y、Z 的标识符被附加在第一条信息的末尾。</p>
</div>
<div class="paragraph">
<p>如果在 cmdline 中设置 <code>--base=auto</code>，它将自动计算基础提交，作为远程跟踪分支和 cmdline 中指定的修订范围的提示提交的合并基础。 对于本地分支，在使用此选项之前，需要通过 <code>git branch --set-upstream-to</code> 使其跟踪远程分支。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_实例"><a class="anchor" href="#_实例"></a>实例</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>提取 R1 和 R2 修订版之间的提交，并用 "git am" 将其应用于当前分支之上，以拣选它们：</p>
<div class="listingblock">
<div class="content">
<pre>$ git format-patch -k --stdout R1..R2 | git am -3 -k</pre>
</div>
</div>
</li>
<li>
<p>提取所有在当前分支但不在原生分支中的提交：</p>
<div class="listingblock">
<div class="content">
<pre>$ git format-patch origin</pre>
</div>
</div>
<div class="paragraph">
<p>每次提交都会在当前目录下创建一个单独的文件。</p>
</div>
</li>
<li>
<p>提取自项目开始以来所有导致 <em>origin</em> 的提交：</p>
<div class="listingblock">
<div class="content">
<pre>$ git format-patch --root origin</pre>
</div>
</div>
</li>
<li>
<p>与前者相同：</p>
<div class="listingblock">
<div class="content">
<pre>$ git format-patch -M -B origin</pre>
</div>
</div>
<div class="paragraph">
<p>此外，它还能智能地检测和处理重命名和完全重写，以产生重命名补丁。 重命名补丁减少了文本输出的数量，一般来说，它更容易审查。 注意，非 Git 的 “补丁” 程序不会理解重命名补丁，所以只有当你知道收件人使用 Git 来应用你的补丁时才会使用它。</p>
</div>
</li>
<li>
<p>从当前分支中提取三个最重要的提交，并将其格式化为可发送电子邮件的补丁：</p>
<div class="listingblock">
<div class="content">
<pre>$ git format-patch -3</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_注意事项"><a class="anchor" href="#_注意事项"></a>注意事项</h2>
<div class="sectionbody">
<div class="paragraph">
<p>请注意，<code>format-patch</code> 将从输出中省略合并提交，即使它们是请求范围的一部分。一个简单的 “补丁” 并不包括足够的信息让接收端重现同一个合并提交。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_参见"><a class="anchor" href="#_参见"></a>参见</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href='{{< relurl "docs/git-am/zh_HANS-CN" >}}'>git-am[1]</a>, <a href='{{< relurl "docs/git-send-email/zh_HANS-CN" >}}'>git-send-email[1]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>属于 <a href='{{< relurl "docs/git/zh_HANS-CN" >}}'>git[1]</a> 文档</p>
</div>
</div>
</div>