---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-checkout Documentation
docname: git-checkout
lang: fr
aliases:
- "/docs/git-checkout/fr/index.html"
---
<div class="sect1">
<h2 id="_nom"><a class="anchor" href="#_nom"></a>NOM</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-checkout - Bascule sur une autre branche ou restaure des fichiers de l&#8217;arbre de travail</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_synopsis"><a class="anchor" href="#_synopsis"></a>SYNOPSIS</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git checkout</em> [-q] [-f] [-m] [&lt;branche&gt;]
<em>git checkout</em> [-q] [-f] [-m] --detach [&lt;branche&gt;]
<em>git checkout</em> [-q] [-f] [-m] [--detach] &lt;commit&gt;
<em>git checkout</em> [-q] [-f] [-m] [[-b|-B|--orphan] &lt;nouvelle-branche&gt;] [&lt;point-de-départ&gt;]
<em>git checkout</em> [-f] &lt;arbre-esque&gt; [--] &lt;spec-de-chemin&gt;&#8230;&#8203;
<em>git checkout</em> [-f] &lt;arbre-esque&gt; --pathspec-from-file=&lt;fichier&gt; [--pathspec-file-nul]
<em>git checkout</em> [-f|--ours|--theirs|-m|--conflict=&lt;style&gt;] [--] &lt;spec-de-chemin&gt;&#8230;&#8203;
<em>git checkout</em> [-f|--ours|--theirs|-m|--conflict=&lt;style&gt;] --pathspec-from-file=&lt;fichier&gt; [--pathspec-file-nul]
 <em>git checkout</em> (-p|--patch) [&lt;arbre-esque&gt;] [--] [&lt;spec-de-chemin&gt;&#8230;&#8203;]</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_description"><a class="anchor" href="#_description"></a>DESCRIPTION</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Met à jour les fichiers dans l&#8217;arbre de travail pour correspondre à la version dans l&#8217;index ou dans l&#8217;arbre spécifié. Si aucun spécificateur de chemin n&#8217;est fourni, <em>git checkout</em> met aussi à jour <code>HEAD</code> pour positionner la branche spécifiée comme la branche actuelle.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-checkout-emgitcheckoutemltbranchegt"> <a class="anchor" href="#git-checkout-emgitcheckoutemltbranchegt"></a><em>git checkout</em> [&lt;branche&gt;] </dt>
<dd>
<p>Pour se préparer à travailler sur <code>&lt;branche&gt;</code>, basculer dessus en mettant l&#8217;index et les fichiers de l&#8217;arbre de travail à jour, et en pointant <code>HEAD</code> sur cette branche. Les modifications locales aux fichiers de l&#8217;arbre de travail sont conservées, de sorte qu&#8217;elles peuvent être validées sur la <code>&lt;branche&gt;</code>.</p>
<div class="paragraph">
<p>Si la <code>&lt;branche&gt;</code> n&#8217;est pas trouvée mais qu&#8217;il existe une branche de suivi pour un dépôt distant unique (appelée <code>&lt;distant&gt;</code>) avec un nom correspondant et <code>--no-guess</code> n&#8217;est pas spécifié, le traiter comme équivalent à</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git checkout -b &lt;branche&gt; --track &lt;distant&gt;/&lt;branche&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Vous pourriez omettre <code>&lt;branche&gt;</code>, auquel cas la commande dégénère en « extraire la branche actuelle », qui est une opération nulle de luxe avec des effets de bord plutôt chers de ne montrer que l&#8217;information de suivi, si elle existe, pour la branche actuelle.</p>
</div>
</dd>
<dt class="hdlist1" id="git-checkout-emgitcheckoutem-b-Bltnouvelle-branchegtltpoint-de-dpartgt"> <a class="anchor" href="#git-checkout-emgitcheckoutem-b-Bltnouvelle-branchegtltpoint-de-dpartgt"></a><em>git checkout</em> -b|-B &lt;nouvelle-branche&gt; [&lt;point-de-départ&gt;] </dt>
<dd>
<p>Spécifier <code>-b</code> provoque la création d&#8217;une nouvelle branche comme si <a href='{{< relurl "docs/git-branch/fr" >}}'>git-branch[1]</a> était lancé puis la branche extraite. Dans ce cas, vous pouvez utiliser les options <code>--track</code> ou <code>--no-track</code>, qui seront passées à <em>git branch</em>. Pour plus de confort, <code>--track</code> sans <code>-b</code> implique la création d&#8217;une branche ; voir la description de <code>--track</code> ci-dessous.</p>
<div class="paragraph">
<p>Si <code>-B</code> est fourni, <code>&lt;nouvelle-branche&gt;</code> est créée si elle n&#8217;existe pas ; sinon, elle est réinitialisée. C&#8217;est l&#8217;équivalent transactionnel de</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git branch -f &lt;branche&gt; [&lt;point-de-départ&gt;]
$ git checkout &lt;branche&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>c&#8217;est-à-dire que la branche n&#8217;est pas réinitialisée/créée à moins que "git checkout" soit réussi (par exemple, lorsque la branche est utilisée dans un autre arbre de travail, pas seulement que la branche actuelle reste la même, mais la branche n&#8217;est pas réinitialisée au point de départ non plus).</p>
</div>
</dd>
<dt class="hdlist1" id="git-checkout-emgitcheckoutem--detachltbranchegt"> <a class="anchor" href="#git-checkout-emgitcheckoutem--detachltbranchegt"></a><em>git checkout</em> --detach [&lt;branche&gt;] </dt>
<dt class="hdlist1" id="git-checkout-emgitcheckoutem--detachltcommitgt"> <a class="anchor" href="#git-checkout-emgitcheckoutem--detachltcommitgt"></a><em>git checkout</em> [--detach] &lt;commit&gt; </dt>
<dd>
<p>Prépare à travailler par-dessus <code>&lt;commit&gt;</code>, en détachant <code>HEAD</code> dessus (voir la section « HEAD DÉTACHÉE »), et en mettant l&#8217;index et les fichiers de l&#8217;arbre de travail à jour. Les modifications locales des fichiers dans l&#8217;arbre de travail sont conservées, de sorte que l&#8217;arbre de travail sera le résultat du commit plus les modifications locales.</p>
<div class="paragraph">
<p>Quand l&#8217;argument <code>&lt;commit&gt;</code> est un nom de branche, l&#8217;option <code>--detach</code> peut être utilisée pour détacher <code>HEAD</code> au sommet de la branche (<code>git checkout &lt;branche&gt;</code> extrairait cette branche sans détacher <code>HEAD</code>).</p>
</div>
<div class="paragraph">
<p>Omettre <code>&lt;branche&gt;</code> détache <code>HEAD</code> au sommet de la branche actuelle.</p>
</div>
</dd>
<dt class="hdlist1" id="git-checkout-emgitcheckoutem-f--ours--theirs-m--conflictltstylegtltarbre-esquegt--ltspcdechemingt82308203"> <a class="anchor" href="#git-checkout-emgitcheckoutem-f--ours--theirs-m--conflictltstylegtltarbre-esquegt--ltspcdechemingt82308203"></a><em>git checkout</em> [-f|--ours|--theirs|-m|--conflict=&lt;style&gt;] [&lt;arbre-esque&gt;] [--] &lt;spéc. de chemin&gt;&#8230;&#8203; </dt>
<dt class="hdlist1" id="git-checkout-emgitcheckoutem-f--ours--theirs-m--conflictltstylegtltarbre-esquegt--pathspec-from-fileltfichiergt--pathspec-file-nul"> <a class="anchor" href="#git-checkout-emgitcheckoutem-f--ours--theirs-m--conflictltstylegtltarbre-esquegt--pathspec-from-fileltfichiergt--pathspec-file-nul"></a><em>git checkout</em> [-f|--ours|--theirs|-m|--conflict=&lt;style&gt;] [&lt;arbre-esque&gt;] --pathspec-from-file=&lt;fichier&gt; [--pathspec-file-nul] </dt>
<dd>
<p>Écraser le contenu des fichiers qui correspondent au spécificateur-de-chemin. Lorsque le <code>&lt;arbre-esque&gt;</code> (le plus souvent un commit) n&#8217;est pas donné, écraser l&#8217;arbre de travail avec le contenu de l&#8217;index. Lorsque le <code>&lt;arbre-esque&gt;</code> est donné, écraser à la fois l&#8217;index et l&#8217;arbre de travail avec le contenu du <code>&lt;arbre-esque&gt;</code>.</p>
<div class="paragraph">
<p>L&#8217;index peut contenir des entrées non fusionnées à cause d&#8217;un échec précédent de fusion. Par défaut, si vous essayez d&#8217;extraire une telle entrée depuis l&#8217;index, l&#8217;opération d&#8217;extraction échouera et rien ne sera extrait. L&#8217;utilisation de <code>-f</code> forcera à ignorer ces entrées non fusionnées. Le contenu depuis un côté donné de la fusion peut être extrait de l&#8217;index en utilisant <code>--ours</code> (notre côté) ou <code>--theirs</code> (l&#8217;autre côté). Avec <code>-m</code>, les modifications opérées sur le fichier de l&#8217;arbre de travail peuvent être jetées pour récréer le résultat originel de conflit de fusion.</p>
</div>
</dd>
<dt class="hdlist1" id="git-checkout-emgitcheckoutem-p--patchltarbre-esquegt--ltspcdechemingt82308203"> <a class="anchor" href="#git-checkout-emgitcheckoutem-p--patchltarbre-esquegt--ltspcdechemingt82308203"></a><em>git checkout</em> (-p|--patch) [&lt;arbre-esque&gt;] [--] [&lt;spéc. de chemin&gt;&#8230;&#8203;] </dt>
<dd>
<p>C&#8217;est similaire au mode précédent, mais vous laisse utiliser l&#8217;interface interactive pour afficher la sortie « diff » et choisir quelles sections utiliser dans le résultat. Voir plus bas la description de l&#8217;option <code>--patch</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_options"><a class="anchor" href="#_options"></a>OPTIONS</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-checkout--q"> <a class="anchor" href="#git-checkout--q"></a>-q </dt>
<dt class="hdlist1" id="git-checkout---quiet"> <a class="anchor" href="#git-checkout---quiet"></a>--quiet </dt>
<dd>
<p>Silencieux, supprimer les messages d&#8217;état.</p>
</dd>
<dt class="hdlist1" id="git-checkout---progress"> <a class="anchor" href="#git-checkout---progress"></a>--progress </dt>
<dt class="hdlist1" id="git-checkout---no-progress"> <a class="anchor" href="#git-checkout---no-progress"></a>--no-progress </dt>
<dd>
<p>L&#8217;état d&#8217;avancement est affiché sur la sortie standard d&#8217;erreur par défaut quand elle est attachée à un terminal, à moins que <code>--quiet</code> ne soit spécifié. Cette bascule active l&#8217;état d&#8217;avancement même sans être attaché à un terminal, indépendamment de <code>--quiet</code>.</p>
</dd>
<dt class="hdlist1" id="git-checkout--f"> <a class="anchor" href="#git-checkout--f"></a>-f </dt>
<dt class="hdlist1" id="git-checkout---force"> <a class="anchor" href="#git-checkout---force"></a>--force </dt>
<dd>
<p>Lors du basculement de branche, continuer même si l&#8217;index ou l&#8217;arbre de travail sont différents de <code>HEAD</code>, et même s&#8217;il y a des fichiers non-suivis qui bloquent.Ceci peut servir à éliminer des modifications locales ainsi que tous les fichiers ou répertoires non-suivis qui gênent.</p>
<div class="paragraph">
<p>Lors de l&#8217;extraction de chemins depuis l&#8217;index, ne pas échouer sur des entrées non fusionnées ; à la place, les entrées non fusionnées sont ignorées.</p>
</div>
</dd>
<dt class="hdlist1" id="git-checkout---ours"> <a class="anchor" href="#git-checkout---ours"></a>--ours </dt>
<dt class="hdlist1" id="git-checkout---theirs"> <a class="anchor" href="#git-checkout---theirs"></a>--theirs </dt>
<dd>
<p>Lors de l&#8217;extraction de chemins depuis l&#8217;index, extraire l&#8217;état #2 (<em>ours</em>, le nôtre) ou #3 (<em>theirs</em>, le leur) pour les chemins non fusionnés.</p>
<div class="paragraph">
<p>Veuillez noter que pendant <code>git rebase</code> et <code>git pull --rebase</code>, <code>ours</code> et <code>theirs</code> peuvent sembler échangés ; <code>--ours</code> fournit la version depuis la branche sur laquelle les modifications sont rebasées, tandis que <code>--theirs</code> fournit la version de la branche qui contient le travail rebasé.</p>
</div>
<div class="paragraph">
<p>C&#8217;est parce que <code>rebase</code> est utilisé dans une approche qui traite l&#8217;historique distant comme la référence canonique partagée, et traite le travail sur la branche que vous rebasez comme un travail tiers à intégrer, et vous endossez temporairement le rôle du gardien de l&#8217;historique canonique quand vous rebasez. En tant que gardien de l&#8217;historique canonique, vous devez voir l&#8217;historique distant comme le vôtre (<em>ours</em>, c&#8217;est-à-dire « notre historique partagé canonique »), tandis que votre travail sur l&#8217;autre branche devient le tiers (<em>theirs</em>, c&#8217;est-à-dire « le travail d&#8217;un contributeur sur le canonique »).</p>
</div>
</dd>
<dt class="hdlist1" id="git-checkout--bltnouvelle-branchegt"> <a class="anchor" href="#git-checkout--bltnouvelle-branchegt"></a>-b &lt;nouvelle-branche&gt; </dt>
<dd>
<p>Créer une nouvelle branche nommée <code>&lt;nouvelle-branche&gt;</code>, la commencer à <code>&lt;point-de-départ&gt;</code> et extraire la branche résultante ; voir <a href='{{< relurl "docs/git-branch/fr" >}}'>git-branch[1]</a> pour plus de détails.</p>
</dd>
<dt class="hdlist1" id="git-checkout--Bltnouvelle-branchegt"> <a class="anchor" href="#git-checkout--Bltnouvelle-branchegt"></a>-B &lt;nouvelle-branche&gt; </dt>
<dd>
<p>Créer la branche <code>&lt;nouvelle-branche&gt;</code>, la commencer à <code>&lt;point-de-départ&gt;</code> et l&#8217;extraire ; si elle existe déjà, alors la réinitialise à <code>&lt;point-de-départ&gt;</code>. C&#8217;est équivalent à lancer <em>git branch</em> avec <code>-f</code> suivi de <em>git checkout</em> de cette branche ; voir <a href='{{< relurl "docs/git-branch/fr" >}}'>git-branch[1]</a> pour plus de détails.</p>
</dd>
<dt class="hdlist1" id="git-checkout--t"> <a class="anchor" href="#git-checkout--t"></a>-t </dt>
<dt class="hdlist1" id="git-checkout---trackdirectinherit"> <a class="anchor" href="#git-checkout---trackdirectinherit"></a>--track[=(direct|inherit)] </dt>
<dd>
<p>À la création d&#8217;une nouvelle branche, établir la configuration <em>upstream</em> (branche amont). Voir <code>--track</code> dans <a href='{{< relurl "docs/git-branch/fr" >}}'>git-branch[1]</a> pour plus de détails.</p>
<div class="paragraph">
<p>Si aucune option <code>-b</code> n&#8217;est fournie, le nom de la nouvelle branche sera dérivé de la branche de suivi à distance, en regardant la partie locale de la spécification de référence configurée pour le distant correspondant et en enlevant la partie initiale jusqu&#8217;au "*". Cela indiquerait d&#8217;utiliser le nom « <code>hack</code> » comme branche locale créée à partir de <code>origin/hack</code> (ou <code>remotes/origin/hack</code>, ou même <code>refs/remotes/origin/hack</code>). Si le nom fourni ne contient pas de barre oblique, ou si le résultat de la dérivation est un nom vide, la dérivation échoue. Vous pouvez spécifier explicitement un nom avec <code>-b</code> dans ce cas.</p>
</div>
</dd>
<dt class="hdlist1" id="git-checkout---no-track"> <a class="anchor" href="#git-checkout---no-track"></a>--no-track </dt>
<dd>
<p>Ne pas renseigner la configuration « amont », même si la configuration <code>branch.autoSetupMerge</code> est true.</p>
</dd>
<dt class="hdlist1" id="git-checkout---guess"> <a class="anchor" href="#git-checkout---guess"></a>--guess </dt>
<dt class="hdlist1" id="git-checkout---no-guess"> <a class="anchor" href="#git-checkout---no-guess"></a>--no-guess </dt>
<dd>
<p>Si la <code>&lt;branche&gt;</code> n&#8217;est pas trouvée mais qu&#8217;il existe une branche de suivi pour un dépôt distant unique (appelé <code>&lt;distant&gt;</code>) avec un nom correspondant, le traiter comme équivalent à</p>
<div class="listingblock">
<div class="content">
<pre>$ git checkout -b &lt;branche&gt; --track &lt;distant&gt;/&lt;branche&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Si la branche existe dans plus d&#8217;un distant et que l&#8217;un d&#8217;entre eux est la valeur de la variable de configuration <code>checkout.defaultRemote</code>, celui-ci sera utilisé pour désambiguïser, même si la &lt;branche&gt; n&#8217;est pas unique parmi tous les distants. Réglez la variable <code>checkout.defaultRemote=origin</code> par exemple pour extraire toujours les branches distantes depuis celle-ci si &lt;branche&gt; est ambigüe mais existe sur le distant <em>origin</em>. Voir aussi <code>checkout.defaultRemote</code> dans <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a>.</p>
</div>
<div class="paragraph">
<p><code>--guess</code> est le comportement par défaut. Utilisez <code>--no-guess</code> pour le désactiver.</p>
</div>
<div class="paragraph">
<p>Le comportement par défaut peut être défini via la variable de configuration <code>checkout.guess</code>.</p>
</div>
</dd>
<dt class="hdlist1" id="git-checkout--l"> <a class="anchor" href="#git-checkout--l"></a>-l </dt>
<dd>
<p>Créer le reflog de la nouvelle branche ; voir <a href='{{< relurl "docs/git-branch/fr" >}}'>git-branch[1]</a> pour plus de détails.</p>
</dd>
<dt class="hdlist1" id="git-checkout--d"> <a class="anchor" href="#git-checkout--d"></a>-d </dt>
<dt class="hdlist1" id="git-checkout---detach"> <a class="anchor" href="#git-checkout---detach"></a>--detach </dt>
<dd>
<p>Plutôt que d&#8217;extraire une branche pour travailler dessus, extraire un commit pour l&#8217;inspecter et faire des expériences jetables. C&#8217;est le comportement par défaut de <code>git checkout &lt;commit&gt;</code> quand <code>&lt;commit&gt;</code> n&#8217;est pas un nom de branche. Voir la section « HEAD DÉTACHÉE » plus bas pour plus de détails.</p>
</dd>
<dt class="hdlist1" id="git-checkout---orphanltnouvelle-branchegt"> <a class="anchor" href="#git-checkout---orphanltnouvelle-branchegt"></a>--orphan &lt;nouvelle-branche&gt; </dt>
<dd>
<p>Créer une nouvelle branche non née, nommée <code>&lt;nouvelle-branche&gt;</code>, commençant depuis <code>&lt;point-de-départ&gt;</code> et basculer dessus. Le premier commit réalisé sur cette branche n&#8217;aura pas de parent et il sera la racine du nouvel historique totalement déconnecté de toutes les autres branches et des autres commits.</p>
<div class="paragraph">
<p>L&#8217;index et l&#8217;arbre de travail sont ajustés comme si vous aviez déjà lancé <code>git checkout &lt;point-de-départ&gt;</code>. Cela vous permet de démarrer un nouvel historique qui enregistre un ensemble de chemins similaires à <code>&lt;point-de-départ&gt;</code> en lançant simplement <code>git commit -a</code> pour créer le commit racine.</p>
</div>
<div class="paragraph">
<p>Ceci peut être utile quand vous souhaitez publier un arbre depuis un commit sans exposer tout son historique. Vous pourriez souhaiter le faire pour publier une branche open source d&#8217;un projet dont l&#8217;arbre présent est « propre », mais dont l&#8217;historique complet contient des morceaux de code propriétaire ou autrement non publiables.</p>
</div>
<div class="paragraph">
<p>Si vous voulez démarrer un historique déconnecté qui enregistre un ensemble de chemins qui sont totalement différents de celui de <code>&lt;point-de-départ&gt;</code>, vous devriez effacer l&#8217;index et l&#8217;arbre de travail juste après avoir créé la branche orpheline en lançant <code>git rm -rf .</code> depuis la racine de l&#8217;arbre de travail. Après, vous pourrez préparer vos nouveaux fichiers, pour repeupler l&#8217;arbre de travail, en les copiant depuis un autre endroit, en les extrayant depuis une archive, etc.</p>
</div>
</dd>
<dt class="hdlist1" id="git-checkout---ignore-skip-worktree-bits"> <a class="anchor" href="#git-checkout---ignore-skip-worktree-bits"></a>--ignore-skip-worktree-bits </dt>
<dd>
<p>En mode d&#8217;extraction clairsemé, <code>git checkout -- &lt;chemins&gt;</code> mettrait seulement à jour les entrées correspondant à <code>&lt;chemins&gt;</code> et aux motifs clairsemés dans <code>$GIT_DIR/info/sparse-checkout</code>. Cette option ignore les motifs clairsemés et ré-ajoute tous les fichiers de <code>&lt;chemins&gt;</code>.</p>
</dd>
<dt class="hdlist1" id="git-checkout--m"> <a class="anchor" href="#git-checkout--m"></a>-m </dt>
<dt class="hdlist1" id="git-checkout---merge"> <a class="anchor" href="#git-checkout---merge"></a>--merge </dt>
<dd>
<p>Lors d&#8217;un basculement de branche, si vous avez des modifications locales sur un fichier ou plus qui sont différentes entre la branche actuelle et celle sur laquelle vous basculez, la commande refuse le basculement pour préserver vos modifications dans leur contexte. Cependant, avec cette option, une fusion à trois points entre la branche actuelle, le contenu de votre arbre de travail et la nouvelle branche est opérée et vous serez sur la nouvelle branche.</p>
<div class="paragraph">
<p>Quand un conflit de fusion apparaît, les entrées d&#8217;index pour les chemins en conflit sont laissées non-fusionnées et vous devez résoudre les conflits et les marquer résolus pour les chemins concernés avec <code>git add</code> (ou <code>git rm</code> si la fusion doit aboutir à la suppression du chemin).</p>
</div>
<div class="paragraph">
<p>Lors de l&#8217;extraction de chemins depuis l&#8217;index, cette option vous permet de récréer la fusion en conflit dans les chemins spécifiés. Cette option ne peut pas être utilisée lors de l&#8217;extraction des chemins depuis un arbre-esque.</p>
</div>
<div class="paragraph">
<p>Lors du basculement de branche avec <code>--merge</code>, les modifications indexées peuvent être perdues.</p>
</div>
</dd>
<dt class="hdlist1" id="git-checkout---conflictltstylegt"> <a class="anchor" href="#git-checkout---conflictltstylegt"></a>--conflict=&lt;style&gt; </dt>
<dd>
<p>Identique à l&#8217;option <code>--merge</code> ci-dessus, mais la manière dont les sections en conflits sont présentées est modifiée, en surchargeant la variable de configuration <code>merge.conflictStyle</code>. Les valeurs possibles sont <code>merge</code> (fusion, par défaut), <code>diff3</code> et <code>zdiff3</code>.</p>
</dd>
<dt class="hdlist1" id="git-checkout--p"> <a class="anchor" href="#git-checkout--p"></a>-p </dt>
<dt class="hdlist1" id="git-checkout---patch"> <a class="anchor" href="#git-checkout---patch"></a>--patch </dt>
<dd>
<p>Sélectionner interactivement les sections dans la différence entre l'<code>&lt;arbre-esque&gt;</code> (ou l&#8217;index, si non spécifié) et l&#8217;arbre de travail. Les sections choisies sont ensuite appliquées en ordre inversé à l&#8217;arbre de travail (et si un <code>&lt;arbre-esque&gt;</code> a été spécifié, à l&#8217;index).</p>
<div class="paragraph">
<p>Ceci signifie que vous pouvez utiliser <code>git checkout -p</code> pour supprimer sélectivement les éditions depuis votre arbre de travail actuel. Voir la section « Mode Interactif » de <a href='{{< relurl "docs/git-add/fr" >}}'>git-add[1]</a> pour apprendre à utiliser le mode <code>--patch</code>.</p>
</div>
<div class="paragraph">
<p>Notez que cette option utilise par défaut le mode sans superposition (voir aussi <code>--overlay</code>), et ne supporte pas actuellement le mode superposition.</p>
</div>
</dd>
<dt class="hdlist1" id="git-checkout---ignore-other-worktrees"> <a class="anchor" href="#git-checkout---ignore-other-worktrees"></a>--ignore-other-worktrees </dt>
<dd>
<p><code>git checkout</code> échoue quand la référence voulue est déjà extraite dans un autre arbre de travail. Cette option force l&#8217;extraction. En d&#8217;autres termes, la réf peut être tenue par plus d&#8217;un arbre de travail.</p>
</dd>
<dt class="hdlist1" id="git-checkout---overwrite-ignore"> <a class="anchor" href="#git-checkout---overwrite-ignore"></a>--overwrite-ignore </dt>
<dt class="hdlist1" id="git-checkout---no-overwrite-ignore"> <a class="anchor" href="#git-checkout---no-overwrite-ignore"></a>--no-overwrite-ignore </dt>
<dd>
<p>Écraser silencieusement les fichiers ignorés lors du basculement de branche. C&#8217;est le comportement par défaut. Utilisez <code>--no-overwrite-ignore</code> pour annuler l&#8217;opération lorsque la nouvelle branche contient des fichiers ignorés.</p>
</dd>
<dt class="hdlist1" id="git-checkout---recurse-submodules"> <a class="anchor" href="#git-checkout---recurse-submodules"></a>--recurse-submodules </dt>
<dt class="hdlist1" id="git-checkout---no-recurse-submodules"> <a class="anchor" href="#git-checkout---no-recurse-submodules"></a>--no-recurse-submodules </dt>
<dd>
<p>L&#8217;utilisation de <code>--recurse-submodules</code> permet de mettre à jour le contenu de tous les sous-modules actifs en fonction du commit enregistré dans le super-projet. Si des modifications locales au sous-modules seraient écrasées, l&#8217;extraction échoue à moins d&#8217;utiliser <code>-f</code>. Si l&#8217;option n&#8217;est pas spécifiée (ou si <code>--no-recurse-submodules</code> est spécifié), les arbres de travail des sous-modules ne sont pas mis à jour. Comme <a href='{{< relurl "docs/git-submodule/fr" >}}'>git-submodule[1]</a>, la <code>HEAD</code> des sous-modules sera détachée.</p>
</dd>
<dt class="hdlist1" id="git-checkout---overlay"> <a class="anchor" href="#git-checkout---overlay"></a>--overlay </dt>
<dt class="hdlist1" id="git-checkout---no-overlay"> <a class="anchor" href="#git-checkout---no-overlay"></a>--no-overlay </dt>
<dd>
<p>Dans le mode de superposition par défaut, <code>git checkout</code> ne supprime jamais les fichiers de l’index ou de l’arbre de travail. Lorsque vous spécifiez <code>--no-overlay</code>, les fichiers qui apparaissent dans l’index et l’arbre de travail, mais pas dans «&lt;arbre-esque&gt;» sont supprimés, pour les faire correspondre à <code>&lt;arbre-esque&gt;</code> exactement.</p>
</dd>
<dt class="hdlist1" id="git-checkout---pathspec-from-fileltfichiergt"> <a class="anchor" href="#git-checkout---pathspec-from-fileltfichiergt"></a>--pathspec-from-file=&lt;fichier&gt; </dt>
<dd>
<p>Le spécificateur de chemin est passé dans <code>&lt;fichier&gt;</code> au lieu des arguments de la ligne de commande. Si <code>&lt;fichier&gt;</code> vaut <code>-</code> alors l&#8217;entrée standard est utilisée. Les éléments du spécificateur de chemin sont séparés par LF ou CR/LF. Les éléments du spécificateur de chemin peuvent être cités comme expliqué pour la variable de configuration <code>core.quotePath</code> (voir <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a>). Voir aussi l&#8217;option <code>--pathspec-file-nul</code> et l&#8217;option globale <code>--literal-pathspecs</code>.</p>
</dd>
<dt class="hdlist1" id="git-checkout---pathspec-file-nul"> <a class="anchor" href="#git-checkout---pathspec-file-nul"></a>--pathspec-file-nul </dt>
<dd>
<p>Uniquement significatif avec <code>--pathspec-from-file</code>. Les éléments du spécificateur de chemin sont séparés par le caractère NUL et tous les autres caractères sont utilisés littéralement (y compris les retours à la ligne et les guillemets).</p>
</dd>
<dt class="hdlist1" id="git-checkout-ltbranchegt"> <a class="anchor" href="#git-checkout-ltbranchegt"></a>&lt;branche&gt; </dt>
<dd>
<p>Branche à extraire ; si c&#8217;est une référence à une branche (c&#8217;est-à-dire un nom qui, préfixé par « refs/heads/ » est une référence valide), alors cette branche est extraite. Sinon, si c&#8217;est une référence à un commit valide, votre <code>HEAD</code> devient « détachée » et vous n&#8217;êtes plus sur aucune branche (voir plus bas pour plus de détails).</p>
<div class="paragraph">
<p>Vous pouvez utiliser la syntaxe <code>@{-N}</code> pour faire référence à la N-ième dernière branche ou commit extrait en utilisant une opération « git checkout ». Vous pouvez aussi spécifier <code>-</code> qui est synonyme de <code>@{-1}</code>.</p>
</div>
<div class="paragraph">
<p>Autre cas spécial supplémentaire, vous pouvez utiliser <code>A...B</code> comme raccourci pour la base de fusion de <code>A</code> et <code>B</code> s&#8217;il y a exactement une seule base de fusion. Vous pouvez ne pas spécifier <code>A</code> ou <code>B</code>, auquel cas ce sera <code>HEAD</code> par défaut.</p>
</div>
</dd>
<dt class="hdlist1" id="git-checkout-ltnouvelle-branchegt"> <a class="anchor" href="#git-checkout-ltnouvelle-branchegt"></a>&lt;nouvelle-branche&gt; </dt>
<dd>
<p>Nom pour une nouvelle branche.</p>
</dd>
<dt class="hdlist1" id="git-checkout-ltpointdedpartgt"> <a class="anchor" href="#git-checkout-ltpointdedpartgt"></a>&lt;point_de_départ&gt; </dt>
<dd>
<p>Le nom du commit auquel démarrer la nouvelle branche ; voir <a href='{{< relurl "docs/git-branch/fr" >}}'>git-branch[1]</a> pour plus de détails. <code>HEAD</code> par défaut.</p>
<div class="paragraph">
<p>Autre cas spécial supplémentaire, vous pouvez utiliser « A&#8230;&#8203;B » comme raccourci pour la base de fusion de <code>A</code> et <code>B</code> s&#8217;il y a exactement une seule base de fusion. Vous pouvez ne pas spécifier <code>A</code> ou <code>B</code>, auquel cas ce sera <code>HEAD</code> par défaut.</p>
</div>
</dd>
<dt class="hdlist1" id="git-checkout-ltarbre-esquegt"> <a class="anchor" href="#git-checkout-ltarbre-esquegt"></a>&lt;arbre-esque&gt; </dt>
<dd>
<p>Arbre depuis lequel extraire (quand des chemins sont indiqués). Si non spécifié, l&#8217;index est utilisé.</p>
<div class="paragraph">
<p>Autre cas spécial supplémentaire, vous pouvez utiliser « A&#8230;&#8203;B » comme raccourci pour la base de fusion de <code>A</code> et <code>B</code> s&#8217;il y a exactement une seule base de fusion. Vous pouvez ne pas spécifier <code>A</code> ou <code>B</code>, auquel cas ce sera <code>HEAD</code> par défaut.</p>
</div>
</dd>
<dt class="hdlist1" id="git-checkout---"> <a class="anchor" href="#git-checkout---"></a>-- </dt>
<dd>
<p>Ne pas interpréter les arguments qui suivent comme options.</p>
</dd>
<dt class="hdlist1" id="git-checkout-ltspcificateurdechemingt82308203"> <a class="anchor" href="#git-checkout-ltspcificateurdechemingt82308203"></a>&lt;spécificateur de chemin&gt;&#8230;&#8203; </dt>
<dd>
<p>Limite les chemins affectés par l&#8217;opération.</p>
<div class="paragraph">
<p>Pour plus de détail, voir l&#8217;entrée <em>spécificateur de chemin</em> dans <a href='{{< relurl "docs/gitglossary/fr" >}}'>gitglossary[7]</a>.</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_head_détachée"><a class="anchor" href="#_head_détachée"></a>HEAD DÉTACHÉE</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>HEAD</code> fait normalement référence à une branche nommée (par exemple, <code>master</code>). Dans le même temps, chaque branche pointe sur un commit spécifique. Regardons un dépôt avec trois commits, dont un est étiqueté, et avec la branche <code>master</code> extraite :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>           HEAD (se réfère à la branche 'master')
            |
            v
a---b---c  branch 'master' (se réfère au commit 'c')
    ^
    |
  tag 'v2.0' (se réfère au commit 'b')</pre>
</div>
</div>
<div class="paragraph">
<p>Quand un commit est créé dans cet état, la branche est mise à jour pour faire référence au nouveau commit. Plus précisément, <em>git commit</em> crée un nouveau commit <code>d</code>, dont le parent est le commit <code>c</code>, et ainsi elle met à jour la branche <code>master</code> pour faire référence au nouveau commit <code>d</code>. <code>HEAD</code> fait toujours référence à la branche <code>master</code> et donc fait maintenant référence indirectement au commit <code>d</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ edit; git add; git commit

               HEAD (se réfère à la branche 'master')
                |
                v
a---b---c---d  branche 'master' (se réfère au commit 'd')
    ^
    |
  tag 'v2.0' (se réfère au commit 'b')</pre>
</div>
</div>
<div class="paragraph">
<p>Il est parfois utile de permettre l&#8217;extraction d&#8217;un commit qui n&#8217;est sommet d&#8217;aucune branche ou même de créer un nouveau commit qui n&#8217;est pas référencé par une branche nommée. Regardons ce qui arrive quand on extrait le commit <code>b</code> (ici, deux manières de faire sont montrées) :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git checkout v2.0  # ou
$ git checkout master^^

   HEAD (se réfère au commit 'b')
    |
    v
a---b---c---d  branch 'master' (se réfère au commit 'd')
    ^
    |
  tag 'v2.0' (se réfère au commit 'b')</pre>
</div>
</div>
<div class="paragraph">
<p>Veuillez noter que quelle que soit la commande d&#8217;extraction utilisée, <code>HEAD</code> pointe maintenant directement sur le commit <code>b</code>. C&#8217;est connu comme étant l&#8217;état <code>HEAD</code> détachée. Ceci signifie simplement que <code>HEAD</code> fait référence à un commit spécifique, par opposition à une référence à une branche nommée. Voyons ce qui arrive quand un commit est créé :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ edit; git add; git commit

     HEAD (se réfère au commit 'e')
      |
      v
      e
     /
a---b---c---d  branche 'master' (se réfère au commit 'd')
    ^
    |
  tag 'v2.0' (se réfère au commit 'b')</pre>
</div>
</div>
<div class="paragraph">
<p>Il y a maintenant un nouveau commit <code>e</code> mais il est référencé seulement par <code>HEAD</code>. Un autre commit peut bien sûr être ajouté dans cet état :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ edit; git add; git commit

	 HEAD (se réfère au commit 'f')
	  |
	  v
      e---f
     /
a---b---c---d  branche 'master' (se réfère au commit 'd')
    ^
    |
  tag 'v2.0' (se réfère au commit 'b')</pre>
</div>
</div>
<div class="paragraph">
<p>En fait, toutes les opérations normales de Git peuvent être exécutées. Mais, regardons ce qui arrive quand <code>master</code> est extraite :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git checkout master

               HEAD (se réfère au branch 'master')
      e---f     |
     /          v
a---b---c---d  branche 'master' (se réfère au commit 'd')
    ^
    |
  tag 'v2.0' (se réfère au commit 'b')</pre>
</div>
</div>
<div class="paragraph">
<p>Il est important de réaliser qu&#8217;à ce moment, rien ne fait référence au commit <code>f</code>. Finalement, le commit <code>f</code> (et par extension le commit <code>e</code>) sera supprimé par le processus de ramasse-miette régulier de Git, à moins de créer une référence avant que cela n&#8217;arrive. Si vous n&#8217;avez pas encore quitté le commit <code>f</code>, une des commandes suivantes permet de créer une référence sur lui :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git checkout -b foo  # ou "git switch -c foo"  <b class="conum">(1)</b>
$ git branch foo                                 <b class="conum">(2)</b>
$ git tag foo                                    <b class="conum">(3)</b></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>crée une nouvelle branche <code>foo</code> qui fait référence au commit <code>f</code>, puis met à jour <code>HEAD</code> pour faire référence à la branche <code>foo</code>. En d&#8217;autres termes, l&#8217;état ne sera plus en <code>HEAD</code> détachée après cette commande.</p>
</li>
<li>
<p>crée aussi une nouvelle branche <code>foo</code> qui fait référence au commit <code>f</code> mais laisse <code>HEAD</code> détachée.</p>
</li>
<li>
<p>crée une nouvelle étiquette <code>foo</code> qui fait référence au commit <code>f</code>, en laissant <code>HEAD</code> détachée.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Si nous ne sommes plus sur <code>f</code>, alors nous devons d&#8217;abord retrouver son nom d&#8217;objet (typiquement en utilisant git reflog), puis nous pouvons créer une référence dessus. Par exemple, pour voir les deux derniers commits sur lesquels <code>HEAD</code> pointait, nous pouvons utiliser l&#8217;une des commandes suivantes :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git reflog -2 HEAD # ou
$ git log -g -2 HEAD</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_désambiguïsation_dargument"><a class="anchor" href="#_désambiguïsation_dargument"></a>DÉSAMBIGUÏSATION D&#8217;ARGUMENT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Quand il n&#8217;y a qu&#8217;un argument fourni et qu&#8217;il n&#8217;est pas <code>--</code> (par exemple <code>git checkout abc</code>) et quand l&#8217;argument est à la fois un <code>&lt;arbre-esque&gt;</code> valide (par exemple une branche <code>abc</code> existe) et un &lt;spécificateur_de_chemin&gt; valide (par exemple un fichier ou un répertoire du nom de « abc » existe), Git vous demandera généralement de lever l&#8217;ambiguïté. Du fait qu&#8217;extraire une branche est une opération très commune, cependant, <code>git checkout abc</code> considère « abc » comme un &lt;arbre-esque&gt; dans une telle situation. Utilisez <code>git checkout -- &lt;spécificateur_de_chemin&gt;</code> si vous voulez extraire ces chemins depuis l&#8217;index.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_exemples"><a class="anchor" href="#_exemples"></a>EXEMPLES</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_1_chemins"><a class="anchor" href="#_1_chemins"></a>1. Chemins</h3>
<div class="paragraph">
<p>La séquence suivante extrait la branche <code>master</code>, ramène le fichier <code>Makefile</code> à deux révisions en arrière, supprime <code>hello.c</code> par erreur et le récupère de l&#8217;index.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git checkout master             <b class="conum">(1)</b>
$ git checkout master~2 Makefile  <b class="conum">(2)</b>
$ rm -f hello.c
$ git checkout hello.c            <b class="conum">(3)</b></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>bascule de branche</p>
</li>
<li>
<p>prend un fichier depuis un autre commit</p>
</li>
<li>
<p>restaure <code>hello.c</code> depuis l&#8217;index</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Si vous souhaitez extraire <em>tous</em> les fichiers source C de l&#8217;index, vous pouvez lancer</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git checkout -- '*.c'</pre>
</div>
</div>
<div class="paragraph">
<p>Notez les guillemets autour de <code>*.c</code>. Le fichier <code>hello.c</code> sera aussi extrait, même s&#8217;il n&#8217;est plus dans l&#8217;arbre de travail, parce que le patron de fichier est utilisé pour trouver les entrées dans l&#8217;index (et non dans l&#8217;arbre de travail par le shell).</p>
</div>
<div class="paragraph">
<p>Si vous avez une branche qui s&#8217;appelle malheureusement <code>hello.c</code>, cette étape pourrait être confondue avec une instruction de basculer sur cette branche. Vous devriez alors plutôt écrire :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git checkout -- hello.c</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_2_fusion"><a class="anchor" href="#_2_fusion"></a>2. Fusion</h3>
<div class="paragraph">
<p>Après avoir travaillé dans la mauvaise branche, basculer sur la branche correcte serait réalisé par :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git checkout monsujet</pre>
</div>
</div>
<div class="paragraph">
<p>Cependant, votre « fausse » branche et votre branche correcte <code>monsujet</code> peuvent être différentes par les fichiers que vous avez modifiés localement, auquel cas l&#8217;extraction ci-dessus échouerait comme ceci :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git checkout monsujet
error: Vos modifications locales aux fichiers suivants seraient écrasées par l'extraction :</pre>
</div>
</div>
<div class="paragraph">
<p>Vous pouvez fournir l&#8217;option <code>-m</code> à la commande, ce qui essaierait une fusion à trois points :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git checkout -m monsujet
Fusion automatique de frotz</pre>
</div>
</div>
<div class="paragraph">
<p>Après cette fusion à trois points, les modifications locales ne sont <em>pas</em> enregistrées dans votre index, donc <code>git diff</code> vous montrerait ce qui a changé depuis le sommet de la nouvelle branche.</p>
</div>
</div>
<div class="sect2">
<h3 id="_3_conflit_de_fusion"><a class="anchor" href="#_3_conflit_de_fusion"></a>3. Conflit de fusion</h3>
<div class="paragraph">
<p>Quand un conflit de fusion arrive pendant un basculement de branche avec l&#8217;option <code>-m</code>, vous devriez voir quelque chose comme :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git checkout -m mytopic
Fusion automatique de frotz
CONFLIT (contenu): Conflit de fusion dans frotz
fatal: merge program failed</pre>
</div>
</div>
<div class="paragraph">
<p>À ce stade, <code>git diff</code> affiche les modifications proprement fusionnées comme dans l&#8217;exemple précédent, ainsi que les modifications en conflit. Éditez et résolvez le conflit et marquez-le résolu avec <code>git add</code> comme d&#8217;habitude :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ edit frotz
$ git add frotz</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_configuration"><a class="anchor" href="#_configuration"></a>CONFIGURATION</h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Missing <code>fr/includes/cmd-config-section-all.txt</code></p>
</div>
<div class="paragraph">
<p>See original version for this content.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Missing <code>fr/config/checkout.txt</code></p>
</div>
<div class="paragraph">
<p>See original version for this content.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_voir_aussi"><a class="anchor" href="#_voir_aussi"></a>VOIR AUSSI</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href='{{< relurl "docs/git-switch/fr" >}}'>git-switch[1]</a>, <a href='{{< relurl "docs/git-restore/fr" >}}'>git-restore[1]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Fait partie de la suite <a href='{{< relurl "docs/git/fr" >}}'>git[1]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_traduction"><a class="anchor" href="#_traduction"></a>TRADUCTION</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Cette  page de manuel a été traduite par Jean-Noël Avila &lt;jn.avila AT free DOT fr&gt; et les membres du projet git-manpages-l10n. Veuillez signaler toute erreur de traduction par un rapport de bogue sur le site <a href="https://github.com/jnavila/git-manpages-l10n" class="bare">https://github.com/jnavila/git-manpages-l10n</a> .</p>
</div>
</div>
</div>