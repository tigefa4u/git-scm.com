---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-rm Documentation
docname: git-rm
lang: pt_BR
aliases:
- "/docs/git-rm/pt_BR/index.html"
---
<div class="sect1">
<h2 id="_nome"><a class="anchor" href="#_nome"></a>NOME</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-rm - Remove os arquivos da árvore de trabalho e do índice</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resumo"><a class="anchor" href="#_resumo"></a>RESUMO</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git rm</em> [-f | --force] [-n] [-r] [--cached] [--ignore-unmatch]
	  [--quiet] [--pathspec-from-file=&lt;arquivo&gt; [--pathspec-file-nul]]
	  [--] [&lt;pathspec&gt;&#8230;&#8203;]</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_descrição"><a class="anchor" href="#_descrição"></a>DESCRIÇÃO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Remove do índice, da árvore de trabalho e do índice os arquivos que correspondam ao <em>pathpec</em>. O comando <code>git rm</code> não removerá um arquivo apenas do seu diretório de trabalho. (Não há opção para remover um arquivo apenas da árvore de trabalho e ainda assim mantê-lo no índice; use <code>/bin/rm</code> se quiser fazer isso). Os arquivos que estão sendo removidos devem ser idênticos aos do cume do ramo e nenhuma atualização de seu conteúdo pode ser colocada no índice, embora esse comportamento padrão possa ser substituído pela opção <code>-f</code>. Quando <code>--cached</code> é fornecido, o conteúdo preparado deve corresponder ao cume da ramificação ou ao arquivo no disco, permitindo que o arquivo seja removido apenas do índice. Quando os "sparse-checkouts" estiverem em uso (consulte <a href='{{< relurl "docs/git-sparse-checkout/pt_BR" >}}'>git-sparse-checkout[1]</a>), o comando <code>git rm</code> removerá apenas os caminhos dentro dos padrões de "sparse-checkout".</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_opções"><a class="anchor" href="#_opções"></a>OPÇÕES</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-rm-ltpathspecgt82308203"> <a class="anchor" href="#git-rm-ltpathspecgt82308203"></a>&lt;pathspec&gt;&#8230;&#8203; </dt>
<dd>
<p>Arquivos para remover. Um nome de diretório à esquerda (<code>dir</code> para remover <code>dir/file1</code> e <code>dir/file2</code> por exemplo) pode ser utilizado para remover todos os arquivos do diretório e, recursivamente, todos os subdiretórios, porém, isso requer que a opção <code>-r</code> seja explicitamente usada.</p>
<div class="paragraph">
<p>O comando remove apenas os caminhos que sejam informados pelo Git.</p>
</div>
<div class="paragraph">
<p>O agrupamento de arquivos faz a correspondência entre os limites do diretório. Assim, considerando dois diretórios <code>d</code> e <code>d2</code>, há uma diferença entre usar <code>git rm 'd*'</code> e <code>git rm 'd/*'</code>, pois o primeiro também removerá todo o diretório <code>d2</code>.</p>
</div>
<div class="paragraph">
<p>Para mais detalhes sobre a sintaxe, consulte a entrada <em>pathspec</em> em <a href='{{< relurl "docs/gitglossary/pt_BR" >}}'>gitglossary[7]</a>.</p>
</div>
</dd>
<dt class="hdlist1" id="git-rm--f"> <a class="anchor" href="#git-rm--f"></a>-f </dt>
<dt class="hdlist1" id="git-rm---force"> <a class="anchor" href="#git-rm---force"></a>--force </dt>
<dd>
<p>Substitua a verificação atualizada.</p>
</dd>
<dt class="hdlist1" id="git-rm--n"> <a class="anchor" href="#git-rm--n"></a>-n </dt>
<dt class="hdlist1" id="git-rm---dry-run"> <a class="anchor" href="#git-rm---dry-run"></a>--dry-run </dt>
<dd>
<p>Na verdade, não remova nenhum arquivo. Em vez disso, mostra apenas se eles existem no índice e se, de outra maneira, seriam removidos pelo comando.</p>
</dd>
<dt class="hdlist1" id="git-rm--r"> <a class="anchor" href="#git-rm--r"></a>-r </dt>
<dd>
<p>Permita a remoção recursiva quando um nome do diretório principal for informado.</p>
</dd>
<dt class="hdlist1" id="git-rm---"> <a class="anchor" href="#git-rm---"></a>-- </dt>
<dd>
<p>Esta opção pode ser utilizada para separar as opções da linha de comandos da lista dos arquivos (útil quando os nomes do arquivo puderem ser confundidos com as opções da linha de comando).</p>
</dd>
<dt class="hdlist1" id="git-rm---cached"> <a class="anchor" href="#git-rm---cached"></a>--cached </dt>
<dd>
<p>Use esta opção para desestabilizar e remover apenas os caminhos do índice. Os arquivos da árvore de trabalho, alterados ou não, serão deixados em paz.</p>
</dd>
<dt class="hdlist1" id="git-rm---ignore-unmatch"> <a class="anchor" href="#git-rm---ignore-unmatch"></a>--ignore-unmatch </dt>
<dd>
<p>Encerre com uma condição zero, ainda que não haja a coincidência com nenhum arquivo.</p>
</dd>
<dt class="hdlist1" id="git-rm---sparse"> <a class="anchor" href="#git-rm---sparse"></a>--sparse </dt>
<dd>
<p>Permite a atualização das entradas no índice fora do cone de averiguação esparsa. Normalmente, o comando <code>git rm</code> se recusa a atualizar as entradas do índice cujos caminhos não se encaixam no cone de averiguação esparsa. Para mais informações consulte <a href='{{< relurl "docs/git-sparse-checkout/pt_BR" >}}'>git-sparse-checkout[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-rm--q"> <a class="anchor" href="#git-rm--q"></a>-q </dt>
<dt class="hdlist1" id="git-rm---quiet"> <a class="anchor" href="#git-rm---quiet"></a>--quiet </dt>
<dd>
<p>O <code>git rm</code> normalmente gera uma linha (na forma de um comando <code>rm</code>) para cada arquivo removido. Essa opção suprime esta saída.</p>
</dd>
<dt class="hdlist1" id="git-rm---pathspec-from-fileltarquivogt"> <a class="anchor" href="#git-rm---pathspec-from-fileltarquivogt"></a>--pathspec-from-file=&lt;arquivo&gt; </dt>
<dd>
<p>O "pathspec" é passado com <code>&lt;arquivo&gt;</code> em vez dos argumentos da linha de comando. Caso o <code>&lt;arquivo&gt;</code> seja exatamente <code>-</code>, a entrada padrão será utilizada. Os elementos do "pathspec" são separados por caracteres de término de linha <code>LF</code> ou <code>CR/LF</code>. Os elementos do "pathspec" podem ser citados conforme explicado na variável de configuração <code>core.quotePath</code> (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>). Consulte também opção <code>--pathspec-file-nul</code> e o global <code>--literal-pathspecs</code>.</p>
</dd>
<dt class="hdlist1" id="git-rm---pathspec-file-nul"> <a class="anchor" href="#git-rm---pathspec-file-nul"></a>--pathspec-file-nul </dt>
<dd>
<p>Só faz algum sentido caso seja utilizado junto com a opção <code>--pathspec-from-file</code>. Os elementos "pathspec" são separados com caracteres <code>NUL</code> e todos os outros caracteres são considerados de forma literal (incluindo as novas linhas e as citações).</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_removendo_os_arquivos_que_desapareceram_do_sistema_de_arquivos"><a class="anchor" href="#_removendo_os_arquivos_que_desapareceram_do_sistema_de_arquivos"></a>REMOVENDO OS ARQUIVOS QUE DESAPARECERAM DO SISTEMA DE ARQUIVOS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Não há uma opção para o comando <code>git rm</code> para remover do índice apenas os caminhos que desapareceram do sistema de arquivos. No entanto, dependendo do caso, há várias maneiras de se fazer isso.</p>
</div>
<div class="sect2">
<h3 id="_utilizando_o_git_commit_a"><a class="anchor" href="#_utilizando_o_git_commit_a"></a>Utilizando o <code>git commit -a</code></h3>
<div class="paragraph">
<p>Se você pretende que o seu próximo commit registre todas as alterações dos arquivos rastreados na árvore de trabalho e registre todas as remoções de arquivos que foram removidos da árvore de trabalho com <code>rm</code> (em oposição ao <code>git rm</code>), use o <code>git commit -a</code>, pois ele notará e registrará automaticamente todas as remoções. Você também pode obter um efeito semelhante sem fazer o commit usando <code>git add -u</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_utilizando_git_add_a"><a class="anchor" href="#_utilizando_git_add_a"></a>Utilizando <code>git add -A</code></h3>
<div class="paragraph">
<p>Ao aceitar um novo código para o fornecedor de um ramo, você provavelmente deseja registrar a remoção dos caminhos e as adições dos novos caminhos, bem como as modificações dos caminhos já existentes.</p>
</div>
<div class="paragraph">
<p>Normalmente, você primeiro remove todos os arquivos rastreados da árvore de trabalho utilizando este comando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>git ls-files -z | xargs -0 rm -f</pre>
</div>
</div>
<div class="paragraph">
<p>e descompacte o novo código na árvore de trabalho. Como alternativa, você pode usar o comando <em>rsync</em> nas alterações na árvore de trabalho.</p>
</div>
<div class="paragraph">
<p>Depois disso, a maneira mais fácil de registrar todas as remoções, adições e modificações na árvore de trabalho é:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>git add -A</pre>
</div>
</div>
<div class="paragraph">
<p>Consulte <a href='{{< relurl "docs/git-add/pt_BR" >}}'>git-add[1]</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_outras_maneiras"><a class="anchor" href="#_outras_maneiras"></a>Outras maneiras</h3>
<div class="paragraph">
<p>Se tudo o que você realmente deseja é remover do índice os arquivos que não estão mais presentes na árvore de trabalho (talvez porque a sua árvore de trabalho esteja suja e você não possa usar o comando <code>git commit -a</code>), utilize o seguinte comando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>git diff --name-only --diff-filter=D -z | xargs -0 git rm --cached</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_submódulos"><a class="anchor" href="#_submódulos"></a>SUBMÓDULOS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Apenas os submódulos que usam um gitfile (o que significa que eles foram clonados com uma versão do Git 1.7.8 ou mais recente) serão removidos da árvore de trabalho, pois o repositório deles reside dentro do diretório .git do superprojeto. Se um submódulo (ou um dos aninhados dentro dele) ainda usar um diretório .git, o <code>git rm</code> moverá o diretório git dos submódulos para o diretório git dos superprojetos para proteger o histórico do submódulo. Se ele existir, a seção submodule.&lt;nome&gt; no arquivo <a href='{{< relurl "docs/gitmodules/pt_BR" >}}'>gitmodules[5]</a> também será removida e esse arquivo será preparado (a menos que --cached ou -n sejam usados).</p>
</div>
<div class="paragraph">
<p>Um submódulo é considerado atualizado quando o "HEAD" é o mesmo que o registrado no índice, nenhum arquivo rastreado é modificado e nenhum arquivo não rastreado que não seja ignorado está presente na árvore de trabalho do submódulo. Os arquivos ignorados são considerados descartáveis e não impedem que a árvore de trabalho de um submódulo seja removida.</p>
</div>
<div class="paragraph">
<p>Caso queira remover apenas a averiguação local de um submódulo vindo da sua árvore de trabalho sem fazer o commit de remoção, em vez disso utilize o <a href='{{< relurl "docs/git-submodule/pt_BR" >}}'>git-submodule[1]</a> <code>deinit</code>. Para obter mais detalhes sobre a remoção do submódulo, veja também <a href='{{< relurl "docs/gitsubmodules/pt_BR" >}}'>gitsubmodules[7]</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_exemplos"><a class="anchor" href="#_exemplos"></a>EXEMPLOS</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-rm-codegitrmDocumentationtxtcode"> <a class="anchor" href="#git-rm-codegitrmDocumentationtxtcode"></a><code>git rm Documentation/\*.txt</code> </dt>
<dd>
<p>Remove todos os arquivos <code>* .txt</code> do índice que estão no diretório <code>Documentation</code> e em qualquer um dos seus subdiretórios.</p>
<div class="paragraph">
<p>Note que o asterisco <code>*</code> é citado no shell neste exemplo; isso permite que o Git e não o shell, expanda os nomes dos caminhos dos arquivos e subdiretórios no diretório <code>Documentation/</code>.</p>
</div>
</dd>
<dt class="hdlist1" id="git-rm-codegitrm-fgit-shcode"> <a class="anchor" href="#git-rm-codegitrm-fgit-shcode"></a><code>git rm -f git-*.sh</code> </dt>
<dd>
<p>Como este exemplo permite que o shell expanda o asterisco (ou seja, você está listando os arquivos explicitamente), ele não considera o <code>subdir/git-foo.sh</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_bugs"><a class="anchor" href="#_bugs"></a>BUGS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sempre que uma atualização do <code>superproject</code> remove um submódulo preenchido (por exemplo, ao alternar entre commits antes e após a remoção), um checkout obsoleto do submódulo permanece no local antigo. A remoção do diretório antigo só é segura quando ele usa um <code>gitfile</code>; caso contrário, o histórico do submódulo também será excluído. Esta etapa será obsoleta quando a atualização recursiva do submódulo for implementada.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_veja_também"><a class="anchor" href="#_veja_também"></a>VEJA TAMBÉM</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href='{{< relurl "docs/git-add/pt_BR" >}}'>git-add[1]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Parte do conjunto <a href='{{< relurl "docs/git/pt_BR" >}}'>git[1]</a></p>
</div>
</div>
</div>