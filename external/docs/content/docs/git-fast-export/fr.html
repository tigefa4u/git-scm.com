---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-fast-export Documentation
docname: git-fast-export
lang: fr
aliases:
- "/docs/git-fast-export/fr/index.html"
---
<div class="sect1">
<h2 id="_nom"><a class="anchor" href="#_nom"></a>NOM</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-fast-export - exportateur de données Git</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_synopsis"><a class="anchor" href="#_synopsis"></a>SYNOPSIS</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git fast-export</em> [&lt;options&gt;] | <em>git fast-import</em></pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_description"><a class="anchor" href="#_description"></a>DESCRIPTION</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ce programme vide les révisions données dans une forme appropriée pour être introduite dans <em>git fast-import</em>.</p>
</div>
<div class="paragraph">
<p>Vous pouvez l&#8217;utiliser comme un remplacement de bundle lisible par l&#8217;homme (voir <a href='{{< relurl "docs/git-bundle/fr" >}}'>git-bundle[1]</a>), ou comme un format qui peut être édité avant d&#8217;être envoyé à <em>git fast-import</em> afin de faire des réécritures d&#8217;historique (une capacité sur laquelle s&#8217;appuient des outils comme <em>git filter-repo</em>).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_options"><a class="anchor" href="#_options"></a>OPTIONS</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-fast-export---progressltngt"> <a class="anchor" href="#git-fast-export---progressltngt"></a>--progress=&lt;n&gt; </dt>
<dd>
<p>Insérer des déclarations <em>de progrès</em> tous les &lt;n&gt;objets, à afficher par <em>git fast-import</em> lors de l’importation.</p>
</dd>
<dt class="hdlist1" id="git-fast-export---signed-tagsverbatimwarnwarn-stripstripabort"> <a class="anchor" href="#git-fast-export---signed-tagsverbatimwarnwarn-stripstripabort"></a>--signed-tags=(verbatim|warn|warn-strip|strip|abort) </dt>
<dd>
<p>Spécifier comment traiter les étiquettes signées. Puisque toute transformation après l&#8217;exportation peut changer les noms des étiquettes (ce qui peut également se produire lors de l&#8217;exclusion des révisions), les signatures ne correspondront pas.</p>
<div class="paragraph">
<p>Lorsque vous demandez à « abandonner » (<em>abort</em> ce qui est la valeur par défaut), ce programme mourra lorsqu&#8217;il rencontrera une étiquette signée. Avec <em>strip</em>, les étiquettes seront silencieusement rendues non signées, avec <em>warn-strip</em> elles seront rendues non signées mais un avertissement sera affiché, avec <em>verbatim</em>, elles seront exportées silencieusement et avec <em>warn</em>, elles seront exportées, mais vous verrez un avertissement.</p>
</div>
</dd>
<dt class="hdlist1" id="git-fast-export---tag-of-filtered-objectabortdroprewrite"> <a class="anchor" href="#git-fast-export---tag-of-filtered-objectabortdroprewrite"></a>--tag-of-filtered-object=(abort|drop|rewrite) </dt>
<dd>
<p>Spécifier comment traiter les étiquettes dont l&#8217;objet étiqueté est filtré. Comme les révisions et les fichiers à exporter peuvent être limités par le chemin d&#8217;accès, les objets étiquetés peuvent être complètement filtrés.</p>
<div class="paragraph">
<p>Lorsqu&#8217;il est demandé à <em>abort</em> (ce qui est la valeur par défaut), ce programme mourra lorsqu&#8217;il rencontrera une telle étiquette. Avec <em>drop</em>, il omettra ces étiquettes de la sortie. Avec <em>rewrite</em>, si l&#8217;objet étiqueté est un commit, il réécrira l&#8217;étiquette pour étiqueter un commit ancêtre (via la réécriture du parent ; voir <a href='{{< relurl "docs/git-rev-list/fr" >}}'>git-rev-list[1]</a>).</p>
</div>
</dd>
<dt class="hdlist1" id="git-fast-export--M"> <a class="anchor" href="#git-fast-export--M"></a>-M </dt>
<dt class="hdlist1" id="git-fast-export--C"> <a class="anchor" href="#git-fast-export--C"></a>-C </dt>
<dd>
<p>Effectuer une détection de déplacement et/ou de copie, comme décrit dans la page de manuel <a href='{{< relurl "docs/git-diff/fr" >}}'>git-diff[1]</a>, et l&#8217;utiliser pour générer des commandes de renommage et de copie dans le journal généré.</p>
<div class="paragraph">
<p>Notez que les versions précédentes de cette commande ne se plaignaient pas et produisaient des résultats incorrects si vous donniez ces options.</p>
</div>
</dd>
<dt class="hdlist1" id="git-fast-export---export-marksltfichiergt"> <a class="anchor" href="#git-fast-export---export-marksltfichiergt"></a>--export-marks=&lt;fichier&gt; </dt>
<dd>
<p>Décharge la table interne des marques dans un &lt;fichier&gt;, une fois terminé. Les marques sont écrites une par ligne comme <code>:markid SHA-1</code>. Seules les marques des révisions sont écrites ; les marques des blobs sont ignorées. Des moteurs peuvent utiliser ce fichier pour valider les importations après qu&#8217;elles aient été complétées, ou pour sauvegarder la table des marques à travers des exécutions incrémentales. Comme &lt;fichier&gt; n&#8217;est ouvert et tronqué qu&#8217;à la fin de l&#8217;opération, le même chemin peut aussi être donné sans risque à --import-marks. Le fichier ne sera pas écrit si aucun nouvel objet n&#8217;a été marqué/exporté.</p>
</dd>
<dt class="hdlist1" id="git-fast-export---import-marksltfichiergt"> <a class="anchor" href="#git-fast-export---import-marksltfichiergt"></a>--import-marks=&lt;fichier&gt; </dt>
<dd>
<p>Avant de traiter toute entrée, charger les marques spécifiées dans &lt;fichier&gt; ;. Le fichier d&#8217;entrée doit exister, doit être lisible, et doit utiliser le même format que celui produit par --export-marks.</p>
</dd>
<dt class="hdlist1" id="git-fast-export---mark-tags"> <a class="anchor" href="#git-fast-export---mark-tags"></a>--mark-tags </dt>
<dd>
<p>En plus de nommer les blobs et les commits avec des identifiants de marque, vous pouvez aussi nommer les étiquettes. Ceci est utile en conjonction avec <code>--export-marks</code> et <code>--import-marks</code>, et est également utile (et nécessaire) pour l&#8217;exportation de étiquettes imbriquées. Cela ne nuit pas aux autres cas et serait la valeur par défaut, mais beaucoup de frontends d&#8217;import rapide ne sont pas préparés à accepter les étiquettes comprenant des identifiants de marque.</p>
<div class="paragraph">
<p>Les commits (ou étiquettes) qui ont déjà été marqués ne seront pas exportés à nouveau. Si le backend utilise un fichier --import-marks similaire, cela permet l&#8217;exportation incrémentale bidirectionnelle du dépôt en gardant les marques identiques entre les exécutions.</p>
</div>
</dd>
<dt class="hdlist1" id="git-fast-export---fake-missing-tagger"> <a class="anchor" href="#git-fast-export---fake-missing-tagger"></a>--fake-missing-tagger </dt>
<dd>
<p>Certains anciens dépôts ont des étiquettes sans étiqueteur. Le protocole d&#8217;importation rapide était assez strict à ce sujet, et ne le permettait pas. Il faut donc simuler un étiqueteur pour pouvoir importer rapidement la sortie.</p>
</dd>
<dt class="hdlist1" id="git-fast-export---use-done-feature"> <a class="anchor" href="#git-fast-export---use-done-feature"></a>--use-done-feature </dt>
<dd>
<p>Démarrer le flux avec une strophe <em>feature done</em> et le terminer avec une commande <em>done</em>.</p>
</dd>
<dt class="hdlist1" id="git-fast-export---no-data"> <a class="anchor" href="#git-fast-export---no-data"></a>--no-data </dt>
<dd>
<p>Ignorer la sortie des objets blob et faire plutôt référence aux blobs via leur hachage SHA-1 original. Ceci est utile pour réécrire la structure du répertoire ou l&#8217;historique d&#8217;un dépôt sans toucher au contenu des fichiers individuels. Notez que le flux résultant ne peut être utilisé que par un dépôt qui contient déjà les objets nécessaires.</p>
</dd>
<dt class="hdlist1" id="git-fast-export---full-tree"> <a class="anchor" href="#git-fast-export---full-tree"></a>--full-tree </dt>
<dd>
<p>Cette option fera en sorte que fast-export émette une directive "deleteall" pour chaque commit suivi d&#8217;une liste complète de tous les fichiers du commit (par opposition à la liste des fichiers qui sont différents du premier parent du commit).</p>
</dd>
<dt class="hdlist1" id="git-fast-export---anonymize"> <a class="anchor" href="#git-fast-export---anonymize"></a>--anonymize </dt>
<dd>
<p>Anonymiser le contenu du dépôt tout en conservant la forme de l&#8217;historique et de l&#8217;arbre stocké. Voir la section <code>ANONYMISATION</code> ci-dessous.</p>
</dd>
<dt class="hdlist1" id="git-fast-export---anonymize-mapltdepuisgtltversgt"> <a class="anchor" href="#git-fast-export---anonymize-mapltdepuisgtltversgt"></a>--anonymize-map=&lt;depuis&gt;[:&lt;vers&gt;] </dt>
<dd>
<p>Convertir le jeton <code>&lt;depuis&gt;</code> en <code>&lt;vers&gt;</code> dans la sortie anonymisée. Si <code>&lt;vers&gt;</code> est omis, convertir <code>&lt;depuis&gt;</code> en lui-même (c&#8217;est-à-dire, ne pa l&#8217;anonymiser). Voir la section sur <code>ANONYMISATION</code> ci-dessous.</p>
</dd>
<dt class="hdlist1" id="git-fast-export---reference-excluded-parents"> <a class="anchor" href="#git-fast-export---reference-excluded-parents"></a>--reference-excluded-parents </dt>
<dd>
<p>Par défaut, l&#8217;exécution d&#8217;une commande telle que <code>git fast-export master~5..master</code> n&#8217;inclura pas le commit master~5 et fera que master~4 n&#8217;aura plus master~5 comme parent (bien que l&#8217;ancien master~4 et le nouveau master~4 auront tous les mêmes fichiers). Utilisez --reference-excluded-parents pour que le flux fasse plutôt référence aux commits dans la plage exclue de l&#8217;historique par leur sha1sum. Notez que le flux résultant ne peut être utilisé que par un dépôt qui contient déjà les commits parents nécessaires.</p>
</dd>
<dt class="hdlist1" id="git-fast-export---show-original-ids"> <a class="anchor" href="#git-fast-export---show-original-ids"></a>--show-original-ids </dt>
<dd>
<p>Ajouter une directive supplémentaire à la sortie pour les commits et les blobs, <code>original-oid &lt;SHA1SUM&gt;</code>. Bien que de telles directives seront probablement ignorées par les importateurs tels que git-fast-import, elles peuvent être utiles pour les filtres intermédiaires (par exemple pour réécrire les messages de commit qui font référence à des commits plus anciens, ou pour dépouiller les blobs par id).</p>
</dd>
<dt class="hdlist1" id="git-fast-export---reencodeyesnoabort"> <a class="anchor" href="#git-fast-export---reencodeyesnoabort"></a>--reencode=(yes|no|abort) </dt>
<dd>
<p>Spécifier comment gérer l&#8217;en-tête <code>encoding</code> dans les objets commit. En demandant <em>abort</em> (« abandonner » qui est la valeur par défaut), ce programme mourra lorsqu&#8217;il rencontrera un tel objet commit. Avec <em>yes</em>, le message de livraison sera ré-encodé en UTF-8. Avec <em>no</em>, l&#8217;encodage original sera préservé.</p>
</dd>
<dt class="hdlist1" id="git-fast-export---refspec"> <a class="anchor" href="#git-fast-export---refspec"></a>--refspec </dt>
<dd>
<p>Appliquer la refspec spécifiée à chaque ref exportée. Plusieurs d&#8217;entre elles peuvent être spécifiées.</p>
</dd>
<dt class="hdlist1" id="git-fast-export-ltgit-rev-list-argsgt82308203"> <a class="anchor" href="#git-fast-export-ltgit-rev-list-argsgt82308203"></a>[&lt;git-rev-list-args&gt;&#8230;&#8203;] </dt>
<dd>
<p>Une liste d&#8217;arguments, acceptable pour <em>git rev-parse</em> et <em>git rev-list</em>, qui spécifie les objets et références spécifiques à exporter. Par exemple, <code>master~10..master</code> provoque l&#8217;exportation de la référence master actuelle avec tous les objets ajoutés depuis le commit de son 10ème ancêtre et (à moins que l&#8217;option --reference-excluded-parents soit spécifiée) tous les fichiers communs à master~9 et master~10.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_exemples"><a class="anchor" href="#_exemples"></a>EXEMPLES</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>$ git fast-export --all | (cd /dépôt/vide &amp;&amp; git fast-import)</pre>
</div>
</div>
<div class="paragraph">
<p>Cela exportera le dépôt entier et l&#8217;importera dans le dépôt vide existant. A l&#8217;exception du réencodage des commits qui ne sont pas en UTF-8, ce sera un miroir un à un.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git fast-export master~5..master |
	sed "s|refs/heads/master|refs/heads/autre|" |
	git fast-import</pre>
</div>
</div>
<div class="paragraph">
<p>Cela crée une nouvelle branche appelée <em>autre</em> à partir de <em>master~5..master</em> (c&#8217;est-à-dire que si <em>master</em> a un historique linéaire, elle prendra les 5 derniers commits).</p>
</div>
<div class="paragraph">
<p>Notez que cela suppose qu&#8217;aucun des blobs et des messages de validation référencés par cette plage de révision ne contient la chaîne <em>refs/heads/master</em>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_anonymisation"><a class="anchor" href="#_anonymisation"></a>ANONYMISATION</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Si l&#8217;option <code>--anonymize</code> est donnée, git tentera de supprimer toutes les informations d&#8217;identification du dépôt tout en conservant suffisamment de l&#8217;arbre original et des modèles d&#8217;historique pour reproduire certains bugs. Le but est qu&#8217;un bug git trouvé sur un dépôt privé persiste dans le dépôt anonymisé, et que ce dernier puisse être partagé avec les développeurs git pour aider à résoudre le bug.</p>
</div>
<div class="paragraph">
<p>Avec cette option, git remplacera tous les noms de référence, les chemins, le contenu des blobs, les messages de commit et d&#8217;étiquette, les noms et les adresses email dans la sortie avec des données anonymes. Deux instances de la même chaîne seront remplacées de manière équivalente (par exemple, deux commits avec le même auteur auront le même auteur anonymisé dans la sortie, mais ne présenteront aucune ressemblance avec la chaîne auteur originale). La relation entre les commits, les branches et les tags est conservée, ainsi que l&#8217;horodatage des commits (mais les messages de commit et les refnames ne ressemblent pas aux originaux). La composition relative de l&#8217;arbre est conservée (par exemple, si vous avez un arbre racine avec 10 fichiers et 3 arbres, la sortie le sera aussi), mais leurs noms et le contenu des fichiers seront remplacés.</p>
</div>
<div class="paragraph">
<p>Si vous pensez avoir trouvé un bogue git, vous pouvez commencer par exporter un flux anonymisé de l&#8217;ensemble du dépôt :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git fast-export --anonymize --all &gt;flux-anon</pre>
</div>
</div>
<div class="paragraph">
<p>Ensuite, confirmez que le bogue persiste dans un dépôt créé à partir de ce flux (de nombreux bogues ne le feront pas, car ils dépendent vraiment du contenu exact du dépôt) :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git init dépôt-anon
$ cd dépôt-anon
$ git fast-import &lt;../flux-anon
$ ... test de votre bogue ...</pre>
</div>
</div>
<div class="paragraph">
<p>Si le dépôt anonyme montre le bogue, il peut être intéressant de partager le <code>flux-anon</code> avec un rapport de bogue normal. Notez que le flux anonymisé se compresse très bien, donc le gzippage est encouragé. Si vous voulez examiner le flux pour vérifier qu&#8217;il ne contient pas de données privées, vous pouvez l&#8217;examiner directement avant de l&#8217;envoyer. Vous pouvez également essayer :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ perl -pe 's/\d+/X/g' &lt;flux-anon | sort -u | less</pre>
</div>
</div>
<div class="paragraph">
<p>qui montre toutes les lignes uniques (avec des nombres convertis en « X », pour réduire « Utilisateur 0 », « Utilisateur 1 », etc. en « Utilisateur X »). Cela produit une sortie beaucoup plus petite, et il est généralement facile de confirmer rapidement qu’il n’y a pas de données privées dans le flux.</p>
</div>
<div class="paragraph">
<p>La reproduction de certains bogues peut nécessiter la référence à des commits ou des chemins particuliers, ce qui devient difficile après que les refnames et les chemins ont été rendus anonymes. Vous pouvez demander à ce qu&#8217;un jeton particulier soit laissé tel quel ou transformé en une nouvelle valeur. Par exemple, si vous avez un bogue qui se reproduit avec <code>git rev-list sensitive -- secret.c</code>, vous pouvez exécuter :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git fast-export --anonymize --all \
      --anonymize-map=sensitive:foo \
      --anonymize-map=secret.c:bar.c \
      &gt;flux</pre>
</div>
</div>
<div class="paragraph">
<p>Après avoir importé le flux, vous pouvez ensuite exécuter <em>git rev-list foo&#8201;&#8212;&#8201;bar.c</em> dans le dépôt anonymisé.</p>
</div>
<div class="paragraph">
<p>Notez que les chemins et les refnames sont séparés en jetons aux frontières des barres obliques. La commande ci-dessus rendrait anonyme <code>sousrép/secret.c</code> comme quelque chose comme <code>chemin123/bar.c</code> ; vous pourriez alors rechercher <code>bar.c</code> dans le dépôt anonymisé pour déterminer le nom de chemin final.</p>
</div>
<div class="paragraph">
<p>Pour simplifier le référencement du chemin final, vous pouvez mettre en correspondance chaque composant du chemin ; ainsi, si vous anonymisez également <code>sousrép</code> en <code>réppublic</code>, alors le chemin final sera <code>réppublic/bar.c</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_limitations"><a class="anchor" href="#_limitations"></a>LIMITATIONS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Puisque <em>git fast-import</em> ne peut pas étiqueter les arbres, vous ne pourrez pas exporter complètement le dépôt linux.git, car il contient une étiquette référençant un arbre au lieu d&#8217;un commit.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_voir_aussi"><a class="anchor" href="#_voir_aussi"></a>VOIR AUSSI</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href='{{< relurl "docs/git-fast-import/fr" >}}'>git-fast-import[1]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Fait partie de la suite <a href='{{< relurl "docs/git/fr" >}}'>git[1]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_traduction"><a class="anchor" href="#_traduction"></a>TRADUCTION</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Cette  page de manuel a été traduite par Jean-Noël Avila &lt;jn.avila AT free DOT fr&gt; et les membres du projet git-manpages-l10n. Veuillez signaler toute erreur de traduction par un rapport de bogue sur le site <a href="https://github.com/jnavila/git-manpages-l10n" class="bare">https://github.com/jnavila/git-manpages-l10n</a> .</p>
</div>
</div>
</div>