---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-fast-export Documentation
docname: git-fast-export
lang: zh_HANS-CN
aliases:
- "/docs/git-fast-export/zh_HANS-CN/index.html"
---
<div class="sect1">
<h2 id="_名称"><a class="anchor" href="#_名称"></a>名称</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-fast-export - Git 数据导出器</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_概述"><a class="anchor" href="#_概述"></a>概述</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git fast-export</em> [&lt;选项&gt;] | <em>git fast-import</em></pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_描述"><a class="anchor" href="#_描述"></a>描述</h2>
<div class="sectionbody">
<div class="paragraph">
<p>该程序会将给定的修订转储为适合导入 <em>git fast-import</em> 的形式。</p>
</div>
<div class="paragraph">
<p>你可以把它用作人类可读的 bundle 替换（参见 <a href='{{< relurl "docs/git-bundle/zh_HANS-CN" >}}'>git-bundle[1]</a>），也可以把它用作一种格式，在输入到 <em>git fast-import</em> 之前进行编辑，以便进行历史重写（<em>git filter-repo</em> 等工具依赖这种能力）。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_选项"><a class="anchor" href="#_选项"></a>选项</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-fast-export---progressltngt"> <a class="anchor" href="#git-fast-export---progressltngt"></a>--progress=&lt;n&gt; </dt>
<dd>
<p>每隔 &lt;n&gt; 个对象插入 <em>progress</em> （进度）语句，在导入时由 <em>git fast-import</em> 显示。</p>
</dd>
<dt class="hdlist1" id="git-fast-export---signed-tagsverbatimwarnwarn-stripstripabort"> <a class="anchor" href="#git-fast-export---signed-tagsverbatimwarnwarn-stripstripabort"></a>--signed-tags=(verbatim|warn|warn-strip|strip|abort) </dt>
<dd>
<p>指定如何处理已签名的标记。 由于导出后的任何转换都可能更改标记名（排除修订时也可能发生这种情况），因此签名将不匹配。</p>
<div class="paragraph">
<p>当要求 <em>abort</em>（禁止，默认值）时，该程序将在遇到已签名标记时死亡。 如果使用 <em>strip</em>（剥夺），标签将被静默地取消签名；如果使用 <em>warn-strip</em>，标签将被取消签名，但会显示警告；如果使用 <em>verbatim</em>（逐字报告），标签将被静默地导出；如果使用 <em>warn</em>，标签将被导出，但会显示警告。</p>
</div>
</dd>
<dt class="hdlist1" id="git-fast-export---tag-of-filtered-objectabortdroprewrite"> <a class="anchor" href="#git-fast-export---tag-of-filtered-objectabortdroprewrite"></a>--tag-of-filtered-object=(abort|drop|rewrite) </dt>
<dd>
<p>指定如何处理已过滤掉标记对象的标记。 由于要导出的版本和文件可能受路径限制，标记对象可能会被完全过滤掉。</p>
<div class="paragraph">
<p>When asking to <em>abort</em> (which is the default), this program will die when encountering such a tag. With <em>drop</em> it will omit such tags from the output. With <em>rewrite</em>, if the tagged object is a commit, it will rewrite the tag to tag an ancestor commit (via parent rewriting; see <a href='{{< relurl "docs/git-rev-list/zh_HANS-CN" >}}'>git-rev-list[1]</a>).</p>
</div>
</dd>
<dt class="hdlist1" id="git-fast-export--M"> <a class="anchor" href="#git-fast-export--M"></a>-M </dt>
<dt class="hdlist1" id="git-fast-export--C"> <a class="anchor" href="#git-fast-export--C"></a>-C </dt>
<dd>
<p>如 <a href='{{< relurl "docs/git-diff/zh_HANS-CN" >}}'>git-diff[1]</a> 手册页所述，执行移动和/或复制检测，并在输出转储中生成重命名和复制命令。</p>
<div class="paragraph">
<p>请注意，如果您提供了这些选项，该命令的早期版本不会发出错误提示，并会产生不正确的结果。</p>
</div>
</dd>
<dt class="hdlist1" id="git-fast-export---export-marksltgt"> <a class="anchor" href="#git-fast-export---export-marksltgt"></a>--export-marks=&lt;文件&gt; </dt>
<dd>
<p>完成后将内部标记表转存到 &lt;文件&gt; 中。 标记以 <code>:markid SHA-1</code> 的形式每行写一个。只转储修订版的标记；忽略 blob 的标记。 后端可以在导入完成后使用此文件验证导入，或在增量运行时保存标记表。 由于 &lt;文件&gt; 仅在导入完成时打开并截断，因此也可以安全地为 --import-marks 提供相同的路径。 如果没有标记/导出新对象，文件将不会被写入。</p>
</dd>
<dt class="hdlist1" id="git-fast-export---import-marksltgt"> <a class="anchor" href="#git-fast-export---import-marksltgt"></a>--import-marks=&lt;文件&gt; </dt>
<dd>
<p>在处理任何输入之前，加载 &lt;文件&gt; 中指定的标记。 输入文件必须存在，必须可读，必须使用与 --export-marks 生成的相同格式。</p>
</dd>
<dt class="hdlist1" id="git-fast-export---mark-tags"> <a class="anchor" href="#git-fast-export---mark-tags"></a>--mark-tags </dt>
<dd>
<p>除了用标记 id 标记 blob 和提交，还可以标记标签。 这与 <code>--export-marks</code>（导出标记） 和 <code>--import-marks</code>（导入标记）`配合使用，对于导出嵌套标记也很有用（而且很必要）。 这对其他情况没有影响，也是默认做法，但许多快速导入前端并不准备接受带有标记标识符的标签。</p>
<div class="paragraph">
<p>任何已标记的提交（或标记）都不会再次导出。 如果后端使用类似的 --import-marks 文件，则可以通过在不同运行中保持相同的标记来实现仓库的增量双向导出。</p>
</div>
</dd>
<dt class="hdlist1" id="git-fast-export---fake-missing-tagger"> <a class="anchor" href="#git-fast-export---fake-missing-tagger"></a>--fake-missing-tagger </dt>
<dd>
<p>有些旧仓库有标签，但没有标记。 快速导入协议对此非常严格，不允许这样做。 所以要伪造一个标签，以便能够快速导入输出。</p>
</dd>
<dt class="hdlist1" id="git-fast-export---use-done-feature"> <a class="anchor" href="#git-fast-export---use-done-feature"></a>--use-done-feature </dt>
<dd>
<p>用 <em>feature done</em> 字符串启动数据流，用 <em>done</em> 命令终止数据流。</p>
</dd>
<dt class="hdlist1" id="git-fast-export---no-data"> <a class="anchor" href="#git-fast-export---no-data"></a>--no-data </dt>
<dd>
<p>跳过 blob 对象的输出，而是通过其原始 SHA-1 哈希值引用 blob。 这在重写仓库的目录结构或历史记录时非常有用，而且不会触及单个文件的内容。 请注意，生成的数据流只能由已包含必要对象的仓库使用。</p>
</dd>
<dt class="hdlist1" id="git-fast-export---full-tree"> <a class="anchor" href="#git-fast-export---full-tree"></a>--full-tree </dt>
<dd>
<p>该选项将导致 fast-export 为每个提交发出一个 "deleteall" 指令，然后列出提交中所有文件的完整列表（而不是只列出与提交的第一个父文件不同的文件）。</p>
</dd>
<dt class="hdlist1" id="git-fast-export---anonymize"> <a class="anchor" href="#git-fast-export---anonymize"></a>--anonymize </dt>
<dd>
<p>对资源库的内容进行匿名化处理，同时仍保留历史记录和存储树的形状。 请参阅下文 <code>匿名化</code> 部分。</p>
</dd>
<dt class="hdlist1" id="git-fast-export---anonymize-mapltgtltgt"> <a class="anchor" href="#git-fast-export---anonymize-mapltgtltgt"></a>--anonymize-map=&lt;开始&gt;[:&lt;结束&gt;] </dt>
<dd>
<p>将匿名化输出中的令牌 <code>&lt;from&gt;</code> 转换为 <code>&lt;to&gt;</code>。如果省略了 <code>&lt;to&gt;</code>，则将 <code>&lt;from&gt;</code> 映射到其本身（即不对其进行匿名化）。请参阅下面的 <code>匿名化</code> 部分。</p>
</dd>
<dt class="hdlist1" id="git-fast-export---reference-excluded-parents"> <a class="anchor" href="#git-fast-export---reference-excluded-parents"></a>--reference-excluded-parents </dt>
<dd>
<p>默认情况下，运行诸如 <code>git fast-export master~5..master</code> 这样的命令不会包含 master~5 提交，并会使 master~4 不再将 master~5 作为父提交（尽管旧的 master~4 和新的 master~4 拥有相同的文件）。 使用 --reference-excluded-parents 可以让数据流通过 sha1sum 来引用历史中排除范围内的提交。 需要注意的是，生成的数据流只能由已包含必要父提交的仓库使用。</p>
</dd>
<dt class="hdlist1" id="git-fast-export---show-original-ids"> <a class="anchor" href="#git-fast-export---show-original-ids"></a>--show-original-ids </dt>
<dd>
<p>为提交和 blob 的输出添加一个额外的指令：<code>original-oid &lt;SHA1SUM&gt;</code>。 虽然这类指令可能会被 git-fast-import 等导入程序忽略，但对于中间过滤器（例如重写引用较早提交的提交信息，或按 id 剔除 blobs）来说可能很有用。</p>
</dd>
<dt class="hdlist1" id="git-fast-export---reencodeyesnoabort"> <a class="anchor" href="#git-fast-export---reencodeyesnoabort"></a>--reencode=(yes|no|abort) </dt>
<dd>
<p>指定如何处理提交对象中的 <code>encoding</code> （编码）头。 如果要求 <em>abort</em>（中止，默认值），程序将在遇到此类提交对象时结束。 如果使用 <em>yes</em>，提交信息将被重新编码为 UTF-8。 如果选择 <em>no</em>，则将保留原始编码。</p>
</dd>
<dt class="hdlist1" id="git-fast-export---refspec"> <a class="anchor" href="#git-fast-export---refspec"></a>--refspec </dt>
<dd>
<p>对导出的每个引用应用指定的引用规范。可以指定多个。</p>
</dd>
<dt class="hdlist1" id="git-fast-export-ltgit-rev-list-argsgt82308203"> <a class="anchor" href="#git-fast-export-ltgit-rev-list-argsgt82308203"></a>[&lt;git-rev-list-args&gt;&#8230;&#8203;] </dt>
<dd>
<p><em>git rev-parse</em> 和 <em>git rev-list</em> 可接受的参数列表，用于指定要导出的特定对象和引用。 例如，<code>master~10..master</code> 会导出当前的主引用，以及其第 10 次祖先提交后添加的所有对象，以及（除非指定了 --reference-excluded-parents 选项）master~9 和 master~10 的所有公共文件。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_实例"><a class="anchor" href="#_实例"></a>实例</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>$ git fast-export --all | (cd /empty/repository &amp;&amp; git fast-import)</pre>
</div>
</div>
<div class="paragraph">
<p>这将导出整个仓库，并导入现有的空仓库。 除了对非 UTF-8 版本的提交进行重新编码外，这将是一个一对一的镜像。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git fast-export master~5..master |
	sed "s|refs/heads/master|refs/heads/other|" |
	git fast-import</pre>
</div>
</div>
<div class="paragraph">
<p>这样就从 <em>master~5..master</em> 中创建了一个名为 <em>other</em> 的新分支（也就是说，如果 <em>master</em> 的历史是线性的，那么它将采用最近的 5 次提交）。</p>
</div>
<div class="paragraph">
<p>请注意，这是在假设该修订范围引用的 blob 和提交信息中没有包含 <em>refs/heads/master</em> 字符串。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_匿名化"><a class="anchor" href="#_匿名化"></a>匿名化</h2>
<div class="sectionbody">
<div class="paragraph">
<p>如果给定了 <code>--anonymize</code> 选项，git 会尝试移除仓库中的所有身份信息，但仍会保留足够的原始树和历史模式来重现某些 bug。这样做的目的是，在私有仓库中发现的 git bug 会在匿名仓库中继续存在，而后者可以与 git 开发人员共享，以帮助解决 bug。</p>
</div>
<div class="paragraph">
<p>使用该选项后，git 会用匿名数据替换输出中的所有引用名、路径、blob 内容、提交和标记信息、姓名和电子邮件地址。 同一字符串的两个实例将被等效替换（例如，两个提交的作者相同，输出中的匿名作者也相同，但与原始作者字符串并无相似之处）。提交、分支和标签之间的关系以及提交时间戳都会保留（但提交信息和引用名与原始信息没有任何相似之处）。保留树的相对构成（例如，如果根树有 10 个文件和 3 个树，输出也会保留），但文件名和文件内容会被替换。</p>
</div>
<div class="paragraph">
<p>如果您认为自己发现了一个 git bug，可以从导出整个仓库的匿名流开始：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git fast-export --anonymize --all &gt;anon-stream</pre>
</div>
</div>
<div class="paragraph">
<p>然后确认错误是否持续存在于根据该数据流创建的仓库中（许多错误不会持续存在，因为它们确实取决于仓库的确切内容）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git init anon-repo
$ cd anon-repo
$ git fast-import &lt;../anon-stream
$ ... test your bug ...</pre>
</div>
</div>
<div class="paragraph">
<p>如果匿名仓库显示了错误，则值得在提交常规错误报告的同时分享 <code>anon-stream</code>（匿名流）。请注意，匿名流的压缩效果非常好，因此建议将其压缩为 gzip 格式。如果您想检查流是否包含任何私人数据，可以在发送前直接阅读。您还可以尝试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ perl -pe 's/\d+/X/g' &lt;anon-stream | sort -u | less</pre>
</div>
</div>
<div class="paragraph">
<p>显示所有的唯一行（数字转换为 "X"，将 "用户 0"、"用户 1" 等折叠为 "用户 X"）。这样产生的输出要小得多，而且通常很容易快速确认数据流中没有私人数据。</p>
</div>
<div class="paragraph">
<p>重现某些错误可能需要引用特定的提交或路径，这在引用名和路径被匿名化后变得很有难度。您可以要求将特定标记保持原样或映射到一个新值。例如，如果有一个 bug 可以用 <code>git rev-list sensitive -- secret.c</code> 来重现，可以运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git fast-export --anonymize --all \
      --anonymize-map=sensitive:foo \
      --anonymize-map=secret.c:bar.c \
      &gt;stream</pre>
</div>
</div>
<div class="paragraph">
<p>导入流之后，就可以在匿名仓库中运行 <code>git rev-list foo -- bar.c</code>。</p>
</div>
<div class="paragraph">
<p>请注意，路径和引用名会在斜线边界被分割成标记。 上面的命令会将 <code>subdir/secret.c</code> 匿名化为类似 <code>path123/bar.c</code> 的内容；然后你可以在匿名化的仓库中搜索 <code>bar.c</code> 以确定最终路径名。</p>
</div>
<div class="paragraph">
<p>为了简化最终路径名的引用，可以对每个路径组件进行映射；因此，如果同时将 <code>subdir</code> 匿名化为 <code>publicdir</code>，那么最终路径名将是 <code>publicdir/bar.c</code>。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_局限"><a class="anchor" href="#_局限"></a>局限</h2>
<div class="sectionbody">
<div class="paragraph">
<p>由于 <em>git fast-import</em> 无法对树进行标记，因此您将无法完全导出 linux.git 仓库，因为其中包含了一个引用树而非提交的标记。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_参见"><a class="anchor" href="#_参见"></a>参见</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href='{{< relurl "docs/git-fast-import/zh_HANS-CN" >}}'>git-fast-import[1]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>属于 <a href='{{< relurl "docs/git/zh_HANS-CN" >}}'>git[1]</a> 文档</p>
</div>
</div>
</div>