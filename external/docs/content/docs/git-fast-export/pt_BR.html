---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-fast-export Documentation
docname: git-fast-export
lang: pt_BR
aliases:
- "/docs/git-fast-export/pt_BR/index.html"
---
<div class="sect1">
<h2 id="_nome"><a class="anchor" href="#_nome"></a>NOME</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-fast-export - Exportador de dados do Git</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resumo"><a class="anchor" href="#_resumo"></a>RESUMO</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git fast-export</em> [&lt;opções&gt;] | <em>git fast-import</em></pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_descrição"><a class="anchor" href="#_descrição"></a>DESCRIÇÃO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este programa despeja as revisões informadas num formato adequado para ser canalizado para o <em>git fast-import</em>.</p>
</div>
<div class="paragraph">
<p>Você pode usá-lo como uma reposição legível do pacote (consulte <a href='{{< relurl "docs/git-bundle/pt_BR" >}}'>git-bundle[1]</a>) ou como um formato que pode ser editado antes que possa ser enviado ao <em>git fast-import</em> para fazer a reescrita no histórico (uma habilidade dependente das ferramentas como <em>git filter-repo</em>).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_opções"><a class="anchor" href="#_opções"></a>OPÇÕES</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-fast-export---progressltngt"> <a class="anchor" href="#git-fast-export---progressltngt"></a>--progress=&lt;n&gt; </dt>
<dd>
<p>Insira instruções de <em>progresso</em> em todos os objetos <code>&lt;n&gt;</code> a serem exibidos por <em>git fast-import</em> durante a importação.</p>
</dd>
<dt class="hdlist1" id="git-fast-export---signed-tagsverbatimwarnwarn-stripstripabort"> <a class="anchor" href="#git-fast-export---signed-tagsverbatimwarnwarn-stripstripabort"></a>--signed-tags=(verbatim|warn|warn-strip|strip|abort) </dt>
<dd>
<p>Especifique como lidar com as etiquetas assinadas. Como qualquer transformação após a exportação pode alterar os nomes das etiquetas (o que também pode acontecer ao excluir revisões), as assinaturas não corresponderão.</p>
<div class="paragraph">
<p>Ao pedir para "abortar" <em>abort</em> (que é a predefinição), esse programa será encerrado ao encontrar uma etiqueta assinada. Com <em>strip</em>, as etiqueta não serão assinadas silenciosamente; com <em>warn-strip</em>, elas não serão assinadas, mas um aviso será exibido; com <em>verbatim</em>, elas serão exportadas silenciosamente; e com <em>warn</em>, elas serão exportadas, mas você verá um aviso.</p>
</div>
</dd>
<dt class="hdlist1" id="git-fast-export---tag-of-filtered-objectabortdroprewrite"> <a class="anchor" href="#git-fast-export---tag-of-filtered-objectabortdroprewrite"></a>--tag-of-filtered-object=(abort|drop|rewrite) </dt>
<dd>
<p>Especifique como lidar com as etiquetas cujo objeto marcado é filtrado. Como as revisões e os arquivos que serão exportados, eles podem ser limitados por caminho, os objetos marcados podem ser completamente filtrados.</p>
<div class="paragraph">
<p>When asking to <em>abort</em> (which is the default), this program will die when encountering such a tag. With <em>drop</em> it will omit such tags from the output. With <em>rewrite</em>, if the tagged object is a commit, it will rewrite the tag to tag an ancestor commit (via parent rewriting; see <a href='{{< relurl "docs/git-rev-list/pt_BR" >}}'>git-rev-list[1]</a>).</p>
</div>
</dd>
<dt class="hdlist1" id="git-fast-export--M"> <a class="anchor" href="#git-fast-export--M"></a>-M </dt>
<dt class="hdlist1" id="git-fast-export--C"> <a class="anchor" href="#git-fast-export--C"></a>-C </dt>
<dd>
<p>Detecta a ação de copiar e mover como descrito na página do manual <a href='{{< relurl "docs/git-diff/pt_BR" >}}'>git-diff[1]</a>, utilize-o para gerar comandos de copiar e renomear na saída.</p>
<div class="paragraph">
<p>Observe que as versões anteriores deste comando não reclamavam e produziam resultados incorretos caso essas opções fossem utilizadas.</p>
</div>
</dd>
<dt class="hdlist1" id="git-fast-export---export-marksltarquivogt"> <a class="anchor" href="#git-fast-export---export-marksltarquivogt"></a>--export-marks=&lt;arquivo&gt; </dt>
<dd>
<p>Despeja a tabela das marcas internas em <code>&lt;arquivo&gt;</code> quando for concluído. As marcas são gravadas uma por linha como <code>:markid SHA-1</code>. Apenas as marcações das revisões são despejadas; as marcações das bolhas são ignoradas. Os "backends" podem usar este arquivo para validar as importações depois que elas forem concluídas ou para salvar a tabela das marcações nas execuções incrementais. Como <code>&lt;arquivo&gt;</code> só é aberto e truncado na conclusão, o mesmo caminho também pode ser usado com segurança com a opção <code>--import-marks</code>. O arquivo não será gravado se nenhum novo objeto tiver sido marcado/exportado.</p>
</dd>
<dt class="hdlist1" id="git-fast-export---import-marksltarquivogt"> <a class="anchor" href="#git-fast-export---import-marksltarquivogt"></a>--import-marks=&lt;arquivo&gt; </dt>
<dd>
<p>Antes de processar qualquer entrada, carregue as marcas especificadas em &lt;arquivo&gt;. O arquivo de entrada deve existir, deve ser legível e deve usar o mesmo formato produzido pela opção <code>--export-marks</code>.</p>
</dd>
<dt class="hdlist1" id="git-fast-export---mark-tags"> <a class="anchor" href="#git-fast-export---mark-tags"></a>--mark-tags </dt>
<dd>
<p>Além de rotular bolhas e os commits com marcações dos IDs, também rotula tags. Isso é útil em conjunto com a opção <code>--export-marks</code> e <code>--import-marks</code>, também é útil (e necessário) para a exportação de etiquetas agrupadas. Isso não prejudica outros casos e seria a predefinição, mas muitos front-ends com importação rápida não estão preparados para aceitar as etiquetas com marcação de identificação.</p>
<div class="paragraph">
<p>Quaisquer commits (ou etiquetas) que já tenham sido marcados não serão exportados novamente. Se o "backend" usar um arquivo <code>--import-marks</code> semelhante, isso permitirá a exportação bidirecional incremental do repositório, mantendo as marcações iguais em todas as execuções.</p>
</div>
</dd>
<dt class="hdlist1" id="git-fast-export---fake-missing-tagger"> <a class="anchor" href="#git-fast-export---fake-missing-tagger"></a>--fake-missing-tagger </dt>
<dd>
<p>Alguns repositórios antigos têm etiquetas sem um rotulador. O protocolo de importação rápida não permitia e era bastante rigoroso com relação a isso. Portanto, falsifique um rotulador visando importar mais rapidamente o resultado.</p>
</dd>
<dt class="hdlist1" id="git-fast-export---use-done-feature"> <a class="anchor" href="#git-fast-export---use-done-feature"></a>--use-done-feature </dt>
<dd>
<p>Inicie o fluxo com uma sub-rotina <em>feature done</em> e finalize-o com um comando <em>done</em>.</p>
</dd>
<dt class="hdlist1" id="git-fast-export---no-data"> <a class="anchor" href="#git-fast-export---no-data"></a>--no-data </dt>
<dd>
<p>Ignore a geração de objetos bolha, em vez disso, faça referência a bolhas através de seu hash SHA-1 original. Isso é útil ao reescrever a estrutura dos diretórios ou do histórico de um repositório sem tocar no conteúdo individual dos arquivos. Observe que o fluxo resultante só pode ser usado por um repositório que já contenha os objetos necessários.</p>
</dd>
<dt class="hdlist1" id="git-fast-export---full-tree"> <a class="anchor" href="#git-fast-export---full-tree"></a>--full-tree </dt>
<dd>
<p>Essa opção fará com que a exportação rápida emita uma diretiva "deleteall" (apague todos) para cada commit seguida por uma lista completa de todos os arquivos no commit (em vez de apenas listar os arquivos diferentes do primeiro commit).</p>
</dd>
<dt class="hdlist1" id="git-fast-export---anonymize"> <a class="anchor" href="#git-fast-export---anonymize"></a>--anonymize </dt>
<dd>
<p>Torne anônimo o conteúdo do repositório e, ao mesmo tempo, manter o formato armazenado do histórico e da árvore. Consulte abaixo a sessão <code>ANONIMIZANDO</code>.</p>
</dd>
<dt class="hdlist1" id="git-fast-export---anonymize-maplta-partir-degtltparagt"> <a class="anchor" href="#git-fast-export---anonymize-maplta-partir-degtltparagt"></a>--anonymize-map=&lt;a-partir-de&gt;[:&lt;para&gt;] </dt>
<dd>
<p>Converta o token <code>&lt;a-partir-de&gt;</code> para <code>&lt;para&gt;</code> na saída anônima. Caso <code>&lt;para&gt;</code> seja omitido, mapeie <code>&lt;a-partir-de&gt;</code> para si mesmo (ou seja, não anonimamente). Consulte a seção 'ANONIMIZANDO` abaixo.</p>
</dd>
<dt class="hdlist1" id="git-fast-export---reference-excluded-parents"> <a class="anchor" href="#git-fast-export---reference-excluded-parents"></a>--reference-excluded-parents </dt>
<dd>
<p>É predefinido que a execução de um comando como o <code>git fast-export master~5..master</code> não incluirá o commit master~5 e fará com que master~4 não tenha mais master~5 como o commit principal (embora tanto o antigo master~4 quanto o novo master~4 tenham todos os mesmos arquivos). Use a opção <code>--reference-excluded-parents</code> para que o fluxo se refira aos commits no intervalo excluído do histórico através do seu sha1sum. Observe que o fluxo resultante só pode ser usado por um repositório que já contenha os commits principais necessários.</p>
</dd>
<dt class="hdlist1" id="git-fast-export---show-original-ids"> <a class="anchor" href="#git-fast-export---show-original-ids"></a>--show-original-ids </dt>
<dd>
<p>Adicione uma diretriz extra à saída para os commits e para as bolhas, <code>original-oid &lt;SHA1SUM&gt;</code>. Embora estas diretivas provavelmente sejam ignoradas durante a importação como o git-fast-import, elas podem ser úteis para filtragem intermediária (para reescrever as mensagens do commit que se referem aos commits mais antigos ou para remover as bolhas por id por exemplo).</p>
</dd>
<dt class="hdlist1" id="git-fast-export---reencodeyesnoabort"> <a class="anchor" href="#git-fast-export---reencodeyesnoabort"></a>--reencode=(yes|no|abort) </dt>
<dd>
<p>Especifique como lidar com o cabeçalho <code>encoding</code> nos objetos commit. Ao pedir para "abortar" <em>abort</em> (que é a predefinição), esse programa será encerrado ao encontrar tal objeto commit. Com <em>yes</em>, a mensagem de commit será recodificada para UTF-8. Com <em>no</em>, a codificação original será preservada.</p>
</dd>
<dt class="hdlist1" id="git-fast-export---refspec"> <a class="anchor" href="#git-fast-export---refspec"></a>--refspec </dt>
<dd>
<p>Aplique o <code>refspec</code> especificado a cada "ref" exportado. Vários deles podem ser especificados.</p>
</dd>
<dt class="hdlist1" id="git-fast-export-ltgit-rev-list-argsgt82308203"> <a class="anchor" href="#git-fast-export-ltgit-rev-list-argsgt82308203"></a>[&lt;git-rev-list-args&gt;&#8230;&#8203;] </dt>
<dd>
<p>Uma lista de argumentos, é aceitável com os comandos <em>git rev-parse</em> e <em>git rev-list</em> que especifica os objetos e referências específicas que srão exportadas. Por exemplo, <code>master~10..master</code> faz com que a referência mestre atual seja exportada juntamente com todos os objetos adicionados desde o décimo commit ancestral e (a menos que a opção <code>--reference-excluded-parents</code> seja usada) todos os arquivos comuns a master~9 e a master~10.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_exemplos"><a class="anchor" href="#_exemplos"></a>EXEMPLOS</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>$ git fast-export --all | (cd /empty/repository &amp;&amp; git fast-import)</pre>
</div>
</div>
<div class="paragraph">
<p>Isso exportará todo o repositório e o importará para um repositório vazio e já existente. Com exceção dos commits de recodificação que não estejam em UTF-8, isso seria um espelho de um para um.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git fast-export master~5..master |
	sed "s|refs/heads/master|refs/heads/other|" |
	git fast-import</pre>
</div>
</div>
<div class="paragraph">
<p>Isso cria um novo ramo chamado <em>other</em> de <em>master~5..master</em> (ou seja, caso <em>master</em> tenha um histórico linear, serão necessários então os últimos 5 commits).</p>
</div>
<div class="paragraph">
<p>Observe que isso pressupõe que nenhuma das bolhas e as mensagens dos commits referenciadas por esse intervalo de revisão, contenha a sequência <code>refs/heads/master</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_anonimizando"><a class="anchor" href="#_anonimizando"></a>ANONIMIZANDO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Caso a opção <code>--anonymize</code> seja utilizada, o git tentará remover todas as informações de identificação do repositório, mantendo ainda o suficiente da árvore original e dos padrões do histórico para reproduzir alguns bugs. O objetivo é que um bug do git encontrado num repositório privado persista no repositório anonimizado e este último pode ser compartilhado com os desenvolvedores do git para ajudar na resolução do problema.</p>
</div>
<div class="paragraph">
<p>Com esta opção, o git substituirá todas a referência dos nomes, dos caminhos, dos conteúdos bolha, das mensagens de commit e das etiquetas, dos nomes e dos endereços de e-mail na saída por dados anônimos. Duas instâncias da mesma "string" serão substituídas de maneira equivalente (dois commits com o mesmo autor vão gerar um mesmo autor anônimo, porém, não terão nenhuma semelhança com a "string" do autor original por exemplo). A relação entre os commits, os ramos e as etiquetas será mantida, bem como os registros de data e hora dos commits (porém as mensagens do commit e a referência dos nomes não têm nenhuma semelhança com os originais). A composição relativa da árvore será mantida (a saída também será mantida se você tiver uma árvore raiz com 10 arquivos e 3 árvores, por exemplo), mas seus nomes e o conteúdo dos arquivos serão substituídos.</p>
</div>
<div class="paragraph">
<p>Caso acredite que tenha encontrado um bug no git, pode começar exportando um fluxo anonimizado de todo o repositório:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git fast-export --anonymize --all &gt;anon-stream</pre>
</div>
</div>
<div class="paragraph">
<p>Em seguida, confirme se o bug persiste num repositório criado a partir desse fluxo (muitos erros não, pois eles realmente dependem do conteúdo exato do repositório):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git init anon-repo
$ cd anon-repo
$ git fast-import &lt;../anon-stream
$ ... teste o seu bug ...</pre>
</div>
</div>
<div class="paragraph">
<p>Caso o repositório anonimizado exiba o erro, pode valer a pena compartilhar o <code>anon-stream</code> junto com um relatório de erro tradicional. Observe que o fluxo anonimizado é muito bem compactado, portanto a sua compactação gzip é altamente recomendável. Caso deseje examinar o fluxo para ver se não contém dados particulares, é possível examiná-lo diretamente antes de enviar. Também é possível tentar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ perl -pe 's/\d+/X/g' &lt;anon-stream | sort -u | less</pre>
</div>
</div>
<div class="paragraph">
<p>que exiba todas as linhas exclusivas (com números convertidos em "X", para recolher o "Usuário 0", "Usuário 1" etc. em "Usuário X"). Isso produz uma saída muito menor e geralmente é de rápida confirmação já que não há dados privados no fluxo.</p>
</div>
<div class="paragraph">
<p>A reprodução de alguns bugs pode exigir a referência para alguns commits em particular ou caminhos específicos, o que se torna desafiador depois que os refnames e os caminhos sejam anonimizados. É possível solicitar que um token em específico seja deixado como está ou seja mapeado para um novo valor. Como por exemplo, caso tenha um bug que seja reproduzido com o comando <code>git rev-list sensitive -- secret.c</code>, é possível executar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git fast-export --anonymize --all \
      --anonymize-map=sensitive:foo \
      --anonymize-map=secret.c:bar.c \
      &gt;stream</pre>
</div>
</div>
<div class="paragraph">
<p>Depois de importar o fluxo, é possível então executar o commando <code>git rev-list foo -- bar.c</code> no repositório anonimizado.</p>
</div>
<div class="paragraph">
<p>Observe que os caminhos e a referência dos nomes são divididos em tokens nos limites das barras. O comando acima anonimizaria o arquivo <code>subdir/secret.c</code> com algo como <code>path123/bar.c</code>; você poderia então procurar pelo arquivo <code>bar.c</code> no repositório anonimizado para determinar o nome final do caminho.</p>
</div>
<div class="paragraph">
<p>Para tornar mais simples a referência ao pathname (nome do caminho), é possível mapear cada componente do caminho; então, caso também anonimize o <code>subdir</code> para <code>publicdir</code>, então o nome final do caminho seria <code>publicdir/bar.c</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_limitações"><a class="anchor" href="#_limitações"></a>LIMITAÇÕES</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Como <em>git fast-import</em> não pode marcar as árvores, você não poderá exportar o repositório linux.git completamente pois ele contém uma marca que faz referência a uma árvore em vez de um commit.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_veja_também"><a class="anchor" href="#_veja_também"></a>VEJA TAMBÉM</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href='{{< relurl "docs/git-fast-import/pt_BR" >}}'>git-fast-import[1]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Parte do conjunto <a href='{{< relurl "docs/git/pt_BR" >}}'>git[1]</a></p>
</div>
</div>
</div>