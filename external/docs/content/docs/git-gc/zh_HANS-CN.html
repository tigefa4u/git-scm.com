---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-gc Documentation
docname: git-gc
lang: zh_HANS-CN
aliases:
- "/docs/git-gc/zh_HANS-CN/index.html"
---
<div class="sect1">
<h2 id="_名称"><a class="anchor" href="#_名称"></a>名称</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-gc - 清理不必要的文件并优化本地仓库</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_概述"><a class="anchor" href="#_概述"></a>概述</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git gc</em> [--aggressive] [--auto] [--quiet] [--prune=&lt;日期&gt; | --no-prune] [--force] [--keep-largest-pack]</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_描述"><a class="anchor" href="#_描述"></a>描述</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在当前版本库中执行一些内务管理任务，比如压缩文件修订（以减少磁盘空间并提高性能），移除之前调用 <em>git add</em> 所创建的不可达对象，打包引用，修剪引用日志、rerere metadata 或过时的工作区。也可以更新辅助索引，如提交图。</p>
</div>
<div class="paragraph">
<p>当运行创建对象的普通上层命令操作时，它们会检查仓库在上次维护后是否有大幅增长，如果有，就自动运行 <code>git gc</code>。参见下面的 <code>gc.auto</code> 以了解如何禁用这一行为。</p>
</div>
<div class="paragraph">
<p>手动运行 <code>git gc</code> 应该只在向仓库添加对象而不定期运行这种上层命令时才需要，以进行一次性的仓库优化，或者例如清理次优的大规模导入。关于导入情况的更多细节，请参见 <a href='{{< relurl "docs/git-fast-import/zh_HANS-CN" >}}'>git-fast-import[1]</a> 中的 “包装文件优化” 部分。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_选项"><a class="anchor" href="#_选项"></a>选项</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-gc---aggressive"> <a class="anchor" href="#git-gc---aggressive"></a>--aggressive </dt>
<dd>
<p>通常，<em>git gc</em> 运行得非常快，同时提供良好的磁盘空间利用率和性能。 这个选项会使 <em>git gc</em> 更积极地优化仓库，代价是花费更多的时间。 这种优化的效果大多是持续性的。详情见下面的 "AGGRESSIVE" 部分。</p>
</dd>
<dt class="hdlist1" id="git-gc---auto"> <a class="anchor" href="#git-gc---auto"></a>--auto </dt>
<dd>
<p>有了这个选项，<em>git gc</em> 就会检查是否需要任何内务处理；如果不需要，它就会退出，不执行任何工作。</p>
<div class="paragraph">
<p>关于这个启发式的工作原理，请看下面 “配置” 部分的 <code>gc.auto</code> 选项。</p>
</div>
<div class="paragraph">
<p>一旦超过配置选项如 <code>gc.auto</code> 和 <code>gc.autoPackLimit</code> 的限制而触发内务管理，所有其他内务管理任务（如 reere、working trees、reflog&#8230;&#8203;）也将被执行。</p>
</div>
</dd>
<dt class="hdlist1" id="git-gc---no-cruft"> <a class="anchor" href="#git-gc---no-cruft"></a>--[no-]cruft </dt>
<dd>
<p>当无法到达的对象过期时，将它们单独打包到一个 cruft 包中，而不是将它们作为散装对象存储。<code>--cruft</code> 是默认开启的。</p>
</dd>
<dt class="hdlist1" id="git-gc---max-cruft-sizeltngt"> <a class="anchor" href="#git-gc---max-cruft-sizeltngt"></a>--max-cruft-size=&lt;n&gt; </dt>
<dd>
<p>在将无法访问的对象打包到 Cruft 包时，限制新 Cruft 包的大小最多为 <code>&lt;n&gt;</code> 字节。覆盖通过 <code>gc.maxCruftSize</code> 配置指定的任何值。参见 <a href='{{< relurl "docs/git-repack/zh_HANS-CN" >}}'>git-repack[1]</a> 的 `--max-cruft-size`选项了解更多。</p>
</dd>
<dt class="hdlist1" id="git-gc---pruneltgt"> <a class="anchor" href="#git-gc---pruneltgt"></a>--prune=&lt;日期&gt; </dt>
<dd>
<p>修剪超过日期的松散对象（默认是 2 周前，可由配置变量 <code>gc.pruneExpire</code> 覆盖）。 --prune=now 删减松散对象，无论其年龄大小，如果有其他进程同时向仓库写入，则会增加损坏的风险；见下面的 “注意事项”。--prune 默认是打开的。</p>
</dd>
<dt class="hdlist1" id="git-gc---no-prune"> <a class="anchor" href="#git-gc---no-prune"></a>--no-prune </dt>
<dd>
<p>不要修剪任何松散的对象。</p>
</dd>
<dt class="hdlist1" id="git-gc---quiet"> <a class="anchor" href="#git-gc---quiet"></a>--quiet </dt>
<dd>
<p>抑制所有进度报告。</p>
</dd>
<dt class="hdlist1" id="git-gc---force"> <a class="anchor" href="#git-gc---force"></a>--force </dt>
<dd>
<p>强制 <code>git gc</code> 运行，即使这个仓库可能有另一个 <code>git gc</code> 实例在运行。</p>
</dd>
<dt class="hdlist1" id="git-gc---keep-largest-pack"> <a class="anchor" href="#git-gc---keep-largest-pack"></a>--keep-largest-pack </dt>
<dd>
<p>除了最大的非破坏性包，任何标有 <code>.keep</code> 文件的包，以及任何破坏性的包，都会被合并为一个包。当使用这个选项时，<code>gc.bigPackThreshold</code> 被忽略。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_侵略的"><a class="anchor" href="#_侵略的"></a>侵略的</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当提供 <code>--aggressive</code> 选项时，<a href='{{< relurl "docs/git-repack/zh_HANS-CN" >}}'>git-repack[1]</a> 将被调用，并带有 <code>-f</code> 标志，这又将把 <code>--no-reuse-delta</code> 传递给 <a href='{{< relurl "docs/git-pack-objects/zh_HANS-CN" >}}'>git-pack-objects[1]</a>。这将丢弃任何现有的 delta 并重新计算，代价是在重新打包上花费更多的时间。</p>
</div>
<div class="paragraph">
<p>这方面的影响主要是持久性的，例如，当包和松散对象被凝聚成另一个包时，该包中现有的 delta 可能会被重新使用，但也有各种情况，我们可能会从一个较新的包中挑选一个次优 delta。</p>
</div>
<div class="paragraph">
<p>此外，提供 <code>--aggressive</code> 将调整传递给 <a href='{{< relurl "docs/git-repack/zh_HANS-CN" >}}'>git-repack[1]</a> 的 <code>--depth</code> 和 <code>--window</code> 选项。见下面的 <code>gc.aggressiveDepth</code> 和 <code>gc.aggressiveWindow</code> 设置。通过使用较大的窗口尺寸，我们更有可能找到更多的最佳 deltas。</p>
</div>
<div class="paragraph">
<p>在没有运行定制的性能基准的情况下，在一个给定的仓库上使用这个选项可能是不值得的。它需要更多的时间，而由此产生的空间/延迟优化可能值得也可能不值得。对于大多数用户和他们的仓库来说，完全不使用这个选项是正确的权衡。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_配置"><a class="anchor" href="#_配置"></a>配置</h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Missing <code>zh_HANS-CN/includes/cmd-config-section-all.txt</code></p>
</div>
<div class="paragraph">
<p>See original version for this content.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Missing <code>zh_HANS-CN/config/gc.txt</code></p>
</div>
<div class="paragraph">
<p>See original version for this content.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_注释"><a class="anchor" href="#_注释"></a>注释</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>git gc</em> 非常努力地不删除在你的仓库中任何地方被引用的对象。特别是，它不仅会保留当前分支和标记集所引用的对象，还会保留索引、远程跟踪分支、 引用日志（可能引用了后来被修改或回绕的分支中的提交）以及 refs/* 名称空间中的任何其他对象。请注意，附在一个对象上的注释（由 <em>git notes</em> 创建的那种）并不有助于保持该对象的活力。如果你期待一些对象被删除，而它们没有被删除，请检查所有这些位置，并决定在你的情况下，删除这些引用是否有意义。</p>
</div>
<div class="paragraph">
<p>另一方面，当 <em>git gc</em> 与另一个进程同时运行时，它有可能删除另一个进程正在使用但还没有创建引用的对象。这可能会导致其他进程失败，或者如果其他进程后来添加了对被删除对象的引用，则可能会破坏仓库。Git 有两个功能可以大大缓解这个问题：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>任何修改时间早于 <code>--prune</code> 日期的对象都会被保留，同时也会保留所有可以到达的对象。</p>
</li>
<li>
<p>大多数向数据库添加对象的操作都会更新对象的修改时间，如果它已经存在，那么 #1 就适用。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>然而，这些功能并不是一个完整的解决方案，所以同时运行命令的用户不得不忍受一些损坏的风险（在实践中似乎很低）。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_钩子"><a class="anchor" href="#_钩子"></a>钩子</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>git gc --auto</em> 命令将运行 <em>pre-auto-gc</em> 钩子。 更多信息请参见 <a href='{{< relurl "docs/githooks/zh_HANS-CN" >}}'>githooks[5]</a>。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_参见"><a class="anchor" href="#_参见"></a>参见</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href='{{< relurl "docs/git-prune/zh_HANS-CN" >}}'>git-prune[1]</a> <a href='{{< relurl "docs/git-reflog/zh_HANS-CN" >}}'>git-reflog[1]</a> <a href='{{< relurl "docs/git-repack/zh_HANS-CN" >}}'>git-repack[1]</a> <a href='{{< relurl "docs/git-rerere/zh_HANS-CN" >}}'>git-rerere[1]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>属于 <a href='{{< relurl "docs/git/zh_HANS-CN" >}}'>git[1]</a> 文档</p>
</div>
</div>
</div>