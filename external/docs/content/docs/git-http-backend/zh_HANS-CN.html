---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-http-backend Documentation
docname: git-http-backend
lang: zh_HANS-CN
aliases:
- "/docs/git-http-backend/zh_HANS-CN/index.html"
---
<div class="sect1">
<h2 id="_名称"><a class="anchor" href="#_名称"></a>名称</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-http-backend - Git 在 HTTP 上的服务器端实现</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_概述"><a class="anchor" href="#_概述"></a>概述</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git http-backend</em></pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_描述"><a class="anchor" href="#_描述"></a>描述</h2>
<div class="sectionbody">
<div class="paragraph">
<p>一个简单的 CGI 程序，为通过 http:// 和 https:// 协议访问仓库的 Git 客户提供内容。 该程序支持客户端使用智能 HTTP 协议和向后兼容的哑 HTTP 协议获取内容，以及客户端使用智能 HTTP 协议推送内容。如果配置得当，它还支持 Git 更高效的 "v2" 协议；见下文环境部分关于`GIT_PROTOCOL` 的讨论。</p>
</div>
<div class="paragraph">
<p>它验证该目录是否有魔术文件 "git-daemon-export-ok"，它将拒绝导出任何没有明确标记为这种方式导出的 Git 目录（除非设置了 <code>GIT_HTTP_EXPORT_ALL</code> 环境变量）。</p>
</div>
<div class="paragraph">
<p>默认情况下，只有 <code>upload-pack</code> 服务被启用，它为 <em>git fetch-pack</em> 和 <em>git ls-remote</em> 客户端服务，这些客户端被 <em>git fetch</em>、<em>git pull</em> 和 <em>git clone</em> 调用。 如果客户端经过认证，<code>receive-pack</code> 服务将被启用，它为 <em>git send-pack</em> 客户端服务，该服务由 <em>git push</em> 调用。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_服务"><a class="anchor" href="#_服务"></a>服务</h2>
<div class="sectionbody">
<div class="paragraph">
<p>这些服务可以使用每个库的配置文件来启用/禁用：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-http-backend-httpgetanyfile"> <a class="anchor" href="#git-http-backend-httpgetanyfile"></a>http.getanyfile </dt>
<dd>
<p>这是为 1.6.6 版本以上的 Git 客户端提供服务，它们无法使用上传包服务。 启用后，客户端能够读取仓库内的任何文件，包括不再能从分支到达但仍然存在的对象。 默认情况下是启用的，但仓库可以通过将此配置项设置为 <code>false</code> 来禁用它。</p>
</dd>
<dt class="hdlist1" id="git-http-backend-httpuploadpack"> <a class="anchor" href="#git-http-backend-httpuploadpack"></a>http.uploadpack </dt>
<dd>
<p>这为 <em>git fetch-pack</em> 和 <em>git ls-remote</em> 客户端服务。 它在默认情况下是启用的，但仓库可以通过将此配置项设置为`false`来禁用它。</p>
</dd>
<dt class="hdlist1" id="git-http-backend-httpreceivepack"> <a class="anchor" href="#git-http-backend-httpreceivepack"></a>http.receivepack </dt>
<dd>
<p>这为 <em>git send-pack</em> 客户提供服务，允许推送。 默认情况下，它对匿名用户是禁用的，而对通过网络服务器认证的用户是启用的。 可以通过设置该项为 <code>false</code> 来禁用它，或者通过设置为 <code>true</code> 来为所有用户（包括匿名用户）启用。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_地址翻译"><a class="anchor" href="#_地址翻译"></a>地址翻译</h2>
<div class="sectionbody">
<div class="paragraph">
<p>为了确定磁盘上仓库的位置，<em>git http-backend</em> 将环境变量 PATH_INFO 和 GIT_PROJECT_ROOT 连接起来，前者由 Web 服务器自动设置，后者则必须在 Web 服务器配置中手动设置。 如果 GIT_PROJECT_ROOT 没有设置，'git http-backend '会读取 PATH_TRANSLATED，这也是由网络服务器自动设置的。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_实例"><a class="anchor" href="#_实例"></a>实例</h2>
<div class="sectionbody">
<div class="paragraph">
<p>下面所有的例子都把 <code>http://$hostname/git/foo/bar.git</code> 映射到 <code>/var/www/git/foo/bar.git</code>。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-http-backend-Apache2x"> <a class="anchor" href="#git-http-backend-Apache2x"></a>Apache 2.x </dt>
<dd>
<p>确保 mod_cgi、mod_alias 和 mod_env被 启用，适当地设置 GIT_PROJECT_ROOT（或 DocumentRoot），并为 CGI 创建一个 ScriptAlias：</p>
<div class="listingblock">
<div class="content">
<pre>SetEnv GIT_PROJECT_ROOT /var/www/git
SetEnv GIT_HTTP_EXPORT_ALL
ScriptAlias /git/ /usr/libexec/git-core/git-http-backend/

# 这在使用 Apache 和现代版本的
# git-http-backend，因为网络服务器会把头信息在
# 环境中作为 HTTP_GIT_PROTOCOL 传递，而 http-backend 会将其复制到
# git_protocol。但你可能需要这一行（或类似的东西，如果你
# 使用不同的 webserver），或者如果你想支持旧的 Git
# 版本没有做这样的复制。
#
# 让 webserver 设置 GIT_PROTOCOL 是完全可以的，即使在
# 现代版本也是如此（并且优先于 HTTP_GIT_PROTOCOL，
# 这意味着它可以被用来覆盖客户端的请求）。
SetEnvIf Git-Protocol ".*"GIT_PROTOCOL=$0</pre>
</div>
</div>
<div class="paragraph">
<p>为了实现匿名的读取访问，但要有认证的写入访问，需要对最初的引用广播（我们通过查询字符串中的服务参数检测为推送）和接收包调用本身进行授权：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>RewriteCond %{QUERY_STRING} service=git-receive-pack [OR]
RewriteCond %{REQUEST_URI} /git-receive-pack$
RewriteRule ^/git/ - [E=AUTHREQUIRED:yes]

&lt;LocationMatch "^/git/"&gt;
	Order Deny,Allow
	Deny from env=AUTHREQUIRED

	AuthType Basic
	AuthName "Git Access"
	Require group committers
	Satisfy Any
	...
&lt;/LocationMatch&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>如果你没有 <code>mod_rewrite</code> 可用来匹配查询字符串，只需保护 <code>git-receive-pack</code> 本身即可，比如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;LocationMatch "^/git/.*/git-receive-pack$"&gt;
	AuthType Basic
	AuthName "Git Access"
	Require group committers
	...
&lt;/LocationMatch&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>在这种模式下，服务器将不会请求认证，直到客户端实际开始推送的对象协商阶段，而不是在最初的接触中。 由于这个原因，你必须在任何应该接受推送的存储库中启用 <code>http.receivepack</code> 配置选项。如果没有设置 <code>http.receivepack</code>，默认行为是拒绝任何未经认证的用户的推送；因此初始请求将向客户端报告 <code>403 Forbidden</code>，甚至不给认证机会。</p>
</div>
<div class="paragraph">
<p>要对读和写都要求认证，可以在仓库或它的一个父目录周围使用 Location 指令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;Location /git/private&gt;
	AuthType Basic
	AuthName "Private Git Access"
	Require group committers
	...
&lt;/Location&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>要在同一个网址上为 gitweb 提供服务，使用 ScriptAliasMatch，只对那些 <em>git http-backend</em> 可以处理的网址进行匹配，其余的转发给 gitweb：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ScriptAliasMatch \
	"(?x)^/git/(.*/(HEAD | \
			info/refs | \
			objects/(info/[^/]+ | \
				 [0-9a-f]{2}/[0-9a-f]{38} | \
				 pack/pack-[0-9a-f]{40}\.(pack|idx)) | \
			git-(upload|receive)-pack))$" \
	/usr/libexec/git-core/git-http-backend/$1

ScriptAlias /git/ /var/www/cgi-bin/gitweb.cgi/</pre>
</div>
</div>
<div class="paragraph">
<p>在一个仓库中为来自不同 <a href='{{< relurl "docs/gitnamespaces/zh_HANS-CN" >}}'>gitnamespaces[7]</a> 的多个仓库提供服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SetEnvIf Request_URI "^/git/([^/]*)" GIT_NAMESPACE=$1
ScriptAliasMatch ^/git/[^/]*(.*) /usr/libexec/git-core/git-http-backend/storage.git$1</pre>
</div>
</div>
</dd>
<dt class="hdlist1" id="git-http-backend-Apache2x-1"> <a class="anchor" href="#git-http-backend-Apache2x-1"></a>加速静态 Apache 2.x </dt>
<dd>
<p>与上述情况类似，但 Apache 可以用来返回存储在磁盘上的静态文件。 在许多系统上，这可能更有效率，因为 Apache 可以要求内核将文件内容从文件系统直接复制到网络上：</p>
<div class="listingblock">
<div class="content">
<pre>SetEnv GIT_PROJECT_ROOT /var/www/git

AliasMatch ^/git/(.*/objects/[0-9a-f]{2}/[0-9a-f]{38})$          /var/www/git/$1
AliasMatch ^/git/(.*/objects/pack/pack-[0-9a-f]{40}.(pack|idx))$ /var/www/git/$1
ScriptAlias /git/ /usr/libexec/git-core/git-http-backend/</pre>
</div>
</div>
<div class="paragraph">
<p>这可以与 gitweb 的配置相结合：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SetEnv GIT_PROJECT_ROOT /var/www/git

AliasMatch ^/git/(.*/objects/[0-9a-f]{2}/[0-9a-f]{38})$          /var/www/git/$1
AliasMatch ^/git/(.*/objects/pack/pack-[0-9a-f]{40}.(pack|idx))$ /var/www/git/$1
ScriptAliasMatch \
	"(?x)^/git/(.*/(HEAD | \
			info/refs | \
			objects/info/[^/]+ | \
			git-(upload|receive)-pack))$" \
	/usr/libexec/git-core/git-http-backend/$1
ScriptAlias /git/ /var/www/cgi-bin/gitweb.cgi/</pre>
</div>
</div>
</dd>
<dt class="hdlist1" id="git-http-backend-Lighttpd"> <a class="anchor" href="#git-http-backend-Lighttpd"></a>Lighttpd </dt>
<dd>
<p>确保 <code>mod_cgi</code>、<code>mod_alias</code>、<code>mod_auth</code>、<code>mod_setenv</code> 已经加载，然后适当设置 <code>GIT_PROJECT_ROOT</code>，并将所有请求重定向到 CGI：</p>
<div class="listingblock">
<div class="content">
<pre>alias.url += ( "/git" =&gt; "/usr/lib/git-core/git-http-backend" )
$HTTP["url"] =~ "^/git" {
	cgi.assign = ("" =&gt; "")
	setenv.add-environment = (
		"GIT_PROJECT_ROOT" =&gt; "/var/www/git",
		"GIT_HTTP_EXPORT_ALL" =&gt; ""
	)
}</pre>
</div>
</div>
<div class="paragraph">
<p>要启用匿名的读取访问，但要有认证的写入访问：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$HTTP["querystring"] =~ "service=git-receive-pack" {
	include "git-auth.conf"
}
$HTTP["url"] =~ "^/git/.*/git-receive-pack$" {
	include "git-auth.conf"
}</pre>
</div>
</div>
<div class="paragraph">
<p>其中 <code>git-auth.conf</code> 看起来像：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>auth.require = (
	"/" =&gt; (
		"method" =&gt; "basic",
		"realm" =&gt; "Git Access",
		"require" =&gt; "valid-user"
	       )
)
# ...并在此设置auth.backend</pre>
</div>
</div>
<div class="paragraph">
<p>要求对读和写都进行认证：</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$HTTP["url"] =~ "^/git/private" {
	include "git-auth.conf"
}</pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_环境变量"><a class="anchor" href="#_环境变量"></a>环境变量</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>git http-backend</em> 依赖于调用网络服务器设置的 <code>CGI</code> 环境变量，包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>PATH_INFO（如果设置了 GIT_PROJECT_ROOT，否则为 PATH_TRANSLATED）</p>
</li>
<li>
<p>REMOTE_USER</p>
</li>
<li>
<p>REMOTE_ADDR</p>
</li>
<li>
<p>CONTENT_TYPE</p>
</li>
<li>
<p>QUERY_STRING</p>
</li>
<li>
<p>REQUEST_METHOD</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>GIT_HTTP_EXPORT_ALL</code> 环境变量可以传递给 <em>git-http-backend</em>，以绕过在允许导出每个仓库前对 "git-daemon-export-ok" 文件的检查。</p>
</div>
<div class="paragraph">
<p><code>GIT_HTTP_MAX_REQUEST_BUFFER</code> 环境变量（或 <code>http.maxRequestBuffer</code> 配置变量）可以被设置为改变 git 在获取过程中所处理的最大引用协商请求；任何需要更大缓冲区的获取将不会成功。 这个值通常不需要改变，但如果你从一个有大量引用的仓库中获取，可能会有帮助。 这个值可以指定一个单位（例如，<code>100M</code> 表示 100 兆字节）。默认是 10 兆字节。</p>
</div>
<div class="paragraph">
<p>客户端可以使用 <code>Git-Protocol</code> HTTP 头来探测可选的协议能力（如 v2 协议）。为了支持这些，该标头的内容必须出现在 <code>GIT_PROTOCOL</code> 环境变量中。大多数网络服务器将通过 <code>HTTP_GIT_PROTOCOL</code> 变量把这个头传递给 CGI，<code>git-http-backend</code> 将自动把它复制到 <code>GIT_PROTOCOL</code>。然而，一些网络服务器可能对他们要传递的头信息更有选择性，在这种情况下，他们需要明确配置（见前面例子部分的 Apache 配置中对 <code>Git-Protocol</code> 的提及）。</p>
</div>
<div class="paragraph">
<p>后台进程将 GIT_COMMITTER_NAME 设置为 <em>$REMOTE_USER</em>，将 GIT_COMMITTER_EMAIL 设置为 <em>${REMOTE_USER}\@http.${REMOTE_ADDR}</em>，确保任何由 <em>git-receive-pack</em> 创建的引用日志包含执行推送的远程用户的一些识别信息。</p>
</div>
<div class="paragraph">
<p>所有 <code>CGI</code> 环境变量对 <em>git-receive-pack</em> 调用的每个钩子都是可用的。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>属于 <a href='{{< relurl "docs/git/zh_HANS-CN" >}}'>git[1]</a> 文档</p>
</div>
</div>
</div>