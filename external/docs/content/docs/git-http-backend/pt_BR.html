---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-http-backend Documentation
docname: git-http-backend
lang: pt_BR
aliases:
- "/docs/git-http-backend/pt_BR/index.html"
---
<div class="sect1">
<h2 id="_nome"><a class="anchor" href="#_nome"></a>NOME</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-http-backend - Implementação do servidor do Git sobre HTTP</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resumo"><a class="anchor" href="#_resumo"></a>RESUMO</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git http-backend</em></pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_descrição"><a class="anchor" href="#_descrição"></a>DESCRIÇÃO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Um programa CGI simples para servir o conteúdo de um repositório Git para clientes Git que acessam o repositório pelos protocolos http:// e https://. O programa oferece suporte a clientes que buscam usando o protocolo HTTP inteligente e o protocolo HTTP burro compatível com versões anteriores, bem como a clientes que enviam usando o protocolo HTTP inteligente. Ele também suporta o protocolo "v2" mais eficiente do Git, se configurado corretamente; consulte a discussão sobre <code>GIT_PROTOCOL</code> na seção AMBIENTE abaixo.</p>
</div>
<div class="paragraph">
<p>Verifica se o diretório possui o arquivo mágico "git-daemon-export-ok" e se recusará a exportar qualquer diretório Git que não tenha sido explicitamente marcado para exportação (a menos que a variável de ambiente <code>GIT_HTTP_EXPORT_ALL</code> esteja definida) .</p>
</div>
<div class="paragraph">
<p>Por padrão, apenas o serviço <code>upload-pack</code> está ativado, que atende aos clientes <em>git fetch-pack</em> e <em>git ls-remote</em>, que são invocados a partir de <em>git fetch</em>, <em>git pull</em> e <em>git clone</em>. Se o cliente for autenticado, o serviço <code>receive-pack</code> será ativado e atenderá aos clientes do <em>git send-pack</em>, que é chamado a partir do <em>git push</em>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_serviços"><a class="anchor" href="#_serviços"></a>SERVIÇOS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Estes serviços podem ser ativados/desativados usando o arquivo de configuração por repositório:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-http-backend-httpgetanyfile"> <a class="anchor" href="#git-http-backend-httpgetanyfile"></a>http.getanyfile </dt>
<dd>
<p>Isso serve para clientes Git anteriores à versão 1.6.6 que não conseguem usar o serviço de pacote de upload. Quando ativado, os clientes podem ler qualquer arquivo no repositório, inclusive objetos que não podem mais ser acessados num ramo, mas que ainda estão presentes. É predefinido que ele seja ativado, porém, um repositório pode desativá-lo definindo esse valor de configuração como <code>false</code>.</p>
</dd>
<dt class="hdlist1" id="git-http-backend-httpuploadpack"> <a class="anchor" href="#git-http-backend-httpuploadpack"></a>http.uploadpack </dt>
<dd>
<p>Isso oferece aos clientes <em>git fetch-pack</em> e <em>git ls-remote</em>. É predefinido que ele seja ativado, porém, um repositório pode desativá-lo definindo esse valor de configuração como <code>false</code>.</p>
</dd>
<dt class="hdlist1" id="git-http-backend-httpreceivepack"> <a class="anchor" href="#git-http-backend-httpreceivepack"></a>http.receivepack </dt>
<dd>
<p>Isso serve para clientes <em>git send-pack</em>, permitindo o envio. Ele é desativado por padrão para usuários anônimos e ativado por padrão para usuários autenticados pelo servidor da web. Ele pode ser desativado definindo esse item como <code>false</code> ou ativado para todos os usuários, inclusive usuários anônimos, definindo-o como <code>true</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tradução_da_url"><a class="anchor" href="#_tradução_da_url"></a>TRADUÇÃO DA URL</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Para determinar o local do repositório no disco, o <em>git http-backend</em> concatena as variáveis de ambiente PATH_INFO, que é definida automaticamente pelo servidor web, e GIT_PROJECT_ROOT, que deve ser definida manualmente na configuração do servidor Web. Se GIT_PROJECT_ROOT não estiver definido, <em>git http-backend</em> lê o PATH_TRANSLATED, que também é definido automaticamente pelo servidor da web.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_exemplos"><a class="anchor" href="#_exemplos"></a>EXEMPLOS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Todos os exemplos a seguir mapeiam o <code>http://$hostname/git/foo/bar.git</code> para <code>/var/www/git/foo/bar.git</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-http-backend-Apache2x"> <a class="anchor" href="#git-http-backend-Apache2x"></a>Apache 2.x </dt>
<dd>
<p>Certifique-se que o <em>mod_cgi</em>, <em>mod_alias</em> e <em>mod_env</em> estejam ativos, defina o <code>GIT_PROJECT_ROOT</code> (ou <em>DocumentRoot</em>) adequadamente e crie um "ScriptAlias" para o CGI:</p>
<div class="listingblock">
<div class="content">
<pre>SetEnv GIT_PROJECT_ROOT /var/www/git
SetEnv GIT_HTTP_EXPORT_ALL
ScriptAlias /git/ /usr/libexec/git-core/git-http-backend/

# Isso não é estritamente necessário ao usar o apache e uma versão moderna do
# git-http-backend, como o servidor web vai passar através do cabeçalho no
# ambiente como HTTP_GIT_PROTOCOL e o http-backend vai copiar isso no
# GIT_PROTOCOL. Mas você pode precisar desta linha (ou algo semelhante caso
# esteja usando um servidor web diferente) ou caso queira que seja compatível com um
# git mais antigo que não fizeram essa cópia.
#
# Ter o servidor web configurado GIT_PROTOCOL é suficiente mesmo com
# versões mais modernas (que terá precedência sobre o HTTP_GIT_PROTOCOL,
# o que significa que pode ser usado para substituir o pedido do cliente).
SetEnvIf Git-Protocol ".*" GIT_PROTOCOL=$0</pre>
</div>
</div>
<div class="paragraph">
<p>Para habilitar o acesso de leitura anônima, porém com acesso de gravação autenticado, exija a autorização para o anúncio da "ref" inicial (que detectamos como um "push" por meio do parâmetro "service" na cadeia de consulta) e a própria chamada do pacote de recebimento:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>RewriteCond %{QUERY_STRING} service=git-receive-pack [OR]
RewriteCond %{REQUEST_URI} /git-receive-pack$
RewriteRule ^/git/ - [E=AUTHREQUIRED:yes]

&lt;LocationMatch "^/git/"&gt;
	Order Deny,Allow
	Deny from env=AUTHREQUIRED

	AuthType Basic
	AuthName "Git Access"
	Require group committers
	Satisfy Any
	...
&lt;/LocationMatch&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Caso não tenha o <code>mod_rewrite</code> disponível para coincidir com o texto sob consulta é suficiente apenas para proteger o próprio <code>git-receive-pack</code>, como:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;LocationMatch "^/git/.*/git-receive-pack$"&gt;
	AuthType Basic
	AuthName "Acesso Git"
	Require group committers
	...
&lt;/LocationMatch&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Nesse modo, o servidor não solicitará autenticação até que o cliente realmente inicie a fase de negociação de envio (push) do objeto, em vez de durante o contato inicial. Por esse motivo, você também deve ativar a opção de configuração <code>http.receivepack</code> em todos os repositórios que devem aceitar um push. O comportamento predefinido, se <code>http.receivepack</code> não estiver definido, é rejeitar qualquer envio por usuários não autenticados; a solicitação inicial, portanto, informará <code>403 Forbidden</code> ao cliente, sem sequer dar uma oportunidade de autenticação.</p>
</div>
<div class="paragraph">
<p>Para exigir a autenticação para ambas as leituras e gravações, utilize uma diretiva local ao redor do repositório ou um dos seus diretórios upstream:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;Location /git/private&gt;
	AuthType Basic
	AuthName "Acesso Git Privado"
	Require group committers
	...
&lt;/Location&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Para veicular o gitweb na mesma URL, utilize um <em>ScriptAliasMatch</em> apenas para ss URLs que o <em>git http-backend</em> pode manipular e encaminhe o restante para o gitweb:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ScriptAliasMatch \
	"(?x)^/git/(.*/(HEAD | \
			info/refs | \
			objects/(info/[^/]+ | \
				 [0-9a-f]{2}/[0-9a-f]{38} | \
				 pack/pack-[0-9a-f]{40}\.(pack|idx)) | \
			git-(upload|receive)-pack))$" \
	/usr/libexec/git-core/git-http-backend/$1

ScriptAlias /git/ /var/www/cgi-bin/gitweb.cgi/</pre>
</div>
</div>
<div class="paragraph">
<p>Para servir os vários repositórios vindos de diferentes <a href='{{< relurl "docs/gitnamespaces/pt_BR" >}}'>gitnamespaces[7]</a> num único repositório:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SetEnvIf Request_URI "^/git/([^/]*)" GIT_NAMESPACE=$1
ScriptAliasMatch ^/git/[^/]*(.*) /usr/libexec/git-core/git-http-backend/storage.git$1</pre>
</div>
</div>
</dd>
<dt class="hdlist1" id="git-http-backend-Apacheestticoacelerado2x"> <a class="anchor" href="#git-http-backend-Apacheestticoacelerado2x"></a>Apache estático acelerado 2.x </dt>
<dd>
<p>Semelhante ao anterior, mas o Apache pode ser usado para retornar arquivos estáticos armazenados no disco. Em muitos sistemas, isso pode ser mais eficiente, pois o Apache pode solicitar ao kernel que copie o conteúdo do arquivo do sistema de arquivos diretamente para a rede:</p>
<div class="listingblock">
<div class="content">
<pre>SetEnv GIT_PROJECT_ROOT /var/www/git

AliasMatch ^/git/(.*/objects/[0-9a-f]{2}/[0-9a-f]{38})$          /var/www/git/$1
AliasMatch ^/git/(.*/objects/pack/pack-[0-9a-f]{40}.(pack|idx))$ /var/www/git/$1
ScriptAlias /git/ /usr/libexec/git-core/git-http-backend/</pre>
</div>
</div>
<div class="paragraph">
<p>Pode ser combinado com a configuração do gitweb:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>SetEnv GIT_PROJECT_ROOT /var/www/git

AliasMatch ^/git/(.*/objects/[0-9a-f]{2}/[0-9a-f]{38})$          /var/www/git/$1
AliasMatch ^/git/(.*/objects/pack/pack-[0-9a-f]{40}.(pack|idx))$ /var/www/git/$1
ScriptAliasMatch \
	"(?x)^/git/(.*/(HEAD | \
			info/refs | \
			objects/info/[^/]+ | \
			git-(upload|receive)-pack))$" \
	/usr/libexec/git-core/git-http-backend/$1
ScriptAlias /git/ /var/www/cgi-bin/gitweb.cgi/</pre>
</div>
</div>
</dd>
<dt class="hdlist1" id="git-http-backend-Lighttpd"> <a class="anchor" href="#git-http-backend-Lighttpd"></a>Lighttpd </dt>
<dd>
<p>Certifique-se de que <code>mod_cgi</code>, <code>mod_alias</code>, <code>mod_auth</code>, <code>mod_setenv</code> estejam carregados, então defina a variável <code>GIT_PROJECT_ROOT</code> adequadamente e redirecione todas as solicitações para o CGI:</p>
<div class="listingblock">
<div class="content">
<pre>alias.url += ( "/git" =&gt; "/usr/lib/git-core/git-http-backend" )
$HTTP["url"] =~ "^/git" {
	cgi.assign = ("" =&gt; "")
	setenv.add-environment = (
		"GIT_PROJECT_ROOT" =&gt; "/var/www/git",
		"GIT_HTTP_EXPORT_ALL" =&gt; ""
	)
}</pre>
</div>
</div>
<div class="paragraph">
<p>Para ativar o acesso de leitura anônima porém o acesso de gravação autenticado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$HTTP["querystring"] =~ "service=git-receive-pack" {
	include "git-auth.conf"
}
$HTTP["url"] =~ "^/git/.*/git-receive-pack$" {
	include "git-auth.conf"
}</pre>
</div>
</div>
<div class="paragraph">
<p>onde o <code>git-auth.conf</code> se parece com:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>auth.require = (
	"/" =&gt; (
		"method" =&gt; "basic",
		"realm" =&gt; "Acesso Git",
		"require" =&gt; "valid-user"
	       )
)
# ...and set up auth.backend here</pre>
</div>
</div>
<div class="paragraph">
<p>Para exigir a autenticação tanto para leituras quanto para gravações:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$HTTP["url"] =~ "^/git/private" {
	include "git-auth.conf"
}</pre>
</div>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_variáveis_do_ambiente"><a class="anchor" href="#_variáveis_do_ambiente"></a>VARIÁVEIS DO AMBIENTE</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O <em>git http-backend</em> conta com as variáveis do ambiente <code>CGI</code> definidas pelo servidor da Web que está sendo invocado, incluindo:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>PATH_INFO</code> (caso <code>GIT_PROJECT_ROOT</code> seja definido, caso contrário utilize <code>PATH_TRANSLATED</code>)</p>
</li>
<li>
<p>REMOTE_USER</p>
</li>
<li>
<p>REMOTE_ADDR</p>
</li>
<li>
<p>CONTENT_TYPE</p>
</li>
<li>
<p>QUERY_STRING</p>
</li>
<li>
<p>REQUEST_METHOD</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A variável de ambiente <code>GIT_HTTP_EXPORT_ALL</code> pode ser passada para o comando <em>git-http-backend</em> para ignorar a verificação do arquivo "git-daemon-export-ok" em cada repositório antes de permitir a exportação desse repositório.</p>
</div>
<div class="paragraph">
<p>A variável de ambiente <code>GIT_HTTP_MAX_REQUEST_BUFFER</code> (ou a opção de configuração <code>http.maxRequestBuffer</code>) pode ser definida para alterar a maior solicitação de negociação de referência que o git tratará durante uma busca; qualquer busca que exija um buffer maior não será bem-sucedida. Normalmente, esse valor não precisa ser alterado, mas pode ser útil se você estiver fazendo a busca num repositório com um número extremamente grande de refs. O valor pode ser especificado com uma unidade (<code>100M</code> para 100 megabytes por exemplo). A predefinição é 10 megabytes.</p>
</div>
<div class="paragraph">
<p>Os clientes podem sondar por capacidades opcionais do protocolo (como o protocolo v2) utilizando o cabeçalho HTTP <code>Git-Protocol</code>. Para ser compatível com eles, o conteúdo desse cabeçalho deve aparecer na variável de ambiente <code>GIT_PROTOCOL</code>. A maioria dos servidores web passará esse cabeçalho para o CGI através da variável <code>HTTP_GIT_PROTOCOL</code> e o <code>git-http-backend</code> copiará automaticamente para a variável <code>GIT_PROTOCOL</code>. Entretanto, alguns servidores web podem ser mais seletivos sobre quais os cabeçalhos eles passarão, nesse caso, eles precisam ser configurados de forma explícita (veja a menção do <code>Git-Protocol</code> na configuração do Apache, a partir da seção EXEMPLOS mais recentes).</p>
</div>
<div class="paragraph">
<p>A estrutura define o <code>GIT_COMMITTER_NAME</code> como <em>$REMOTE_USER</em> e <code>GIT_COMMITTER_EMAIL</code> como <em>${REMOTE_USER}@http.${REMOTE_ADDR}</em>, garantindo que quaisquer reflogs que forem criados através do comando <em>git-receive-pack</em> contenham algumas informações de identificação do ramo remoto do usuário que executou o push.</p>
</div>
<div class="paragraph">
<p>Todas as variáveis do ambiente <code>CGI</code> estão disponíveis para cada um dos ganchos invocados pelo comando <em>git-receive-pack</em>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Parte do conjunto <a href='{{< relurl "docs/git/pt_BR" >}}'>git[1]</a></p>
</div>
</div>
</div>