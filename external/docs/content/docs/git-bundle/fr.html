---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-bundle Documentation
docname: git-bundle
lang: fr
aliases:
- "/docs/git-bundle/fr/index.html"
---
<div class="sect1">
<h2 id="_nom"><a class="anchor" href="#_nom"></a>NOM</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-bundle - Déplace les objets et les références par archive</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_synopsis"><a class="anchor" href="#_synopsis"></a>SYNOPSIS</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git bundle</em> create [-q | --quiet | --progress]
		    [--version=&lt;version&gt;] &lt;fichier&gt; &lt;arguments-git-rev-list&gt;
<em>git bundle</em> verify [-q | --quiet] &lt;fichier&gt;
<em>git bundle</em> list-heads &lt;fichier&gt; [&lt;nom-de-ref&gt;&#8230;&#8203;]
<em>git bundle</em> unbundle [--progress] &lt;fichier&gt; [&lt;nom-de-ref&gt;&#8230;&#8203;]</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_description"><a class="anchor" href="#_description"></a>DESCRIPTION</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Créer, décompresser et manipuler des fichiers "bundle". Les colis sont utilisés pour le transfert "hors ligne" d&#8217;objets Git sans qu&#8217;un "serveur" actif se trouve de l&#8217;autre côté de la connexion réseau.</p>
</div>
<div class="paragraph">
<p>Ils peuvent être utilisés pour créer des sauvegardes incrémentielles et complètes d&#8217;un dépôt, et pour relayer l&#8217;état des références d&#8217;un dépôt à un autre.</p>
</div>
<div class="paragraph">
<p>Les commandes Git qui récupèrent ou autrement "lisent" via des protocoles tels que <code>ssh://</code> et <code>https://</code> peuvent aussi opérer sur des fichiers cois. Il est possible de <a href='{{< relurl "docs/git-clone/fr" >}}'>git-clone[1]</a> un nouveau dépôt à partir d&#8217;un colis, d&#8217;utiliser <a href='{{< relurl "docs/git-fetch/fr" >}}'>git-fetch[1]</a> pour en récupérer, et de lister les références qu&#8217;il contient avec <a href='{{< relurl "docs/git-ls-remote/fr" >}}'>git-ls-remote[1]</a>. Il n&#8217;y a pas de support d'"écriture" correspondant, c&#8217;est-à-dire qu&#8217;un <em>git push</em> dans un colis n&#8217;est pas supporté.</p>
</div>
<div class="paragraph">
<p>Voir la section "EXEMPLES" ci-dessous pour plus des exemples d&#8217;utilisation des colis.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_formats_des_colis"><a class="anchor" href="#_formats_des_colis"></a>FORMATS DES COLIS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Les colis sont des fichiers <code>.pack</code> (voir <a href='{{< relurl "docs/git-pack-objects/fr" >}}'>git-pack-objects[1]</a>) avec un en-tête indiquant quelles références sont contenues dans le colis.</p>
</div>
<div class="paragraph">
<p>Comme le format d&#8217;archive packed lui-même, les colis peuvent être soit autonomes, soit créés à l&#8217;aide d&#8217;exclusions. Voir la section "PRÉREQUIS D&#8217;OBJET" ci-dessous.</p>
</div>
<div class="paragraph">
<p>Les colis créés en utilisant les exclusions de révision sont des "paquets minces" créés en utilisant l&#8217;option <code>--thin</code> de <a href='{{< relurl "docs/git-pack-objects/fr" >}}'>git-pack-objects[1]</a>, et dépaquetés en utilisant l&#8217;option <code>--fix-thin</code> de <a href='{{< relurl "docs/git-index-pack/fr" >}}'>git-index-pack[1]</a>.</p>
</div>
<div class="paragraph">
<p>Il n&#8217;y a pas d&#8217;option pour créer un "paquet épais" lors de l&#8217;utilisation des exclusions de révision, et les utilisateurs ne doivent pas s&#8217;inquiéter de la différence. En utilisant des "paquets minces", les paquets créés à l&#8217;aide d&#8217;exclusions sont plus petits en taille. Le fait qu&#8217;ils soient "minces" sous le capot est simplement noté ici comme une curiosité, et comme une référence à d&#8217;autres documents.</p>
</div>
<div class="paragraph">
<p>Voir <a href='{{< relurl "docs/gitformat-bundle/fr" >}}'>gitformat-bundle[5]</a> pour plus de détails et la discussion sur le "paquets fins" dans <a href='{{< relurl "docs/gitformat-pack/fr" >}}'>gitformat-pack[5]</a> pour plus de détails.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_options"><a class="anchor" href="#_options"></a>OPTIONS</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-bundle-createoptionsltfichiergtltgit-rev-list-argsgt"> <a class="anchor" href="#git-bundle-createoptionsltfichiergtltgit-rev-list-argsgt"></a>create [options] &lt;fichier&gt; &lt;git-rev-list-args&gt; </dt>
<dd>
<p>Utilisé pour créer un regroupement nommé <em>fichier</em>. Cela nécessite les arguments <em>&lt;arguments-git-rev-list&gt;</em> pour définir le contenu du regroupement. options' contient les options spécifiques à la sous-commande <em>git bundle create</em>. si <em>fichier</em> est <code>-</code>, le paquet envoyé sur la sortie standard.</p>
</dd>
<dt class="hdlist1" id="git-bundle-verifyltfichiergt"> <a class="anchor" href="#git-bundle-verifyltfichiergt"></a>verify &lt;fichier&gt; </dt>
<dd>
<p>Utilisé pour vérifier qu&#8217;un fichier regroupement est valide et s&#8217;appliquera proprement au dépôt actuel. Cela inclut des vérifications sur le format du regroupement lui-même ainsi que la vérification que les commits pré-requis existent et sont complètement liés dans le dépôt actuel. <em>git bundle</em> affiche une liste des commits manquants, s&#8217;il y en a. Enfin, des informations sur des capacités supplémentaires, telles que "object filter" sont imprimées. Voir "Capacités" dans <a href='{{< relurl "docs/gitformat-bundle/fr" >}}'>gitformat-bundle[5]</a> pour plus d&#8217;informations. Le code de sortie est zéro en cas de succès, mais sera non nul si le fichier colis est invalide. Si <em>fichier</em> est <code>-</code>, le paquet est lu sur l&#8217;entrée standard.</p>
</dd>
<dt class="hdlist1" id="git-bundle-list-headsltfichiergt"> <a class="anchor" href="#git-bundle-list-headsltfichiergt"></a>list-heads &lt;fichier&gt; </dt>
<dd>
<p>Liste les références définies dans le regroupement. Si elle est suivie d&#8217;une liste de références, seules les références correspondant à celles données sont imprimées. Si <em>fichier</em> est <code>-</code>, le paquet est lu sur l&#8217;entrée standard.</p>
</dd>
<dt class="hdlist1" id="git-bundle-unbundleltfichiergt"> <a class="anchor" href="#git-bundle-unbundleltfichiergt"></a>unbundle &lt;fichier&gt; </dt>
<dd>
<p>Passe les objets du groupement à <em>git index-pack</em> pour qu&#8217;ils soient stockés dans le dépôt, puis affiche les noms de toutes les références définies. Si une liste de références est donnée, seules les références correspondant à celles de la liste sont imprimées. Cette commande est vraiment de plomberie et n&#8217;est définie que pour être appelée par <em>git fetch</em>. si <em>fichier</em> est <code>-</code>, le paquet est lu depuis l&#8217;entrée standard.</p>
</dd>
<dt class="hdlist1" id="git-bundle-ltgit-rev-list-argsgt"> <a class="anchor" href="#git-bundle-ltgit-rev-list-argsgt"></a>&lt;git-rev-list-args&gt; </dt>
<dd>
<p>Une liste d&#8217;arguments, acceptable pour <em>git rev-parse</em> et <em>git rev-list</em> (et contenant une référence nommée, voir SPECIFICATION DES REFERENCES ci-dessous), qui spécifie les objets et références spécifiques à transporter. Par exemple, <code>master~10..master</code> fait en sorte que la référence master actuelle soit regroupée avec tous les objets ajoutés depuis le dixième commit de son ancêtre. Il n&#8217;y a pas de limite explicite au nombre de références et d&#8217;objets qui peuvent être regroupés.</p>
</dd>
<dt class="hdlist1" id="git-bundle-ltnom-de-rfgt82308203"> <a class="anchor" href="#git-bundle-ltnom-de-rfgt82308203"></a>[&lt;nom-de-réf&gt;&#8230;&#8203;] </dt>
<dd>
<p>Une liste de références utilisée pour limiter les références signalées comme disponibles. Ceci est principalement utile à <em>git fetch</em>, qui s&#8217;attend à ne recevoir que les références demandées et pas nécessairement tout le contenu du pack (dans ce cas, <em>git bundle</em> agit comme <em>git fetch-pack</em>).</p>
</dd>
<dt class="hdlist1" id="git-bundle---progress"> <a class="anchor" href="#git-bundle---progress"></a>--progress </dt>
<dd>
<p>L&#8217;état d&#8217;avancement est affiché sur la sortie d&#8217;erreur standard quand elle est attachée à un terminal, à moins que -q soit spécifié. Ce drapeau force l&#8217;état d&#8217;avancement même si le flux d&#8217;erreur standard n&#8217;est pas dirigé vers un terminal.</p>
</dd>
<dt class="hdlist1" id="git-bundle---versionltversiongt"> <a class="anchor" href="#git-bundle---versionltversiongt"></a>--version=&lt;version&gt; </dt>
<dd>
<p>Spécifier la version du regroupement. La version 2 est l&#8217;ancien format et ne peut être utilisée qu&#8217;avec les dépôts SHA-1 ; la version 3, plus récente, contient des capacités qui permettent des extensions. La valeur par défaut est le plus ancien format pris en charge, en fonction de l&#8217;algorithme de hachage utilisé.</p>
</dd>
<dt class="hdlist1" id="git-bundle--q"> <a class="anchor" href="#git-bundle--q"></a>-q </dt>
<dt class="hdlist1" id="git-bundle---quiet"> <a class="anchor" href="#git-bundle---quiet"></a>--quiet </dt>
<dd>
<p>Ce drapeau permet à la commande de ne pas signaler sa progression sur le flux d&#8217;erreur standard.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_spécification_des_références"><a class="anchor" href="#_spécification_des_références"></a>SPÉCIFICATION DES RÉFÉRENCES</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Les révisions doivent être accompagnées de noms de référence pour être regroupées dans un colis.</p>
</div>
<div class="paragraph">
<p>Plus d&#8217;une référence peut être empaquetée, et plus d&#8217;un ensemble d&#8217;objets prérequis peut être spécifié. Les objets empaquetés sont ceux qui ne sont pas contenus dans l&#8217;union des prérequis.</p>
</div>
<div class="paragraph">
<p>La commande <em>git bundle create</em> résout les noms de référence pour vous en utilisant les mêmes règles que <code>git rev-parse --abbrev-ref=loose</code>. Chaque pré-requis peut être spécifié explicitement (par exemple <code>^master~10</code>), ou implicitement (par exemple <code>master~10..master</code>, <code>--since=10.days.ago master</code>).</p>
</div>
<div class="paragraph">
<p>Tous ces cas simples sont OK (en supposant que nous avons des branches "master" et "next") :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bundle create master.bundle master
$ echo master | git bundle create master.bundle --stdin
$ git bundle create master-and-next.bundle master next
$ (echo master; echo next) | git bundle create master-and-next.bundle --stdin</pre>
</div>
</div>
<div class="paragraph">
<p>Et il en est de même pour ces exemples (et le même mais avec <code>--stdin</code> omis) :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bundle create recent-master.bundle master~10..master
$ git bundle create recent-updates.bundle master~10..master next~5..next</pre>
</div>
</div>
<div class="paragraph">
<p>Un nom de révision ou un intervalle dont le côté droit ne peut être résolu en une référence n&#8217;est pas accepté :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bundle create HEAD.bundle $(git rev-parse HEAD)
fatal: Refus de créer un colis vide.
$ git bundle create master-yesterday.bundle master~10..master~5
fatal: Refus de créer un colis vide.</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pré_requis_dobjet"><a class="anchor" href="#_pré_requis_dobjet"></a>PRÉ-REQUIS D&#8217;OBJET</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Lors de la création de colis, il est possible de créer un colis autonome qui peut être dégroupé dans un dépôt sans historique commun, ainsi que de fournir des révisions négatives pour exclure les objets nécessaires dans les parties antérieures de l&#8217;historique.</p>
</div>
<div class="paragraph">
<p>Fournir une révision telle que <code>nouveau</code> à <code>git bundle create</code> créera un fichier colis qui contient tous les objets accessibles depuis la révision <code>nouveau</code>. Ce colis peut être dégroupé dans n&#8217;importe quel dépôt pour obtenir un historique complet qui mène à la révision <code>nouveau</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bundle create complet.bundle nouveau</pre>
</div>
</div>
<div class="paragraph">
<p>Une plage de révision telle que <code>ancien..nouveau</code> produira un fichier colis qui nécessitera l&#8217;existence de la révision <code>ancien</code> (et de tout objet pouvant être atteint à partir de celle-ci) pour que le colis puisse être "dégroupé" :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bundle create complet.bundle ancien..nouveau</pre>
</div>
</div>
<div class="paragraph">
<p>Un colis autonome sans pré-requis peut être extrait n&#8217;importe où, même dans un dépôt vide, ou peut être cloné (c-à-d, <code>nouveau</code>, mais pas <code>ancien..nouveau</code>).</p>
</div>
<div class="paragraph">
<p>Il n&#8217;y a pas de problème à être prudent et faire en sorte que le fichier regroupement contienne des objets déjà présents dans la destination, car ceux-ci sont ignorés lors du déballage à la destination.</p>
</div>
<div class="paragraph">
<p>Si vous voulez imiter <code>git clone --mirror</code>, qui inclurait vos refs comme <code>refs/remotes/*</code>, utilisez <code>--all</code>. Si vous voulez fournir le même ensemble de références qu&#8217;un clone directement depuis le dépôt source, utilisez <code>--branches --tags</code> pour les <code>&lt;arguments-git-rev-list&gt;</code>.</p>
</div>
<div class="paragraph">
<p>La commande <em>git bundle verify</em> peut être utilisée pour vérifier si votre dépôt destinataire possède les commits pré-requis nécessaires pour un colis.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_exemples"><a class="anchor" href="#_exemples"></a>EXEMPLES</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Supposons que vous vouliez transférer l&#8217;historique d&#8217;un dépôt R1 sur la machine A vers un autre dépôt R2 sur la machine B. Pour une raison quelconque, la connexion directe entre A et B n&#8217;est pas autorisée, mais nous pouvons déplacer les données de A à B via un mécanisme quelconque (CD, email, etc.). Nous voulons mettre à jour R2 avec le développement fait sur la branche master dans R1.</p>
</div>
<div class="paragraph">
<p>Pour amorcer le processus, vous pouvez d&#8217;abord créer un paquet qui n&#8217;a pas de prérequis. Vous pouvez utiliser une étiquette pour vous rappeler jusqu&#8217;à quel commit le dernier traitement a été fait, afin de faciliter la mise à jour ultérieure de l&#8217;autre dépôt avec un paquet incrémental :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>machineA$ cd R1
machineA$ git bundle create fichier.paquet master
machineA$ git tag -f dernierpaquetR2 master</pre>
</div>
</div>
<div class="paragraph">
<p>Ensuite, vous transférez fichier.paquet sur la machine cible B. Comme ce paquet ne nécessite pas l&#8217;extraction d&#8217;un objet existant, vous pouvez créer un nouveau déôt sur la machine B en le clonant :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>machineB$ git clone -b master /home/moi/tmp/fichier.paquet R2</pre>
</div>
</div>
<div class="paragraph">
<p>Cela définira un répertoire distant appelé "origin" dans le dépôt résultant qui vous permettra de récupérer et de tirer du paquet. Le fichier $GIT_DIR/config dans R2 aura une entrée comme celle-ci :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[remote "origin"]
    url = /home/moi/tmp/fichier.paquet
    fetch = refs/heads/*:refs/remotes/origin/*</pre>
</div>
</div>
<div class="paragraph">
<p>Pour mettre à jour le dépôt mine.git résultant, vous pouvez récupérer ou tirer après avoir remplacé le paquet stocké dans /home/moi/tmp/fichier.paquet par des mises à jour incrémentales.</p>
</div>
<div class="paragraph">
<p>Après avoir travaillé un peu plus dans le dépôt d&#8217;origine, vous pouvez créer un paquet incrémental pour mettre à jour l&#8217;autre dépôt :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>machineA$ cd R1
machineA$ git bundle create fichier.paquet dernierpaquetR2..master
machineA$ git tag -f dernierpaquetR2 master</pre>
</div>
</div>
<div class="paragraph">
<p>Vous transférez ensuite le paquet sur l&#8217;autre machine pour remplacer /home/moi/tmp/fichier.paquet, et vous tirez à partir de celui-ci.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>machineB$ cd R2
machineB$ git pull</pre>
</div>
</div>
<div class="paragraph">
<p>Si vous savez jusqu&#8217;à quel commit le dépôt destinataire devrait avoir les objets nécessaires, vous pouvez utiliser cette connaissance pour spécifier le prérequis, en donnant un point de coupure pour limiter les révisions et les objets qui vont dans le paquet résultant. L&#8217;exemple précédent a utilisé l&#8217;étiquette dernierpaquetR2 dans ce but, mais vous pouvez utiliser toute autre option que vous donneriez à la commande <a href='{{< relurl "docs/git-log/fr" >}}'>git-log[1]</a>. Voici d&#8217;autres exemples :</p>
</div>
<div class="paragraph">
<p>Vous pouvez utiliser une étiquette qui est présente dans les deux dépôts :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bundle create monpaquet v1.0.0..master</pre>
</div>
</div>
<div class="paragraph">
<p>Vous pouvez utiliser un prérequis défini par le temps :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bundle create monpaquet --since=10.days master</pre>
</div>
</div>
<div class="paragraph">
<p>Vous pouvez utiliser le nombre de commits :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bundle create monpaquet -10 master</pre>
</div>
</div>
<div class="paragraph">
<p>Vous pouvez lancer <code>git-bundle verify</code> pour voir si vous pouvez extraire d&#8217;un paquet qui a été créé avec un prérequis :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bundle verify monpaquet</pre>
</div>
</div>
<div class="paragraph">
<p>Cela permettra d’énumérer ce que vous devez avoir pour extraire du paquet et fera une erreur si vous ne les avez pas.</p>
</div>
<div class="paragraph">
<p>Du point de vue du dépôt destinataire, un paquet est exactement comme un dépôt ordinaire dont il extrait ou tire des données. Vous pouvez, par exemple, aligner les références lors de l&#8217;extraction :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git fetch monpaquet master:localRef</pre>
</div>
</div>
<div class="paragraph">
<p>Vous pouvez également voir quelles références il offre :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git ls-remote monpaquet</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_formats_de_fichier"><a class="anchor" href="#_formats_de_fichier"></a>FORMATS DE FICHIER</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Voir <a href='{{< relurl "docs/gitformat-bundle/fr" >}}'>gitformat-bundle[5]</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Fait partie de la suite <a href='{{< relurl "docs/git/fr" >}}'>git[1]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_traduction"><a class="anchor" href="#_traduction"></a>TRADUCTION</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Cette  page de manuel a été traduite par Jean-Noël Avila &lt;jn.avila AT free DOT fr&gt; et les membres du projet git-manpages-l10n. Veuillez signaler toute erreur de traduction par un rapport de bogue sur le site <a href="https://github.com/jnavila/git-manpages-l10n" class="bare">https://github.com/jnavila/git-manpages-l10n</a> .</p>
</div>
</div>
</div>