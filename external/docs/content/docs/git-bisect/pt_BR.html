---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-bisect Documentation
docname: git-bisect
lang: pt_BR
aliases:
- "/docs/git-bisect/pt_BR/index.html"
---
<div class="sect1">
<h2 id="_nome"><a class="anchor" href="#_nome"></a>NOME</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-bisect - Utilize a pesquisa binária para localizar o commit que introduziu um bug</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resumo"><a class="anchor" href="#_resumo"></a>RESUMO</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git bisect</em> &lt;subcomando&gt; &lt;opções&gt;</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_descrição"><a class="anchor" href="#_descrição"></a>DESCRIÇÃO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>O comando assume vários subcomandos das diferentes opções dependendo do subcomando:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>git bisect start [--term-(bad|new)=&lt;term-new&gt; --term-(good|old)=&lt;term-old&gt;]
	  [--no-checkout] [--first-parent] [&lt;bad&gt; [&lt;good&gt;...]] [--] [&lt;pathspec&gt;...]
git bisect (bad|new|&lt;term-new&gt;) [&lt;rev&gt;]
git bisect (good|old|&lt;term-old&gt;) [&lt;rev&gt;...]
git bisect terms [--term-(good|old) | --term-(bad|new)]
git bisect skip [(&lt;rev&gt;|&lt;range&gt;)...]
git bisect reset [&lt;commit&gt;]
git bisect (visualize|view)
git bisect replay &lt;logfile&gt;
git bisect log
git bisect run &lt;cmd&gt; [&lt;arg&gt;...]
git bisect help</pre>
</div>
</div>
<div class="paragraph">
<p>Este comando utiliza um algoritmo de pesquisa binária para descobrir qual o commit no histórico do seu projeto introduziu um "bug" (problema). Você o utiliza informando primeiro a um commit "bad" (ruim) que é informado por conter o bug e um commit "good" (bom) informado antes da introdução do bug. Então o comando <code>git bisect</code> seleciona um commit entre estes dois pontos extremos e pergunta se o commit selecionado é "bom" ou "ruim". Continua estreitando o intervalo até encontrar o commit exato responsável pela introdução da alteração.</p>
</div>
<div class="paragraph">
<p>De fato, o comando <code>git bisect</code> pode ser utilizado para encontrar o commit que alterou <strong>qualquer</strong> propriedade do seu projeto; um commit que corrigiu um problema ou um commit que fez com que o desempenho de um benchmark melhorasse por exemplo. Para dar apoio a nesta utilização mais genérica, os termos "old" (antigo) e "new" (novo) podem ser utilizados no lugar de "good" (bom) e "bad" (ruim), ou escolha os seus próprios termos. Consulte a seção "Termos alternativos" abaixo para obter mais informações.</p>
</div>
<div class="sect2">
<h3 id="_comandos_bisect_básicos_start_começar_bad_ruim_good_bom"><a class="anchor" href="#_comandos_bisect_básicos_start_começar_bad_ruim_good_bom"></a>Comandos "bisect" básicos : <code>start</code> (começar), <code>bad</code> (ruim), <code>good</code> (bom)</h3>
<div class="paragraph">
<p>Como exemplo, suponha que você esteja tentando encontrar um commit que estragou um recurso que funcionava na versão <code>v2.6.13-rc2</code> do seu projeto. Você começa uma seção "besect" como demonstrado abaixo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect start
$ git bisect bad                 # A versão atual está ruim
$ git bisect good v2.6.13-rc2    # v2.6.13-rc2 é conhecido por estar bom</pre>
</div>
</div>
<div class="paragraph">
<p>Uma vez que você tenha utilizado pelo menos um commit ruim e um commit bom, o comando <code>git bisect</code> seleciona um commit no meio deste intervalo do histórico, faz a averiguação e produz algo por exemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Bisecting: 675 revisões deixadas para testar depois disso (aproximadamente 10 passos)</pre>
</div>
</div>
<div class="paragraph">
<p>Agora você deve compilar a versão com check-out e testá-la. Caso esta versão funcione corretamente, digite</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect good</pre>
</div>
</div>
<div class="paragraph">
<p>Se essa versão estiver quebrada, digite</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect bad</pre>
</div>
</div>
<div class="paragraph">
<p>Então o comando <code>git bisect</code> irá responder algo como</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Bisecting: 337 revisões deixadas para testar depois disso (aproximadamente 9 passos)</pre>
</div>
</div>
<div class="paragraph">
<p>Continue repetindo o processo: compile a árvore, teste-a e dependendo se ela for boa ou ruim, execute o comando <code>git bisect good</code> ou <code>git bisect bad</code> para solicitar o próximo commit que precisa ser testado.</p>
</div>
<div class="paragraph">
<p>Eventualmente, não haverá mais revisões a serem inspecionadas e o comando exibirá uma descrição do primeiro commit ruim. A referência <code>refs/bisect/bad</code> será deixada apontando para o commit.</p>
</div>
</div>
<div class="sect2">
<h3 id="_bisect_reset"><a class="anchor" href="#_bisect_reset"></a>Bisect reset</h3>
<div class="paragraph">
<p>Para limpar a condição geral bisseção e retornar ao <code>HEAD</code> original, execute o seguinte comando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect reset</pre>
</div>
</div>
<div class="paragraph">
<p>É predefinido que isso retornará a sua árvore para o commit que foi verificado antes do comando <code>git bisect start</code>. (Um novo <code>git bisect start</code> também fará isso, já que ele limpa o antigo estado de bisseção.)</p>
</div>
<div class="paragraph">
<p>Com um argumento opcional, você pode retornar para um commit diferente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect reset &lt;commit&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Por exemplo, <code>git bisect reset bisect/bad</code> irá verificar a primeira revisão ruim enquanto o <code>git bisect reset HEAD</code> deixará você no commit atual da bisseção evitando a alternância para outros commits.</p>
</div>
</div>
<div class="sect2">
<h3 id="_termos_alternativos"><a class="anchor" href="#_termos_alternativos"></a>Termos alternativos</h3>
<div class="paragraph">
<p>Às vezes, você não está procurando por um commit que introduziu um problema, mas sim um commit que causou uma alteração "antiga" entre alguma condição "nova". Você pode estar procurando por um commit que introduziu uma correção em específico por exemplo. Ou você pode estar procurando o primeiro commit onde os nomes dos arquivos do código-fonte foram finalmente convertidos para o padrão de nomes da sua empresa. Ou algo assim.</p>
</div>
<div class="paragraph">
<p>Nesses casos, pode ser muito confuso utilizar as opções "good" e "bad" para se referir a "condição antes da mudança" e "a condição após a mudança". Portanto, você pode utilizar os termos "old" e "new" respectivamente, no lugar de "good" e "bad". (Observe que não é possível misturar "good" e "bad" com "old" e "new" numa única sessão.)</p>
</div>
<div class="paragraph">
<p>Neste uso mais geral, você utiliza o comando <code>git bisect</code> com um commit "new" que tem alguma propriedade e um commit "old" que não tem nenhuma. Cada vez que o comando <code>git bisect</code> faz a verificação de um commit, você testa se o commit tem a propriedade. Em caso afirmativo, marque o commit como "new"; Caso contrário, marque-o como "old". Quando a bisseção tiver sido concluída, o comando <code>git bisect</code> informará qual o commit que introduziu a propriedade.</p>
</div>
<div class="paragraph">
<p>Para utilizar "old" e "new" em vez de "good" e "bad", você deve executar <code>git bisect start</code> sem nenhum commit e depois executar os seguintes comandos para adicionar os commits:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>git bisect old [&lt;rev&gt;]</pre>
</div>
</div>
<div class="paragraph">
<p>para indicar que um commit foi feito antes da alteração solicitada, ou</p>
</div>
<div class="listingblock">
<div class="content">
<pre>git bisect new [&lt;rev&gt;...]</pre>
</div>
</div>
<div class="paragraph">
<p>para indicar que foi depois.</p>
</div>
<div class="paragraph">
<p>Para receber um lembrete dos termos utilizados no momento, utilize</p>
</div>
<div class="listingblock">
<div class="content">
<pre>git bisect terms</pre>
</div>
</div>
<div class="paragraph">
<p>You can get just the old term with <code>git bisect terms --term-old</code> or <code>git bisect terms --term-good</code>; <code>git bisect terms --term-new</code> and <code>git bisect terms --term-bad</code> can be used to learn how to call the commits more recent than the sought change.</p>
</div>
<div class="paragraph">
<p>Caso queira utilizar os seus próprios termos em vez de "bad"/"good" ou "new"/"old", escolha qualquer nome que quiser (exceto os subcomandos bisect já existentes como <code>reset</code>, <code>start</code>, &#8230;&#8203;) iniciando uma bisseção utilizando</p>
</div>
<div class="listingblock">
<div class="content">
<pre>git bisect start --term-old &lt;termo-antigo&gt; --term-new &lt;novo-termo&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Caso esteja procurando por um commit que introduziu uma regressão ao desempenho, poderá utilizar por exemplo</p>
</div>
<div class="listingblock">
<div class="content">
<pre>git bisect start --term-old fast --term-new slow</pre>
</div>
</div>
<div class="paragraph">
<p>Ou caso esteja procurando o commit que corrigiu um problema, você pode usar</p>
</div>
<div class="listingblock">
<div class="content">
<pre>git bisect start --term-new fixed --term-old broken</pre>
</div>
</div>
<div class="paragraph">
<p>Então, utilize <code>git bisect &lt;termo-antigo&gt;</code> e <code>git bisect &lt;novo-termo&gt;</code> em vez de <code>git bisect good</code> e <code>git bisect bad</code> para marcar os commits.</p>
</div>
</div>
<div class="sect2">
<h3 id="_bisect_visualizeobserve"><a class="anchor" href="#_bisect_visualizeobserve"></a>Bisect visualize/observe</h3>
<div class="paragraph">
<p>Para ver os suspeitos restantes no <em>gitk</em>, utilize o seguinte comando durante o processo de bisseção (o <code>view</code> do subcomando pode ser utilizado como uma alternativa ao <code>visualize</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect visualize</pre>
</div>
</div>
<div class="paragraph">
<p>O Git detecta um ambiente gráfico através de várias variáveis de ambiente: <code>DISPLAY</code>, que é definido em ambientes X Window System nos sistemas Unix. <code>SESSIONNAME</code>, que é definido no Cygwin nas sessões de desktop interativas. <code>MSYSTEM</code>, que é definido no Msys2 e o Git para Windows. <code>SECURITYSESSIONID</code>, que pode ser definido no macOS nas sessões de ambiente de trabalho interativas.</p>
</div>
<div class="paragraph">
<p>O <em>git log</em> será usado caso nenhuma destas variável de ambiente sejam definidas. Tamém é possível usar as opções de linha de comando como <code>-p</code> e <code>--stat</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect visualize --stat</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bisect_log_e_bisect_replay"><a class="anchor" href="#_bisect_log_e_bisect_replay"></a>Bisect log e bisect replay</h3>
<div class="paragraph">
<p>Depois de ter marcado as revisões como boas ou ruins, emita o seguinte comando para exibir o que foi feito até agora:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect log</pre>
</div>
</div>
<div class="paragraph">
<p>Caso descubra que cometeu um erro ao especificar a condição de uma revisão, é possível salvar o arquivo gerado num arquivo, editá-lo para remover as entradas que estiverem incorretas e em seguida, utilizar os seguintes comandos para corrigir a condição de corrigido:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect reset
$ git bisect replay that-file</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_evitando_o_teste_de_um_commit"><a class="anchor" href="#_evitando_o_teste_de_um_commit"></a>Evitando o teste de um commit</h3>
<div class="paragraph">
<p>Se no meio de uma sessão bisect, você sabe que a revisão sugerida não é boa para testar (ela falha em construir e você sabe que a falha não tem nada a ver com o bug que você está procurando por exemplo), é possível selecionar manualmente um commit próximo e testá-lo em vez disso.</p>
</div>
<div class="paragraph">
<p>Por exemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect good/bad			# a rodada anterior estava boa ou ruim.
Bisecting: 337 revisions left to test after this (roughly 9 steps)
$ git bisect visualize			# oops, isso não foi interessante.
$ git reset --hard HEAD~3		# tente 3 revisões anteriores
					# ao que foi sugerido</pre>
</div>
</div>
<div class="paragraph">
<p>Em seguida, compile, teste a revisão escolhida e depois marque a revisão da maneira usual como boa ou ruim.</p>
</div>
</div>
<div class="sect2">
<h3 id="_bisect_skip"><a class="anchor" href="#_bisect_skip"></a>Bisect skip</h3>
<div class="paragraph">
<p>Em vez de escolher um commit próximo, é possível pedir ao Git para fazer isso por você, utilizando o comando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect skip                 # A versão atual não pode ser testada</pre>
</div>
</div>
<div class="paragraph">
<p>No entanto, caso você pule um commit adjacente ao que você está procurando, o Git não saberá exatamente qual destes commits foi o primeiro que estava ruim.</p>
</div>
<div class="paragraph">
<p>É possível Você também pular um intervalo de commits em vez de apenas um, utilizando a notação do intervalo. Por exemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect skip v2.5..v2.6</pre>
</div>
</div>
<div class="paragraph">
<p>Isso diz ao processo "bisect" que nenhum commit após a versão <code>v2.5</code> e até a versão <code>v2.6</code>, deve ser testada.</p>
</div>
<div class="paragraph">
<p>Observe que, caso você também queira pular o primeiro commit do intervalo, utilize o seguinte comando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect skip v2.5 v2.5..v2.6</pre>
</div>
</div>
<div class="paragraph">
<p>Informa ao processo "bisect" que os commits entre as versões <code>v2.5</code> e <code>v2.6</code> (inclusive) devem ser ignorados.</p>
</div>
</div>
<div class="sect2">
<h3 id="_reduza_a_bisseção_informando_mais_parâmetros_para_o_início_do_bisect"><a class="anchor" href="#_reduza_a_bisseção_informando_mais_parâmetros_para_o_início_do_bisect"></a>Reduza a bisseção informando mais parâmetros para o início do bisect</h3>
<div class="paragraph">
<p>É possível reduzir ainda mais a quantidade de tentativas caso saiba qual parte da árvore está envolvida no problema que está sendo rastreado, especificando parâmetros de pathpec ao usar o comando <code>bisect start</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect start -- arch/i386 include/asm-i386</pre>
</div>
</div>
<div class="paragraph">
<p>Caso saiba de antemão se há mais de um commit bom, é possível restringir o espaço do "bisect" ao informar todos os commits bons imediatamente após o commit com problema quando utilizar o comando <code>bisect start</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect start v2.6.20-rc6 v2.6.20-rc4 v2.6.20-rc1 --
                   # v2.6.20-rc6 é ruim
                   # v2.6.20-rc4 é v2.6.20-rc1 está bom</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bisect_run"><a class="anchor" href="#_bisect_run"></a>Bisect run</h3>
<div class="paragraph">
<p>Caso tenha um script que possa dizer se o código-fonte atual é bom ou ruim, é possível fazer o "bisect" utilize o seguinte comando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect run meu_script opções</pre>
</div>
</div>
<div class="paragraph">
<p>Observe que o script (<code>meu_script</code> no exemplo acima) deve encerrar com o código 0 caso o código-fonte atual seja bom/antigo e encerrar com um código entre 1 e 127 (inclusive), exceto 125, caso o código-fonte atual seja ruim/novo.</p>
</div>
<div class="paragraph">
<p>Qualquer outro código gerado interromperá o processo bisect. Deve ser observado que um programa que encerra com <code>exit (-1)</code> deixa um $? = 255, (consulte a página do manual exit(3)), pois o valor é cortado com <code>&amp; 0377</code>.</p>
</div>
<div class="paragraph">
<p>O código especial 125 da saída deve ser utilizado quando o código-fonte atual não puder ser testado. Caso o script encerre com este código, a revisão atual será ignorada (consulte o comando <code>git bisect skip</code> acima). O 125 foi selecionado como o maior valor a ser utilizado para esta finalidade, pois 126 e 127 são utilizandos pelos shells POSIX para sinalizar uma condição de erro específica (127 é utilizado para o comando não encontrado, 126 é para o comando que foi encontrado, mas não é executável - estes detalhes não são importantes, pois são erros normais do script, no que diz respeito ao comando <code>bisect run</code>).</p>
</div>
<div class="paragraph">
<p>Muitas vezes você pode achar que durante uma sessão bisect você queira ter alterações temporárias (<code>s/#define DEBUG 0/#define DEBUG 1/</code> ao cabeçalho de um arquivo, ou "a revisão que não tem este commit e precisa que esta correção seja aplicada como um quebra galho que seja irrelevante para esta bisseção por exemplo") aplicada à revisão que está sendo testada.</p>
</div>
<div class="paragraph">
<p>Para lidar com essa situação, depois que o comando interno <em>git bisect</em> encontrar a próxima revisão que será testada, o script poderá aplicar a correção antes da compilação, executar o teste real, e depois, decidir se a revisão (possivelmente com a correção necessária) passou no teste, em seguida, retorna a árvore para o estado original. Finalmente, o script deve encerrar com a condição real do teste permitindo que o loop do comando <code>git bisect run</code> determine o resultado final da sessão bisect.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_opções"><a class="anchor" href="#_opções"></a>OPÇÕES</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-bisect---no-checkout"> <a class="anchor" href="#git-bisect---no-checkout"></a>--no-checkout </dt>
<dd>
<div class="paragraph">
<p>Não faça o "checkout" da nova árvore de trabalho em cada iteração do processo de bissecção. Em vez disso, basta atualizar a referência chamada <code>BISECT_HEAD</code> para que ela aponte para o commit que deverá ser testado.</p>
</div>
<div class="paragraph">
<p>Essa opção pode ser útil quando o teste que você executaria em cada etapa não exigir uma árvore com check-out.</p>
</div>
<div class="paragraph">
<p>Caso o repositório seja simples, assume-se a opção <code>--no-checkout</code>.</p>
</div>
</dd>
<dt class="hdlist1" id="git-bisect---first-parent"> <a class="anchor" href="#git-bisect---first-parent"></a>--first-parent </dt>
<dd>
<div class="paragraph">
<p>Siga apenas o primeiro commit ao ver a mesclagem de um commit.</p>
</div>
<div class="paragraph">
<p>Durante a detecção das regressões introduzidas através da mesclagem de um ramo o commit mesclado será identificado como uma introdução do bug e os seus ancestrais serão ignorados.</p>
</div>
<div class="paragraph">
<p>Esta opção é útil para evitar falsos positivos quando um ramo que foi mesclado tenham commits quebrados ou que não possam ser construídos, porém a mesclagem em si foi OK.</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_exemplos"><a class="anchor" href="#_exemplos"></a>EXEMPLOS</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Faça o bisect automaticamente uma construção quebrada entre v1.2 e HEAD:</p>
<div class="listingblock">
<div class="content">
<pre>$ git bisect start HEAD v1.2 --      # HEAD está ruim, v1.2 está bom
$ git bisect run make                # "make" compila o app
$ git bisect reset                   # encerra a seção bisect</pre>
</div>
</div>
</li>
<li>
<p>Faça o bisect automaticamente num teste que falhou entre a <code>origin</code> (origem) e o <code>HEAD</code>:</p>
<div class="listingblock">
<div class="content">
<pre>$ git bisect start HEAD origin --    # HEAD está ruim, origin está bom
$ git bisect run make test           # "make test" compila e testa
$ git bisect reset                   # encerra a seção bisect</pre>
</div>
</div>
</li>
<li>
<p>Faça o bisect automaticamente num teste quebrado:</p>
<div class="listingblock">
<div class="content">
<pre>$ cat ~/test.sh
#!/bin/sh
make || exit 125                     # ignora as construções quebradas
~/check_test_case.sh                 # será que o exemplo passa?
$ git bisect start HEAD HEAD~10 --   # o culpado está entre os últimos 10
$ git bisect run ~/test.sh
$ git bisect reset                   # encerra a seção bisect</pre>
</div>
</div>
<div class="paragraph">
<p>Aqui utilizamos um script <code>test.sh</code>. Neste scriipt, caso o <code>make</code> falhe, nós ignoramos o commit atual. O arquivo <code>check_test_case.sh</code> deve encerrar com <code>exit 0</code> se o cenário de teste for aprovado, caso contrário, <code>exit 1</code>.</p>
</div>
<div class="paragraph">
<p>É mais seguro se os arquivos <code>test.sh</code> e <code>check_test_case.sh</code> estiverem fora do repositório para evitar interações entre os processos <code>bisect</code>, <code>make</code>, <code>test</code> e os scripts.</p>
</div>
</li>
<li>
<p>Faça o bisect automaticamente com alterações temporárias (hot-fix):</p>
<div class="listingblock">
<div class="content">
<pre>$ cat ~/test.sh
#!/bin/sh

# faz ajustes na árvore de trabalho ao mesclar
# a solução do problema no ramo e tenta compilá-lo
if	git merge --no-commit --no-ff hot-fix &amp;&amp;
	make
then
	# executa testes específicos no projeto e informa a sua condição atual
	~/check_test_case.sh
	status=$?
else
	# diga a quem requisitou que isso não pode ser testado
	status=125
fi

# desfaça o ajuste para permitir uma alteração limpa para o próximo commit
git reset --hard

# controle de retorno
existir $status</pre>
</div>
</div>
<div class="paragraph">
<p>São aplicadas alterações de um hotfix para ramificação antes de cada teste, caso o seu ambiente de construção ou teste tenha sido alterado para que as revisões mais antigas precisem de uma correção que as mais recentes já tenham por exemplo. (Certifique-se que o hot-fix do ramo tenha base num commit que está contida em todos as revisões que você esteja fazendo o bisect, para que a mesclagem não realize muitos resgates ou utilize o comando <code>git cherry-pick</code> em vez do <code>git merge</code>. )</p>
</div>
</li>
<li>
<p>Faça o bisect automaticamente num teste quebrado:</p>
<div class="listingblock">
<div class="content">
<pre>$ git bisect start HEAD HEAD~10 --   # o culpado está entre os últimos 10
$ git bisect run sh -c "make || exit 125; ~/check_test_case.sh"
$ git bisect reset                   # encerra a seção bisect</pre>
</div>
</div>
<div class="paragraph">
<p>Isso exibe o que você pode fazer sem executar um script caso escreva o teste numa única linha.</p>
</div>
</li>
<li>
<p>Localize uma boa região do grafo dos objetos num repositório que foi danificado</p>
<div class="listingblock">
<div class="content">
<pre>$ git bisect start HEAD &lt;known-good-commit&gt; [ &lt;boundary-commit&gt; ... ] --no-checkout
$ git bisect run sh -c '
	GOOD=$(git for-each-ref "--format=%(objectname)" refs/bisect/good-*) &amp;&amp;
	git rev-list --objects BISECT_HEAD --not $GOOD &gt;tmp.$$ &amp;&amp;
	git pack-objects --stdout &gt;/dev/null &lt;tmp.$$
	rc=$?
	rm -f tmp.$$
	test $rc = 0'

$ git bisect reset                   # encerra a seção bisect</pre>
</div>
</div>
<div class="paragraph">
<p>Neste caso, quando <em>git bisect run</em> encerra, o bisect/bad (ruim) irá apontar para um commit que tenha pelo menos uma origem cujo grafo seja completamente cruzado no sentido requerido pelo comando <em>git pack objects</em>.</p>
</div>
</li>
<li>
<p>Procure por uma correção em vez de uma regressão no código</p>
<div class="listingblock">
<div class="content">
<pre>$ git bisect start
$ git bisect new HEAD    # o commit atual é marcado como novo
$ git bisect old HEAD~10 # o décimo commit a partir de agora é marcado como antigo</pre>
</div>
</div>
<div class="paragraph">
<p>ou:</p>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git bisect start --term-old broken --term-new fixed
$ git bisect fixed
$ git bisect broken HEAD~10</pre>
</div>
</div>
<div class="sect2">
<h3 id="_conseguindo_ajuda"><a class="anchor" href="#_conseguindo_ajuda"></a>Conseguindo ajuda</h3>
<div class="paragraph">
<p>Utilize o comando <code>git bisect</code> para obter uma descrição resumida da sua utilização e <code>git bisect help</code> ou <code>git bisect -h</code> para obter uma descrição completa.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_veja_também"><a class="anchor" href="#_veja_também"></a>VEJA TAMBÉM</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="{{< relurl "docs/git-bisect-lk2009/pt_BR" >}}">Lutando contra regressões com git bisect</a>, <a href='{{< relurl "docs/git-blame/pt_BR" >}}'>git-blame[1]</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Parte do conjunto <a href='{{< relurl "docs/git/pt_BR" >}}'>git[1]</a></p>
</div>
</div>
</div>