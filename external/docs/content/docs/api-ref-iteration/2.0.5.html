---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - api-ref-iteration Documentation
docname: api-ref-iteration
version: 2.0.5
aliases:
- "/docs/api-ref-iteration/2.0.5/index.html"
- "/docs/api-ref-iteration/2.1.4/index.html"
- "/docs/api-ref-iteration/2.2.3/index.html"
- "/docs/api-ref-iteration/2.3.10/index.html"
- "/docs/api-ref-iteration/2.4.12/index.html"
---
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Iteration of refs is done by using an iterate function which will call a
callback function for every ref. The callback function has this
signature:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>int handle_one_ref(const char *refname, const unsigned char *sha1,
		   int flags, void *cb_data);</pre>
</div>
</div>
<div class="paragraph">
<p>There are different kinds of iterate functions which all take a
callback of this type. The callback is then called for each found ref
until the callback returns nonzero. The returned value is then also
returned by the iterate function.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_iteration_functions"><a class="anchor" href="#_iteration_functions"></a>Iteration functions</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><code>head_ref()</code> just iterates the head ref.</p>
</li>
<li>
<p><code>for_each_ref()</code> iterates all refs.</p>
</li>
<li>
<p><code>for_each_ref_in()</code> iterates all refs which have a defined prefix and
strips that prefix from the passed variable refname.</p>
</li>
<li>
<p><code>for_each_tag_ref()</code>, <code>for_each_branch_ref()</code>, <code>for_each_remote_ref()</code>,
<code>for_each_replace_ref()</code> iterate refs from the respective area.</p>
</li>
<li>
<p><code>for_each_glob_ref()</code> iterates all refs that match the specified glob
pattern.</p>
</li>
<li>
<p><code>for_each_glob_ref_in()</code> the previous and <code>for_each_ref_in()</code> combined.</p>
</li>
<li>
<p><code>head_ref_submodule()</code>, <code>for_each_ref_submodule()</code>,
<code>for_each_ref_in_submodule()</code>, <code>for_each_tag_ref_submodule()</code>,
<code>for_each_branch_ref_submodule()</code>, <code>for_each_remote_ref_submodule()</code>
do the same as the functions described above but for a specified
submodule.</p>
</li>
<li>
<p><code>for_each_rawref()</code> can be used to learn about broken ref and symref.</p>
</li>
<li>
<p><code>for_each_reflog()</code> iterates each reflog file.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_submodules"><a class="anchor" href="#_submodules"></a>Submodules</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you want to iterate the refs of a submodule you first need to add the
submodules object database. You can do this by a code-snippet like
this:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>const char *path = "path/to/submodule"
if (add_submodule_odb(path))
	die("Error submodule '%s' not populated.", path);</pre>
</div>
</div>
<div class="paragraph">
<p><code>add_submodule_odb()</code> will return zero on success. If you
do not do this you will get an error for each ref that it does not point
to a valid object.</p>
</div>
<div class="paragraph">
<p>Note: As a side-effect of this you can not safely assume that all
objects you lookup are available in superproject. All submodule objects
will be available the same way as the superprojects objects.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_example"><a class="anchor" href="#_example"></a>Example:</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>static int handle_remote_ref(const char *refname,
		const unsigned char *sha1, int flags, void *cb_data)
{
	struct strbuf *output = cb_data;
	strbuf_addf(output, "%s\n", refname);
	return 0;
}

...

	struct strbuf output = STRBUF_INIT;
	for_each_remote_ref(handle_remote_ref, &amp;output);
	printf("%s", output.buf);</pre>
</div>
</div>
</div>
</div>