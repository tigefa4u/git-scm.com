---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-fetch Documentation
docname: git-fetch
lang: fr
aliases:
- "/docs/git-fetch/fr/index.html"
---
<div class="sect1">
<h2 id="_nom"><a class="anchor" href="#_nom"></a>NOM</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-fetch - Télécharger les objets et références depuis un autre dépôt</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_synopsis"><a class="anchor" href="#_synopsis"></a>SYNOPSIS</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git fetch</em> [&lt;options&gt;] [&lt;dépôt&gt; [&lt;spéc-de-réf&gt;&#8230;&#8203;]]
<em>git fetch</em> [&lt;options&gt;] &lt;groupe&gt;
<em>git fetch</em> --multiple [&lt;options&gt;] [(&lt;dépôt&gt; | &lt;groupe&gt;)&#8230;&#8203;]
<em>git fetch</em> --all [&lt;options&gt;]</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_description"><a class="anchor" href="#_description"></a>DESCRIPTION</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Récupérer des branches et/ou des étiquettes (collectivement, "réfs") depuis un ou plusieurs autres dépôts, ainsi que les objets nécessaires pour compléter leur historique. Les branches de suivi à distance sont mises à jour (voir la description de &lt;spéc-de-réf&gt; ci-dessous pour les moyens de contrôler ce comportement).</p>
</div>
<div class="paragraph">
<p>Par défaut, toute étiquette qui pointe vers les historiques recherchés est également recherchée ; l&#8217;effet est de rechercher les étiquettes qui pointent vers les branches qui vous intéressent. Ce comportement par défaut peut être modifié en utilisant les options --tags ou --no-tags ou en configurant remote.&lt;nom&gt;.tagOpt. En utilisant une spécification de référence qui récupère les étiquettes explicitement, vous pouvez également récupérer les étiquettes qui ne pointent pas sur les branches qui vous intéressent.</p>
</div>
<div class="paragraph">
<p><em>git fetch</em> peut aller chercher à partir d&#8217;un seul dépôt nommé ou d&#8217;une seule URL, ou à partir de plusieurs dépôts à la fois si &lt;groupe&gt; est donné et qu&#8217;il y a une entrée remotes.&lt;groupe&gt; dans le fichier de configuration. (Voir <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a>).</p>
</div>
<div class="paragraph">
<p>Lorsqu&#8217;aucun distant n&#8217;est spécifié, par défaut le distant <code>origin</code> sera utilisé, à moins qu&#8217;il n&#8217;y ait une branche amont configurée pour la branche courante.</p>
</div>
<div class="paragraph">
<p>Les noms des refs qui sont récupérés, ainsi que les noms des objets qu&#8217;ils pointent, sont écrits dans <code>.git/FETCH_HEAD</code>. Ces informations peuvent être utilisées par des scripts ou d&#8217;autres commandes git, telles que <a href='{{< relurl "docs/git-pull/fr" >}}'>git-pull[1]</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_options"><a class="anchor" href="#_options"></a>OPTIONS</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-fetch---no-all"> <a class="anchor" href="#git-fetch---no-all"></a>--[no-]all </dt>
<dd>
<p>Récupérer tous les distants . Cela surcharge la variable de configuration <code>fetch.all</code> .</p>
</dd>
<dt class="hdlist1" id="git-fetch--a"> <a class="anchor" href="#git-fetch--a"></a>-a </dt>
<dt class="hdlist1" id="git-fetch---append"> <a class="anchor" href="#git-fetch---append"></a>--append </dt>
<dd>
<p>Ajouter les noms de références et les noms d&#8217;objets des références récupérées au contenu existant de <code>.git/FETCH_HEAD</code>. Sans cette option, les anciennes données dans <code>.git/FETCH_HEAD</code> seront écrasées.</p>
</dd>
<dt class="hdlist1" id="git-fetch---atomic"> <a class="anchor" href="#git-fetch---atomic"></a>--atomic </dt>
<dd>
<p>Utiliser une transaction atomique pour mettre à jour les références locales. Soit toutes les références sont mises à jour, soit, en cas d&#8217;erreur, aucune référence n&#8217;est mise à jour.</p>
</dd>
<dt class="hdlist1" id="git-fetch---depthltprofondeurgt"> <a class="anchor" href="#git-fetch---depthltprofondeurgt"></a>--depth=&lt;profondeur&gt; </dt>
<dd>
<p>Limiter la récupération au nombre spécifié de commits à partir du sommet de l&#8217;historique de chaque branche distante. Si vous allez chercher dans un dépôt "superficiel" créé par <code>git clone</code> avec l&#8217;option <code>--depth=&lt;profondeur&gt;</code> (voir <a href='{{< relurl "docs/git-clone/fr" >}}'>git-clone[1]</a>), approfondir ou raccourcir l&#8217;historique jusqu&#8217;au nombre spécifié de validations. Les étiquettes pour les commits approfondis ne sont pas récupérées.</p>
</dd>
<dt class="hdlist1" id="git-fetch---deepenltprofondeurgt"> <a class="anchor" href="#git-fetch---deepenltprofondeurgt"></a>--deepen=&lt;profondeur&gt; </dt>
<dd>
<p>Semblable à --depth, sauf que cela précise le nombre de commits à partir de la limite actuelle superficielle au lieu du sommet de l&#8217;historique de chaque branche distante.</p>
</dd>
<dt class="hdlist1" id="git-fetch---shallow-sinceltdategt"> <a class="anchor" href="#git-fetch---shallow-sinceltdategt"></a>--shallow-since=&lt;date&gt; </dt>
<dd>
<p>Approfondir ou raccourcir l&#8217;historique d&#8217;un dépôt superficiel pour inclure tous les commits accessibles après &lt;date&gt;.</p>
</dd>
<dt class="hdlist1" id="git-fetch---shallow-excludeltrvisiongt"> <a class="anchor" href="#git-fetch---shallow-excludeltrvisiongt"></a>--shallow-exclude=&lt;révision&gt; </dt>
<dd>
<p>Approfondir ou raccourcir l&#8217;historique d&#8217;un dépôt superficiel afin d&#8217;exclure les commits accessibles depuis une branche ou une étiquette distante spécifiée. Cette option peut être spécifiée plusieurs fois.</p>
</dd>
<dt class="hdlist1" id="git-fetch---unshallow"> <a class="anchor" href="#git-fetch---unshallow"></a>--unshallow </dt>
<dd>
<p>Si le dépôt de sources est complet, convertir un dépôt superficiel en un dépôt complet, en supprimant toutes les limitations imposées par les dépôts superficiels.</p>
<div class="paragraph">
<p>Si le dépôt source est superficiel, il faut en extraire le plus possible afin que le dépôt actuel ait le même historique que le dépôt source.</p>
</div>
</dd>
<dt class="hdlist1" id="git-fetch---update-shallow"> <a class="anchor" href="#git-fetch---update-shallow"></a>--update-shallow </dt>
<dd>
<p>Par défaut, lors de la récupération d&#8217;un dépôt superficiel, <code>git fetch</code> refuse les références qui nécessitent une mise à jour de .git/shallow. Cette option met à jour le fichier .git/shallow et accepte de telles références.</p>
</dd>
<dt class="hdlist1" id="git-fetch---negotiation-tipltcommitglobgt"> <a class="anchor" href="#git-fetch---negotiation-tipltcommitglobgt"></a>--negotiation-tip=&lt;commit|glob&gt; </dt>
<dd>
<p>Par défaut, Git signalera au serveur les commits accessibles à partir de toutes les références locales pour trouver les commits communs afin de réduire la taille du fichier de paquet à recevoir. Si ceci est spécifié, Git ne signalera que les commits accessibles à partir des sommets donnés. Ceci est utile pour accélérer les recherches lorsque l&#8217;utilisateur sait quelle réf locale est susceptible d&#8217;avoir des commits en commun avec la réf amont qui est recherchée.</p>
<div class="paragraph">
<p>Cette option peut être spécifiée plus d&#8217;une fois ; si c&#8217;est le cas, Git signalera les commits accessibles à partir de l&#8217;un des commits donnés.</p>
</div>
<div class="paragraph">
<p>L&#8217;argument de cette option peut être un glob sur les noms de référence, une référence ou le SHA-1 (éventuellement abrégé) d&#8217;un commit. La spécification d&#8217;un glob équivaut à spécifier cette option plusieurs fois, une pour chaque nom de référence correspondant.</p>
</div>
<div class="paragraph">
<p>Voir aussi les variables de configuration <code>fetch.negotiationAlgorithm</code> et <code>push.negotiate</code> documentées dans <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a>, ainsi que l&#8217;option <code>--negotiate-only</code> ci-après.</p>
</div>
</dd>
<dt class="hdlist1" id="git-fetch---negotiate-only"> <a class="anchor" href="#git-fetch---negotiate-only"></a>--negotiate-only </dt>
<dd>
<p>Ne rien récupérer du serveur, et à la place afficher les ancêtres des arguments fournis par <code>--negotiation-tip=*</code>, que nous avons en commun avec le serveur.</p>
<div class="paragraph">
<p>C&#8217;est incompatible avec <code>--recurse-submodules=[yes|on-demand]</code>. En interne, ceci est utilisé pour implémenter l&#8217;option <code>push.negotiate</code>, voir <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a>.</p>
</div>
</dd>
<dt class="hdlist1" id="git-fetch---dry-run"> <a class="anchor" href="#git-fetch---dry-run"></a>--dry-run </dt>
<dd>
<p>Montrer ce qui serait fait, sans faire de changements.</p>
</dd>
<dt class="hdlist1" id="git-fetch---porcelain"> <a class="anchor" href="#git-fetch---porcelain"></a>--porcelain </dt>
<dd>
<p>Afficher la sortie sur la sortie standard dans un format facile à décrypter pour les scripts. Voir la section SORTIE dans <a href='{{< relurl "docs/git-fetch/fr" >}}'>git-fetch[1]</a> pour plus de détails.</p>
<div class="paragraph">
<p>C&#8217;est incompatible avec <code>--recurse-submodules=[yes|on-demand]`et a la priorité sur l'option de configuration `fetch.output</code>.</p>
</div>
</dd>
<dt class="hdlist1" id="git-fetch---no-write-fetch-head"> <a class="anchor" href="#git-fetch---no-write-fetch-head"></a>--[no-]write-fetch-head </dt>
<dd>
<p>Ecrire la liste des refs distants récupérés dans le fichier <code>FETCH_HEAD</code> directement sous <code>$GIT_DIR</code>. C&#8217;est la valeur par défaut. Passer <code>--no-write-fetch-head</code> depuis la ligne de commande indique à Git de ne pas écrire le fichier. Avec l&#8217;option <code>--dry-run</code>, le fichier n&#8217;est jamais écrit.</p>
</dd>
<dt class="hdlist1" id="git-fetch--f"> <a class="anchor" href="#git-fetch--f"></a>-f </dt>
<dt class="hdlist1" id="git-fetch---force"> <a class="anchor" href="#git-fetch---force"></a>--force </dt>
<dd>
<p>Lorsque <em>git fetch</em> est utilisé avec la spécification de référence <code>&lt;src&gt;:&lt;dst&gt;</code>, il peut refuser de mettre à jour la branche locale comme cela a été discuté
dans la partie <code>&lt;spécificateur-de-référence&gt;</code> ci-dessous.
Cette option permet de passer outre à ce contrôle.</p>
</dd>
<dt class="hdlist1" id="git-fetch--k"> <a class="anchor" href="#git-fetch--k"></a>-k </dt>
<dt class="hdlist1" id="git-fetch---keep"> <a class="anchor" href="#git-fetch---keep"></a>--keep </dt>
<dd>
<p>Conserver le paquet téléchargé.</p>
</dd>
<dt class="hdlist1" id="git-fetch---multiple"> <a class="anchor" href="#git-fetch---multiple"></a>--multiple </dt>
<dd>
<p>Permettre de spécifier plusieurs arguments &lt;dépôt&gt; et &lt;groupe&gt;. Aucun &lt;spécificateur-de-référence&gt; ne peut être spécifié.</p>
</dd>
<dt class="hdlist1" id="git-fetch---no-auto-maintenance"> <a class="anchor" href="#git-fetch---no-auto-maintenance"></a>--[no-]auto-maintenance </dt>
<dt class="hdlist1" id="git-fetch---no-auto-gc"> <a class="anchor" href="#git-fetch---no-auto-gc"></a>--[no-]auto-gc </dt>
<dd>
<p>Exécuter <code>git maintenance --auto</code> à la fin pour effectuer la maintenance automatique du dépôt si nécessaire. (<code>--[no-]auto-gc</code> est un synonym.) Ceci est activé par défaut.</p>
</dd>
<dt class="hdlist1" id="git-fetch---no-write-commit-graph"> <a class="anchor" href="#git-fetch---no-write-commit-graph"></a>--[no-]write-commit-graph </dt>
<dd>
<p>Écrire un graphe de commit après avoir récupéré. Ceci remplace le paramètre de configuration <code>fetch.writeCommitGraph</code>.</p>
</dd>
<dt class="hdlist1" id="git-fetch---prefetch"> <a class="anchor" href="#git-fetch---prefetch"></a>--prefetch </dt>
<dd>
<p>Modifier le spécificateur de référence configuré pour placer toutes les refs dans l&#8217;espace de noms <code>refs/prefetch/</code>. Voir la tâche <code>prefetch</code> dans <a href='{{< relurl "docs/git-maintenance/fr" >}}'>git-maintenance[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-fetch--p"> <a class="anchor" href="#git-fetch--p"></a>-p </dt>
<dt class="hdlist1" id="git-fetch---prune"> <a class="anchor" href="#git-fetch---prune"></a>--prune </dt>
<dd>
<p>Avant de récupérer, supprimer toutes les références de suivi à distance qui n&#8217;existent plus sur le dépôt distant. Les étiquettes ne sont pas sujettes à l&#8217;élagage si elles ne sont récupérées qu&#8217;en raison du suivi automatique de l&#8217;étiquette par défaut ou en raison d&#8217;une option --tags. Cependant, si les étiquettes sont récupérées en raison d&#8217;un spécificateur de référence explicite (soit en ligne de commande, soit dans la configuration distante, par exemple si le dépôt distant a été cloné avec l&#8217;option --mirror), alors elles sont également sujettes à l&#8217;élagage. La fourniture de <code>--prune-tags</code> est une abréviation pour la fourniture du spécificateur de référence d&#8217;étiquette.</p>
<div class="paragraph">
<p>Voir la section ÉLAGAGE ci-dessous pour plus de détails.</p>
</div>
</dd>
<dt class="hdlist1" id="git-fetch--P"> <a class="anchor" href="#git-fetch--P"></a>-P </dt>
<dt class="hdlist1" id="git-fetch---prune-tags"> <a class="anchor" href="#git-fetch---prune-tags"></a>--prune-tags </dt>
<dd>
<p>Avant de récupérer, supprimer toutes les étiquettes locales qui n&#8217;existent plus sur le distant si <code>--prune</code> est activé. Cette option doit être utilisée avec plus de précaution, car contrairement à <code>--prune</code>, elle supprime toutes les références locales (étiquettes locales) qui ont été créées. Cette option est un raccourci pour la fourniture du spécificateur de référence d&#8217;étiquette explicite avec <code>--prune</code>, voir la discussion à ce sujet dans sa documentation.</p>
<div class="paragraph">
<p>Voir la section ÉLAGAGE ci-dessous pour plus de détails.</p>
</div>
</dd>
<dt class="hdlist1" id="git-fetch--n"> <a class="anchor" href="#git-fetch--n"></a>-n </dt>
<dt class="hdlist1" id="git-fetch---no-tags"> <a class="anchor" href="#git-fetch---no-tags"></a>--no-tags </dt>
<dd>
<p>Par défaut, les étiquettes qui pointent sur des objets téléchargés à partir du dépôt distant sont récupérées et stockées localement. Cette option désactive le suivi automatique des étiquettes. Le comportement par défaut d&#8217;un distant peut être spécifié avec le paramètre remote.&lt;nom&gt;.tagOpt. Voir <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-fetch---refetch"> <a class="anchor" href="#git-fetch---refetch"></a>--refetch </dt>
<dd>
<p>Au lieu de négocier avec le serveur pour éviter de transférer les commits et les objets associés qui sont déjà présents localement, cette option récupère tous les objets comme le ferait un nouveau clone. Utilisez cette option pour réappliquer un filtre de clone partiel depuis la configuration ou en utilisant <code>--filter=</code> lorsque la définition du filtre a changé. La maintenance automatique post-récupération effectuera une consolidation des paquets de la base de données des objets pour supprimer tout objet en double.</p>
</dd>
<dt class="hdlist1" id="git-fetch---refmapltspcificateur-de-rfrencegt"> <a class="anchor" href="#git-fetch---refmapltspcificateur-de-rfrencegt"></a>--refmap=&lt;spécificateur-de-référence&gt; </dt>
<dd>
<p>Lors de la récupération des références listées en ligne de commande, utiliser la spécification de référence (qui peut être donnée plusieurs fois) pour mapper les références sur les branches de suivi à distance, au lieu des valeurs des variables de configuration <code>remote.*.fetch</code> pour le dépôt distant. Fournir un <code>&lt;spécificateur-de-référence&gt;</code> vide à l&#8217;option <code>--refmap</code> fait que Git ignore les spécification de référence configurées et se fie entièrement aux spécifications de référence fournies comme arguments de la ligne de commande. Voir la section sur les "Branches de suivi à distance configurées" pour plus de détails.</p>
</dd>
<dt class="hdlist1" id="git-fetch--t"> <a class="anchor" href="#git-fetch--t"></a>-t </dt>
<dt class="hdlist1" id="git-fetch---tags"> <a class="anchor" href="#git-fetch---tags"></a>--tags </dt>
<dd>
<p>Récupérer toutes les étiquettes à distance (c&#8217;est-à-dire, récupérer les étiquettes <code>refs/tags/*</code> dans les étiquettes locales avec le même nom), en plus de tout ce qui serait récupéré autrement. L&#8217;utilisation de cette seule option ne soumet pas les étiquettes à un élagage, même si --prune est utilisé (bien que les étiquettes puissent être élaguées de toute façon si elles sont aussi la destination d&#8217;une spécification de référence explicite ; voir <code>--prune</code>).</p>
</dd>
<dt class="hdlist1" id="git-fetch---recurse-submodulesyeson-demandno"> <a class="anchor" href="#git-fetch---recurse-submodulesyeson-demandno"></a>--recurse-submodules[=(yes|on-demand|no)] </dt>
<dd>
<p>Cette option contrôle si et sous quelles conditions les nouveaux commits des sous-modules doivent être récupérés également. Lorsqu&#8217;il parcourt les sous-modules, <code>git fetch</code> essaie toujours de récupérer les sous-modules "modifiés", c&#8217;est-à-dire les sous-modules qui ont des commits référencés par un commit de superprojet récemment récupéré mais qui sont manquants dans le clone de sous-module local. Un sous-module modifié peut être récupéré tant qu&#8217;il est présent localement, par exemple dans <code>$GIT_DIR/modules/</code> (voir <a href='{{< relurl "docs/gitsubmodules/fr" >}}'>gitsubmodules[7]</a>) ; si l&#8217;amont ajoute un nouveau sous-module, ce sous-module ne peut pas être récupéré jusqu&#8217;à ce qu&#8217;il soit cloné, par exemple par <code>git submodule update</code>.</p>
<div class="paragraph">
<p>Lorsqu&#8217;il est défini sur <em>on-demand</em>, seuls les sous-modules modifiés sont récupérés. Lorsqu&#8217;il a pour valeur <em>yes</em>, tous les sous-modules peuplés sont récupérés et les sous-modules non peuplés et modifiés sont récupérés. Avec la valeur <em>no</em>, les sous-modules ne sont jamais récupérés.</p>
</div>
<div class="paragraph">
<p>Lorsque cette option n&#8217;est pas spécifiée, elle utilise la valeur de <code>fetch.recurseSubmodules</code> si elle est définie (voir <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a>), et prend par défaut la valeur <em>on-demand</em> si elle n&#8217;est pas définie. Lorsque cette option est utilisée sans aucune valeur, elle prend par défaut la valeur <em>yes</em>.</p>
</div>
</dd>
<dt class="hdlist1" id="git-fetch--j"> <a class="anchor" href="#git-fetch--j"></a>-j </dt>
<dt class="hdlist1" id="git-fetch---jobsltngt"> <a class="anchor" href="#git-fetch---jobsltngt"></a>--jobs=&lt;n&gt; </dt>
<dd>
<p>Nombre d&#8217;enfants parallèles à utiliser pour toutes les formes d&#8217;extraction.</p>
<div class="paragraph">
<p>Si l&#8217;option <code>--multiple</code> a été spécifiée, les différents distants seront récupérés en parallèle. Si plusieurs sous-modules sont récupérés, ils seront récupérés en parallèle. Pour les contrôler indépendamment, utilisez les paramètres de configuration <code>fetch.parallel</code> et <code>submodule.fetchJobs</code> (voir <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a>).</p>
</div>
<div class="paragraph">
<p>Généralement, les recherches récursives parallèles et sur des distants multiples seront plus rapides. Par défaut, les recherches sont effectuées de manière séquentielle, et non en parallèle.</p>
</div>
</dd>
<dt class="hdlist1" id="git-fetch---no-recurse-submodules"> <a class="anchor" href="#git-fetch---no-recurse-submodules"></a>--no-recurse-submodules </dt>
<dd>
<p>Désactiver la récupération récursive des sous-modules (cela a le même effet que d&#8217;utiliser l&#8217;option <code>--recurse-submodules=no</code>).</p>
</dd>
<dt class="hdlist1" id="git-fetch---set-upstream"> <a class="anchor" href="#git-fetch---set-upstream"></a>--set-upstream </dt>
<dd>
<p>Si le distant est récupéré avec succès, ajouter la référence (de suivi) amont , utilisée par les commandes sans argument <a href='{{< relurl "docs/git-pull/fr" >}}'>git-pull[1]</a> et autres. Pour plus d&#8217;informations, voir <code>branch.&lt;nom&gt;.merge</code> et <code>branch.&lt;nom&gt;.remote</code> dans <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-fetch---submodule-prefixltchemingt"> <a class="anchor" href="#git-fetch---submodule-prefixltchemingt"></a>--submodule-prefix=&lt;chemin&gt; </dt>
<dd>
<p>Préfixer &lt;chemin&gt; aux chemins affichés dans les messages informatifs tels que "Récupération du sous-module foo". Cette option est utilisée en interne lors de la récursion sur les sous-modules.</p>
</dd>
<dt class="hdlist1" id="git-fetch---recurse-submodules-defaultyeson-demand"> <a class="anchor" href="#git-fetch---recurse-submodules-defaultyeson-demand"></a>--recurse-submodules-default=[yes|on-demand] </dt>
<dd>
<p>Cette option est utilisée en interne pour fournir temporairement une valeur par défaut non négative pour l&#8217;option --recurse-submodules. Toutes les autres méthodes de configuration de la récupération récursive des sous-module (comme les paramètres de <a href='{{< relurl "docs/gitmodules/fr" >}}'>gitmodules[5]</a> et <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a>) remplacent cette option, tout comme le fait de spécifier directement --[no-]recurse-submodules.</p>
</dd>
<dt class="hdlist1" id="git-fetch--u"> <a class="anchor" href="#git-fetch--u"></a>-u </dt>
<dt class="hdlist1" id="git-fetch---update-head-ok"> <a class="anchor" href="#git-fetch---update-head-ok"></a>--update-head-ok </dt>
<dd>
<p>Par défaut, <em>git fetch</em> refuse de mettre à jour la tête qui correspond à la branche en cours. Ce drapeau désactive la vérification. C&#8217;est purement pour l&#8217;usage interne de <em>git pull</em> pour communiquer avec <em>git fetch</em>, et à moins que vous n&#8217;implémentiez votre propre Porcelaine, vous n&#8217;êtes pas censé l&#8217;utiliser.</p>
</dd>
<dt class="hdlist1" id="git-fetch---upload-packltupload-packgt"> <a class="anchor" href="#git-fetch---upload-packltupload-packgt"></a>--upload-pack &lt;upload-pack&gt; </dt>
<dd>
<p>Lorsqu&#8217;il est donné, et que le dépôt à récupérer est géré par <em>git fetch-pack</em>, <code>--exec=&lt;upload-pack&gt;</code> est passé à la commande pour spécifier le chemin par défaut pour la commande exécutée à l&#8217;autre bout.</p>
</dd>
<dt class="hdlist1" id="git-fetch--q"> <a class="anchor" href="#git-fetch--q"></a>-q </dt>
<dt class="hdlist1" id="git-fetch---quiet"> <a class="anchor" href="#git-fetch---quiet"></a>--quiet </dt>
<dd>
<p>Passer --quiet pour git-fetch-pack et faire taire toute autre commande git utilisée en interne. La progression n&#8217;est pas signalée dans le flux d&#8217;erreurs standard.</p>
</dd>
<dt class="hdlist1" id="git-fetch--v"> <a class="anchor" href="#git-fetch--v"></a>-v </dt>
<dt class="hdlist1" id="git-fetch---verbose"> <a class="anchor" href="#git-fetch---verbose"></a>--verbose </dt>
<dd>
<p>Mode bavard.</p>
</dd>
<dt class="hdlist1" id="git-fetch---progress"> <a class="anchor" href="#git-fetch---progress"></a>--progress </dt>
<dd>
<p>L&#8217;état d&#8217;avancement est affiché sur la sortie d&#8217;erreur standard quand elle est attachée à un terminal, à moins que -q soit spécifié. Ce drapeau force l&#8217;état d&#8217;avancement même si le flux d&#8217;erreur standard n&#8217;est pas dirigé vers un terminal.</p>
</dd>
<dt class="hdlist1" id="git-fetch--oltoptiongt"> <a class="anchor" href="#git-fetch--oltoptiongt"></a>-o &lt;option&gt; </dt>
<dt class="hdlist1" id="git-fetch---server-optionltoptiongt"> <a class="anchor" href="#git-fetch---server-optionltoptiongt"></a>--server-option=&lt;option&gt; </dt>
<dd>
<p>Transmettre la chaîne donnée au serveur lors d&#8217;une communication utilisant la version 2 du protocole. La chaîne donnée ne doit pas contenir de caractère NUL ou LF. La gestion par le serveur des options du serveur, y compris les options inconnues, est spécifique au serveur. Lorsque plusieurs <code>--server-option=&lt;option&gt;</code> sont donnés, ils sont tous envoyés à l&#8217;autre côté dans l&#8217;ordre indiqué sur la ligne de commande.</p>
</dd>
<dt class="hdlist1" id="git-fetch---show-forced-updates"> <a class="anchor" href="#git-fetch---show-forced-updates"></a>--show-forced-updates </dt>
<dd>
<p>Par défaut, git vérifie si une branche est mise à jour de force pendant la récupération. Cela peut être désactivé via fetch.showForcedUpdates, mais l&#8217;option --show-forced-updates garantit que cette vérification a lieu. Voir <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-fetch---no-show-forced-updates"> <a class="anchor" href="#git-fetch---no-show-forced-updates"></a>--no-show-forced-updates </dt>
<dd>
<p>Par défaut, git vérifie si une branche est mise à jour de force pendant la récupération. Passer --no-show-forced-updates ou régler fetch.showForcedUpdates à false pour sauter cette vérification pour des raisons de performance. Si elle est utilisée pendant <em>git-pull</em>, l&#8217;option --ff-only vérifiera toujours les mises à jour forcées avant de tenter une mise à jour rapide. Voir <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-fetch--4"> <a class="anchor" href="#git-fetch--4"></a>-4 </dt>
<dt class="hdlist1" id="git-fetch---ipv4"> <a class="anchor" href="#git-fetch---ipv4"></a>--ipv4 </dt>
<dd>
<p>Utiliser uniquement les adresses IPv4, en ignorant les adresses IPv6.</p>
</dd>
<dt class="hdlist1" id="git-fetch--6"> <a class="anchor" href="#git-fetch--6"></a>-6 </dt>
<dt class="hdlist1" id="git-fetch---ipv6"> <a class="anchor" href="#git-fetch---ipv6"></a>--ipv6 </dt>
<dd>
<p>Utiliser uniquement les adresses IPv6, en ignorant les adresses IPv4.</p>
</dd>
</dl>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-fetch-ltdptgt"> <a class="anchor" href="#git-fetch-ltdptgt"></a>&lt;dépôt&gt; </dt>
<dd>
<p>Le dépôt "distant" qui est la source d&#8217;une opération de récupération ou de tirage. Ce paramètre peut être soit une URL (voir la section <a href="#URLS">URLS GIT</a> ci-dessous) soit le nom d&#8217;un remote (voir la section <a href="#REMOTES">DISTANTS</a> ci-dessous).</p>
</dd>
<dt class="hdlist1" id="git-fetch-ltgroupegt"> <a class="anchor" href="#git-fetch-ltgroupegt"></a>&lt;groupe&gt; </dt>
<dd>
<p>Un nom faisant référence à une liste des dépôts comme la valeur de remotes.&lt;groupe&gt; dans le fichier de configuration. (voir <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a>).</p>
</dd>
<dt class="hdlist1" id="git-fetch-ltspcificateur-de-rfrencegt"> <a class="anchor" href="#git-fetch-ltspcificateur-de-rfrencegt"></a>&lt;spécificateur-de-référence&gt; </dt>
<dd>
<p>Préciser les références à récupérer et les références locales à mettre à jour. Lorsqu&#8217;aucun &lt;spéc-de-réf&gt; n&#8217;apparaît sur la ligne de commande, les références à récupérer sont lues à partir des variables <code>remote.&lt;dépôt&gt;.fetch</code> à la place
(voir <a href="#CRTB">BRANCHES DE SUIVI À DISTANCE CONFIGURÉES</a> ci-dessous).</p>
<div class="paragraph">
<p>Le format d&#8217;un paramètre &lt;spéc-de-réf&gt; est un plus <code>+</code> optionnel, suivi de la source &lt;src&gt;, suivi de deux points <code>:</code>, suivi de la destination ref &lt;dst&gt;. Les deux points peuvent être omis lorsque &lt;dst&gt; est vide. &lt;src&gt; est typiquement une réf, mais cela peut aussi être un nom d&#8217;objet hexadécimal entier.</p>
</div>
<div class="paragraph">
<p>Un &lt;spec-de-réf&gt; peut contenir un <code>*</code> dans son &lt;src&gt; pour indiquer une simple correspondance de motif. Un tel refspec fonctionne comme un motif qui correspond à n&#8217;importe quelle ref avec le même préfixe. Un motif &lt;spec-de-réf&gt; doit avoir un <code>*</code> dans les deux &lt;src&gt; et &lt;dst&gt;. Il va faire correspondre les références à la destination en remplaçant le <code>*</code> par le contenu correspondant de la source.</p>
</div>
<div class="paragraph">
<p>Si un spécificateur de référence est préfixé par <code>^</code>, il sera interprété comme un spécificateur de référence négatif. Plutôt que de spécifier les références à récupérer ou les références locales à mettre à jour, un tel spécificateur de référence spécifiera les références à exclure. Une référence sera considérée comme correspondante si elle correspond à au moins une référence positive, et ne correspond à aucune référence négative. Les spécificateurs de référence négatifs peuvent être utiles pour restreindre le champ d&#8217;application d&#8217;un spécificateur modèle de référence afin qu&#8217;il n&#8217;inclue pas de références spécifiques. Les spécificateurs de référence négatifs peuvent eux-mêmes être des spécificateurs modèles de référence . Cependant, ils ne peuvent contenir qu&#8217;un &lt;src&gt; et ne peuvent pas spécifier un &lt;dst&gt;. Les noms d&#8217;objets hexagonaux complets ne sont pas non plus pris en charge.</p>
</div>
<div class="paragraph">
<p><code>tag &lt;étiquette&gt;</code> signifie la même chose que <code>refs/tags/&lt;tag&gt;:refs/tags/&lt;tag&gt;</code> ; cela demande de tout récupérer jusqu&#8217;à l&#8217;étiquette donnée.</p>
</div>
<div class="paragraph">
<p>La référence distante qui correspond à &lt;src&gt; est récupérée, et si &lt;dst&gt; n&#8217;est pas une chaîne vide, une tentative est faite pour mettre à jour la référence locale qui lui correspond.</p>
</div>
<div class="paragraph">
<p>Le fait que cette mise à jour soit autorisée sans <code>--force</code> dépend de l&#8217;espace de noms de référence vers lequel elle est récupérée, du type d&#8217;objet récupéré, et si la mise à jour est considérée comme une avance rapide. Généralement, les mêmes règles s&#8217;appliquent pour la récupération que pour la poussée, voir la section <code>&lt;spéc-de-réf&gt;...</code> de <a href='{{< relurl "docs/git-push/fr" >}}'>git-push[1]</a> pour les connaître. Les exceptions à ces règles particulières à <em>git fetch</em> sont notées ci-dessous.</p>
</div>
<div class="paragraph">
<p>Jusqu&#8217;à la version 2.20 de Git, et contrairement à ce qui se passe avec <a href='{{< relurl "docs/git-push/fr" >}}'>git-push[1]</a>, toute mise à jour de <code>refs/tags/*</code> serait acceptée sans <code>+</code> dans la spéc-de-réf (ou <code>--force</code>). Lors de la récupération, nous considérons sans distinction toutes les mises à jour d&#8217;étiquettes depuis un dépôt distance comme des récupérations forcées. Depuis la version 2.20 de Git, la récupération pour mettre à jour les <code>refs/tags/*</code> fonctionne de la même manière que lors de la poussée. C&#8217;est-à-dire que toute mise à jour sera rejetée sans "+" dans le spécificateur de référence (ou <code>--force</code>).</p>
</div>
<div class="paragraph">
<p>Contrairement à une poussée avec <a href='{{< relurl "docs/git-push/fr" >}}'>git-push[1]</a>, toute mise à jour en dehors de <code>refs/{tags,heads}/*</code> sera acceptée sans <code>+</code> dans le spéc-de-réf (ou <code>--force</code>), que ce soit en échangeant par exemple un objet arbre pour un blob, ou un commit pour un autre commit qui n&#8217;a pas le commit précédent comme ancêtre etc.</p>
</div>
<div class="paragraph">
<p>Contrairement à une poussée avec <a href='{{< relurl "docs/git-push/fr" >}}'>git-push[1]</a>, il n&#8217;y a pas de configuration qui modifie ces règles, et rien de tel qu&#8217;un crochet pré-récupération <code>pre-fetch</code> analogue à celui de pré-réception`pre-receive`.</p>
</div>
<div class="paragraph">
<p>Comme pour la poussée avec <a href='{{< relurl "docs/git-push/fr" >}}'>git-push[1]</a>, toutes les règles décrites ci-dessus concernant ce qui n&#8217;est pas autorisé comme une mise à jour, peuvent être annulées en ajoutant un "+" optionnel à un spécificateur de référence (ou en utilisant l&#8217;option de ligne de commande <code>--force</code>). La seule exception à cette règle est qu&#8217;aucun forçage ne fera accepter à l&#8217;espace de noms <code>refs/heads/*</code> un objet non commit.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Lorsque la branche distante que vous voulez récupérer est connue pour être régulièrement rembobinée et rebasée, on s&#8217;attend à ce que son nouveau sommet ne soit pas un descendant de son sommet précédent (telle qu&#8217;il était stocké dans votre branche de suivi à distance la dernière fois que vous l&#8217;avez récupéré). Vous pouvez utiliser le signe "+" pour indiquer que des mises à jour non en avance rapide seront nécessaires pour ces branches. Il n&#8217;y a aucun moyen de déterminer ou de déclarer qu&#8217;une branche sera rendue disponible dans un dépôt avec ce comportement ; l&#8217;utilisateur qui tire doit simplement savoir que c&#8217;est le modèle d&#8217;utilisation attendu pour une branche.
</td>
</tr>
</table>
</div>
</dd>
</dl>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-fetch---stdin"> <a class="anchor" href="#git-fetch---stdin"></a>--stdin </dt>
<dd>
<p>Lire les spécifications de référence, une par ligne, de stdin en plus de celles fournies comme arguments. Le format "tag &lt;nom&gt;" n&#8217;est pas pris en charge.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_url_git"><a class="anchor" href="#_url_git"></a>URL GIT<a id="URLS"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>En général, les URL contiennent une information sur le protocole de transport, l&#8217;adresse du serveur distant et le chemin vers le dépôt. En fonction du protocole de transport, certaines de ces informations peuvent être absentes.</p>
</div>
<div class="paragraph">
<p>Git supporte les protocoles ssh, git, http et https (en plus, ftp et ftps peuvent être utilisés pour la récupération, mais ceux-ci sont inefficaces et déconseillés ; ne les utilisez pas).</p>
</div>
<div class="paragraph">
<p>Le transport natif (c&#8217;est-à-dire l&#8217;URL git://) n&#8217;utilise pas d&#8217;authentification et ne devrait être utilisé qu&#8217;avec précaution sur des réseaux non sécurisés.</p>
</div>
<div class="paragraph">
<p>Les syntaxes suivantes peuvent être utilisées avec eux :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ssh://</code>[<em>&lt;utilisateur&gt;</em><code>@</code>]<em>&lt;hôte&gt;</em>[<code>:</code><em>&lt;port&gt;</em>]<code>/</code><em>&lt;chemin-du-dépôt-git&gt;</em></p>
</li>
<li>
<p><code>git://</code><em>&lt;hôte&gt;</em>[:<em>&lt;port&gt;</em>]<code>/</code><em>&lt;chemin-du-dépôt-git&gt;</em></p>
</li>
<li>
<p><code>http</code>[<code>s</code>]<code>://</code><em>&lt;hôtet&gt;</em>[<code>:</code><em>&lt;port&gt;</em>]<code>/</code><em>&lt;chemin-du-dépôt-git&gt;</em></p>
</li>
<li>
<p><code>ftp</code>[<code>s</code>]<code>://</code><em>&lt;hôte&gt;</em>[<code>:</code><em>&lt;port&gt;</em>]<code>/</code><em>&lt;chemin-du-dépôt-git&gt;</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Une syntaxe alternative de type scp peut aussi être utilisée pour le protocole ssh :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>[<em>&lt;utilisateur&gt;</em><code>@</code>]<em>&lt;hôte&gt;</em><code>:/</code><em>&lt;chemin-du-dépôt-git&gt;</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Cette syntaxe n&#8217;est reconnue que s&#8217;il n&#8217;y a pas de barre oblique devant les premiers deux-points. Cela permet de prendre en charge des chemins locaux qui contiendraient des deux-points. Par exemple, le chemin local <code>toto:titi</code> pourrait être spécifié comme un chemin absolu ou <code>./toto:titi</code> pour éviter d&#8217;être interprété comme une url ssh.</p>
</div>
<div class="paragraph">
<p>Les protocoles ssh et git supportent en plus l&#8217;expansion <code>~</code><em>&lt;utilisateur&gt;</em>  :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ssh://</code>[<em>&lt;utilisateur&gt;</em><code>@</code>]<em>&lt;hôte&gt;</em>[<code>:</code><em>&lt;port&gt;</em>]<code>/~</code><em>&lt;utilisateur&gt;</em><code>/</code><em>&lt;chemin-du-dépôt-git&gt;</em></p>
</li>
<li>
<p><code>git://</code><em>&lt;hôte&gt;</em>[<code>:</code><em>&lt;port&gt;</em>]<code>/~</code><em>&lt;utilisateur&gt;</em><code>/</code><em>&lt;chemin-du-dépôt-git&gt;</em></p>
</li>
<li>
<p>[<em>&lt;utilisateur&gt;</em><code>@</code>]<em>&lt;hôte&gt;</em><code>:~</code><em>&lt;utilisateur&gt;</em><code>/</code><em>&lt;chemin-du-dépôt-git&gt;</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Pour les dépôts locaux, supportés aussi nativement par Git, les syntaxes suivantes sont aussi admises :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>/chemin/du/dépôt.git/</code></p>
</li>
<li>
<p><code><a href="file:///chemin/du/dépôt.git/" class="bare">file:///chemin/du/dépôt.git/</a></code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ces deux syntaxes sont à peu près équivalentes, à part lors d&#8217;un clonage, où la première implique l&#8217;option <code>--local</code>. Voir <a href='{{< relurl "docs/git-clone/fr" >}}'>git-clone[1]</a> pour plus de détails.</p>
</div>
<div class="paragraph">
<p><code>git clone</code>, <code>git fetch</code> et <code>git pull</code>, mais pas <code>git push</code>, acceptent également un fichier paquet approprié. Voir <a href='{{< relurl "docs/git-bundle/fr" >}}'>git-bundle[1]</a>.</p>
</div>
<div class="paragraph">
<p>Quand Git ne sait pas comment gérer un certain protocole, il essaie d&#8217;utiliser l&#8217;assistant de gestion de distant <code>remote-</code><em>&lt;transport&gt;</em>, s&#8217;il existe. Pour requérir l&#8217;emploi d&#8217;un assistant spécifique, la syntaxe suivante peut être utilisée :</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>&lt;transport&gt;</em>::<em>&lt;adresse&gt;</em></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>où <em>&lt;adresse&gt;</em> peut être un chemin, un serveur et chemin, ou une chaîne URL arbitraire reconnue par l&#8217;assistant de gestion de distant invoqué. Voir <a href='{{< relurl "docs/gitremote-helpers/fr" >}}'>gitremote-helpers[7]</a> pour plus de détails.</p>
</div>
<div class="paragraph">
<p>S&#8217;il y a un grand nombre de dépôts aux noms similaires et que vous souhaitez utiliser un format différent pour eux (de telle sorte que les URL que vous utiliserez seront réécrites en URL fonctionnelles), vous pouvez créer une section de configuration de la forme :</p>
</div>
<div class="verseblock">
<pre class="content">	[url "<em>&lt;veritable-base-d-url&gt;</em>"]
		insteadOf = <em>&lt;autre-base-d&#8217;URL&gt;</em></pre>
</div>
<div class="paragraph">
<p>Par exemple, avec ceci :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	[url "git://git.host.xz/"]
		insteadOf = host.xz:/chemin/vers/
		insteadOf = travail:</pre>
</div>
</div>
<div class="paragraph">
<p>une URL comme « travail:depot.git » ou « host.xz:/chemin/vers/depot.git » sera réécrite dans tout contexte qui requiert une URL en « git://git.host.xz/depot.git ».</p>
</div>
<div class="paragraph">
<p>Si vous souhaitez réécrire les URL seulement pour pousser, vous pouvez créer une section de configuration de la forme :</p>
</div>
<div class="verseblock">
<pre class="content">	[url "<em>&lt;veritable-base-d&#8217;URL&gt;</em>"]
		pushInsteadOf = <em>&lt;autre-base-d-URL&gt;</em></pre>
</div>
<div class="paragraph">
<p>Par exemple, avec ceci :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	[url "ssh://exemple.org/"]
		pushInsteadOf = git://exemple.org/</pre>
</div>
</div>
<div class="paragraph">
<p>une URL telle que « git://exemple.org/chemin/vers/le/depot.git » sera réécrite en « ssh://exemple.org/chemin/vers/le/depot.git » pour les poussées, mais les tirages utiliseront encore l&#8217;URL originale.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_distants"><a class="anchor" href="#_distants"></a>DISTANTS<a id="REMOTES"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Le nom de l&#8217;un des éléments suivants peut être utilisé à la place d&#8217;une URL en tant qu&#8217;argument <code>&lt;dépôt&gt;</code> :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>un distant dans le fichier de configuration Git : <code>$GIT_DIR/config</code>,</p>
</li>
<li>
<p>un fichier dans le répertoire <code>$GIT_DIR/remotes</code>, ou</p>
</li>
<li>
<p>un fichier dans le répertoire <code>$GIT_DIR/branches</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Toutes ces options vous permettent également d&#8217;omettre le spécificateur de référence de la ligne de commande car elles contiennent chacune un spécificateur de référence que git utilisera par défaut.</p>
</div>
<div class="sect2">
<h3 id="_distant_nommé_dans_le_fichier_de_configuration"><a class="anchor" href="#_distant_nommé_dans_le_fichier_de_configuration"></a>distant nommé dans le fichier de configuration</h3>
<div class="paragraph">
<p>Vous pouvez choisir de fournir le nom d&#8217;un distant que vous aviez précédemment configuré en utilisant <a href='{{< relurl "docs/git-remote/fr" >}}'>git-remote[1]</a>, <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a> ou même par une modification manuelle du fichier <code>$GIT_DIR/config</code>. L&#8217;URL de ce distant sera utilisée pour accéder au dépôt. Le spécificateur de référence de ce distant sera utilisé par défaut lorsque vous ne fournissez pas de spécificateur de référence sur la ligne de commande. L&#8217;entrée dans le fichier de configuration apparaîtra comme ceci :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	[remote "&lt;nom&gt;"]
		url = &lt;URL&gt;
		pushurl = &lt;url-poussée&gt;
		push = &lt;spéc-de-réf&gt;
		fetch = &lt;spéc-de-réf&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Le <code>&lt;url-de-poussée&gt;</code> est utilisé uniquement pour les poussées. Il est optionnel et sa valeur par défaut est <code>&lt;URL&gt;</code>. Pousser vers un distant affecte tous les urls-de-poussés définis ou tous les urls définis si aucun url-de-poussée n&#8217;est défini. Fetch, cependant, ne récupérera que le premier url défini si plusieurs urls sont définis.</p>
</div>
</div>
<div class="sect2">
<h3 id="_fichier_nommé_dans_git_dirremotes"><a class="anchor" href="#_fichier_nommé_dans_git_dirremotes"></a>Fichier nommé dans <code>$GIT_DIR/remotes</code></h3>
<div class="paragraph">
<p>Vous pouvez choisir de fournir le nom d&#8217;un fichier dans <code>$GIT_DIR/remotes</code>. L&#8217;URL dans ce fichier sera utilisée pour accéder au dépôt. Le spécificateur de référence dans ce fichier sera utilisé par défaut lorsque vous ne fournissez pas de spécificateur de référence sur la ligne de commande. Ce fichier doit avoir le format suivant :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	URL: un des format d'URL ci-dessus
	Push: &lt;spéc-de-réf&gt;
	Pull: &lt;spéc-de-réf&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Les lignes <code>Push:</code>" sont utilisées par <em>git push</em> et les lignes <code>Pull:</code> sont utilisées par <em>git pull</em> et <em>git fetch</em>. Des lignes <code>Push:</code> et <code>Pull:</code> multiples peuvent être spécifiées pour des mappages supplémentaires de branches.</p>
</div>
</div>
<div class="sect2">
<h3 id="_fichier_nommé_dans_git_dirbranches"><a class="anchor" href="#_fichier_nommé_dans_git_dirbranches"></a>Fichier nommé dans <code>$GIT_DIR/branches</code></h3>
<div class="paragraph">
<p>Vous pouvez choisir de fournir le nom d&#8217;un fichier dans <code>$GIT_DIR/branches</code>. L&#8217;URL de ce fichier sera utilisée pour accéder au dépôt. Ce fichier doit avoir le format suivant :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	&lt;URL&gt;#&lt;tête&gt;</pre>
</div>
</div>
<div class="paragraph">
<p><code>&lt;URL&gt;</code> est obligatoire ; <code>#&lt;tête&gt;</code> est facultatif.</p>
</div>
<div class="paragraph">
<p>En fonction de l&#8217;opération, git utilisera l&#8217;un des spécificateurs de référence suivants, si vous n&#8217;en fournissez pas un en ligne de commande. <code>&lt;branche&gt;</code> est le nom de ce fichier dans <code>$GIT_DIR/branches</code> et <code>&lt;tête&gt;</code> vaut par défaut <code>master</code>.</p>
</div>
<div class="paragraph">
<p>git fetch utilise :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	refs/heads/&lt;tête&gt;:refs/heads/&lt;branche&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>git push utilise :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	HEAD:refs/heads/&lt;tête&gt;</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="CRTB"><a class="anchor" href="#CRTB"></a>LES BRANCHES DE SUIVI À DISTANCE CONFIGURÉES</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Vous interagissez souvent avec le même dépôt distant en y allant régulièrement et de manière répétée. Afin de suivre la progression d&#8217;un tel dépôt distant, <code>git fetch</code> vous permet de configurer les variables de configuration <code>remote.&lt;dépôt&gt;.fetch</code>.</p>
</div>
<div class="paragraph">
<p>En général, une telle variable peut ressembler à ceci :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[remote "origin"]
	fetch = +refs/heads/*:refs/remotes/origin/*</pre>
</div>
</div>
<div class="paragraph">
<p>Cette configuration est utilisée de deux façons :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Lorsque <code>git fetch</code> est lancé sans spécifier les branches et/ou les étiquettes à récupérer en ligne de commande, par exemple <code>git fetch origin</code> ou <code>git fetch</code>, les valeurs <code>remote.&lt;dépôt&gt;.fetch</code> sont utilisées comme spéc-de-réf --elles spécifient quelles réfs à récupérer et quelles réfs locales à mettre à jour. L&#8217;exemple ci-dessus va chercher toutes les branches qui existent dans <code>origin</code> (c&#8217;est-à-dire toute réf qui correspond au côté gauche de la valeur, "refs/heads/*") et mettre à jour les branches de suivi à distance correspondantes dans la hiérarchie <code>refs/remotes/origin/*</code>.</p>
</li>
<li>
<p>Lorsque <code>git fetch</code> est lancé avec des branches et/ou des étiquettes explicites à récupérer en ligne de commande, par exemple <code>git fetch origin master</code>, les &lt;spéc-de-réf&gt;s données en ligne de commande déterminent ce qui doit être récupéré (par exemple <code>master</code> dans l&#8217;exemple, qui est un raccourci pour <code>master:</code>, ce qui signifie "chercher la branche <em>master</em> mais je ne dis pas explicitement quelle branche de suivi à distance mettre à jour avec elle depuis la ligne de commande"), et la commande de l&#8217;exemple ne cherchera <em>que</em> la branche <em>master</em>. Les valeurs de <code>remote.&lt;dépôt&gt;.fetch</code> déterminent quelle branche de suivi à distance, s&#8217;il y en a une, est mise à jour. Lorsqu&#8217;elles sont utilisées de cette façon, les valeurs de <code>remote.&lt;dépôt&gt;.fetch</code> n&#8217;ont aucun effet sur la décision de ce qui est récupéré (c&#8217;est-à-dire que les valeurs ne sont pas utilisées comme spéc-de-réf lorsque la ligne de commande liste les spéc-de-réfs) ; elles ne sont utilisées que pour décider de l&#8217;endroit où les réfs qui sont récupérées sont stockées en agissant comme une table de correspondance.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Cette dernière utilisation des valeurs de <code>remote.&lt;dépôt&gt;.fetch</code> peut être écrasée en donnant le(s) paramètre(s) <code>--refmap=&lt;spéc-de-réf&gt;</code> sur la ligne de commande.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_élagage"><a class="anchor" href="#_élagage"></a>ÉLAGAGE</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Par défaut, Git conserve les données à moins qu&#8217;elles ne soient explicitement jetées ; cela s&#8217;étend à la conservation des références locales aux branches des distants qui ont eux-mêmes supprimé ces branches.</p>
</div>
<div class="paragraph">
<p>Si on les laisse s&#8217;accumuler, ces références périmées pourraient rendre les performances mauvaises sur les gros dépôt qui ont beaucoup de branches, et par exemple rendre la sortie de commandes comme <code>git branch -a --contains &lt;commit&gt;</code> inutilement verbeuse, ainsi qu&#8217;avoir un impact sur tout ce qui travaillera avec l&#8217;ensemble des références connues.</p>
</div>
<div class="paragraph">
<p>Ces références de suivi à distance peuvent être supprimées une seule fois avec l&#8217;une ou l&#8217;autre des commandes suivantes :</p>
</div>
<div class="listingblock">
<div class="content">
<pre># Pendant la récupération
$ git fetch --prune &lt;nom&gt;

# Élaguer seulement, ne pas récupére
$ git remote prune &lt;nom&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Pour élaguer les références dans le cadre de votre flux de travail normal sans avoir besoin de vous rappeler de l&#8217;exécuter, définissez <code>fetch.prune</code> globalement, ou <code>remote.&lt;nom&gt;.prune</code> pour chaque dépôt distant dans la configuration. Voir <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a>.</p>
</div>
<div class="paragraph">
<p>C&#8217;est là que les choses deviennent délicates et plus spécifiques. La fonction d&#8217;élagage ne se préoccupe pas vraiment des branches, elle va plutôt élaguer les références locales &#8592;&#8594; à distance en fonction du spécificateur de référence du dépôt distant (voir <code>&lt;spéc-de-réf&gt;</code> et <a href="#CRTB">BRANCHES DE SUIVI À DISTANCE CONFIGURÉES</a> ci-dessus).</p>
</div>
<div class="paragraph">
<p>Par conséquent, si le spécificateur de référence du serveur distant inclut par exemple <code>refs/tags/*:refs/tags/*</code>, ou si vous lancez manuellement par exemple <code>git fetch --prune &lt;nom&gt; "refs/tags/*:refs/tags/*"</code>, ce ne seront pas les branches de suivi à distance qui seront supprimées, mais toute étiquette locale qui n&#8217;existe pas sur le serveur distant.</p>
</div>
<div class="paragraph">
<p>Ce n&#8217;est peut-être pas ce à quoi vous vous attendez, c&#8217;est-à-dire que vous voulez élaguer le server distant <code>&lt;nom&gt;</code>, mais aussi y récupérer explicitement des étiquettes, de sorte que lorsque vous le récupérez, vous supprimez toutes vos étiquettes locales, dont la plupart ne proviennent pas du dépôt distant <code>&lt;nom&gt;</code> au départ.</p>
</div>
<div class="paragraph">
<p>Soyez donc prudent lorsque vous utilisez un spécificateur de référence comme <code>refs/tags/*:refs/tags/*</code>, ou toute autre spécificateur de référence qui pourrait faire correspondre des références de plusieurs dépôts distants au même espace de noms local.</p>
</div>
<div class="paragraph">
<p>Étant donné que la mise à jour des branches et des étiquettes sur le dépôt distant est un cas d&#8217;utilisation courant, l&#8217;option <code>--prune-tags</code> peut être fournie avec <code>--prune</code> pour élaguer les étiquettes locales qui n&#8217;existent pas sur le dépôt distant, et forcer la mise à jour des étiquettes qui diffèrent. L&#8217;élagage des étiquettes peut également être activé avec <code>fetch.pruneTags</code> ou <code>remote.&lt;nom&gt;.pruneTags</code> dans la configuration. Voir <a href='{{< relurl "docs/git-config/fr" >}}'>git-config[1]</a>.</p>
</div>
<div class="paragraph">
<p>L&#8217;option <code>--prune-tags</code> est équivalente à avoir <code>refs/tags/*:refs/tags/*</code> déclaré dans les spécificateurs de référence du dépôt distant. Cela peut conduire à des interactions apparemment étranges :</p>
</div>
<div class="listingblock">
<div class="content">
<pre># Ces deux ligne vont chercher les étiquettes
$ git fetch --no-tags origin 'refs/tags/*:refs/tags/*
$ git fetch --no-tags --prune-tags origin</pre>
</div>
</div>
<div class="paragraph">
<p>La raison pour laquelle il ne génère pas d&#8217;erreur lorsqu&#8217;il est fourni sans <code>--prune</code> ou ses pendants en configuration est pour la flexibilité des versions configurées et pour maintenir un mappage 1 = 1 entre ce que font les drapeaux de ligne de commande et ce que font les versions de configuration.</p>
</div>
<div class="paragraph">
<p>Il est raisonnable, par exemple de configurer <code>fetch.pruneTags = true</code> dans` ~ / .gitconfig` pour que les étiquettes soient élaguées chaque fois que <code>git fetch --prune</code> est exécuté, sans que chaque appel de <code>git fetch</code> sans <code>--prune</code> soit une erreur.</p>
</div>
<div class="paragraph">
<p>L&#8217;élagage des étiquettes avec <code>--prune-tags</code> fonctionne également lors de la récupération d&#8217;une URL au lieu d&#8217;un dépôt distant nommé. Toutes ces lignes élagueront les étiquettes non trouvées sur origin :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git fetch origin --prune --prune-tags
$ git fetch origin --prune 'refs/tags/*:refs/tags/*
$ git fetch &lt;url-d-origin&gt; --prune --prune-tags
$ git fetch &lt;url-d-origin&gt; --prune 'refs/tags/*:refs/tags/*</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sortie"><a class="anchor" href="#_sortie"></a>SORTIE</h2>
<div class="sectionbody">
<div class="paragraph">
<p>La sortie de "git fetch" dépend de la méthode de transport utilisée ; cette section décrit la sortie lors de la récupération sur le protocole Git (soit localement soit via ssh) et le protocole Smart HTTP.</p>
</div>
<div class="paragraph">
<p>L&#8217;état de la récupération est affiché sous forme de tableau, chaque ligne représentant l&#8217;état d&#8217;une seule référence. Chaque ligne est de la forme :</p>
</div>
<div class="listingblock">
<div class="content">
<pre> &lt;drapeau&gt; &lt;résumé&gt; &lt;de&gt; -&gt; &lt;à&gt; [&lt;raison&gt;]</pre>
</div>
</div>
<div class="paragraph">
<p>Lorsque vous utilisez <code>--porcelain</code>, le format de sortie est destiné à être analysé par la machine. Contrairement aux formats de sortie lisibles par l&#8217;homme, il s&#8217;imprime donc sur la sortie standard au lieu de l&#8217;erreur standard. Chaque ligne est de la forme :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;drapeau&gt; &lt;ancien-id-objet&gt; &lt;nouveau-id-objet&gt; &lt;référence-locale&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>L&#8217;état des références à jour n&#8217;est affiché que si l&#8217;option --verbose est utilisée.</p>
</div>
<div class="paragraph">
<p>En mode de sortie compact, spécifié avec la variable de configuration fetch.output, si l&#8217;un des deux <code>&lt;de&gt;</code> ou <code>&lt;à&gt;</code> est trouvé dans l&#8217;autre chaîne, il sera substitué par <code>*</code> dans l&#8217;autre chaîne. Par exemple, <code>master -&gt; origin/master</code> devient <code>master -&gt; origin/*</code>.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-fetch-drapeau"> <a class="anchor" href="#git-fetch-drapeau"></a>drapeau </dt>
<dd>
<p>Un seul caractère indiquant le statut de la référence :</p>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-fetch-espace"> <a class="anchor" href="#git-fetch-espace"></a>(espace) </dt>
<dd>
<p>pour une récupération en avance rapide réussie ;</p>
</dd>
<dt class="hdlist1" id="git-fetch-codecode"> <a class="anchor" href="#git-fetch-codecode"></a><code>+</code> </dt>
<dd>
<p>pour une mise à jour forcée avec succès ;</p>
</dd>
<dt class="hdlist1" id="git-fetch-code-code"> <a class="anchor" href="#git-fetch-code-code"></a><code>-</code> </dt>
<dd>
<p>pour une ref. élaguée avec succès ;</p>
</dd>
<dt class="hdlist1" id="git-fetch-codetcode"> <a class="anchor" href="#git-fetch-codetcode"></a><code>t</code> </dt>
<dd>
<p>pour une mise à jour d&#8217;étiquette avec succès ;</p>
</dd>
<dt class="hdlist1" id="git-fetch-codecode-1"> <a class="anchor" href="#git-fetch-codecode-1"></a><code>*</code> </dt>
<dd>
<p>pour la récupération réussie d&#8217;une nouvelle réf. ;</p>
</dd>
<dt class="hdlist1" id="git-fetch-codecode-1-1"> <a class="anchor" href="#git-fetch-codecode-1-1"></a><code>!</code> </dt>
<dd>
<p>pour une référence qui a été rejetée ou qui n&#8217;a pas pu être mise à jour ; et</p>
</dd>
<dt class="hdlist1" id="git-fetch-codecode-1-1-1"> <a class="anchor" href="#git-fetch-codecode-1-1-1"></a><code>=</code> </dt>
<dd>
<p>pour une référence qui était à jour et n&#8217;avait pas besoin d&#8217;être récupérée.</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1" id="git-fetch-rsum"> <a class="anchor" href="#git-fetch-rsum"></a>résumé </dt>
<dd>
<p>Pour une réf récupérée avec succès, le résumé montre les anciennes et les nouvelles valeurs de la réf sous une forme qui peut être utilisée comme argument pour <code>git log</code> (c&#8217;est <code>&lt;ancien&gt;..&lt;nouveau&gt;</code> dans la plupart des cas, et <code>&lt;ancien&gt;...&lt;nouveau&gt;</code> pour les mises à jour forcées pas en avance rapide).</p>
</dd>
<dt class="hdlist1" id="git-fetch-de"> <a class="anchor" href="#git-fetch-de"></a>de </dt>
<dd>
<p>Le nom de la référence distante récupérée, moins son préfixe "refs/&lt;type&gt;/". En cas de suppression, le nom de la référence distante est "(none)".</p>
</dd>
<dt class="hdlist1" id="git-fetch-"> <a class="anchor" href="#git-fetch-"></a>à </dt>
<dd>
<p>Le nom de la référence locale en cours de mise à jour, moins son préfixe <code>refs/&lt;type&gt;/</code>.</p>
</dd>
<dt class="hdlist1" id="git-fetch-raison"> <a class="anchor" href="#git-fetch-raison"></a>raison </dt>
<dd>
<p>Une explication compréhensible. Dans le cas des références qui ont été récupérées avec succès, aucune explication n&#8217;est nécessaire. Dans le cas d&#8217;une référence en échec, la raison de l&#8217;échec est décrite.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_exemples"><a class="anchor" href="#_exemples"></a>EXEMPLES</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Mettre à jour les branches de suivi distantes :</p>
<div class="listingblock">
<div class="content">
<pre>$ git fetch origin</pre>
</div>
</div>
<div class="paragraph">
<p>La commande ci-dessus copie toutes les branches de l&#8217;espace de nom distant <code>refs/heads/</code> et les stocke dans l&#8217;espace de noms local <code>refs/remotes/origin/</code>, sauf si l&#8217;option <code>remote. &lt;dépôt&gt; .fetch</code> est utilisée pour spécifier un spécificateur de référence autre que celui par défaut.</p>
</div>
</li>
<li>
<p>En utilisant explicitement les spécificateurs de référence :</p>
<div class="listingblock">
<div class="content">
<pre>$ git fetch origin +seen:seen maint:tmp</pre>
</div>
</div>
<div class="paragraph">
<p>Cela met à jour (ou crée, si nécessaire) les branches <code>seen</code> et <code>tmp</code> dans le dépôt local en récupérant (respectivement) les branches <code>seen</code> et <code>maint</code> dans le dépôt distant.</p>
</div>
<div class="paragraph">
<p>La branche <code>seen</code> sera mise à jour même si ce n&#8217;est pas en avance rapide, car elle est préfixée par un signe plus ; <code>tmp</code> ne le sera pas.</p>
</div>
</li>
<li>
<p>Jette un coup d&#8217;œil à la branche d&#8217;un dépôt distant, sans configurer le distant dans votre dépôt local :</p>
<div class="listingblock">
<div class="content">
<pre>$ git fetch git://git.kernel.org/pub/scm/git/git.git maint
$ git log FETCH_HEAD</pre>
</div>
</div>
<div class="paragraph">
<p>La première commande récupère la branche <code>maint</code> dans le dépôt à <code>git://git.kernel.org/pub/scm/git/git.git</code> et la seconde commande utilise <code>FETCH_HEAD</code> pour examiner la branche avec <a href='{{< relurl "docs/git-log/fr" >}}'>git-log[1]</a>. Les objets récupérés seront éventuellement supprimés par le service d&#8217;entretien intégré de git (voir <a href='{{< relurl "docs/git-gc/fr" >}}'>git-gc[1]</a>).</p>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_sécurité"><a class="anchor" href="#_sécurité"></a>SÉCURITÉ</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Les protocoles "fetch" et "push" ne sont pas conçus pour empêcher un tiers de voler des données de l&#8217;autre dépôt qui n&#8217;étaient pas destinées à être partagées. Si vous avez des données privées que vous devez protéger contre un tiers malveillant, la meilleure solution est de les stocker dans un autre dépôt. Cela s&#8217;applique aussi bien aux clients qu&#8217;aux serveurs. En particulier, les espaces de noms sur un serveur ne sont pas efficaces pour le contrôle de l&#8217;accès en lecture ; vous ne devez accorder l&#8217;accès en lecture à un espace de noms qu&#8217;aux clients auxquels vous feriez confiance pour l&#8217;accès en lecture à l&#8217;ensemble du dépôt.</p>
</div>
<div class="paragraph">
<p>Les vecteurs d&#8217;attaque connus sont les suivants :</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>La victime envoie des lignes "have" annonçant les identifiants des objets qu&#8217;elle possède et qui ne sont pas explicitement destinés à être partagés, mais qui peuvent être utilisés pour optimiser le transfert si le pair les possède également. L&#8217;attaquant choisit un ID d&#8217;objet X à voler et envoie une référence à X, mais n&#8217;est pas obligé d&#8217;envoyer le contenu de X parce que la victime l&#8217;a déjà. La victime croit maintenant que l&#8217;attaquant a X, et elle lui renvoie le contenu de X plus tard. (Cette attaque est la plus simple à réaliser pour un client sur un serveur, en créant une référence à X dans l&#8217;espace de noms auquel le client a accès et en la récupérant ensuite. La façon la plus probable pour un serveur de l&#8217;exécuter sur un client est de "fusionner" X dans une branche publique et d&#8217;espérer que l&#8217;utilisateur fasse un travail supplémentaire sur cette branche et la repousse vers le serveur sans remarquer la fusion).</p>
</li>
<li>
<p>Comme en n°1, l&#8217;attaquant choisit un objet ID X à voler. La victime envoie un objet Y que l&#8217;attaquant possède déjà, et l&#8217;attaquant prétend faussement avoir X et non Y, de sorte que la victime envoie Y comme delta contre X. Le delta révèle à l&#8217;attaquant des régions de X qui sont similaires à Y.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_configuration"><a class="anchor" href="#_configuration"></a>CONFIGURATION</h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Missing <code>fr/includes/cmd-config-section-all.txt</code></p>
</div>
<div class="paragraph">
<p>See original version for this content.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Missing <code>fr/config/fetch.txt</code></p>
</div>
<div class="paragraph">
<p>See original version for this content.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_bogues"><a class="anchor" href="#_bogues"></a>BOGUES</h2>
<div class="sectionbody">
<div class="paragraph">
<p>L&#8217;utilisation de --recurse-submodules ne permet actuellement d&#8217;obtenir de nouveaux commits que dans les sous-modules qui sont présents par exemple dans \$GIT_DIR/modules/`. Lorsqu&#8217;un nouveau sous-module est ajouté en amont, le sous-module lui-même ne peut pas être récupéré, ce qui rend impossible de vérifier ce sous-module plus tard sans avoir à le récupérer à nouveau. Ce problème devrait être corrigé dans une prochaine version de Git.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_voir_aussi"><a class="anchor" href="#_voir_aussi"></a>VOIR AUSSI</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href='{{< relurl "docs/git-pull/fr" >}}'>git-pull[1]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Fait partie de la suite <a href='{{< relurl "docs/git/fr" >}}'>git[1]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_traduction"><a class="anchor" href="#_traduction"></a>TRADUCTION</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Cette  page de manuel a été traduite par Jean-Noël Avila &lt;jn.avila AT free DOT fr&gt; et les membres du projet git-manpages-l10n. Veuillez signaler toute erreur de traduction par un rapport de bogue sur le site <a href="https://github.com/jnavila/git-manpages-l10n" class="bare">https://github.com/jnavila/git-manpages-l10n</a> .</p>
</div>
</div>
</div>