---
### DO NOT EDIT! Generated by script/update-docs.rb

category: manual
section: documentation
subsection: manual
title: Git - git-fetch Documentation
docname: git-fetch
lang: pt_BR
aliases:
- "/docs/git-fetch/pt_BR/index.html"
---
<div class="sect1">
<h2 id="_nome"><a class="anchor" href="#_nome"></a>NOME</h2>
<div class="sectionbody">
<div class="paragraph">
<p>git-fetch - Faz o download dos objetos e <code>refs</code> do outro repositório</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resumo"><a class="anchor" href="#_resumo"></a>RESUMO</h2>
<div class="sectionbody">
<div class="verseblock">
<pre class="content"><em>git fetch</em> [&lt;opções&gt;] [&lt;repositório&gt; [&lt;refspec&gt;&#8230;&#8203;]]
<em>git fetch</em> [&lt;opções&gt;] &lt;grupo&gt;
<em>git fetch</em> --multiple [&lt;opções&gt;] [(&lt;repositório&gt; | &lt;grupo&gt;)&#8230;&#8203;]
<em>git fetch</em> --all [&lt;opções&gt;]</pre>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_descrição"><a class="anchor" href="#_descrição"></a>DESCRIÇÃO</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Obtenha as ramificações e/ou as etiquetas (coletivamente, "refs") de um ou mais repositórios, juntamente com os objetos necessários para completar os seus históricos. As ramificações de rastreamento remoto são atualizadas (consulte a descrição de <code>&lt;refspec&gt;</code> abaixo para obter formas de controlar este comportamento).</p>
</div>
<div class="paragraph">
<p>É predefinido que qualquer etiqueta que aponte para os históricos que estão sendo obtidos também seja obtido; o efeito é obter as etiquetas que apontem para as ramificações onde você esteja interessado. Este comportamento predefinido pode ser alterado com o uso das opções <code>--tags</code> ou <code>--no-tags</code> ou com a configuração <code>remote.&lt;nome&gt;.tagOpt</code>. Ao usar um refspec que obtenha as etiquetas de forma explícita, você também pode obter as etiquetas que não apontam para as ramificações onde você esteja interessado.</p>
</div>
<div class="paragraph">
<p>O <em>git fetch</em> pode obter num único repositório ou determinada URL, ou em vários repositórios de uma só vez se o <code>&lt;grupo&gt;</code> for usado e houver uma entrada <code>remotes.&lt;grupo&gt;</code> no arquivo de configuração. (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>).</p>
</div>
<div class="paragraph">
<p>Por predefinição quando nenhum ponto remoto é utilizado, o <code>origin</code> será utilizado, a menos que haja um ramo <code>upstream</code> configurado para o ramo atual.</p>
</div>
<div class="paragraph">
<p>Os nomes das referências que forem obtidas, juntamente com os nomes dos objetos para onde elas apontam, são gravados em <code>.git/FETCH_HEAD</code>. Estas informações podem ser usadas por scripts ou outros comandos git, como <a href='{{< relurl "docs/git-pull/pt_BR" >}}'>git-pull[1]</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_opções"><a class="anchor" href="#_opções"></a>OPÇÕES</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-fetch---no-all"> <a class="anchor" href="#git-fetch---no-all"></a>--[no-]all </dt>
<dd>
<p>Busque todas os <code>refs</code> remotos. Isso substitui a variável de configuração <code>fetch.all</code>.</p>
</dd>
<dt class="hdlist1" id="git-fetch--a"> <a class="anchor" href="#git-fetch--a"></a>-a </dt>
<dt class="hdlist1" id="git-fetch---append"> <a class="anchor" href="#git-fetch---append"></a>--append </dt>
<dd>
<p>Acrescenta os nomes das refs e os nomes dos objetos das refs obtidas ao conteúdo existente do <code>.git/FETCH_HEAD</code>. Sem essa opção, os dados antigos em <code>.git/FETCH_HEAD</code> serão substituídos.</p>
</dd>
<dt class="hdlist1" id="git-fetch---atomic"> <a class="anchor" href="#git-fetch---atomic"></a>--atomic </dt>
<dd>
<p>Utilize uma transação atômica para atualizar as refs locais. Ou todas as refs são atualizadas ou por erro, nenhuma será.</p>
</dd>
<dt class="hdlist1" id="git-fetch---depthltprofundidadegt"> <a class="anchor" href="#git-fetch---depthltprofundidadegt"></a>--depth=&lt;profundidade&gt; </dt>
<dd>
<p>Limite a captura para uma quantidade específica de commits na ponta do histórico de cada ramificação remota. Caso esteja capturando um repositório <em>shallow</em> (superficial) criado pelo <code>git clone</code> com a opção <code>--depth=&lt;profundidade&gt;</code> (consulte <a href='{{< relurl "docs/git-clone/pt_BR" >}}'>git-clone[1]</a>), aprofunde ou encurte o histórico para a quantidade usada de commits. As tags para os commits aprofundados não são capturados.</p>
</dd>
<dt class="hdlist1" id="git-fetch---deepenltprofundidadegt"> <a class="anchor" href="#git-fetch---deepenltprofundidadegt"></a>--deepen=&lt;profundidade&gt; </dt>
<dd>
<p>Semelhante a opção <code>--depth</code>, exceto que especifica a quantidade de commits do limite raso atual em vez da ponta de cada histórico do ramo remoto.</p>
</dd>
<dt class="hdlist1" id="git-fetch---shallow-sinceltdatagt"> <a class="anchor" href="#git-fetch---shallow-sinceltdatagt"></a>--shallow-since=&lt;data&gt; </dt>
<dd>
<p>Aprofunde ou encurte o histórico de um repositório raso para incluir todas os commits acessíveis após a &lt;data&gt;.</p>
</dd>
<dt class="hdlist1" id="git-fetch---shallow-excludeltrevisogt"> <a class="anchor" href="#git-fetch---shallow-excludeltrevisogt"></a>--shallow-exclude=&lt;revisão&gt; </dt>
<dd>
<p>Aprofunde ou reduza o histórico de um repositório superficial para excluir os commits acessíveis a partir de um ramo ou tag remoto informada. Esta opção pode ser utilizada várias vezes.</p>
</dd>
<dt class="hdlist1" id="git-fetch---unshallow"> <a class="anchor" href="#git-fetch---unshallow"></a>--unshallow </dt>
<dd>
<p>Caso o repositório de origem esteja completo, converta um repositório raso num completo, removendo todas as limitações impostas pelos repositórios rasos.</p>
<div class="paragraph">
<p>Caso o repositório de origem seja superficial, busque o máximo possível para que o repositório atual tenha o mesmo histórico que o repositório de origem.</p>
</div>
</dd>
<dt class="hdlist1" id="git-fetch---update-shallow"> <a class="anchor" href="#git-fetch---update-shallow"></a>--update-shallow </dt>
<dd>
<p>É predefinido que durante a captura num repositório superficial, o <code>git fetch</code> recuse os refs que exijam a atualização do <code>.git/shallow</code>. Esta opção atualiza o <code>.git/shallow</code> e aceita tais refs.</p>
</dd>
<dt class="hdlist1" id="git-fetch---negotiation-tipltcommitglobgt"> <a class="anchor" href="#git-fetch---negotiation-tipltcommitglobgt"></a>--negotiation-tip=&lt;commit|glob&gt; </dt>
<dd>
<p>É predefinido que o Git relate ao servidor os commits acessíveis a partir de todas as refs locais para encontrar commits comuns numa tentativa de reduzir o tamanho do pacote dos arquivos que serão recebidos. Se for especificado, o Git relatará apenas os commits acessíveis a partir das dicas fornecidas. Isso é útil para acelerar as obtenções quando o usuário sabe qual ref local provavelmente terá commits em comum com a ref upstream que está sendo buscada.</p>
<div class="paragraph">
<p>Esta opção pode ser utilizada mais de uma vez; Se assim for, o Git irá reportar os commits de qualquer um dos commits informados.</p>
</div>
<div class="paragraph">
<p>O argumento para esta opção pode ser um "ref" aos nomes de referência, uma referência ou o (possivelmente abreviado) SHA-1 de um commit. Especificar um agrupamento é o equivalente a utilizar esta opção várias vezes, uma para cada nome "ref" coincidente.</p>
</div>
<div class="paragraph">
<p>Consulte também a variável de configuração <code>fetch.negotiationAlgorithm</code> e <code>push.negotiate</code> documentada em <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a> e na opção <code>--negotiate-only</code> abaixo.</p>
</div>
</dd>
<dt class="hdlist1" id="git-fetch---negotiate-only"> <a class="anchor" href="#git-fetch---negotiate-only"></a>--negotiate-only </dt>
<dd>
<p>Não busque nada do servidor e imprima os argumentos <code>--negotiation-tip=*</code> fornecidos anteriormente e que nós temos em comum com o servidor.</p>
<div class="paragraph">
<p>Isso é incompatível com <code>--recurse-submodules=[yes|on-demand]</code>. Internamente, isso é usado para implementar a opção <code>push.negotiate</code>, para mais detalhes consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>.</p>
</div>
</dd>
<dt class="hdlist1" id="git-fetch---dry-run"> <a class="anchor" href="#git-fetch---dry-run"></a>--dry-run </dt>
<dd>
<p>Exiba apenas o que seria feito, sem fazer quaisquer alterações.</p>
</dd>
<dt class="hdlist1" id="git-fetch---porcelain"> <a class="anchor" href="#git-fetch---porcelain"></a>--porcelain </dt>
<dd>
<p>Imprima na saída padrão num formato fácil para scripts. Consulte a seção OUTPUT em <a href='{{< relurl "docs/git-fetch/pt_BR" >}}'>git-fetch[1]</a> para obter mais detalhes.</p>
<div class="paragraph">
<p>Isso é compatível com a opção <code>--recurse-submodules=[yes|on-demand]</code> e tem precedência sobre a opção de configuração <code>fetch.output</code>.</p>
</div>
</dd>
<dt class="hdlist1" id="git-fetch---no-write-fetch-head"> <a class="anchor" href="#git-fetch---no-write-fetch-head"></a>--[no-]write-fetch-head </dt>
<dd>
<p>Escreva a lista de refs remotas obtidas no arquivo <code>FETCH_HEAD</code> diretamente em <code>$GIT_DIR</code>. Esta é a predefinição. Usar a opção <code>--no-write-fetch-head</code> na linha de comando diz ao Git para não escrever o arquivo. Na opção <code>--dry-run</code>, o arquivo nunca é gravado.</p>
</dd>
<dt class="hdlist1" id="git-fetch--f"> <a class="anchor" href="#git-fetch--f"></a>-f </dt>
<dt class="hdlist1" id="git-fetch---force"> <a class="anchor" href="#git-fetch---force"></a>--force </dt>
<dd>
<p>Quando <em>git fetch</em> é utilizado com <code>&lt;src&gt;:&lt;dst&gt;</code> "refspec", ele pode se recusar a atualizar o ramo local como discutido
na parte <code>&lt;refspec&gt;</code> abaixo.
Esta opção sobrescreve esta verificação.</p>
</dd>
<dt class="hdlist1" id="git-fetch--k"> <a class="anchor" href="#git-fetch--k"></a>-k </dt>
<dt class="hdlist1" id="git-fetch---keep"> <a class="anchor" href="#git-fetch---keep"></a>--keep </dt>
<dd>
<p>Mantenha o pacote que foi baixado.</p>
</dd>
<dt class="hdlist1" id="git-fetch---multiple"> <a class="anchor" href="#git-fetch---multiple"></a>--multiple </dt>
<dd>
<p>Permita que vários argumentos &lt;repositório&gt; e &lt;grupo&gt; sejam utilizados. Nenhum <code>&lt;refspec&gt;</code> pode ser utilizado.</p>
</dd>
<dt class="hdlist1" id="git-fetch---no-auto-maintenance"> <a class="anchor" href="#git-fetch---no-auto-maintenance"></a>--[no-]auto-maintenance </dt>
<dt class="hdlist1" id="git-fetch---no-auto-gc"> <a class="anchor" href="#git-fetch---no-auto-gc"></a>--[no-]auto-gc </dt>
<dd>
<p>Execute <code>git maintenance run --auto</code> no final para realizar a manutenção automática do repositório, caso seja necessário. (<code>--[no-]auto-gc</code> é um sinônimo.) A predefinição é ativado.</p>
</dd>
<dt class="hdlist1" id="git-fetch---no-write-commit-graph"> <a class="anchor" href="#git-fetch---no-write-commit-graph"></a>--[no-]write-commit-graph </dt>
<dd>
<p>Grave um grafo do commit após a captura remota. Este sobrescreve a configuração <code>fetch.writeCommitGraph</code>.</p>
</dd>
<dt class="hdlist1" id="git-fetch---prefetch"> <a class="anchor" href="#git-fetch---prefetch"></a>--prefetch </dt>
<dd>
<p>Altere o refspec configurado para colocar todos os refs no namespace <code>refs/prefetch/</code>. Consulte a tarefa <code>prefetch</code> em <a href='{{< relurl "docs/git-maintenance/pt_BR" >}}'>git-maintenance[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-fetch--p"> <a class="anchor" href="#git-fetch--p"></a>-p </dt>
<dt class="hdlist1" id="git-fetch---prune"> <a class="anchor" href="#git-fetch---prune"></a>--prune </dt>
<dd>
<p>Antes de obter, remova todas as referências de rastreamento remoto que não existam mais no ramo remoto. As tags não estão sujeitas à poda se forem apenas obtidas devido ao acompanhamento automático da tag predefinida ou devido a uma opção <code>--tags</code>. No entanto, se as tags forem obtidas através de uma refspec explícita (na linha de comando ou na configuração remota, por exemplo, se o ramo remoto tiver sido clonado com a opção <code>--mirror</code>), elas também estarão sujeitas à poda. Usar a opção <code>--prune-tags</code> é um atalho para fornecer a tag refspec.</p>
<div class="paragraph">
<p>Consulte a seção de PRUNING abaixo para mais detalhes.</p>
</div>
</dd>
<dt class="hdlist1" id="git-fetch--P"> <a class="anchor" href="#git-fetch--P"></a>-P </dt>
<dt class="hdlist1" id="git-fetch---prune-tags"> <a class="anchor" href="#git-fetch---prune-tags"></a>--prune-tags </dt>
<dd>
<p>Antes de capturar, remova as tags locais que não existam mais remotamente caso a opção <code>--prune</code> esteja ativa. Esta opção deve ser utilizada com mais cuidado, ao contrário da opção <code>--prune</code>, ela removerá todas as referências locais (tags locais) que forem criadas. Esta opção é um atalho para informar a tag explícita refspec junto com a opção <code>--prune</code>, consulte a discussão sobre isso em sua documentação.</p>
<div class="paragraph">
<p>Consulte a seção de PRUNING abaixo para mais detalhes.</p>
</div>
</dd>
<dt class="hdlist1" id="git-fetch--n"> <a class="anchor" href="#git-fetch--n"></a>-n </dt>
<dt class="hdlist1" id="git-fetch---no-tags"> <a class="anchor" href="#git-fetch---no-tags"></a>--no-tags </dt>
<dd>
<p>É predefinido que as tags que apontam para objetos que são baixados do repositório remoto são obtidas e armazenadas localmente. Essa opção desativa o acompanhamento automático de tags. O comportamento padrão de um ramo remoto pode ser especificado com a configuração remote.&lt;nome&gt;.tagOpt. Consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-fetch---refetch"> <a class="anchor" href="#git-fetch---refetch"></a>--refetch </dt>
<dd>
<p>Em vez de negociar com o servidor para evitar a transferência dos commits e dos objetos associados que já estão presentes no local, esta opção faz a busca de todos os objetos da mesma maneira que seria feito com um novo clone. Use isso para reaplicar um filtro de clone parcial da configuração ou usando <code>--filter=</code> quando a definição do filtro for alterada. A manutenção automática pós-busca realizará a consolidação do pacote no banco de dados dos objetos para seja removido quaisquer objetos duplicados.</p>
</dd>
<dt class="hdlist1" id="git-fetch---refmapltrefspecgt"> <a class="anchor" href="#git-fetch---refmapltrefspecgt"></a>--refmap=&lt;refspec&gt; </dt>
<dd>
<p>Ao obter as refs listadas na linha de comando, use o refspec especificado (pode ser usado mais de uma vez) para mapear as refs nas ramificações de rastreamento remoto, em vez dos valores das variáveis de configuração <code>remote.*.fetch</code> do repositório remoto. Fornecer um <code>&lt;refspec&gt;</code> vazio para a opção <code>--refmap</code> faz com que o Git ignore os refspecs configurados e confie inteiramente nos refspecs fornecidos como argumentos da linha de comando. Consulte a seção "Configurações dos Ramos Monitorados Remotamente" para obter detalhes.</p>
</dd>
<dt class="hdlist1" id="git-fetch--t"> <a class="anchor" href="#git-fetch--t"></a>-t </dt>
<dt class="hdlist1" id="git-fetch---tags"> <a class="anchor" href="#git-fetch---tags"></a>--tags </dt>
<dd>
<p>Obtém todas as tags do ramo remoto (ou seja, obtém as tags remotas <code>refs/tags/*</code> em tags locais com o mesmo nome), além de tudo o que seria obtido de outra maneira. O uso dessa opção por si só não sujeita as tags à poda, mesmo que a opção --prune seja usada (embora as tags possam ser podadas de qualquer forma se também forem o destino de um "refspec" explícito; consulte <code>--prune</code>).</p>
</dd>
<dt class="hdlist1" id="git-fetch---recurse-submodulesyeson-demandno"> <a class="anchor" href="#git-fetch---recurse-submodulesyeson-demandno"></a>--recurse-submodules[=(yes|on-demand|no)] </dt>
<dd>
<p>Essa opção controla se e sob quais condições os novos commits dos submódulos também devem ser obtidos. Ao percorrer os submódulos, o <code>git fetch</code> sempre tenta obter os submódulos "alterados", ou seja, um submódulo que tenha commits referenciados por um commit de superprojeto recém-buscado, mas que esteja faltando no clone do submódulo local. Um submódulo alterado pode ser buscado desde que esteja presente localmente, por exemplo, em <code>$GIT_DIR/modules/</code> (consulte <a href='{{< relurl "docs/gitsubmodules/pt_BR" >}}'>gitsubmodules[7]</a>); se o upstream adicionar um novo submódulo, esse submódulo não poderá ser buscado até que seja clonado, por exemplo, pelo comando <code>git submodule update</code>.</p>
<div class="paragraph">
<p>Quando for definido como <em>sob demanda</em>, apenas os submódulos que tenham sido alterados são buscados. Quando for definido como <em>yes</em>, todos os submódulos que tenham sido colonizados ou não, assim como tenham sido alterados, todos eles serão buscados . Quando for definido como <em>no</em>, os submódulos nunca serão buscados.</p>
</div>
<div class="paragraph">
<p>Quando não especificado, utiliza o valor de <code>fetch.recurseSubmodules</code> se estiver definido (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>), tendo como predefinição <em>on-demand</em> caso não esteja definido. Quando essa opção é usada sem nenhum valor, a predefinição é <em>yes</em>.</p>
</div>
</dd>
<dt class="hdlist1" id="git-fetch--j"> <a class="anchor" href="#git-fetch--j"></a>-j </dt>
<dt class="hdlist1" id="git-fetch---jobsltngt"> <a class="anchor" href="#git-fetch---jobsltngt"></a>--jobs=&lt;n&gt; </dt>
<dd>
<p>A quantidade de processos paralelos que serão utilizados para todas as formas de captura.</p>
<div class="paragraph">
<p>Caso a opção <code>--multiple</code> seja utilizada, os diferentes ramos remotos serão capturados em paralelo. Caso vários submódulos sejam capturados, estes serão capturados em paralelo. Para controlá-los de forma independente, utilize as definições da configuração <code>fetch.parallel</code> e <code>submodule.fetchJobs</code> (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>).</p>
</div>
<div class="paragraph">
<p>Normalmente, as capturas remotas dos múltiplos ramos de forma paralela e recursiva serão mais rápidas. A predefinição é realizar as capturas em sequência e não em paralelo.</p>
</div>
</dd>
<dt class="hdlist1" id="git-fetch---no-recurse-submodules"> <a class="anchor" href="#git-fetch---no-recurse-submodules"></a>--no-recurse-submodules </dt>
<dd>
<p>Desative a captura recursiva dos submódulos (tem o mesmo efeito que utilizar a opção <code>--recurse-submodules=no</code>).</p>
</dd>
<dt class="hdlist1" id="git-fetch---set-upstream"> <a class="anchor" href="#git-fetch---set-upstream"></a>--set-upstream </dt>
<dd>
<p>Caso a captura remota seja bem sucedida, uma referência de rastreamento <code>add</code> será adicionada ao upstream, utilizado pelo argumento <code>less</code> <a href='{{< relurl "docs/git-pull/pt_BR" >}}'>git-pull[1]</a> e outros comandos. Para mais informações, consulte <code>branch.&lt;nome&gt;.merge</code> e <code>branch.&lt;nome&gt;.remote</code> em <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-fetch---submodule-prefixltcaminhogt"> <a class="anchor" href="#git-fetch---submodule-prefixltcaminhogt"></a>--submodule-prefix=&lt;caminho&gt; </dt>
<dd>
<p>Acrescenta &lt;caminho&gt; aos caminhos impressos nas mensagens informativas, como "Fetching submodule foo". Essa opção é usada internamente quando se recorre a submódulos.</p>
</dd>
<dt class="hdlist1" id="git-fetch---recurse-submodules-defaultyeson-demand"> <a class="anchor" href="#git-fetch---recurse-submodules-defaultyeson-demand"></a>--recurse-submodules-default=[yes|on-demand] </dt>
<dd>
<p>Essa opção é usada internamente para fornecer temporariamente um valor predefinido não negativo para a opção <code>--recurse-submodules</code>. Todos os outros métodos de configuração da recursão do submódulo fetch (como as configurações do comando <a href='{{< relurl "docs/gitmodules/pt_BR" >}}'>gitmodules[5]</a> e <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>) substituem essa opção, assim como especificar <code>--[no-]recurse-submodules</code> diretamente.</p>
</dd>
<dt class="hdlist1" id="git-fetch--u"> <a class="anchor" href="#git-fetch--u"></a>-u </dt>
<dt class="hdlist1" id="git-fetch---update-head-ok"> <a class="anchor" href="#git-fetch---update-head-ok"></a>--update-head-ok </dt>
<dd>
<p>É predefinido que o comando "git fetch" se recuse a atualizar o cabeçalho correspondente ao ramo atual. Esta opção desativa a verificação. Isso serve apenas para uso interno do comando "git pull" para se comunicar com o comando "git fetch" e, a menos que você esteja implementando a sua própria porcelana, você não deve usá-lo.</p>
</dd>
<dt class="hdlist1" id="git-fetch---upload-packltpacote-para-enviogt"> <a class="anchor" href="#git-fetch---upload-packltpacote-para-enviogt"></a>--upload-pack &lt;pacote-para-envio&gt; </dt>
<dd>
<p>Quando o repositório é informado para capturar e que seja manipulado por <em>git fetch-pack</em>, o <code>--exec=&lt;upload-pack&gt;</code> é passado para o comando utilizar um caminho alternativo para o comando executado na outra extremidade.</p>
</dd>
<dt class="hdlist1" id="git-fetch--q"> <a class="anchor" href="#git-fetch--q"></a>-q </dt>
<dt class="hdlist1" id="git-fetch---quiet"> <a class="anchor" href="#git-fetch---quiet"></a>--quiet </dt>
<dd>
<p>Repasse a opção <code>--quiet</code> para o <code>git-fetch-pack</code> e silencie qualquer outro comando git utilizado internamente. O progresso não é relatado para o fluxo de erro predefinido.</p>
</dd>
<dt class="hdlist1" id="git-fetch--v"> <a class="anchor" href="#git-fetch--v"></a>-v </dt>
<dt class="hdlist1" id="git-fetch---verbose"> <a class="anchor" href="#git-fetch---verbose"></a>--verbose </dt>
<dd>
<p>Seja loquaz.</p>
</dd>
<dt class="hdlist1" id="git-fetch---progress"> <a class="anchor" href="#git-fetch---progress"></a>--progress </dt>
<dd>
<p>É predefinido que a condição geral do progresso seja relatada no fluxo de erros quando estiver conectado num terminal, a menos que <code>-q</code> seja utilizado. Esta opção impõem a condição geral do progresso, mesmo que o fluxo de erro predefinido não seja direcionado para um terminal.</p>
</dd>
<dt class="hdlist1" id="git-fetch--oltopogt"> <a class="anchor" href="#git-fetch--oltopogt"></a>-o &lt;opção&gt; </dt>
<dt class="hdlist1" id="git-fetch---server-optionltopogt"> <a class="anchor" href="#git-fetch---server-optionltopogt"></a>--server-option=&lt;opção&gt; </dt>
<dd>
<p>Transmita a sequência usada para o servidor ao se comunicar utilizando o protocolo versão 2. A sequência informada não deve conter um caractere <code>NUL</code> ou <code>LF</code>. O tratamento das opções do servidor, incluindo os desconhecidos, é específico do servidor. Quando a opção <code>--server-option=&lt;opção&gt;</code> forem utilizadas várias vezes, todos serão enviados para o outro lado na ordem listada na linha de comando.</p>
</dd>
<dt class="hdlist1" id="git-fetch---show-forced-updates"> <a class="anchor" href="#git-fetch---show-forced-updates"></a>--show-forced-updates </dt>
<dd>
<p>É predefinido que o git verifique se uma ramificação é atualizada à força durante o fetch. Isso pode ser desativado através do fetch.showForcedUpdates, mas a opção <code>--show-forced-updates</code> garante que essa verificação ocorra. Consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-fetch---no-show-forced-updates"> <a class="anchor" href="#git-fetch---no-show-forced-updates"></a>--no-show-forced-updates </dt>
<dd>
<p>É predefinido que o Git verifique se a atualização do ramo foi imposta durante uma captura. Utilize a opção <code>--no-show-forced-updates</code> ou defina <code>fetch.showForcedUpdates</code> como to <code>false</code> para ignorar esta verificação por questões de desempenho. Se utilizada durante o <code>git-pull</code>, a opção <code>--ff-only</code> ainda verificará quais as atualizações foram impostas antes de tentar uma atualização rápida. Consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>.</p>
</dd>
<dt class="hdlist1" id="git-fetch--4"> <a class="anchor" href="#git-fetch--4"></a>-4 </dt>
<dt class="hdlist1" id="git-fetch---ipv4"> <a class="anchor" href="#git-fetch---ipv4"></a>--ipv4 </dt>
<dd>
<p>Utilize apenas os endereços IPv4, ignorando os endereços IPv6.</p>
</dd>
<dt class="hdlist1" id="git-fetch--6"> <a class="anchor" href="#git-fetch--6"></a>-6 </dt>
<dt class="hdlist1" id="git-fetch---ipv6"> <a class="anchor" href="#git-fetch---ipv6"></a>--ipv6 </dt>
<dd>
<p>Utilize apenas os endereços IPv6, ignorando os endereços IPv4.</p>
</dd>
</dl>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-fetch-ltrepositriogt"> <a class="anchor" href="#git-fetch-ltrepositriogt"></a>&lt;repositório&gt; </dt>
<dd>
<p>O repositório "remote" é a fonte de uma operação <em>fetch</em> ou <em>pull</em>. Este parâmetro pode ser uma URL (consulte a seção <a href="#URLS">GIT URLS</a> abaixo) ou o nome de um controle remoto (consulte a seção <a href="#REMOTES">RAMOS REMOTOS</a> abaixo).</p>
</dd>
<dt class="hdlist1" id="git-fetch-ltgrupogt"> <a class="anchor" href="#git-fetch-ltgrupogt"></a>&lt;grupo&gt; </dt>
<dd>
<p>Um nome referente a uma lista de repositórios remotos como o valor de <code>remotes.&lt;grupo&gt;</code> no arquivo de configuração. (consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>).</p>
</dd>
<dt class="hdlist1" id="git-fetch-ltrefspecgt"> <a class="anchor" href="#git-fetch-ltrefspecgt"></a>&lt;refspec&gt; </dt>
<dd>
<p>Especifica quais as refs que devem ser obtidas via <em>fetch</em> e quais as refs locais devem ser atualizadas. Quando não houver um <code>&lt;refspec&gt;</code> na linha de comando, as refs que serão obtidas com <em>fetch</em> serão lidas a partir das variáveis <code>remote.&lt;repositório&gt;.fetch</code>
(consulte <a href="#CRTB">CONFIGURAÇÕES DOS RAMOS MONITORADOS REMOTAMENTE</a> below).</p>
<div class="paragraph">
<p>O formato de um parâmetro <code>&lt;refspec&gt;</code> é um sinal de adição opcional <code>+</code>, seguido pela origem <code>&lt;src&gt;</code>, seguido por dois-pontos <code>:</code>, seguido pela referência de destino <code>&lt;dst&gt;</code>. Os dois-pontos podem ser omitidos quando o valor de <code>&lt;dst&gt;</code> estiver vazio. O valor de <code>&lt;src&gt;</code> normalmente é uma referência, mas também pode ser um nome de um objeto hexadecimal inteiramente escrito.</p>
</div>
<div class="paragraph">
<p>Uma &lt;refspec&gt; pode conter um <code>*</code> na sua origem &lt;src&gt; para indicar uma simples combinação de padrões. Tal "refspec" funciona como um "glob" que combina com qualquer ref de mesmo prefixo. Um padrão &lt;refspec&gt; deve conter um <code>*</code> tanto origem &lt;src&gt; quanto no destino &lt;dst&gt;. Ele irá mapear os reffs para o destino substituindo o <code>*</code> pelo conteúdo correspondente da fonte.</p>
</div>
<div class="paragraph">
<p>Se um <em>refspec</em> for prefixado por <code>^</code>, ele será interpretado como um refspec negativo. Em vez de especificar quais as <em>refs</em> devem ser obtidas com <em>fetch</em> ou quais as refs locais devem ser atualizadas, esta refspec especificará as refs que serão excluídas. Uma ref será considerada compatível se corresponder a pelo menos uma refspec positiva e não corresponder a nenhuma refspec negativa. As refspecs negativas podem ser úteis para restringir o escopo de um padrão refspec para que não inclua refs específicas. As refspecs negativas podem ser refspecs de padrão. No entanto, eles podem conter apenas um <code>&lt;src&gt;</code> e não especificar um <code>&lt;dst&gt;</code>. Também não há suporte para nomes de objetos hexadecimais totalmente mencionados.</p>
</div>
<div class="paragraph">
<p>A <code>tag</code> significa o mesmo que <code>refs/tags/&lt;tag&gt;:refs/tags/&lt;tag&gt;</code>; ele solicita a buscaa de tudo até a tag informada.</p>
</div>
<div class="paragraph">
<p>A "ref" remota que coincida com &lt;src&gt; é buscada e se &lt;dst&gt; não seja uma sequência vazia, é feita uma tentativa de atualizar a referência local que coincida com ela.</p>
</div>
<div class="paragraph">
<p>Caso a atualização seja permitida sem a opção <code>--force</code> depende do espaço de nomes da ref onde está sendo buscada, do tipo do objeto que está sendo buscado e se a atualização é considerada um avanço rápido. Geralmente, as mesmas regras se aplicam à busca e ao impulsionar, consulte a seção <code>&lt;refspec&gt;...</code> do <a href='{{< relurl "docs/git-push/pt_BR" >}}'>git-push[1]</a> para saber o que são. As exceções para estas regras específicas para o comando <em>git fetch</em> são anotadas abaixo.</p>
</div>
<div class="paragraph">
<p>Até a versão 2.20 do Git, e ao contrário do que ocorre quando se faz um push com <a href='{{< relurl "docs/git-push/pt_BR" >}}'>git-push[1]</a>, quaisquer atualizações para <code>refs/tags/*</code> seriam aceitas sem <code>+</code> no refspec (ou a opção <code>--force</code>). Ao fazer a obtenção com <em>fetch</em>, consideramos promiscuamente todas as atualizações das etiquetas de um ramo remoto como sendo um <em>fetch</em> forçado. Desde a versão 2.20 do Git, a busca para atualizar <code>refs/tags/*</code> funciona da mesma forma que o push. Ou seja, todas as atualizações serão rejeitadas sem <code>+</code> no refspec (ou <code>--force</code>).</p>
</div>
<div class="paragraph">
<p>Ao contrário quando impulsionamos com o <a href='{{< relurl "docs/git-push/pt_BR" >}}'>git-push[1]</a>, qualquer atualização fora do <code>refs/{tags,heads}/*</code> será aceito sem o sinal <code>+</code> no refspec (ou <code>--force</code>), seja trocando, por exemplo, um objeto de árvore para uma bolha ou um commit para outro commit que não tenha o commit anterior como ancestral, etc.</p>
</div>
<div class="paragraph">
<p>Ao contrário quando impulsionamos com o <a href='{{< relurl "docs/git-push/pt_BR" >}}'>git-push[1]</a>, não existe uma configuração que corrija estas regras, e nada como um gancho <code>pre-fetch</code> análogo ao gancho <code>pre-receive</code>.</p>
</div>
<div class="paragraph">
<p>Assim como impulsionar com <a href='{{< relurl "docs/git-push/pt_BR" >}}'>git-push[1]</a>, todas as regras descritas acima sobre o que não é permitido como uma atualização pode ser sobrescrito ao adicionar um caractere opcional no "refspec" começando com <code>+</code> (ou ao utilizar a opção <code>--force</code> na linha de comando). A única exceção a isso é que nenhuma quantidade de imposição fará com que o espaço de nomes <code>refs/heads/*</code> aceite um objeto que não seja um commit.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Quando o ramo remoto que você deseja obter com <em>fetch</em> for conhecido por ser rebobinado ter feito um <em>rebase</em> regularmente, espera-se que o novo cume não seja descendente do cume anterior (conforme foi armazenado no último <em>fetch</em> que você fez no ramo rastreado remotamente). Você deve usar o sinal <code>+</code> para indicar que serão necessárias atualizações que não sejam de avanço rápido para estas ramificações. Não há nenhuma maneira de determinar ou declarar que um ramo será disponibilizado num repositório com este comportamento; o usuário que o extrai simplesmente deve saber que esse é o padrão de uso esperado para um ramo.
</td>
</tr>
</table>
</div>
</dd>
</dl>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-fetch---stdin"> <a class="anchor" href="#git-fetch---stdin"></a>--stdin </dt>
<dd>
<p>Faz a leitura linha a linha dos refspecs a partir do stdin adicionalmente aqueles fornecidos pelos argumentos. O formato "tag &lt;nome&gt;" não é compatível.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git_urls"><a class="anchor" href="#_git_urls"></a>GIT URLS<a id="URLS"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Em geral as URLs contêm informações sobre o protocolo de transporte, o endereço do servidor remoto e o caminho para o repositório. Dependendo do protocolo de transporte, algumas dessas informações podem estar ausentes.</p>
</div>
<div class="paragraph">
<p>O Git suporta os protocolos ssh, git, http e https (além do ftp e ftps podem ser utilizados para captura (feching), porém é ineficiente e obsoleto; não os utilize).</p>
</div>
<div class="paragraph">
<p>O transporte nativo (ou seja, git:// URL) não faz a autenticação e deve ser utilizado com cuidado em redes sem segurança.</p>
</div>
<div class="paragraph">
<p>As seguintes sintaxes podem ser utilizadas com eles:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ssh://[user@]host.xz[:port]/caminho/para/o/repositório.git/</p>
</li>
<li>
<p>git://host.xz[:port]/caminho/para/o/repositório.git/</p>
</li>
<li>
<p>http[s]://host.xz[:port]/caminho/para/o/repositório.git/</p>
</li>
<li>
<p>ftp[s]://host.xz[:port]/caminho/para/o/repositório.git/</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Uma sintaxe alternativa como scp também pode ser utilizada com o protocolo ssh:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>[user@]host.xz:caminho/para/o/repositório.git/</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Essa sintaxe apenas é reconhecida caso não haja barras antes dos primeiros dois pontos. Isso ajuda a diferenciar um caminho local que contém dois pontos. Por exemplo, o caminho local <code>foo:bar</code> pode ser utilizado como um caminho absoluto ou <code>./foo:bar</code> para evitar ser mal interpretado como uma url ssh.</p>
</div>
<div class="paragraph">
<p>Os protocolos ssh e git também oferecem suporte à expansão do ~nome do usuário:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ssh://[user@]host.xz[:port]/~[user]/caminho/para/o/repositório.git/</p>
</li>
<li>
<p>git://host.xz[:port]/~[user]/caminho/para/o/repositório.git/</p>
</li>
<li>
<p>[user@]host.xz:/~[user]/caminho/para/o/repositório.git/</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para os repositórios locais, as seguintes sintaxes podem ser utilizadas que também são compatíveis de forma nativa pelo Git:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>/caminho/para/o/repositório.git/</p>
</li>
<li>
<p>file:///caminho/para/o/repositório.git/</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Estas duas sintaxes são basicamente equivalentes, exceto durante a clonagem, quando a primeira implica no uso da opção <code>--local</code>. Para mais detalhes, consulte <a href='{{< relurl "docs/git-clone/pt_BR" >}}'>git-clone[1]</a>.</p>
</div>
<div class="paragraph">
<p>O <em>git clone</em>, <em>git fetch</em> e <em>git pull</em>, mas não o <em>git push</em>, também aceitarão um arquivo do pacote adequado. Consulte <a href='{{< relurl "docs/git-bundle/pt_BR" >}}'>git-bundle[1]</a>.</p>
</div>
<div class="paragraph">
<p>Quando o Git não sabe como lidar com um determinado protocolo de transporte, quando existe, ele tenta usar o auxiliar <code>remote-&lt;transporte&gt;</code>. Para os repositórios locais, as seguintes sintaxes podem ser utilizadas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>&lt;transporte&gt;::&lt;endereço&gt;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>onde &lt;endereço&gt; pode ser um caminho, um servidor e um caminho ou uma sequência arbitrária semelhante a uma URL reconhecida por um auxiliar remoto em específico que está sendo chamado. Para mais detalhes, consulte <a href='{{< relurl "docs/gitremote-helpers/pt_BR" >}}'>gitremote-helpers[7]</a>.</p>
</div>
<div class="paragraph">
<p>Se houver um grande número de repositórios remotos com nomes semelhantes e caso queira usar um formato diferente para eles (de modo que as URLs utilizadas sejam reescritas nas URLs que funcionam), você poderá criar uma seção de configuração da opção:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	[url "&lt;url-da-base-atual&gt;"]
		insteadOf = &lt;url-da-outra-base&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Por exemplo, com isso:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	[url "git://git.host.xz/"]
		insteadOf = host.xz:/path/to/
		insteadOf = work:</pre>
</div>
</div>
<div class="paragraph">
<p>uma URL como "work:repo.git" ou como "host.xz:/caminho/para/o/repositório.git" será reescrito em qualquer contexto onde a URL seja "git://git.host.xz/repo.git".</p>
</div>
<div class="paragraph">
<p>Caso queira reescrever apenas as URLs para envio por "push" (impulsionamento), é possível criar uma seção de configuração da opção:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	[url "&lt;url da base atual&gt;"]
		pushInsteadOf = &lt;a url da outra base&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Por exemplo, com isso:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	[url "ssh://exemplo.org/"]
		pushInsteadOf = git://exemplo.org/</pre>
</div>
</div>
<div class="paragraph">
<p>uma URL como "git://exemplo.org/caminho/para/o/repositório.git" será reescrito para "ssh://exemplo.org/caminho/para/o/repositório.git" para os "pushes" (impulsionamentos), porém os "pulls" (obtenções) ainda usarão a URL original.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_remotos"><a class="anchor" href="#_remotos"></a>REMOTOS<a id="REMOTES"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>O nome de um dos seguintes pode ser usado em vez de uma URL como argumento do <code>&lt;repositório&gt;</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>um ramo remoto no arquivo de configuração do Git: <code>$GIT_DIR/config</code>,</p>
</li>
<li>
<p>um arquivo no diretório <code>$GIT_DIR/remotes</code> ou</p>
</li>
<li>
<p>um arquivo no diretório <code>$GIT_DIR/branches</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Tudo isso também permite seja omitido o refspec da linha de comando, pois cada um contém um refspec que o git utilizará de maneira predefinida.</p>
</div>
<div class="sect2">
<h3 id="_ramo_remoto_nomeado_no_arquivo_de_configuração"><a class="anchor" href="#_ramo_remoto_nomeado_no_arquivo_de_configuração"></a>Ramo remoto nomeado no arquivo de configuração</h3>
<div class="paragraph">
<p>Você pode optar por mencionar o nome de um ramo remoto que você configurou anteriormente usando o comando <a href='{{< relurl "docs/git-remote/pt_BR" >}}'>git-remote[1]</a>, <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a> ou até mesmo por uma edição manual no arquivo <code>$GIT_DIR/config</code>. A URL deste ramo remoto será usada para acessar o repositório. O "refspec" deste ramo remoto será usado por padrão quando você não fornecer um "refspec" na linha de comando. A entrada no arquivo de configuração teria a seguinte aparência:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	[remote "&lt;nome&gt;"]
		url = &lt;URL&gt;
		pushurl = &lt;pushurl&gt;
		push = &lt;refspec&gt;
		fetch = &lt;refspec&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>O <code>&lt;pushurl&gt;</code> é usado somente para envios. É opcional e o padrão é <code>&lt;URL&gt;</code>. O envio para um controle remoto afeta todos os pushurls definidos ou todos as urls definidas se não houver pushurls definidos. No entanto, o Fetch só buscará a primeira url definida caso haja várias urls definidas.</p>
</div>
</div>
<div class="sect2">
<h3 id="_arquivo_nomeado_no_git_dirremotes"><a class="anchor" href="#_arquivo_nomeado_no_git_dirremotes"></a>Arquivo nomeado no <code>$GIT_DIR/remotes</code></h3>
<div class="paragraph">
<p>Você pode optar por fornecer o nome de um arquivo em <code>$GIT_DIR/remotes</code>. A URL nesse arquivo será usado para acessar o repositório. O "refspec" neste arquivo será usado como padrão quando você não fornecer um "refspec" na linha de comando. Este arquivo deve ter os seguintes formatos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	URL: um dos formatos da URL acima
	Push: &lt;refspec&gt;
	Pull: &lt;refspec&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>As linhas <code>Push:</code> são usadas pelo comando <em>git push</em> e as linhas <code>Pull:</code> são usadas pelo comando <em>git pull</em> e pelo comando <em>git fetch</em>. Várias linhas <code>Push:</code> e <code>Pull:</code> podem ser especificadas para fazer os mapeamentos das ramificações adicionais.</p>
</div>
</div>
<div class="sect2">
<h3 id="_arquivo_informado_em_git_dirbranches"><a class="anchor" href="#_arquivo_informado_em_git_dirbranches"></a>Arquivo informado em <code>$GIT_DIR/branches</code></h3>
<div class="paragraph">
<p>Você pode optar por fornecer o nome de um arquivo em <code>$GIT_DIR/branches</code>. A URL nesse arquivo será usado para acessar o repositório. Este arquivo deve ter os seguintes formatos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	&lt;URL&gt;#&lt;head&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>A <code>&lt;URL&gt;</code> é necessária; <code>#&lt;head&gt;</code> é opcional.</p>
</div>
<div class="paragraph">
<p>Dependendo da operação, o git usará um dos seguintes "refspecs", caso você não forneça um na linha de comando. O <code>&lt;ramo&gt;</code> é o nome desse arquivo em <code>$GIT_DIR/branches</code> e <code>&lt;cabeçalho&gt;</code> tem como <code>master</code> como predefinição.</p>
</div>
<div class="paragraph">
<p>O git fetch usa:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	refs/heads/&lt;head&gt;:refs/heads/&lt;ramo&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>O comando <code>git push</code> usa:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>	HEAD:refs/heads/&lt;head&gt;</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_configurações_dos_ramos_monitorados_remotamente"><a class="anchor" href="#_configurações_dos_ramos_monitorados_remotamente"></a>CONFIGURAÇÕES DOS RAMOS MONITORADOS REMOTAMENTE<a id="CRTB"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Você costuma interagir com o mesmo repositório remoto fazendo buscas regulares e repetidas nele. Para acompanhar o progresso deste repositório remoto, o comando <code>git fetch</code> permite que você configure as variáveis de configuração <code>remote.&lt;repositório&gt;.fetch</code>.</p>
</div>
<div class="paragraph">
<p>Normalmente, essa variável pode ser assim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[remote "origin"]
	fetch = +refs/heads/*:refs/remotes/origin/*</pre>
</div>
</div>
<div class="paragraph">
<p>Essa configuração é utilizada de duas maneiras:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Quando o comando <code>git fetch</code> é executado sem especificar quais ramificações e/ou tags devem ser buscadas na linha de comando, por exemplo, o comando <code>git fetch origin</code> ou <code>git fetch</code>, os valores <code>remote.&lt;repositório&gt;.fetch</code> são usados como refspecs - eles especificam quais referências devem ser obtidas e quais referências locais devem ser atualizadas. O exemplo acima obterá todas as ramificações que existem em <code>origin</code> (ou seja, qualquer referência que corresponda ao lado esquerdo do valor, <code>refs/heads/*</code>) e atualizará as ramificações de rastreamento remoto correspondentes na hierarquia <code>refs/remotes/origin/*</code>.</p>
</li>
<li>
<p>Quando o comando <code>git fetch</code> é executado com ramificações e/ou tags explícitas que serão obtidas através da linha de comando, por exemplo, <code>git fetch origin master</code>, as &lt;refspec&gt;s informadas na linha de comando determinam o que deve ser obtido (por exemplo, <code>master</code> no exemplo, que é uma abreviação de <code>master:</code>, que por sua vez significa "buscar a ramificação <em>master</em>, mas não digo explicitamente qual ramificação de rastreamento remoto atualizar com ela a partir da linha de comando"), e o comando de exemplo buscará <em>apenas</em> a ramificação <em>master</em>. Os valores <code>remote.&lt;repositório&gt;.fetch</code> determinam qual ramo rastreado remotamente, se ele existir, ele será atualizado. Quando usados dessa maneira, os valores <code>remote.&lt;repositório&gt;.fetch</code> não têm nenhum efeito na decisão de <em>o que</em> é buscado (ou seja, os valores não são usados como refspecs quando a linha de comando listar refspecs); eles são usados apenas para decidir <em>onde</em> as refs que são buscadas são armazenadas, agindo como um mapeamento.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>O último valores do <code>remote.&lt;repositório&gt;.fetch</code> podem ser substituídos, ao usar os parâmetros <code>--refmap=&lt;refspec&gt;</code> na linha de comando.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_poda"><a class="anchor" href="#_poda"></a>PODA</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A disposição predefinida do Git se organiza de forma a manter os dados a menos que sejam descartados de forma explicita; isso se estende a manter referências locais nas ramificações remotas que elas mesmas excluíram.</p>
</div>
<div class="paragraph">
<p>Se desassistidas, essas referências obsoletas podem piorar o desempenho em repositórios grandes e ocupados aonde apresentam muita rotatividade e por exemplo, façam uso de comandos como <code>git branch -a --contains &lt;commit&gt;</code> cuja saída é desnecessariamente detalhada, cautilizando impacto de desempenho em qualquer outra referência de trabalho conhecida.</p>
</div>
<div class="paragraph">
<p>Estas referências de rastreamento remoto podem ser excluídas com um único:</p>
</div>
<div class="listingblock">
<div class="content">
<pre># Enquanto estiver fazendo a captura
$ git fetch --prune &lt;nome&gt;

# Exclua apenas, não busque nada
$ git remote prune &lt;nome&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>Para remover as referências como parte do seu fluxo de trabalho normal sem precisar se lembrar de executá-lo, defina <code>fetch.prune</code> globalmente ou com a configuração ` remote.&lt;nome&gt;.prune` por ramo remoto. Consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>.</p>
</div>
<div class="paragraph">
<p>Aqui é onde as coisas ficam complicadas e mais específicas. O recurso de poda não se preocupa de fato com as ramificações; em vez disso, ele poda as referências remotas &#8592;&#8594; locais como uma função no refspec remoto (consulte <code>&lt;refspec&gt;</code> e <a href="#CRTB">CONFIGURAÇÕES DOS RAMOS MONITORADOS REMOTAMENTE</a> acima).</p>
</div>
<div class="paragraph">
<p>Portanto, caso o <code>refspec</code> remoto inclua <code>refs/tags/*:refs/tags/*</code> por exemplo ou caso execute manualmente <code>git fetch --prune &lt;nome&gt; "refs/tags/*:refs/tags/*"</code> por exemplo. As ramificações remotas rastreadas que forem excluídas não expirarão, a não ser qualquer outra tag local que não exista remotamente.</p>
</div>
<div class="paragraph">
<p>Senão for o que você deseja, caso queira remover remotamente o <code>&lt;nome&gt;</code> por exemplo e também capturar explicitamente as tags a partir dele; primeiramente, ao recolher dele você exclui todas as tags locais, a maioria das quais podem não terem vindo do <code>&lt;nome&gt;</code> remoto.</p>
</div>
<div class="paragraph">
<p>Assim, tenha cuidado ao utilizar isso com um <code>refspec</code> como <code>refs/tags/*:refs/tags/*</code> ou qualquer outro <code>refspec</code> que possa mapear as referências de diferentes pontos remotos para o mesmo <code>namespace</code> local.</p>
</div>
<div class="paragraph">
<p>Como manter-se atualizado com as ramificações e as tags remotamente é um caso de uso comum, a opção <code>--prune-tags</code> pode ser utilizada junto com o <code>--prune</code> para remover as tags locais que não existam no ponto remoto e impor a atualização dessas tags que estiverem diferentes. A remoção de tags também podem ser ativadas com <code>fetch.pruneTags</code> ou <code>remote.&lt;nome&gt;.pruneTags</code> nas configurações. Consulte <a href='{{< relurl "docs/git-config/pt_BR" >}}'>git-config[1]</a>.</p>
</div>
<div class="paragraph">
<p>A opção <code>--prune-tags</code> é equivalente a ter o <code>refs/tags/*:refs/tags/*</code> declarado nos <code>refspecs</code> remotos. Isso pode ocasionar algumas interações estranhas:</p>
</div>
<div class="listingblock">
<div class="content">
<pre># Ambas capturam as tags
$ git fetch --no-tags origin 'refs/tags/*:refs/tags/*'
$ git fetch --no-tags --prune-tags origin</pre>
</div>
</div>
<div class="paragraph">
<p>O motivo pelo qual não ocorre um erro durante o uso sem a opção <code>--prune</code> ou as suas versões de configuração, é a flexibilidade das versões configuradas, para manter um mapeamento 1=1 entre as opções da linha de comando e o que as versões das configuração fazem.</p>
</div>
<div class="paragraph">
<p>É razoável que a configuração <code>fetch.pruneTags=true</code> em <code>~/.gitconfig</code> que as tags sejam removidas sempre que o comando <code>git fetch --prune</code> seja executado, sem fazer com que todas as invocações do comando <code>git fetch</code> sem a opção <code>--prune</code> cause um erro.</p>
</div>
<div class="paragraph">
<p>A remoção de tags com <code>--prune-tags</code> também funciona durante o resgate de uma URL em vez de um determinado nome remoto. Todas essas tags de remoção serão encontradas em <code>origin</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git fetch origin --prune --prune-tags
$ git fetch origin --prune 'refs/tags/*:refs/tags/*'
$ git fetch &lt;url-of-origin&gt; --prune --prune-tags
$ git fetch &lt;url-of-origin&gt; --prune 'refs/tags/*:refs/tags/*'</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_saída"><a class="anchor" href="#_saída"></a>SAÍDA</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A saída do comando "git fetch" depende do método de transporte utilizado; Esta seção descreve a saída durante a utilização da captura ao utilizar o protocolo Git (localmente ou via ssh) e o protocolo inteligente "Smart HTTP".</p>
</div>
<div class="paragraph">
<p>A condição da saída durante a captura é produzida em forma de tabela, com cada linha representando a condição de uma única referência. Cada linha é uma forma de:</p>
</div>
<div class="listingblock">
<div class="content">
<pre> &lt;flag&gt; &lt;resumo&gt; &lt;de&gt; -&gt; &lt;para&gt; [&lt;motivo&gt;]</pre>
</div>
</div>
<div class="paragraph">
<p>Ao usar <code>--porcelain</code>, o formato gerado serve para ser analisado por uma máquina. Em contraste com os formatos de saída legíveis para humanos, ele imprime na saída predefinida em na de erro padrão. Cada linha tem o formato:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&lt;flag&gt; &lt;id-antiga-do-objeto&gt; &lt;id-nova-do-objeto&gt; &lt;referência-local&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>A condição das referências atualizadas é exibido caso a opção --verbose seja utilizada.</p>
</div>
<div class="paragraph">
<p>O modo de saída compacta é definida com a variável de configuração <code>fetch.output</code>, caso <code>&lt;de&gt;</code> ou <code>&lt;para&gt;</code> seja inteiramente encontrada em outra cadeia de caracteres, esta será substituída por <code>*</code> na outra cadeia de caracteres. <code>master -&gt; origin/master</code> se torna <code>master -&gt; origin/*</code> por exemplo.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-fetch-sinalizarsinalizaoindicaomarcaomarcador"> <a class="anchor" href="#git-fetch-sinalizarsinalizaoindicaomarcaomarcador"></a>sinalizar, sinalização, indicação, marcação, marcador </dt>
<dd>
<p>Um único caractere indicando a condição da referência:</p>
<div class="dlist">
<dl>
<dt class="hdlist1" id="git-fetch-space"> <a class="anchor" href="#git-fetch-space"></a>(space) </dt>
<dd>
<p>para um avanço rápido bem sucedido;</p>
</dd>
<dt class="hdlist1" id="git-fetch-codecode"> <a class="anchor" href="#git-fetch-codecode"></a><code>+</code> </dt>
<dd>
<p>para uma imposição de atualização bem sucedida;</p>
</dd>
<dt class="hdlist1" id="git-fetch-code-code"> <a class="anchor" href="#git-fetch-code-code"></a><code>-</code> </dt>
<dd>
<p>para uma eliminação da referência bem sucedida;</p>
</dd>
<dt class="hdlist1" id="git-fetch-codetcode"> <a class="anchor" href="#git-fetch-codetcode"></a><code>t</code> </dt>
<dd>
<p>para uma atualização da tag bem sucedida;</p>
</dd>
<dt class="hdlist1" id="git-fetch-codecode-1"> <a class="anchor" href="#git-fetch-codecode-1"></a><code>*</code> </dt>
<dd>
<p>para a captura de uma nova referência bem sucedida;</p>
</dd>
<dt class="hdlist1" id="git-fetch-codecode-1-1"> <a class="anchor" href="#git-fetch-codecode-1-1"></a><code>!</code> </dt>
<dd>
<p>para uma referência que foi rejeitada ou a sua atualização tenha falhado; e</p>
</dd>
<dt class="hdlist1" id="git-fetch-codecode-1-1-1"> <a class="anchor" href="#git-fetch-codecode-1-1-1"></a><code>=</code> </dt>
<dd>
<p>para uma referência que estava atualizada e não precisou de nenhuma captura.</p>
</dd>
</dl>
</div>
</dd>
<dt class="hdlist1" id="git-fetch-resumo"> <a class="anchor" href="#git-fetch-resumo"></a>resumo </dt>
<dd>
<p>Para a a captura de uma referência bem sucedida, o resumo exibe os valores antigos e novos num formato adequado para a utilização como argumento para o comando <code>git log</code> (<code>&lt;antigo&gt;..&lt;novo&gt;</code> na maioria dos casos, e <code>&lt;antigo&gt;...&lt;novo&gt;</code> para atualizações de avanço rápido que forem impostas).</p>
</dd>
<dt class="hdlist1" id="git-fetch-de"> <a class="anchor" href="#git-fetch-de"></a>de </dt>
<dd>
<p>The name of the remote ref being fetched from, minus its <code>refs/&lt;tipo&gt;/</code> prefix. In the case of deletion, the name of the remote ref is "(none)".</p>
</dd>
<dt class="hdlist1" id="git-fetch-para"> <a class="anchor" href="#git-fetch-para"></a>para </dt>
<dd>
<p>The name of the local ref being updated, minus its <code>refs/&lt;tipo&gt;/</code> prefix.</p>
</dd>
<dt class="hdlist1" id="git-fetch-motivo"> <a class="anchor" href="#git-fetch-motivo"></a>motivo </dt>
<dd>
<p>Uma explicação legível para humanos. No caso de referências capturadas com sucesso, nenhuma explicação é necessária. Para uma referência com falha, o motivo será explanado.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_exemplos"><a class="anchor" href="#_exemplos"></a>EXEMPLOS</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Atualize as ramificações de rastreamento remoto:</p>
<div class="listingblock">
<div class="content">
<pre>$ git fetch origin</pre>
</div>
</div>
<div class="paragraph">
<p>O comando acima copia todas as ramificações do <code>refs/heads/</code> do espaço de nomes remoto e as armazena em <code>refs/remotes/origin/</code> com um espaço de nomes local, a menos que a opção <code>remote.&lt;repositório&gt;.fetch</code> seja utilizada para definir um <code>refspec</code> fora do que já vem predefinido.</p>
</div>
</li>
<li>
<p>Utilizando <code>refspecs</code> de forma explicita:</p>
<div class="listingblock">
<div class="content">
<pre>$ git fetch origin +seen:seen maint:tmp</pre>
</div>
</div>
<div class="paragraph">
<p>Isso atualiza (ou cria, conforme necessário) as ramificações <code>seen</code> e <code>tmp</code> no repositório local, buscando nas ramificações (respectivamente) <code>seen</code> e <code>maint</code> do repositório remoto.</p>
</div>
<div class="paragraph">
<p>O ramo <code>seen</code> será atualizado ainda que não faça um avanço rápido, porque é prefixado com um sinal de mais; já o <code>tmp</code> não será.</p>
</div>
</li>
<li>
<p>Dê uma olhada no ramo remoto sem a configuração remota do seu repositório local:</p>
<div class="listingblock">
<div class="content">
<pre>$ git fetch git://git.kernel.org/pub/scm/git/git.git maint
$ git log FETCH_HEAD</pre>
</div>
</div>
<div class="paragraph">
<p>O primeiro comando obtém a ramificação <code>maint</code> do repositório em <code>git://git.kernel.org/pub/scm/git/git.git</code> e o segundo comando usa <code>FETCH_HEAD</code> para examinar a ramificação com <a href='{{< relurl "docs/git-log/pt_BR" >}}'>git-log[1]</a>. Os objetos obtidos serão eventualmente removidos pela manutenção interna do git (consulte <a href='{{< relurl "docs/git-gc/pt_BR" >}}'>git-gc[1]</a>).</p>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_segurança"><a class="anchor" href="#_segurança"></a>SEGURANÇA</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Os protocolos de busca e envio não foram projetados para impedir que um lado roube os dados do outro repositório que não deveriam ser compartilhado. Caso tenha dados particulares que precisam ser protegidos de um par malicioso, a sua melhor opção é armazená-los em um outro repositório. Isso se aplica aos clientes e aos servidores. Em particular, os espaço de nomes em um servidor não são eficazes para o controle de acesso de leitura; você só deve conceder acesso de leitura a um espaço de nomes para os clientes que você confiaria o acesso de leitura para todo o repositório.</p>
</div>
<div class="paragraph">
<p>Os vetores de ataque informados são os seguintes:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A vítima envia as linhas "have" anunciando as IDs dos objetos que possui, que não são explicitamente planejados para serem compartilhados, porém podem ser usados para otimizar a transferência caso o par também os tenha. O atacante escolhe um ID do objeto <em>X</em> para roubar e envia uma "ref" para <em>X</em>, porém não é necessário enviar o conteúdo do <em>X</em> porque a vítima já o possui. Agora a vítima acredita que o atacante tem o <em>X</em> e depois envia seu conteúdo de volta ao atacante. (Esse ataque é mais simples para um cliente executar em um servidor, criando uma "ref" para <em>X</em> no espaço de nomes onde o cliente tem acesso e em seguida, buscando-o. A maneira mais provável de um servidor executá-lo em um cliente é "mesclar" <em>X</em> em um ramo público e esperar que o usuário faça um trabalho adicional neste ramo, enviá-lo de volta ao servidor sem perceber a mesclagem.)</p>
</li>
<li>
<p>Como no item 1, o invasor escolhe a ID do objeto X para roubar. A vítima envia um objeto Y que o invasor já possui, e o invasor alega falsamente que possui X e não Y, então a vítima envia Y como um delta contra X. O delta revela ao invasor regiões de X que são semelhantes a Y.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_configuração"><a class="anchor" href="#_configuração"></a>CONFIGURAÇÃO</h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Missing <code>pt_BR/includes/cmd-config-section-all.txt</code></p>
</div>
<div class="paragraph">
<p>See original version for this content.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph">
<p>Missing <code>pt_BR/config/fetch.txt</code></p>
</div>
<div class="paragraph">
<p>See original version for this content.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_bugs"><a class="anchor" href="#_bugs"></a>BUGS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Com a opção <code>--recurse-submodules</code> só se pode buscar por novos commits nos submódulos que estejam presentes localmente, por exemplo, em <code>$GIT_DIR/modules/</code>. Se o upstream adicionar um novo submódulo, este submódulo não pode ser buscado até que seja clonado, por exemplo, através do <code>git submodule update</code>. Isso deve ser corrigido numa versão futura do Git.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_veja_também"><a class="anchor" href="#_veja_também"></a>VEJA TAMBÉM</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href='{{< relurl "docs/git-pull/pt_BR" >}}'>git-pull[1]</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_git"><a class="anchor" href="#_git"></a>GIT</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Parte do conjunto <a href='{{< relurl "docs/git/pt_BR" >}}'>git[1]</a></p>
</div>
</div>
</div>