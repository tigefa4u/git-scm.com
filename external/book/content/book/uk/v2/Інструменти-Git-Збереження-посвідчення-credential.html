---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: uk
  chapter:
    title: Інструменти Git
    number: 7
  section:
    title: Збереження посвідчення (credential)
    number: 14
    cs_number: '7.14'
    previous: book/uk/v2/Інструменти-Git-Заміна
    next: book/uk/v2/Інструменти-Git-Підсумок
title: Git - Збереження посвідчення (credential)
url: "/book/uk/v2/Інструменти-Git-Збереження-посвідчення-credential.html"
---
<h2 id="_credential_caching">Збереження посвідчення (credential)</h2>
<div class="paragraph">
<p>

Якщо ви використовуєте протокол SSH для зʼєднання з віддаленими сховищами, то можете використовувати ключ без пароля, що дозволяє безпечно передавати дані без набирання імʼя користувача та пароля.
Втім, це неможливо з HTTP протоколами – кожне зʼєднання потребує імені та пароля.
Все стає ще складнішим з двокроковою авторизацією: значення, яке треба використати як пароль, випадково згенероване та невимовне.</p>
</div>
<div class="paragraph">
<p>На щастя, Git має систему посвідчень, яка може тут зарадити.
Щойно встановлений Git пропонує чимало опцій:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Типова поведінка — взагалі нічого не запамʼятовувати.
Кожне зʼєднання потребує від вас імʼя користувача та пароль.</p>
</li>
<li>
<p>Режим “cache” зберігає посвідчення в памʼяті визначений термін.
Жоден пароль не зберігається на диску, та вичищається з памʼяті за 15 хвилин.</p>
</li>
<li>
<p>Режим “store” зберігає посвідчення до простого текстового файлу на диску, та ніколи не застаріває.
Це означає, що доки ви не зміните пароль для Git, вам ніколи не доведеться набирати ваші дані знов.
Недоліком цього методу є те, що ваші паролі зберігаються текстом у простому файлі в домашній директорії.</p>
</li>
<li>
<p>Якщо ви використовуєте Mac, Git має режим “osxkeychain”, який зберігає посвідчення у безпечному ланцюгу ключів (keychain), що є привʼязаним до вашого системного облікового запису.
Цей метод зберігає посвідчення на диску і ніколи не застаріває, проте його зашифровано так само, як система зберігає сертифікати HTTPS та автозаповнювачі Safari.</p>
</li>
<li>
<p>Якщо ви використовуєте Windows, то можете встановити помічник (helper) під назвою “Git Credential Manager for Windows”.
Це схоже на описаний вище “osxkeychain”, проте використовує Windows Credential Store для контролю за приватною інформацією.
Його можна знайти за посиланням <a href="https://github.com/Microsoft/Git-Credential-Manager-for-Windows" class="bare">https://github.com/Microsoft/Git-Credential-Manager-for-Windows</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Щоб задати один з цих методів, треба встановити значення налаштування Git:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global credential.helper cache</code></pre>
</div>
</div>
<div class="paragraph">
<p>Деякі з цих помічників мають опції.
Помагач “store” може приймати аргумент <code>--file &lt;шлях&gt;</code>, який задає, куди зберігається текстовий файл (типове значення <code>~/.git-credentials</code>).
Помагач “cache” приймає опцію <code>--timeout &lt;секунд&gt;</code>, яка змінює термін, протягом якого демон працює (типове значення “900”, тобто 15 хвилин).
Ось приклад, як можна налаштувати помічник “store” особистим іменем файлу:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global credential.helper 'store --file ~/.my-credentials'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git навіть дозволяє налаштувати декілька помічників.
При пошуку посвідчення для певного хосту, Git зробить запит до них по черзі та зупиниться при першій відповіді.
При збереженні посвідчень, Git надішле імʼя користувача та пароль до <strong>всіх</strong> помічників зі списку і вони самі можуть вибрати, що з ними робити.
Ось як виглядав би <code>.gitconfig</code>, якби у вас був файл посвідчень на зовнішньому носії, проте ви бажали б використати кеш у памʼяті, щоб заощадити набирання, якщо носій не підключено:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">[credential]
    helper = store --file /mnt/thumbdrive/.git-credentials
    helper = cache --timeout 30000</code></pre>
</div>
</div>
<div class="sect3">
<h3 id="_під_капотом">Під капотом</h3>
<div class="paragraph">
<p>Як все це працює?
Головною командою Git з системи помічників з посвідченнями є <code>git credential</code>, яка приймає команду в якості аргументу, а потім ще ввід через stdin.</p>
</div>
<div class="paragraph">
<p>Можливо це легше зрозуміти за допомогою прикладу.
Припустімо, помічник посвідчень вже налаштовано, та він вже зберіг посвідчення для <code>mygithost</code>.
Ось сесія, що використовує команду “fill”, яка викликається при спробі знайти посвідчення для хосту:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git credential fill <b class="conum">(1)</b>
protocol=https <b class="conum">(2)</b>
host=mygithost
<b class="conum">(3)</b>
protocol=https <b class="conum">(4)</b>
host=mygithost
username=bob
password=s3cre7
$ git credential fill <b class="conum">(5)</b>
protocol=https
host=unknownhost

Username for 'https://unknownhost': bob
Password for 'https://bob@unknownhost':
protocol=https
host=unknownhost
username=bob
password=s3cre7</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Ця команда розпочинає взаємодію.</p>
</li>
<li>
<p>Відтак Git-credential очікує вводу з stdin.
Ми кажемо йому що знаємо: протокол та імʼя хосту.</p>
</li>
<li>
<p>Порожній рядок означає, що ввід завершено, та система посвідчень має відповісти, що вона знає.</p>
</li>
<li>
<p>Далі Git-credential приймає керування та пише до stdout інформацію, яку знайшов.</p>
</li>
<li>
<p>Якщо посвідчень не знайдено, Git запитує в користувача імʼя та пароль, та видає їх назад до stdout, з якого був викликаний (у даному випадку вони підʼєднані до однієї консолі).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Насправді, система посвідчень викликає програму, яка відокремлена від власно Git; яку саме залежить від значення налаштування <code>credential.helper</code>.
Ось декілька форм, які воно може мати:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Значення налаштування</th>
<th class="tableblock halign-left valign-top">Поведінка</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>foo</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Виконує <code>git-credential-foo</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>foo -a --opt=bcd</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Виконує <code>git-credential-foo -a --opt=bcd</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/absolute/path/foo -xyz</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Виконує <code>/absolute/path/foo -xyz</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>!f() { echo "password=s3cre7"; }; f</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Код після <code>!</code> передається на виконання до оболонки (shell)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Отже, вищеописані помічники насправді мають назви <code>git-credential-cache</code>, <code>git-credential-store</code> тощо, та ми можемо їх налаштувати, щоб вони приймали аргументи командного рядка.
Загальна форма для цього “git-credential-foo [аргументи] &lt;дія&gt;.”
Протокол stdin/stdout такий самий, як для git-credential, проте вони використовують трохи інших набір дій:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>get</code> — це запит пари імені/пароля.</p>
</li>
<li>
<p><code>store</code> — це запит на зберігання набору посвідчень у памʼяті помічника.</p>
</li>
<li>
<p><code>erase</code> — очистити посвідчення для наданих властивостей з памʼяті помічника.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Для дій <code>store</code> та <code>erase</code> відповідь не потрібна (Git все одно її ігнорує).
Втім, щодо дії <code>get</code>, Git дуже зацікавлений у тому, що скаже помічник.
Якщо помічник не знає нічого корисного, він може просто вийти без виводу, проте, якщо він щось знає, він має доповнити прийняту інформацію тою, яку зберіг.
Вивід сприймається як послідовність виразів присвоєння; будь-що надане замінить те, що Git вже знає.</p>
</div>
<div class="paragraph">
<p>Ось такий саме приклад, як і попередній, проте пропустимо git-credential та перейдемо відразу до git-credential-store:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git credential-store --file ~/git.store store <b class="conum">(1)</b>
protocol=https
host=mygithost
username=bob
password=s3cre7
$ git credential-store --file ~/git.store get <b class="conum">(2)</b>
protocol=https
host=mygithost

username=bob <b class="conum">(3)</b>
password=s3cre7</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Тут ми кажемо <code>git-credential-store</code> зберегти деякі посвідчення: імʼя “bob” та пароль “s3cre7” мають використовуватись при доступі до <code>https://mygithost</code>.</p>
</li>
<li>
<p>Тепер ми отримаємо це посвідчення.
Ми надаємо вже відомі частини зʼєднання (<code>https://mygithost</code>) та порожній рядок.</p>
</li>
<li>
<p><code>git-credential-store</code> відповідає збереженими вище імʼям користувача та паролем.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Ось як виглядає файл <code>~/git.store</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">https://bob:s3cre7@mygithost</code></pre>
</div>
</div>
<div class="paragraph">
<p>Це просто послідовність рядків, кожен з яких містить декорований посвідченням URL.
Помічники <code>osxkeychain</code> і <code>wincred</code> використовують локальний формат своїх cховищ, у той час як <code>cache</code> використовує власний формат в памʼяті (яку жоден інший процес не може прочитати).</p>
</div>
</div>
<div class="sect3">
<h3 id="_спеціальний_кеш_посвідчень">Спеціальний кеш посвідчень</h3>
<div class="paragraph">
<p>Враховуючи, що <code>git-credential-store</code> та її друзі є окремими від Git програмами, нескладно зрозуміти, що <em>будь-яка</em> програма може бути помічником посвідчень Git.
Помагачі, які постачає Git, доречні в багатьох поширених випадках, проте не у всіх.
Наприклад, скажімо, ваша команда має якісь посвідчення, які використовуються всією командою, можливо для розробки.
Вони зберігаються у спільній директорії, проте, ви не бажаєте копіювати їх до вашого власного сховища посвідчень, адже вони часто змінюються.
Жоден з існуючих помічників тут не зарадить; подивімося, що доведеться зробити, щоб написати свій власний.
Є декілька ключових функцій, які ця програма має виконувати:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Єдина дія, якій треба приділити увагу — це <code>get</code>; <code>store</code> та <code>erase</code> є операціями запису, отже просто завершимо програму без наслідків при отриманні їх.</p>
</li>
<li>
<p>Формат спільного файлу посвідчень такий самий, як і той, що використовує <code>git-credential-store</code>.</p>
</li>
<li>
<p>Розташування цього файлу доволі стале, проте варто надати користувачу можливість змінювати шлях до нього, про всяк випадок.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Ще раз наголошуємо, ми напишемо цей додаток на Ruby, проте це можна зробити будь-якою мовою, якщо Git може виконати результат.
Ось повний вихідний код нового помічника посвідчень:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#!/usr/bin/env ruby

require 'optparse'

path = File.expand_path '~/.git-credentials' # <b class="conum">(1)</b>
OptionParser.new do |opts|
    opts.banner = 'USAGE: git-credential-read-only [options] &lt;action&gt;'
    opts.on('-f', '--file PATH', 'Specify path for backing store') do |argpath|
        path = File.expand_path argpath
    end
end.parse!

exit(0) unless ARGV[0].downcase == 'get' # <b class="conum">(2)</b>
exit(0) unless File.exists? path

known = {} # <b class="conum">(3)</b>
while line = STDIN.gets
    break if line.strip == ''
    k,v = line.strip.split '=', 2
    known[k] = v
end

File.readlines(path).each do |fileline| # <b class="conum">(4)</b>
    prot,user,pass,host = fileline.scan(/^(.*?):\/\/(.*?):(.*?)@(.*)$/).first
    if prot == known['protocol'] and host == known['host'] and user == known['username'] then
        puts "protocol=#{prot}"
        puts "host=#{host}"
        puts "username=#{user}"
        puts "password=#{pass}"
        exit(0)
    end
end</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Тут ми розбираємо опції командного рядка: дозволяємо користувачу задати вхідний файл. Типове значення — <code>~/.git-credentials</code>.</p>
</li>
<li>
<p>Ця програма відповідає виключно, якщо задана дія <code>get</code> та файл з даними існує.</p>
</li>
<li>
<p>Цей цикл читає з stdin доки не зустріне перший порожній рядок.
Вхід зберігається в хеші <code>known</code> для подальшого використання.</p>
</li>
<li>
<p>Цей цикл читає вміст файлу з даними — шукає відповідності.
Якщо протокол та хост з <code>known</code> відповідають поточному рядку, програма друкує результати до stdout та завершує свою роботу.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Ми збережемо наш помічник як <code>git-credential-read-only</code>, покладемо кудись до нашого <code>PATH</code> та позначимо як викона́нний.
Ось як виглядає інтерактивна сесія:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git credential-read-only --file=/mnt/shared/creds get
protocol=https
host=mygithost

protocol=https
host=mygithost
username=bob
password=s3cre7</code></pre>
</div>
</div>
<div class="paragraph">
<p>Оскільки його назва починається з “git-”, ми можемо використати простий синтаксис для значення налаштування:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global credential.helper 'read-only --file /mnt/shared/creds'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Як ви можете бачити, розширення системи є доволі прямолінійним, та може вирішувати якісь повсякденні завдання для вас та вашої команди.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>