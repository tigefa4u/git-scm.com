---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: uk
  chapter:
    title: Галуження в git
    number: 3
  section:
    title: Перебазовування
    number: 6
    cs_number: '3.6'
    previous: book/uk/v2/Галуження-в-git-Віддалені-гілки
    next: book/uk/v2/Галуження-в-git-Підсумок
title: Git - Перебазовування
url: "/book/uk/v2/Галуження-в-git-Перебазовування.html"
---
<h2 id="_rebasing">Перебазовування</h2>
<div class="paragraph">
<p>
Git має два основні способи інтегрувати зміни з гілки в гілку: <code>merge</code> (зливання) та <code>rebase</code>(перебазовування).
У цій секції вивчатимете що таке перебазовування, як його виконувати, чому воно вважається таким чудовим інструментом та випадки, коли його не варто застосовувати.</p>
</div>
<div class="sect3">
<h3 id="_просте_перебазовування">Просте перебазовування</h3>
<div class="paragraph">
<p>Поверніться до попереднього прикладу з <a href="{{< relurl "book/uk/v2/ch00/_basic_merging" >}}">Основи зливання</a>, де видно, що ваша робота розгалузилася в комітах по двох різних гілках.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/uk/v2/images/basic-rebase-1.png" >}}" alt="Просте розгалуження історії.">
</div>
<div class="title">Рисунок 35. Просте розгалуження історії</div>
</div>
<div class="paragraph">
<p>Найпростіше інтегрувати гілки, як ми вже розглянули, за допомогою команди <code>merge</code>.
Вона виконає триточкове зливання між двома останніми знімками гілок (<code>C3</code> і <code>C4</code>) та їх найближчим спільним предком (<code>C2</code>), створивши новий знімок (і коміт).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/uk/v2/images/basic-rebase-2.png" >}}" alt="Інтеграція розгалуженої історії за допомогою зливання.">
</div>
<div class="title">Рисунок 36. Інтеграція розгалуженої історії за допомогою зливання</div>
</div>
<div class="paragraph">
<p>Проте, існує інший спосіб: можете взяти латку (patch) змін з <code>C4</code> і накласти її поверху <code>C3</code>.
У Git це називають <em>перебазовуванням</em> (rebasing).
За допомогою <code>rebase</code>, ви можете взяти всі зміни, що були в комітах одної гілки та відтворити їх на іншій гілці.</p>
</div>
<div class="paragraph">
<p>Для цього прикладу, виконайте наступне:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command</code></pre>
</div>
</div>
<div class="paragraph">
<p>Працює це так: шукається спільний предок двох гілок (поточної та тої, на котру перебазовуєтесь); отримуються відмінності (diff), спричинені кожним комітом поточної гілки; відмінності зберігаються в тимчасові файли; поточна гілка встановлюється (reset) на коміт гілки, на яку перебазовуєтесь; та нарешті, застосовується кожна зміна.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/uk/v2/images/basic-rebase-3.png" >}}" alt="Перебазовування зміни з `C4` на `C3`.">
</div>
<div class="title">Рисунок 37. Перебазовування зміни з <code>C4</code> на <code>C3</code>
</div>
</div>
<div class="paragraph">
<p>Тепер ви можете повернутися на <code>master</code> та зробити злиття перемотуванням (fast-forward merge).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
$ git merge experiment</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/uk/v2/images/basic-rebase-4.png" >}}" alt="Злиття перемотуванням гілки master.">
</div>
<div class="title">Рисунок 38. Злиття перемотуванням гілки master</div>
</div>
<div class="paragraph">
<p>Тепер знімок, що вказує на <code>C4'</code> є точнісінько таким, на який вказував <code>C5</code> із нашого прикладу зі зливанням.
Кінцевий результат інтеграції змін нічим не відрізняється, проте, у випадку перебазовування отримуємо чистішу історію.
Якщо подивитеся на журнал перебазованої гілки, то він буде лінійним: здається, що вся робота була послідовною, незважаючи на те, що насправді, вона виконувалася паралельно.</p>
</div>
<div class="paragraph">
<p>Ви часто використовуватимите це, щоб переконатися в тому, що ваші коміти накладалися на віддалені гілки чисто — наприклад, якщо хочете зробити внесок до проекту, яким самі не керуєте.
У цьому випадку, ви працюватимете в гілці й потім перебазуєтеся на <code>origin/master</code>, коли будете готові надіслати свої латки до основного проекту.
У свою чергу, керуючий проектом не змушений робити ніякої додаткової інтеграційної роботи — просто перемотати гілку або чисто накласти зміни.</p>
</div>
<div class="paragraph">
<p>Зауважте, що відбиток, на який вказує фінальний коміт, чи він є останнім з перебазовуваних комітів у випадку перебазовування, чи це фінальний коміт зливання, є одинаковим — відрізняється лише історія.
Операція перебазовування відтворює зміни з однієї лінії роботи на іншій лінії в тій же послідовності, в якій ці зміни зустрічалися, у той час, як зливання бере кінцеві точки та зливає їх докупи.</p>
</div>
</div>
<div class="sect3">
<h3 id="_цікавіше_перебазовування">Цікавіше перебазовування</h3>
<div class="paragraph">
<p>Під час перебазовування ви можете програвати зміни не лише на цільовій гілці.
Для прикладу візьміть історію <a href="{{< relurl "book/uk/v2/ch00/rbdiag_e" >}}">Історія з тематичною гілкою, відгалуженою від іншої тематичної гілки</a>.
Ви створили тематичну гілку (<code>server</code>) для того, щоб додати певну серверну функціональність до свого проекту та додали туди коміт.
Потім створили гілку для змін на клієнтській стороні (<code>client</code>), де встигли зробити кілька комітів.
Нарешті, повернулися до гілки з серверними змінами та додали кілька комітів там.</p>
</div>
<div id="rbdiag_e" class="imageblock">
<div class="content">
<img src="{{< relurl "book/uk/v2/images/interesting-rebase-1.png" >}}" alt="Історія з тематичною гілкою" width="відгалуженою від іншої тематичної гілки.">
</div>
<div class="title">Рисунок 39. Історія з тематичною гілкою, відгалуженою від іншої тематичної гілки</div>
</div>
<div class="paragraph">
<p>Допустимо, ви вирішили злити зміни клієнтської сторони до головної лінії коду для релізу, але хочете зачекати з серверними, доки вони будуть більше відтестовані.
Для цього можете взяти клієнтські зміни, які ще не є на сервері (<code>C8</code> і <code>C9</code>), та відтворити їх на <code>master</code>, користуючись опцією <code>--onto</code> команди <code>git rebase</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rebase --onto master server client</code></pre>
</div>
</div>
<div class="paragraph">
<p>Що означає “Візьми гілку <code>client</code>, знайди всі латки, відколи вона відгалузилася від гілки <code>server</code>, та відтвори їх у гілці <code>client</code>, ніби вона насправді базувалася на гілці <code>master</code>.”
Це трохи складно, але результат доволі класний.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/uk/v2/images/interesting-rebase-2.png" >}}" alt="Перебазовування тематичної гілки" width="що відгалужена від іншої гілки.">
</div>
<div class="title">Рисунок 40. Перебазування тематичної гілки, що відгалужена від іншої гілки</div>
</div>
<div class="paragraph">
<p>Тепер можете перемотати свою основну гілку <code>master</code> (дивіться <a href="{{< relurl "book/uk/v2/ch00/rbdiag_g" >}}">Перемотування гілки master, для залучення в неї змін з клієнтської гілки</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
$ git merge client</code></pre>
</div>
</div>
<div id="rbdiag_g" class="imageblock">
<div class="content">
<img src="{{< relurl "book/uk/v2/images/interesting-rebase-3.png" >}}" alt="Перемотування гілки master" width="для залучення в неї змін з клієнтської гілки.">
</div>
<div class="title">Рисунок 41. Перемотування гілки master, для залучення в неї змін з клієнтської гілки</div>
</div>
<div class="paragraph">
<p>Скажімо, тепер ви також вирішили прийняти зміни з серверної гілки.
Ви можете перебазувати серверну гілку на <code>master</code> без переходу на неї, користуючись командою <code>git rebase &lt;базова гілка&gt; &lt;тематична гілка&gt;</code>, що перейде на тематичну гілку (в нашому випадку <code>server</code>) та застосує її зміни на базовій гілці (<code>master</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rebase master server</code></pre>
</div>
</div>
<div class="paragraph">
<p>Це відтворить вашу зроблену роботу з <code>server</code> поверху <code>master</code>, як відображено в <a href="{{< relurl "book/uk/v2/ch00/rbdiag_h" >}}">Перебазовування серверної гілки поверху <code>master</code></a>.</p>
</div>
<div id="rbdiag_h" class="imageblock">
<div class="content">
<img src="{{< relurl "book/uk/v2/images/interesting-rebase-4.png" >}}" alt="Перебазовування серверної гілки поверху `master`.">
</div>
<div class="title">Рисунок 42. Перебазовування серверної гілки поверху <code>master</code>
</div>
</div>
<div class="paragraph">
<p>Тоді, можете перемотати базову гілку (<code>master</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
$ git merge server</code></pre>
</div>
</div>
<div class="paragraph">
<p>Гілки <code>client</code> та <code>server</code> можна вилучати, оскільки вся робота з них вже інтегрована і вам вони більше не знадобляться, що зробить вашу історію такою як <a href="{{< relurl "book/uk/v2/ch00/rbdiag_i" >}}">Остаточна історія комітів</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch -d client
$ git branch -d server</code></pre>
</div>
</div>
<div id="rbdiag_i" class="imageblock">
<div class="content">
<img src="{{< relurl "book/uk/v2/images/interesting-rebase-5.png" >}}" alt="Остаточна історія комітів.">
</div>
<div class="title">Рисунок 43. Остаточна історія комітів</div>
</div>
</div>
<div class="sect3">
<h3 id="_rebase_peril">Небезпеки перебазовування</h3>
<div class="paragraph">
<p>
Ох, але все блаженство перебазовування не позбавлене й своїх недоліків, які можна підсумувати одним рядком:</p>
</div>
<div class="paragraph">
<p><strong>Не перебазовуйте коміти, що існують в інших репозиторіях.</strong></p>
</div>
<div class="paragraph">
<p>Якщо будете слідувати цьому правилу, то все буде гаразд.
Якщо ні, то люди ненавидітимуть вас, а сім’я та друзі зневажатимуть.</p>
</div>
<div class="paragraph">
<p>Коли ви перебазовуєте, то втрачаєте існуючі коміти, а натомість створюєте нові, які є схожі, проте інші.
Якщо ви виклали (push) коміти та інші забрали (pull) їх, базуючи на них свою роботу, а потім ви перезаписали ці коміти з допомогою <code>git rebase</code> та виклали (push) їх знову, учасники проекту будуть змушені знову зливати свою роботу, а потім у вас буде плутанина, коли ви будете тягнути (pull) їхню роботу назад у свій репозиторій.</p>
</div>
<div class="paragraph">
<p>Погляньмо на приклад того, як перебазовування змін, які вже зробили публічними, може створювати проблеми.
Нехай ви зклонували репозиторій з центрального сервера і трохи в ньому попрацювали.
Історія комітів виглядає десь так:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/uk/v2/images/perils-of-rebasing-1.png" >}}" alt="Склонували репозиторій та трохи в ньому попрацювали.">
</div>
<div class="title">Рисунок 44. Склонували репозиторій та трохи в ньому попрацювали</div>
</div>
<div class="paragraph">
<p>Тепер ще хтось додав змін, включно із зливанням, та відправив ці зміни на центральний сервер.
Ви отримали ці зміни та злили нову віддалену гілку зі своєю роботою, отже ваша історія виглядає десь так:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/uk/v2/images/perils-of-rebasing-2.png" >}}" alt="Отримали ще коміти та злили їх із своєю роботою.">
</div>
<div class="title">Рисунок 45. Отримали ще коміти та злили їх із своєю роботою</div>
</div>
<div class="paragraph">
<p>Далі, ті, хто викладали та зливали зміни, вирішили повернутися та перебазувати зроблену роботу, виконавши <code>git push --force</code> для того, щоб переписати історію на сервері.
Коли ви оновитися (<code>fetch</code>), то отримаєте з сервера нові коміти.</p>
</div>
<div id="_pre_merge_rebase_work" class="imageblock">
<div class="content">
<img src="{{< relurl "book/uk/v2/images/perils-of-rebasing-3.png" >}}" alt="Хтось виклав перебазовані коміти, зневажаючи коміти, на яких ви базували свою роботу.">
</div>
<div class="title">Рисунок 46. Хтось виклав перебазовані коміти, зневажаючи коміти, на яких ви базували свою роботу</div>
</div>
<div class="paragraph">
<p>Тепер ви обидвоє в неприємній ситуації.
Якщо виконаєте <code>git pull</code>, то створите новий коміт злиття, який включатиме обидві лінії історії, а ваш репозиторій виглядатиме так:</p>
</div>
<div id="_merge_rebase_work" class="imageblock">
<div class="content">
<img src="{{< relurl "book/uk/v2/images/perils-of-rebasing-4.png" >}}" alt="Ви знову виконали зливання тої самої роботи в новий коміт зливання.">
</div>
<div class="title">Рисунок 47. Ви знову виконали зливання тої самої роботи в новий коміт зливання</div>
</div>
<div class="paragraph">
<p>Коли ви виконаєте <code>git log</code> для такої історії, то побачите два коміти, що мають того ж автора, дату та повідомлення, що є досить заплутаним.
Більше того, коли ви відправите (push) таку історію, ви відновите всі перебазовані коміти на центральному сервері, що й надалі заплутуватиме інших.
Мабуть, інші розробники не хочуть мати <code>C4</code> та <code>C6</code> в історії, власне чому вони й ініціювали перебазовування.</p>
</div>
</div>
<div class="sect3">
<h3 id="_rebase_rebase">Перебазовуйся коли перебазовуєшся</h3>
<div class="paragraph">
<p>Якщо ж ви <strong>опинилися</strong> в схожій ситуації, Git має деякі чари, що можуть допомогти.
Коли хтось у вашій команді примусово надіслав зміни, що перетерли роботу, на якій ви базувалися, — вам доведеться розібратися котрі зміни ваші, а котрі перетерто.</p>
</div>
<div class="paragraph">
<p>Виявляється, що крім контрольної SHA-1 суми коміту Git також вираховує контрольну суму, що базується на латці (patch), спричиненою комітом.
Вона називається “patch-id”.</p>
</div>
<div class="paragraph">
<p>Якщо ви візьмете роботу, що була перетертою, та перебазуєте її поверх нових комітів ваших колег, Git часто може сам розібратися що є унікально вашим та застосувати це поверху нової гілки.</p>
</div>
<div class="paragraph">
<p>Скажімо, для попереднього прикладу, якщо, будучи на <a href="{{< relurl "book/uk/v2/ch00/_pre_merge_rebase_work" >}}">Хтось виклав перебазовані коміти, зневажаючи коміти, на яких ви базували свою роботу</a>, ми, замість зливання, виконаємо <code>git rebase teamone/master</code>, Git зробить таке:
* Визначить які зміни є унікальні для нашої гілки (C2, C3, C4, C6, C7)
* Визначить що не є комітами злиття (C2, C3, C4)
* Визначить які коміти не були переписані в цільовій гілці (лише C2 та C3, оскільки C4 має таку ж латку як і C4')
* Застосує ті коміти поверху <code>teamone/master</code></p>
</div>
<div class="paragraph">
<p>Отже, замість результатів, які ми бачили в <a href="{{< relurl "book/uk/v2/ch00/_merge_rebase_work" >}}">Ви знову виконали зливання тої самої роботи в новий коміт зливання</a>, ми матимемо щось більш схоже на <a href="{{< relurl "book/uk/v2/ch00/_rebase_rebase_work" >}}">Перебазовування поверх примусово надісланих (force-pushed) змін.</a>.</p>
</div>
<div id="_rebase_rebase_work" class="imageblock">
<div class="content">
<img src="{{< relurl "book/uk/v2/images/perils-of-rebasing-5.png" >}}" alt="Перебазовування поверх змушено надісланих (force-pushed) змін.">
</div>
<div class="title">Рисунок 48. Перебазовування поверх примусово надісланих (force-pushed) змін.</div>
</div>
<div class="paragraph">
<p>Це спрацювало лише тому, що C4 та C4' що ви та ваш колега зробили мають майже однакові латки.
Інакше перебазовування не могло б визначити що це є дублікат і додало б ще одне C4-подібну латку (яка, швидше за все не могла б успішно застосуватися, оскільки зміни вже були б у хоча б одному місці).</p>
</div>
<div class="paragraph">
<p>Ви також можете спростити процес виконуючи <code>git pull --rebase</code> замість звичайного <code>git pull</code>.
Або "вручну" виконати послідовно <code>git fetch</code> та <code>git rebase teamone/master</code>.</p>
</div>
<div class="paragraph">
<p>Якщо ви використовуєте <code>git pull</code> та бажаєте щоб <code>--rebase</code> виконувався за замовчуванням, можете відповідно встановити конфігураційну опцію <code>pull.rebase</code>, виконавши щось типу <code>git config --global pull.rebase true</code>.</p>
</div>
<div class="paragraph">
<p>Якщо ви сприймаєте перебазовування як спосіб очистки комітів перед надсиланням (push) та якщо ви перебазовуєте лише коміти, що не були досі опубліковані, тоді все буде гаразд.
Якщо ж ви перебазовуєте коміти, що вже були опубліковані, а інші вже базують свої зміни на них, то легко можете опинитися в жахливих неприємностях та зневажанні колег.</p>
</div>
<div class="paragraph">
<p>Якщо ж ви, чи ваші колеги, все ж мають таку необхідність, з тих чи інших причин, упевніться що інші виконують <code>git pull --rebase</code> для того, щоб трохи полегшити неприємну ситуацію.</p>
</div>
</div>
<div class="sect3">
<h3 id="_перебазовування_чи_зливання">Перебазовування чи зливання</h3>
<div class="paragraph">
<p>
Побачивши перебазовування та зливання в дії, у вас може виникнути запитання: котре з них краще.
Перед тим, як відповісти, повернімося до того, що для нас означає історія змін.</p>
</div>
<div class="paragraph">
<p>Одна з точок зору, що історія репозиторія, це — <strong>запис того, що власне трапилося.</strong>
Це історичний документ сам по собі, та його не можна підробляти.
Під цим кутом, переписування історії є майже блюзнірством; ви <em>брешете</em> про те, що ж відбулося насправді.
Ну то й що, як там серія заплутаних комітів зливання?
Саме так все сталося, нехай репозиторій тримає це для прозорості нащадків.</p>
</div>
<div class="paragraph">
<p>Протилежна точка зору — сприймати історію як <strong>оповідання про те, як створювали проект.</strong>
Ви ж не будете опубліковувати чернетки вашого творіння, також інструкція з підтримки вашого програмного забезпечення заслуговує детальної редакції.
Представники цього табору активно використовують такі інструменти як перебазовування та фільтрація гілок для представлення історії в спосіб, найзручніший майбутнім читачам.</p>
</div>
<div class="paragraph">
<p>Повертаючись до питання що краще: перебазовування чи зливання, — сподіваємося ви й самі бачите що воно не таке й просте.
Git є могутнім інструментом та дозволяє робити багато речей з вашою історією, проте кожна команда та проект є різними.
І тепер, коли ви вже познайомилися з тим, як працюють обидва підходи, рішення про те, який кращий для вашої ситуації, залишається за вами.</p>
</div>
<div class="paragraph">
<p>Взагалі, щоб отримати найкраще з двох світів, дотримуйтеся правила перебазовувати ті локальні зміни, якими ви ще не поділилися, перед надсиланням для того, щоб тримати свою історію чистішою, але ніколи не перебазовувати те, що вже було кудись надіслано.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>