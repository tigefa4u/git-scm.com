---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: uk
  chapter:
    title: Налаштування Git
    number: 8
  section:
    title: Конфігурація Git
    number: 1
    cs_number: '8.1'
    previous: book/uk/v2/Інструменти-Git-Підсумок
    next: book/uk/v2/Налаштування-Git-Атрибути-Git
title: Git - Конфігурація Git
url: "/book/uk/v2/Налаштування-Git-Конфігурація-Git.html"
---
<p>До цього часу ми розглянули основи роботи Git і як його використовувати, а також ми розповіли про декілька засобів, які надає Git для легшого та ефективнішого його використання.
У цьому розділі ми побачимо, як можна змусити Git працювати бажаним чином, запровадивши декілька важливих конфігураційних налаштувань.
Із цими засобами легко змусити Git працювати точно так, як потрібно вам, вашій компанії чи групі.</p>
<h2 id="_git_config">Конфігурація Git</h2>
<div class="paragraph">
<p>
Як ви вже читали в <a href="{{< relurl "book/uk/v2/ch00/ch01-getting-started" >}}">Вступ</a>, можна вказати конфігураційні налаштування Git використовуючи команду <code>git config</code>.
Одна з перших речей, що ви зробили — це вказали ваше ім’я та електронну адресу:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com</code></pre>
</div>
</div>
<div class="paragraph">
<p>Тут ви вивчите декілька більш цікавих налаштувань для пристосування Git у такий же самий спосіб.</p>
</div>
<div class="paragraph">
<p>Спочатку швидке резюме: Git використовує низку конфігураційних файлів для визначення нетипової поведінки, яка вам може знадобитися.
Перше місце, куди Git заглядає за цими значеннями, знаходиться у системному файлі <code>/etc/gitconfig</code>, який містить значення, що застосовуються для всіх користувачів системи та всіх їхніх репозиторіїв.
Якщо передати опцію <code>--system</code> до <code>git config</code>, то він буде читати і записувати саме в цей файл.</p>
</div>
<div class="paragraph">
<p>Наступне місце, куди дивиться Git — це файл <code>~/.gitconfig</code> (або <code>~/.config/git/config</code>), який є специфічним для кожного користувача.
Ви можете змусити Git читати і записувати в цей файл за допомогою опції <code>--global</code>.</p>
</div>
<div class="paragraph">
<p>Нарешті, Git шукає конфігураційні значення у файлі налаштувань, що розміщений у директорії Git-а (<code>.git/config</code>) будь-якого поточного репозиторія, що ви використовуєте, і відповідають налаштуванням за допомогою опції <code>--local</code> команди <code>git config</code>.
Ці значення є специфічними для цього окремого репозиторія.
(Якщо не задати явно рівень конфігурацію, типово буде використано цей.)</p>
</div>
<div class="paragraph">
<p>Кожен з цих “рівнів” (системний, глобальний, локальний) переписує значення попереднього рівня, тобто, наприклад, значення в <code>.git/config</code> перекриває значення в <code>/etc/gitconfig</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Зауваження</div>
</td>
<td class="content">
<div class="paragraph">
<p>Конфігураційні файли Git-а є звичайним текстом, тому ви можете задати ці значення, відредагувавши файл вручну дотримуючись коректного синтаксису.
Однак у загальному випадку легше виконати команду <code>git config</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h3 id="_базові_налаштування_клієнта">Базові налаштування клієнта</h3>
<div class="paragraph">
<p>Конфігураційні опції, що розпізнаються Git-ом, належать до двох категорій: клієнтські та серверні.
Більшість опцій стосуються сторони клієнта — налаштування ваших персональних робочих вподобань.
Існує багато, <em>багато</em> конфігураційних опцій, але велика частка їх корисна лише в певних крайніх випадках; ми розкриємо тут лише найзагальніші та найкорисніші.
Щоб побачити список усіх опцій, підтримуваних вашою версією Git, виконайте</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ man git-config</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ця команда виводить список усіх доступних опцій з доволі докладним описом.
Також ви можете знайти цю інформацію на <a href="http://git-scm.com/docs/git-config.html" class="bare">http://git-scm.com/docs/git-config.html</a>.</p>
</div>
<div class="sect4">
<h4 id="_core_editor"><code>core.editor</code></h4>
<div class="paragraph">
<p>
За замовчуванням, Git використовує будь-що вказане вами як типовий текстовий редактор у змінних середовища <code>VISUAL</code> чи <code>EDITOR</code>, або повертається до редактора <code>vi</code>, щоб створювати чи вредагувати ваші повідомлення до комітів та теґів.
Щоб змінити типові налаштування на щось інше, використовуйте опцію core.editor`:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global core.editor emacs</code></pre>
</div>
</div>
<div class="paragraph">
<p>Тепер не важливо, що вказано як типовий редактор для терміналу, Git буде викликати Emacs для редагування повідомлень.</p>
</div>
</div>
<div class="sect4">
<h4 id="_commit_template"><code>commit.template</code></h4>
<div class="paragraph">
<p>
Якщо ви вкажете для цього параметра шлях до файла у вашій системі, Git буде використовувати той файл як типове значення для повідомлення при створенні коміту.
Власний шаблон для повідомлення коміту може нагадувати вам (або іншим) про правильний формат і стиль таких повідомлень.</p>
</div>
<div class="paragraph">
<p>Наприклад, розглянемо файл шаблону <code>~/.gitmessage.txt</code> з таким вмістом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">Subject line (try to keep under 50 characters)

Multi-line description of commit,
feel free to be detailed.

[Ticket: X]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Зверніть увагу на те, що цей шаблон нагадує творцю коміту, що рядок з темою має бути коротким (заради гарного виводу <code>git log --oneline</code>), а також докладніше описати коміт, і послатися на номер задачі, якщо така існує.</p>
</div>
<div class="paragraph">
<p>Щоб вказати Git, що потрібно використовувати його як типове значення для повідомлення, яке з’являтиметься в редакторі після виконання команди <code>git commit</code>, потрібно встановити значення для <code>commit.template</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global commit.template ~/.gitmessage.txt
$ git commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Після цього, під час створення коміту, ваш редактор буде відкривати щось на зразок наступного в якості заповнювача для повідомлення коміту:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">Subject line (try to keep under 60 characters)

Multi-line description of commit,
feel free to be detailed.

[Ticket: X]
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#   (use "git reset HEAD &lt;file&gt;..." to unstage)
#
# modified:   lib/test.rb
#
~
~
".git/COMMIT_EDITMSG" 14L, 297C</code></pre>
</div>
</div>
<div class="paragraph">
<p>Якщо ваша команда має певні вимоги до повідомлення коміту, то встановлення шаблону для цих вимог у системі та налаштування Git, щоб він використовував його за замовчуванням, збільшить шанси регулярного дотримання цих вимог.</p>
</div>
</div>
<div class="sect4">
<h4 id="_core_pager"><code>core.pager</code></h4>
<div class="paragraph">
<p>
Це налаштування визначає, який прогортач сторінок використовується, коли Git прогортає виведення, таке як <code>log</code> і <code>diff</code>.
Ви можете встановити його в значення <code>more</code> чи ваш улюблений прогортач сторінок (за замовчуванням — це <code>less</code>), чи вимкнути його, задавши як значення порожній рядок:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global core.pager ''</code></pre>
</div>
</div>
<div class="paragraph">
<p>Якщо ви виконаєте це, Git буде відображати увесь результат всіх команд, незалежно від його довжини.</p>
</div>
</div>
<div class="sect4">
<h4 id="_user_signingkey"><code>user.signingkey</code></h4>
<div class="paragraph">
<p>
Якщо ви створюєте підписані анотовані теґи (як це обговорювалось у <a href="{{< relurl "book/uk/v2/ch00/_signing" >}}">Підписання праці</a>), то встановлення вашого GPG ключа підпису в конфігураційних налаштуваннях зробить це простішим.
Вкажіть ID вашого ключа наступним чином:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global user.signingkey &lt;gpg-key-id&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Тепер ви можете підписувати теґи без необхідності кожного разу вказувати ваш ключ у команді <code>git tag</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git tag -s &lt;tag-name&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_core_excludesfile"><code>core.excludesfile</code></h4>
<div class="paragraph">
<p>
Ви можете задати шаблони у файлі <code>.gitignore</code> вашого проекту для того, щоб Git не бачив їх як невідслідковувані та не намагався індексувати при виконанні команди <code>git add</code> на них, як це обговорювалось у <a href="{{< relurl "book/uk/v2/ch00/_ignoring" >}}">Ігнорування файлів</a>.</p>
</div>
<div class="paragraph">
<p>Але іноді виникає потреба ігнорувати певні файли у всіх сховищах, з якими ви працюєте.
Якщо ваш комп’ютер працює на macOS, ви, напевно, знайомі з файлами <code>.DS_Store</code>.
Якщо ж ви надаєте перевагу редактору Emacs, то знаєте про файли, що їхні назви закінчуються на <code>~</code> чи <code>.swp</code>.</p>
</div>
<div class="paragraph">
<p>Ця опція дозволяє написати щось на зразок глобального файлу <code>.gitignore</code>.
Якщо ви створите файл <code>~/.gitignore_global</code> з наступним вмістом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">*~
.*.swp
.DS_Store</code></pre>
</div>
</div>
<div class="paragraph">
<p>…та виконаєте команду <code>git config --global core.excludesfile ~/.gitignore_global</code>, то Git більше ніколи не буде турбувати вас щодо цих файлів.</p>
</div>
</div>
<div class="sect4">
<h4 id="_help_autocorrect"><code>help.autocorrect</code></h4>
<div class="paragraph">
<p>
Якщо ви помиляєтесь при наборі команди, то виводиться щось подібне до цього:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git chekcout master
git: 'chekcout' is not a git command. See 'git --help'.

Did you mean this?
    checkout</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git послужливо намагається зрозуміти, що ви мали на увазі, але відмовляється виконувати це.
Якщо встановити значення <code>help.autocorrect</code> рівним 1, то Git буде все ж таки виконувати цю команду:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git chekcout master
WARNING: You called a Git command named 'chekcout', which does not exist.
Continuing under the assumption that you meant 'checkout'
in 0.1 seconds automatically...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Зверніть увагу на це дивне “0.1 seconds”. Насправді значення опції <code>help.autocorrect</code> є цілим числом, що представляє десяті секудни.
Тому, якщо встановити його рівним 50, то Git дасть вам 5 секунд, щоб змінити свою думку перед виконанням відкоректованої команди.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_кольори_у_git">Кольори у Git</h3>
<div class="paragraph">
<p>
Git повністю підтримує кольорове виведення у терміналі, що робить візуальний розбір результатів виконання команд значно швидшим та легшим.
Чимало опцій можуть допомогти налаштувати кольори відповідно до ваших вподобань.</p>
</div>
<div class="sect4">
<h4 id="_color_ui"><code>color.ui</code></h4>
<div class="paragraph">
<p>Git автоматично розфарбовує більшу частину свого виведення, але є головний вимикач, якщо вам не подобається така поведінка.
Щоб вимкнути кольорове виведення Git у терміналі, зробіть наступне:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global color.ui false</code></pre>
</div>
</div>
<div class="paragraph">
<p>Типовим налаштуванням є <code>auto</code>, що розфарбовує виведення, коли воно йде прямо у термінал, але уникає керування кольором, коли виведення переадресовується у канал чи файл.</p>
</div>
<div class="paragraph">
<p>Ви також можете встановити його у значення <code>always</code> для ігнорування різниці між терміналами та каналами.
Вам рідко хотітиметься цього; у більшості сценаріїв, якщо вам потрібне кольорове кодування у переадресованому виведенні, можна передати параметр <code>--color</code> в команду Git, щоб змусити його використовувати кольорове кодування.
Типове значення майже завжди є тим, чого ви бажаєте.</p>
</div>
</div>
<div class="sect4">
<h4 id="_color"><code>color.*</code></h4>
<div class="paragraph">
<p>Якщо ви хочете вказати більш конкретно, яку команду розфарбовувати і як — Git постачає налаштування кольору для конкретних команд-дієслів.
Кожна з них може бути задана в <code>true</code>, <code>false</code> або <code>always</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>color.branch
color.diff
color.interactive
color.status</pre>
</div>
</div>
<div class="paragraph">
<p>На додаток, кожне з цих підналаштувань можна використовувати для встановлення конкретного кольору для частини виводу, якщо ви бажаєте змінити кожен колір.
Наприклад, щоб встановити метадані у вашому виводі різниці в синій текст, чорне тло та грубий шрифт, ви можете виконати</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global color.diff.meta "blue black bold"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ви можете встановити колір у будь-яке з наступних значень: <code>normal</code>, <code>black</code>, <code>red</code>, <code>green</code>, <code>yellow</code>, <code>blue</code>, <code>magenta</code>, <code>cyan</code>, чи <code>white</code>.
Якщо вам потрібні такі атрибути як bold з попереднього прикладу, то можете вибирати з <code>bold</code>, <code>dim</code>, <code>ul</code> (підкреслено), <code>blink</code> та <code>reverse</code> (переставити тло та текст).</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_external_merge_tools">Зовнішні інструменти зливання (merge) та різниці (diff)</h3>
<div class="paragraph">
<p>
Хоча Git має вбудовану імплементацію отримання різниці, яку ми використовували в цій книзі, ви можете натомість налаштувати зовнішній інструмент.
Ви також можете налаштувати графічний інструмент для розв’язання конфліктів зливання замість того, щоб розв’язувати їх вручну.
Ми продемонструємо налаштування Perforce Visual Merge Tool (P4Merge) для відображення різниці та розв’язання конфліктів, адже це гарна графічна програма та вона безкоштовна.</p>
</div>
<div class="paragraph">
<p>Якщо ви бажаєте спробувати її, P4Merge працює на всіх розповсюджених платформах, отже ви маєте бути в змозі це зробити.
Ми використовуватимемо в прикладах шляхи, які працюють на системах Mac та Linux; для Windows, вам доведеться замінити <code>/usr/local/bin</code> на шлях до програми у вашому середовищі.</p>
</div>
<div class="paragraph">
<p>Спочатку, <a href="https://www.perforce.com/product/components/perforce-visual-merge-and-diff-tools">завантажте P4Merge з Perforce</a>.
Далі, ви налаштуєте зовнішні скрипти обгортки для виконання своїх команд.
Ми використовуватимемо шлях Mac для програми; на інших системах, він буде там, де встановлено файл <code>p4merge</code>.
Налаштуйте обгортку для зливання під назвою <code>extMerge</code>, яка викликає програму з усіма опціями:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat /usr/local/bin/extMerge
#!/bin/sh
/Applications/p4merge.app/Contents/MacOS/p4merge $*</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обгортка diff перевіряє, чи дійсно отримано сім параметрів, та передає два з них до вашого скрипта зливання.
Типово, Git передає наступні аргументи до програми diff:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>path old-file old-hex old-mode new-file new-hex new-mode</code></pre>
</div>
</div>
<div class="paragraph">
<p>Оскільки вам потрібні лише <code>old-file</code> та <code>new-file</code>, ви використовуєте обгортку, щоб передати лише потрібні.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat /usr/local/bin/extDiff
#!/bin/sh
[ $# -eq 7 ] &amp;&amp; /usr/local/bin/extMerge "$2" "$5"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вам також потрібно переконатися, що ці програми виконанні:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ sudo chmod +x /usr/local/bin/extMerge
$ sudo chmod +x /usr/local/bin/extDiff</code></pre>
</div>
</div>
<div class="paragraph">
<p>Тепер ви можете налаштувати свій конфігураційний файл, щоб використовувалися ваші власні інструменти відображення різниці та розв’язання конфліктів.
Для цього потрібні декілька налаштувань: <code>merge.tool</code>, щоб сказати Git яку стратегію використовувати, <code>mergetool.&lt;інструмент&gt;.cmd</code>, щоб задати, як виконувати команду, <code>mergetool.&lt;інструмент&gt;.trustExitCode</code>, щоб сказати Git, чи означає код виходу програми успішність розв’язання чи ні, а також <code>diff.external</code>, щоб сказати Git, яку команду треба виконувати для відображення різниці.
Отже, ви можете або виконати наступні чотири команди config</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global merge.tool extMerge
$ git config --global mergetool.extMerge.cmd \
  'extMerge "$BASE" "$LOCAL" "$REMOTE" "$MERGED"'
$ git config --global mergetool.extMerge.trustExitCode false
$ git config --global diff.external extDiff</code></pre>
</div>
</div>
<div class="paragraph">
<p>або відредагувати файл <code>~/.gitconfig</code>, щоб додати ці рядки:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">[merge]
  tool = extMerge
[mergetool "extMerge"]
  cmd = extMerge "$BASE" "$LOCAL" "$REMOTE" "$MERGED"
  trustExitCode = false
[diff]
  external = extDiff</code></pre>
</div>
</div>
<div class="paragraph">
<p>Після того як це зроблено, якщо ви виконаєте команду diff, на кшталт такої:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff 32d1776b1^ 32d1776b1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Замість отримання різниці в командному рядку, Git запустить P4Merge, який виглядає приблизно так:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/uk/v2/images/p4merge.png" >}}" alt="P4Merge.">
</div>
<div class="title">Рисунок 142. P4Merge.</div>
</div>
<div class="paragraph">
<p>Якщо ви спробуєте злити дві гілки та отримаєте конфлікти злиття, то можете виконати команду <code>git mergetool</code>; вона запускає P4Merge, щоб дозволити вам розв’язати конфлікти цим графічним інструментом.</p>
</div>
<div class="paragraph">
<p>У такому налаштуванні обгорток зручно те, що ви легко можете змінити інструменти diff та merge.
Наприклад, щоб змінити свої <code>extDiff</code> та <code>extMerge</code> так, щоб вони натомість викликали KDiff3, усе, що вам треба зробити — змінити файл <code>extMerge</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat /usr/local/bin/extMerge
#!/bin/sh
/Applications/kdiff3.app/Contents/MacOS/kdiff3 $*</code></pre>
</div>
</div>
<div class="paragraph">
<p>Тепер, Git використовуватиме інструмент KDiff3 для відображення різниць та розв’язання конфліктів зливання.</p>
</div>
<div class="paragraph">
<p>Git одразу має налаштування для використання великої кількості інших інструментів розв’язання конфліктів без необхідності налаштування команд.
Щоб побачити список підтримуваних інструментів, спробуйте:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git mergetool --tool-help
'git mergetool --tool=&lt;tool&gt;' may be set to one of the following:
        emerge
        gvimdiff
        gvimdiff2
        opendiff
        p4merge
        vimdiff
        vimdiff2

The following tools are valid, but not currently available:
        araxis
        bc3
        codecompare
        deltawalker
        diffmerge
        diffuse
        ecmerge
        kdiff3
        meld
        tkdiff
        tortoisemerge
        xxdiff

Some of the tools listed above only work in a windowed
environment. If run in a terminal-only session, they will fail.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Якщо ви не зацікавлені у використанні KDiff3 для різниць, а надаєте йому перевагу лише для розв’язання конфліктів, та команда kdiff3 є у вашому path, то можете виконати</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global merge.tool kdiff3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Якщо ви виконаєте це замість налаштування файлів <code>extMerge</code> та <code>extDiff</code>, то Git буде використовувати KDiff3 для розв’язання конфліктів, а для відображення різниць звичайний інструмент Git.</p>
</div>
</div>
<div class="sect3">
<h3 id="_форматування_та_пробільні_символи">Форматування та пробільні символи.</h3>
<div class="paragraph">
<p>
Проблеми з форматуванням та пробільними символами є одними з найбільш дратуючих та невловимих, та багато розробників стикаються з ними під час співпраці, особливо міжплатформевої.
Латки чи інша співпраця дуже легко можуть запровадити непомітні зміни пробільних символів, адже редактори тихо впроваджують їх, та якщо файли колись бували на системі Windows, усі символи кінця рядка можуть бути змінені.
Git має декілька опцій, щоб зарадити з цим.</p>
</div>
<div class="sect4">
<h4 id="_core_autocrlf"><code>core.autocrlf</code></h4>
<div class="paragraph">
<p>
Якщо ви програмуєте під Windows та працюєте з людьми, які цього не роблять (чи навпаки), то колись ви, імовірно, отримаєте проблеми з кінцями рядків.
Таке трапляється через те, що Windows використовує і символ повернення каретки, і символи зміни рядка для нових рядків у файлах, в той час як системи Mac та Linux використовують лише символ нового рядка.
Це непомітно, проте неймовірно навісний факт для міжплатформової праці; багато редакторів Windows тихо замінюють існуючі кінці рядків LF на CRLF, або додають обидва символи, коли користувач натискає клавішу ентер.</p>
</div>
<div class="paragraph">
<p>Git може впоратись з цим: автоматично конвертувати кінці рядків CRLF до LF, коли ви додаєте файл до індексу, та навпаки, коли ви отримуєте код до файлової системи.
Ви можете увімкнути цей функціонал за допомогою налаштування <code>core.autocrlf</code>.
Якщо ви працюєте на машині Windows, то встановлення цього в <code>true</code> конвертує LF до CRLF під час отримання коду:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global core.autocrlf true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Якщо ви на системі Linux чи Mac, які використовують кінці рядків LF, то ви не бажаєте, щоб Git автоматично конвертував їх під час отримання файлів; втім, якщо файл з CRLF випадково впроваджено, то ви можете бажати, щоб Git це виправив.
Ви можете сказати Git перетворювати CRLF на LF під час створення коміту, проте не навпаки, якщо встановете <code>core.autocrlf</code> у значення input:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global core.autocrlf input</code></pre>
</div>
</div>
<div class="paragraph">
<p>Таке схема має залишити вам символи CRLF після отримань на Windows, та символ LF  на системах Mac та Linux у сховищі.</p>
</div>
<div class="paragraph">
<p>Якщо ви програміст Windows та розробляєте проект лише для Windows, то можете вимкнути цю функціональність, тобто записувати повернення каретки до сховища, якщо встановите це конфігураційне значення у <code>false</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global core.autocrlf false</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_core_whitespace"><code>core.whitespace</code></h4>
<div class="paragraph">
<p>Git одразу налаштовано визначати та виправляти деякі проблеми з пробільними символами.
Він може шукати шість головних проблем з пробільними символами — три типово ввімкнуті та можуть бути вимкнені, а інші три типово вимкнені, проте можуть бути активовані.</p>
</div>
<div class="paragraph">
<p>Типово ввімкнені: <code>blank-at-eol</code>, яка шукає пробіли наприкінці рядка; <code>blank-at-eof</code>, яка помічає порожні рядки наприкінці файлу; та <code>space-before-tab</code>, яка шукає пробіли перед табами на початку рядка.</p>
</div>
<div class="paragraph">
<p>Три типово вимкнені, які можна увімкнути: <code>indent-with-non-tab</code>, яка шукає рядки, які починаються з пробілів замість табів (та контролюється опцією <code>tabwidth</code>); <code>tab-in-indent</code>, яка слідкує за табами у відступах; та <code>cr-at-eol</code>, яка каже Git, що переведення каретки наприкінці рядків це нормально.</p>
</div>
<div class="paragraph">
<p>Ви можете сказати Git, які з них ви бажаєте ввімкнути, якщо встановите налаштування <code>core.whitespace</code> у значення, які ви бажаєте щоб працювали чи ні, розділені комами.
Ви можете вимкнути опцію, додавши <code>-</code> перед її назвою, або залишити типове значення, просто не зазначивши в рядку налаштувань..
Наприклад, якщо ви бажаєте встановити все, крім <code>space-before-tab</code>, то можете зробити таке (<code>trailing-space</code> — це скорочення для двох опцій: <code>blank-at-eol</code> та <code>blank-at-eof</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global core.whitespace \
    trailing-space,-space-before-tab,indent-with-non-tab,tab-in-indent,cr-at-eol</code></pre>
</div>
</div>
<div class="paragraph">
<p>Або ви можете вказати лише частину, що відрізняється від типових значень:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global core.whitespace \
    -space-before-tab,indent-with-non-tab,tab-in-indent,cr-at-eol</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git знаходитиме ці проблеми, коли ви виконуєте команду <code>git diff</code> та намагатиметься розфарбувати їх, щоб ви могли виправити їх перед збереженням коміту.
Він також використовує ці значення, щоб допомогти застосовувати латки командою <code>git apply</code>.
Коли ви застосовуєте латки, ви можете попросити Git попереджати вас, якщо вони містять зазначені проблеми пробільних символів:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git apply --whitespace=warn &lt;patch&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Або ви можете зробити так, щоб Git намагався автоматично виправити ці проблеми перед застосуванням латки:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git apply --whitespace=fix &lt;patch&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ці опції також стосуються команди <code>git rebase</code>.
Якщо ви зберегли в коміті помилки пробільних символів, проте ще не надіслали зміни, то можете виконати git rebase --whitespace=fix, щоб Git автоматично виправив ці проблеми під час переписування латок.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_конфігурація_сервера">Конфігурація сервера</h3>
<div class="paragraph">
<p>Геть не так багато конфігураційних опцій існує для серверної частини Git, проте є декілька цікавих, які ви можете запам’ятати.</p>
</div>
<div class="sect4">
<h4 id="_receive_fsckobjects"><code>receive.fsckObjects</code></h4>
<div class="paragraph">
<p>Git має можливість переконатися, що кожен отриманий під час push об’єкт досі збігається зі SHA-1 сумою та вказує на чинні об’єкти.
Втім, він типово цього не робить; ця операція забирає багато часу, та може уповільнити операцію, особливо з великими сховищами чи надсиланнями.
Якщо ви бажаєте, щоб Git перевіряв цілісність об’єктів під час кожного надсилання, ви можете змусити його це робити, якщо встановите налаштування <code>receive.fsckObjects</code> у true.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --system receive.fsckObjects true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Тепер, Git перевірятиме цілісність вашого сховища перед прийняттям кожного надсилання, щоб переконатись, що пошкодженні (чи шкідливі) клієнти не впроваджують зіпсованих даних.</p>
</div>
</div>
<div class="sect4">
<h4 id="_receive_denynonfastforwards"><code>receive.denyNonFastForwards</code></h4>
<div class="paragraph">
<p>Якщо ви перебазовуєте коміти, які вже надсилали та потім знову намагаєтесь надіслати, чи іншим чином намагаєтесь надіслати коміт до віддаленої гілки, яка не містить коміту, на який зараз вказує гілка, то вам відмовлять.
Це зазвичай гарна політика; проте у випадку перебазування, ви можете вирішити, що знаєте, що робите, та примусити оновлення віддаленої гілки за допомогою опції <code>-f</code> команди push.</p>
</div>
<div class="paragraph">
<p>Щоб сказати Git відмовляти примусовим надсиланням, встановіть <code>receive.denyNonFastForwards</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --system receive.denyNonFastForwards true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ви також можете досягти цього за допомогою серверного гаку на отримання, що ми розглянемо трохи пізніше.
Цей підхід дозволяє вам робити складніші речі, наприклад відмовляти не перемотуванням для деяких користувачів.</p>
</div>
</div>
<div class="sect4">
<h4 id="_receive_denydeletes"><code>receive.denyDeletes</code></h4>
<div class="paragraph">
<p>Один з манівців до політики <code>denyNonFastForwards</code> для користувачів — вилучити гілку, а потім надіслати зміни до нового посилання.
Щоб уникнути цього, встановіть <code>receive.denyDeletes</code> у true:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --system receive.denyDeletes true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Це відмовляє будь-яким вилученням гілок чи теґів — жоден користувач не зможе цього робити.
Щоб вилучити віддалену гілку, вам доведеться вилучати файли посилань з сервера вручну.
Існують цікавіши методи робити це для окремих користувачів на базі ACL, про що ви дізнаєтесь в <a href="{{< relurl "book/uk/v2/ch00/_an_example_git_enforced_policy" >}}">Приклад політики користування виконуваної Git-ом</a>.</p>
</div>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>