---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: uk
  chapter:
    title: Інструменти Git
    number: 7
  section:
    title: Складне злиття
    number: 8
    cs_number: '7.8'
    previous: book/uk/v2/Інструменти-Git-Усвідомлення-скидання-reset
    next: book/uk/v2/Інструменти-Git-Rerere
title: Git - Складне злиття
url: "/book/uk/v2/Інструменти-Git-Складне-злиття.html"
---
<h2 id="_advanced_merging">Складне злиття</h2>
<div class="paragraph">
<p>Зливання в Git зазвичай проходить доволі легко.
Оскільки Git дозволяє легко зливати іншу гілку декілька разів, ви можете працювати з дуже довготривалою гілкою, і в той же час оновлювати її в процесі роботи, та часто розв’язувати маленькі конфлікти замість того, щоб бути враженим величезним конфліктом наприкінці роботи з нею.</p>
</div>
<div class="paragraph">
<p>Утім, іноді трапляються й хитромудрі конфлікти.
На відміну від інших систем контролю версій, Git не намагається бути надто розумним щодо розв’язання конфліктів.
Філософія Git — бути розумним, коли злиття можна зробити однозначно, проте, якщо є конфлікт, Git не намагається бути розумним та автоматично його вирішити.
Отже, якщо ви надто зволікаєте зі злиттям двох гілок, що розходяться швидко, у вас можуть виникнути проблеми.</p>
</div>
<div class="paragraph">
<p>У цій секції, ми розглянемо деякі з тих проблем, що можуть виникнути, та які утиліти Git допомагають впоратись з багатьма складними ситуаціями.
Ми також розглянемо деякі інші, нестандартні типи зливань, які ви можете робити, а також як відмовитися від вже зробленого зливання.</p>
</div>
<div class="sect3">
<h3 id="_конфлікти_злиття">Конфлікти злиття</h3>
<div class="paragraph">
<p>Хоч ми й розглянули деякі основи розв’язання конфліктів зливання в <a href="{{< relurl "book/uk/v2/ch00/_basic_merge_conflicts" >}}">Основи конфліктів зливання</a>, для складніших конфліктів Git пропонує декілька утиліт, що допоможуть вам збагнути що коїться та як краще мати справу з конфліктом.</p>
</div>
<div class="paragraph">
<p>Спершу, якщо це взагалі можливо, спробуйте зробити вашу робочу директорію чистою до того, як робити зливання, що призводять до конфліктів.
Якщо у вас є незавершені зміни, або зробіть коміт до тимчасової гілки, або сховайте їх (stash).
Таким чином ви зможете скасувати <strong>будь-яку</strong> з ваших спроб.
Якщо у вас є незбережені зміни у робочій директорій, коли ви намагаєтесь зробити зливання, деякі з наступних інструкцій можуть сприяти втраті вашої праці.</p>
</div>
<div class="paragraph">
<p>Розгляньмо дуже простий приклад.
У нас є надпростий файл Ruby, що друкує <em>hello world</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
  puts 'hello world'
end

hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>У нашому репозиторії, ми створюємо нову гілку <code>whitespace</code> та замінюємо всі Unix символи нового рядка на варіант DOS, тобто змінюємо кожен рядок файлу, проте виключно пробільні символи.
Потім ми змінюємо рядок “hello world” на “hello mundo”.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b whitespace
Switched to a new branch 'whitespace'

$ unix2dos hello.rb
unix2dos: converting file hello.rb to DOS format ...
$ git commit -am 'converted hello.rb to DOS'
[whitespace 3270f76] converted hello.rb to DOS
 1 file changed, 7 insertions(+), 7 deletions(-)

$ vim hello.rb
$ git diff -b
diff --git a/hello.rb b/hello.rb
index ac51efd..e85207e 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,7 @@
 #! /usr/bin/env ruby

 def hello
-  puts 'hello world'
+  puts 'hello mundo'^M
 end

 hello()

$ git commit -am 'hello mundo change'
[whitespace 6d338d2] hello mundo change
 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Тепер перейдемо назад до гілки та додамо якийсь опис цієї функції.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
Switched to branch 'master'

$ vim hello.rb
$ git diff
diff --git a/hello.rb b/hello.rb
index ac51efd..36c06c8 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello world'
 end

$ git commit -am 'document the function'
[master bec6336] document the function
 1 file changed, 1 insertion(+)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Тепер ми спробуємо злити до гілки <code>whitespace</code> та отримаємо конфлікти через зміни пробільних символів.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge whitespace
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="sect4">
<h4 id="_abort_merge">Припинення злиття</h4>
<div class="paragraph">
<p>Тепер у нас є декілька варіантів.
По-перше, розповімо, як вийти з цього становища.
Можливо, ви не очікували конфліктів, та не дуже бажаєте вирішувати ситуацію зараз, ви можете просто припинити злиття за допомогою <code>git merge --abort</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status -sb
## master
UU hello.rb

$ git merge --abort

$ git status -sb
## master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Опція <code>git merge --abort</code> намагається повернутися до стану, в якому ви були до початку зливання.
Єдиний випадок, коли це може не вийти бездоганно — якщо у вас були несховані незбережені зміни в робочій директорії, коли ви почали злиття, інакше все пройде без проблем.</p>
</div>
<div class="paragraph">
<p>Якщо з будь-якої причини ви просто бажаєте почати все з початку, ви можете виконати <code>git reset --hard HEAD</code>, і ваше сховище повернеться до стану останнього коміту.
Памʼятайте, що будь-які не збережені в коміті зміни будуть втрачені, отже переконайтеся, що всі локальні зміни вам не потрібні.</p>
</div>
</div>
<div class="sect4">
<h4 id="_ігнорування_пробільних_символів">Ігнорування пробільних символів</h4>
<div class="paragraph">
<p>У цьому окремому випадку, конфлікти пов’язані з пробільними символами.
Ми знаємо про це, адже випадок простий, проте це доволі легко побачити в реальних ситуаціях, подивившись на конфлікт: кожен рядок видалено з одного боку та знову додано з іншого.
Без додаткових опцій, Git розглядає всі рядки як змінені, отже не може злити файли.</p>
</div>
<div class="paragraph">
<p>Втім, типова стратегія зливання може приймати опції, а декілька з них про правильне ігнорування зміни пробільних символів.
Якщо ви бачите, що у вас купа проблем з пробільними символами при злитті, ви можете просто припинити його та спробувати ще раз, цього разу з <code>-Xignore-all-space</code> або <code>-Xignore-space-change</code>.
Перша опція <strong>цілковито</strong> ігнорує пробільні символи при порівнянні рядків, а друга сприймає послідовності одного чи більше пробільних символів як рівнозначні.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge -Xignore-space-change whitespace
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Оскільки в даному випадку, справжні зміни файла не конфліктують, щойно ми проігноруємо зміни пробільних символів, злиття пройде чудово.</p>
</div>
<div class="paragraph">
<p>Це просто рятує життя, якщо хтось з вашої команди подеколи полюбляє замінити пробіли на таби чи навпаки.</p>
</div>
</div>
<div class="sect4">
<h4 id="_manual_remerge">Повторне злиття файла вручну</h4>
<div class="paragraph">
<p>Хоч Git і може впоратися з обробкою пробільних символів доволі якісно, існують інші типи змін, які Git певно не можне обробити автоматично, проте самі зміни зроблені автоматично.
Наприклад, вдамо, що Git не зміг впоратися зі змінами пробілів, та ми маємо зробити це самі.</p>
</div>
<div class="paragraph">
<p>Що нам насправді треба зробити — це прогнати файл, який ми намагаємося злити, через програму <code>dos2unix</code> до того, як починати власне злиття файла.
То як нам це зробити?</p>
</div>
<div class="paragraph">
<p>Спочатку нам треба потрапити до стану конфлікту злиття.
Потім нам треба отримати копії нашої версії файла, їхньої версії (з гілки, яку ми зливаємо до нашої) та спільної версії (звідки обидві сторони розгалузились).
Далі ми бажаємо виправити або їхній варіант або наш та спробувати злити знову лише цей один файл.</p>
</div>
<div class="paragraph">
<p>Отримати три версії файла насправді доволі просто.
Git зберігає кожну з цих версій в індексі під “станами” (stages), які мають пов’язані з ними номери.
Стан 1 — це спільний предок, стан 2 — це ваша версія, а стан 3 — з `MERGE_HEAD, версія, яку ви зливаєте до себе (“їхня”, theirs)</p>
</div>
<div class="paragraph">
<p>Ви можете витягнути копію кожної з цих версій конфліктного файлу за допомогою команди <code>git show</code> зі спеціальним синтактом.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show :1:hello.rb &gt; hello.common.rb
$ git show :2:hello.rb &gt; hello.ours.rb
$ git show :3:hello.rb &gt; hello.theirs.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Якщо ви бажаєте чогось суворішого, скористайтесь кухонною командою <code>ls-files -u</code>, щоб отримати власне SHA-1 суми Git блобів кожного з цих файлів</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git ls-files -u
100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1	hello.rb
100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2	hello.rb
100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3	hello.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>:1:hello.rb</code> — це просто скорочення для пошуку SHA-1 цього блобу.</p>
</div>
<div class="paragraph">
<p>Тепер у нас є зміст всіх трьох станів у нашій робочій директорії, ми можемо вручну виправити їхню версію — усунути проблему з пробільними символами, та ще раз злити файл за допомогою маловідомої команди <code>git merge-file</code>, яка робить саме це.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ dos2unix hello.theirs.rb
dos2unix: converting file hello.theirs.rb to Unix format ...

$ git merge-file -p \
    hello.ours.rb hello.common.rb hello.theirs.rb &gt; hello.rb

$ git diff -b
diff --cc hello.rb
index 36c06c8,e85207e..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,8 -1,7 +1,8 @@@
  #! /usr/bin/env ruby

 +# prints out a greeting
  def hello
-   puts 'hello world'
+   puts 'hello mundo'
  end

  hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Тепер ми гарно злили файл.
Насправді, це працює навіть краще, ніж опція <code>ignore-space-change</code>, адже зміни пробільних символів виправлено до злиття, а не просто проігноровано.
У злитті з <code>ignore-space-change</code>, ми в результаті отримали декілька рядків з DOS символами нового рядка, що призвело до змішання.</p>
</div>
<div class="paragraph">
<p>До того, як завершувати цей коміт, ви можете поглянути, що саме змінилось між однією чи іншою стороною: ви можете попросити <code>git diff</code> порівняти те, що ви збираєтесь зберегти з вашої робочої директорії як результат злиття, з будь-яким з цих станів.
Пройдімось по ним усім.</p>
</div>
<div class="paragraph">
<p>Щоб порівняти результат з тим, що було до зливання, іншими словами, щоб побачити, що саме з’явилось від злиття, можна виконати <code>git diff --ours</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --ours
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index 36c06c8..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -2,7 +2,7 @@

 # prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Отже тут ми легко можемо побачити, що саме сталося в нашій гілці, що ми насправді змінюємо у файлі цим злиттям: змінюємо один рядок.</p>
</div>
<div class="paragraph">
<p>Якщо ми бажаємо побачити, чим результат зливання відрізняється від того, що було на їхній стороні, можемо виконати <code>git diff --theirs</code>.
У цьому й наступному прикладі, ми маємо використати <code>-b</code>, щоб прибрати пробільні символи, бо порівняння проходить зі збереженим у Git, а не з нашим очищеним файлом <code>hello.theirs.rb</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --theirs -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index e85207e..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello mundo'
 end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Нарешті, ви можете побачити, як файл змінився з обох сторін за допомогою <code>git diff --base</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --base -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index ac51efd..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,8 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Тепер ми можемо використати команду <code>git clean</code>, щоб прибрати зайві файли, що ми їх створили для зливання вручну, бо вони більше не потрібні.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clean -f
Removing hello.common.rb
Removing hello.ours.rb
Removing hello.theirs.rb</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_checking_out_conflicts">Отримання при конфліктах</h4>
<div class="paragraph">
<p>Можливо, ми наразі не задоволені розв’язанням конфлікту з якихось причин, або можливо редагування вручну однієї чи обох сторін досі не вийшло та нам треба більше контексту.</p>
</div>
<div class="paragraph">
<p>Змінімо трохи наш приклад.
У цьому прикладі, у нас є дві більш довготривалі гілки, у кожній по декілька комітів, проте при зливанні створюють конфлікт саме за змістом.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --graph --oneline --decorate --all
* f1270f7 (HEAD, master) update README
* 9af9d3b add a README
* 694971d update phrase to hola world
| * e3eb223 (mundo) add more tests
| * 7cff591 add testing script
| * c3ffff1 changed text to hello mundo
|/
* b7dcc89 initial hello world code</code></pre>
</div>
</div>
<div class="paragraph">
<p>Тепер у нас три унікальних коміти, які є лише в гілці <code>master</code>, та три інших коміти, які є в гілці <code>mundo</code>.
Якщо ми спробуємо злити <code>mundo</code>, то отримаємо конфлікт.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ми хотіли б побачити, у чому власне конфлікт.
Якщо відкрити файл, то побачимо щось таке:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
  puts 'hola world'
=======
  puts 'hello mundo'
&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo
end

hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обидві сторони зливання додали зміст до цього файлу, проте деякі з комітів змінили файл в одному місці, що й спричинило цей конфлікт.</p>
</div>
<div class="paragraph">
<p>Дослідімо декілька утиліт у вашому розпорядженні, щоб визначити, як виник цей конфлікт.
Можливо, як саме варто розв’язати конфлікт не є очевидним.
Вам потрібно більше контексту.</p>
</div>
<div class="paragraph">
<p>Одна з корисних команд — <code>git checkout</code> з опцією <code>--conflict</code>.
Ця команда ще раз отримає файл, та замінить позначки конфлікту (conflict markers).
Це може бути корисним, якщо ви бажаєте відновити позначки та спробувати розв’язати їх знову.</p>
</div>
<div class="paragraph">
<p>Ви можете встановити <code>--conflict</code> значення <code>diff3</code>, або <code>merge</code> (що є типовим значенням).
Якщо передати <code>diff3</code>, то Git використає трохи іншу версію позначок конфлікту: не тільки надасть вам “вашу” та “їхню” версії, а ще й “базову” версію до файлу, щоб надати вам більше контексту.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout --conflict=diff3 hello.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Після виконання, файл стане виглядати так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; ours
  puts 'hola world'
||||||| base
  puts 'hello world'
=======
  puts 'hello mundo'
&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs
end

hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Якщо вам подобається такий формат, ви можете зробити його типовим для майбутніх конфліктів злиття, якщо встановите налаштування <code>merge.conflictstyle</code> у значення <code>diff3</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global merge.conflictstyle diff3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Команда <code>git checkout</code> також приймає опції <code>--ours</code> та <code>--theirs</code>, які є дійсно швидким засобом вибору лише однієї сторони, взагалі без зливання іншої.</p>
</div>
<div class="paragraph">
<p>Це особливо корисно для конфліктів двійкових файлів, адже ви можете просто вибрати одну сторону, або коли ви хочете злити окремі файли з іншої гілки - ви можете злити, а потім отримати (checkout) окремі файли з однієї сторони до створення коміту.</p>
</div>
</div>
<div class="sect4">
<h4 id="_merge_log">Журнал зливання</h4>
<div class="paragraph">
<p>Ще одна корисна утиліта при розв’язанні конфліктів злиття — <code>git log</code>.
Вона може допомогти вам отримати інформацію про те, що могло сприяти конфлікту.
Переглянути трохи історії, щоб запам’ятати, чому два рядки розробки зачепили одну область коду, може бути дуже корисним подеколи.</p>
</div>
<div class="paragraph">
<p>Щоб отримати повний список усіх унікальних комітів, що є у будь-якій з конфліктуючих гілок, можна використати синтаксис “потрійної крапки”, про який ми дізналися в <a href="{{< relurl "book/uk/v2/ch00/_triple_dot" >}}">Потрійна крапка</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --left-right HEAD...MERGE_HEAD
&lt; f1270f7 update README
&lt; 9af9d3b add a README
&lt; 694971d update phrase to hola world
&gt; e3eb223 add more tests
&gt; 7cff591 add testing script
&gt; c3ffff1 changed text to hello mundo</code></pre>
</div>
</div>
<div class="paragraph">
<p>Це гарний список усіх шести комітів, а також з якої лінії розробки надійшов кожен коміт.</p>
</div>
<div class="paragraph">
<p>Ми можемо ще спростити список так, щоб це надало нам більш точний контекст.
Якщо додати опцію <code>--merge</code> до <code>git log</code>, вона покаже лише ті коміти з обох сторін злиття, які зачепили файл, в якому наразі є конфлікти.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --left-right --merge
&lt; 694971d update phrase to hola world
&gt; c3ffff1 changed text to hello mundo</code></pre>
</div>
</div>
<div class="paragraph">
<p>Якщо виконати це з опцією <code>-p</code>, отримаємо лише зміни у файлах, які опинились у конфлікті.
Це може бути <strong>дійсно</strong> корисним у швидкому надаванні контексту, що допоможе зрозуміти причини конфлікту та як його розумно розв’язати.</p>
</div>
</div>
<div class="sect4">
<h4 id="_поєднаний_формат_різниці_diff">Поєднаний формат різниці (diff)</h4>
<div class="paragraph">
<p>Оскільки Git індексує будь-які успішні результати злиття, коли ви виконуєте <code>git diff</code> у стані конфлікту злиття, ви отримуєте лише конфліктуючі зміни.
Це може бути корисним, щоб побачити, що вам ще треба розв’язати.</p>
</div>
<div class="paragraph">
<p>Якщо виконати <code>git diff</code> одразу після конфлікту злиття, то вона видасть інформацію в доволі унікальному форматі різниці.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,11 @@@
  #! /usr/bin/env ruby

  def hello
++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
 +  puts 'hola world'
++=======
+   puts 'hello mundo'
++&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo
  end

  hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Формат називається “Поєднана різниця” (combined diff) та видає дві колонки даних навпроти кожного рядка.
Перша колонка показує вам, якщо рядок змінився (доданий чи вилучений) між “вашою” гілкою та файлом у робочій директорії, а друга колонка робить те саме між “їхньою” гілкою та робочою директорією.</p>
</div>
<div class="paragraph">
<p>Отже в цьому прикладі можна побачити, що рядки <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> та <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> є в робочій копії, проте їх нема в жодній зі сторін зливання.
Це має сенс, адже утиліта злиття додала їх для нас, але від нас очікується їх вилучення.</p>
</div>
<div class="paragraph">
<p>Якщо розв’язати конфлікт та виконати <code>git diff</code> знову, ми побачимо схожий результат, проте трохи корисніший.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ vim hello.rb
$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Це показує нам, що “hola world” був на нашій стороні, проте не в робочій копії; “hello mundo” був на їхній стороні, проте не в робочій копії; та нарешті, “hola mundo” не був у жодній зі сторін, проте є в робочій копії.
Це може бути корисним, щоб переглянути розв’язання конфлікту до створення коміту.</p>
</div>
<div class="paragraph">
<p>Ви також можете отримати таке від <code>git log</code> для будь-якого вже зробленого зливання, щоб побачити як щось було розв’язано.
Git зробить видрук у цьому форматі, якщо виконати <code>git show</code> для коміту злиття, або якщо додати опцію <code>--cc</code> до <code>git log -p</code> (яка типово показує лише латки для комітів не злиття).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --cc -p -1
commit 14f41939956d80b9e17bb8721354c33f8d5b5a79
Merge: f1270f7 e3eb223
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Sep 19 18:14:49 2014 +0200

    Merge branch 'mundo'

    Conflicts:
        hello.rb

diff --cc hello.rb
index 0399cd5,59727f0..e1d0799
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_undoing_merges">Скасування зливань</h3>
<div class="paragraph">
<p>Тепер, коли ви знаєте, як створити коміт злиття, ви напевно зробите якусь помилку.
Одна з чудових речей роботи з Git — що це нормально робити помилки, адже їх можливо (та зазвичай легко) виправити.</p>
</div>
<div class="paragraph">
<p>Коміти зливання тут не відрізняються.
Скажімо, ви почали працювати над тематичною гілкою, та випадково злили її до <code>master</code>, і тепер історія комітів виглядає так:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/uk/v2/images/undomerge-start.png" >}}" alt="Випадковий коміт злиття.">
</div>
<div class="title">Рисунок 137. Випадковий коміт злиття</div>
</div>
<div class="paragraph">
<p>Є два підходи до цієї проблеми, у залежності від бажаного результату.</p>
</div>
<div class="sect4">
<h4 id="_виправити_посилання">Виправити посилання</h4>
<div class="paragraph">
<p>Якщо небажаний коміт зливання існує лише у вашому локальному репозиторії, найлегше та найкраще рішення — пересунути гілки так, щоб вони вказували на що ви забажаєте.
У більшості випадків, якщо одразу після помилки <code>git merge</code>, виконати <code>git reset --hard HEAD~</code>, то вказівники гілок будуть скинуті і будуть виглядати так:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/uk/v2/images/undomerge-reset.png" >}}" alt="Історія після `git reset --hard HEAD~`.">
</div>
<div class="title">Рисунок 138. Історія після <code>git reset --hard HEAD~</code>
</div>
</div>
<div class="paragraph">
<p>Ми розглядали <code>reset</code> у <a href="{{< relurl "book/uk/v2/ch00/_git_reset" >}}">Усвідомлення скидання (reset)</a>, отже, вам має бути неважко зрозуміти, що тут сталося.
Ось швидке повторення: <code>reset --hard</code> зазвичай робить наступні кроки:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Пересунути гілку, на яку вказує HEAD.
У даному випадку, ми бажаємо пересунути <code>master</code> до того, де вона була до коміту злиття (<code>C6</code>).</p>
</li>
<li>
<p>Скопіювати HEAD до індекс.</p>
</li>
<li>
<p>Скопіювати індекс до робочої директорії.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Недолік цього підходу є те, що це переписування історії, що може стати проблемою в спільному репозиторії.
Прогляньте <a href="{{< relurl "book/uk/v2/ch00/_rebase_peril" >}}">Небезпеки перебазовування</a> для докладного опису того, що може статися; коротка версія така: якщо інші люди мають коміти, які ви переписуєте, вам варто уникати <code>reset</code>.
Цей підхід також не спрацює, якщо інші коміти були створені після злиття; переміщення посилань у результаті втратить ці зміни.</p>
</div>
</div>
<div class="sect4">
<h4 id="_reverse_commit">Вивертання коміту</h4>
<div class="paragraph">
<p>Якщо переміщення вказівників гілок не спрацює для вас, Git дає ще один варіант: створити новий коміт, що скасовує всі зміни з існуючого коміту.
Git називає цю операцію “вивертання” (revert), і в цьому конкретному випадку, треба викликати його так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git revert -m 1 HEAD
[master b1d8379] Revert "Merge branch 'topic'"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Опція <code>-m 1</code> вказує, який батько є “стрижневим” (mainline) та має бути збереженим.
Якщо виконати злиття до <code>HEAD</code> (<code>git merge topic</code>), новий коміт матиме двох батьків: перший це <code>HEAD</code> (<code>C6</code>), а другий — останній коміт гілки, яку ви зливаєте (<code>C4</code>).
У даному випадку, ми бажаємо скасувати всі зміни, спричинені у батьку #2 (<code>C4</code>), проте зберігти весь зміст з батька #1 (<code>C6</code>).</p>
</div>
<div class="paragraph">
<p>Історія з виверненим комітом виглядає так:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/uk/v2/images/undomerge-revert.png" >}}" alt="Історія після `git revert -m 1`.">
</div>
<div class="title">Рисунок 139. Історія після <code>git revert -m 1</code>
</div>
</div>
<div class="paragraph">
<p>Новий коміт <code>^M</code> має точно такий зміст, як <code>C6</code>, отже починаючи звідти, усе нібито злиття ніколи не було, окрім того, що тепер не злиті коміти досі присутні в історії <code>HEAD</code>.
Git заплутається, якщо ви спробуєте злити <code>topic</code> до <code>master</code> знову:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge topic
Already up-to-date.</code></pre>
</div>
</div>
<div class="paragraph">
<p>У гілці <code>topic</code> немає нічого недосяжного з гілки <code>master</code>.
Гірше того, якщо ви додасте щось до <code>topic</code>, та зіллєте знову, Git візьме лише зміни <em>після</em> виверту злиття:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/uk/v2/images/undomerge-revert2.png" >}}" alt="Історія з поганим злиттям.">
</div>
<div class="title">Рисунок 140. Історія з поганим злиттям</div>
</div>
<div class="paragraph">
<p>Найкращій вихід — це вивернути виворіт першого злиття, адже тепер ви бажаєте повернути зміни, які ви були вивернули, <strong>потім</strong> створити новий коміт злиття:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git revert ^M
[master 09f0126] Revert "Revert "Merge branch 'topic'""
$ git merge topic</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/uk/v2/images/undomerge-revert3.png" >}}" alt="Історія після повторного злиття вивернутого злиття.">
</div>
<div class="title">Рисунок 141. Історія після повторного злиття вивернутого злиття</div>
</div>
<div class="paragraph">
<p>У цьому прикладі, <code>M</code> та <code>^M</code> взаємно знищились.
<code>^^M</code> в результаті зливає зміни <code>C3</code> та <code>C4</code>, а <code>C8</code> зливає зміну <code>C7</code>, отже тепер <code>topic</code> повністю злито.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_інші_типи_зливань">Інші типи зливань</h3>
<div class="paragraph">
<p>Досі ми розглядали нормальні злиття двох гілок, що зазвичай обробляються тим, що називається стратегією злиття “recursive”.
Одначе, існують й інші методи зливати гілки разом.
Швидко розгляньмо декілька з них.</p>
</div>
<div class="sect4">
<h4 id="_перевага_нашого_чи_їхнього">Перевага нашого чи їхнього</h4>
<div class="paragraph">
<p>Почнімо з додаткових можливостей звичайного режиму зливання “recursive”.
Ми вже зустрічали опції <code>ignore-all-space</code> та <code>ignore-space-change</code>, які передаються до <code>-X</code>, проте ми також можемо сказати Git надавати перевагу одній чи іншій стороні, коли він бачить конфлікт.</p>
</div>
<div class="paragraph">
<p>Без додаткових опцій, коли Git бачить конфлікт між двома гілками при зливанні, він додасть позначки конфлікту до вашого коду та позначить файл конфліктним, та дасть вам його розв’язати.
Якщо ви бажаєте, щоб Git просто вибрав якусь сторону та проігнорував іншу замість того, щоб залишати вам вручну розв’язувати конфлікт, ви можете передати команді <code>merge</code> опцію <code>-Xours</code> чи <code>-Xtheirs</code>.</p>
</div>
<div class="paragraph">
<p>Якщо це зробити, Git не буде додавати позначки конфлікту.
Будь-які зміни, що можна злити, будуть злиті.
Для будь-яких конфліктуючих змін, Git просто вибере сторону, яку ви задали, включно з двійковими файлами.</p>
</div>
<div class="paragraph">
<p>Якщо ми повернемося до попереднього прикладу “hello world”, ми можемо бачити, що зливання нашої гілки призводить до конфліктів.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved 'hello.rb' using previous resolution.
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Проте якщо виконати з <code>-Xours</code> або <code>-Xtheirs</code>, конфлікту не буде.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge -Xours mundo
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 test.sh  | 2 ++
 2 files changed, 3 insertions(+), 1 deletion(-)
 create mode 100644 test.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>У даному випадку, замість отримання позначок конфлікту у файлі з “hello mundo” з одного боку та “hola world” з іншого, Git просто обере “hola world”.
Однак, усі інші неконфліктуючі зміни на цій гілці успішно злиті.</p>
</div>
<div class="paragraph">
<p>Цю опцію також можна передати команді <code>git merge-file</code>, яку ми бачили раніше, наприклад виконавши <code>git merge-file --ours</code> для окремих зливань файлів.</p>
</div>
<div class="paragraph">
<p>Якщо вам потрібно щось схоже, проте щоб Git навіть не намагався зливати зміни з іншої сторони, є більш драконівська опція, а саме <em>стратегія</em> злиття “ours”.
Це не те саме, що <em>опція</em> рекурсивного (recursive) злиття “ours”.</p>
</div>
<div class="paragraph">
<p>Це фактично зробить підроблене злиття.
Буде записано новий коміт злиття з обома гілками в якості батьків, проте на гілку, яку ви зливаєте, навіть не глянуть.
У якості результату злиття буде записано саме код вашої поточної гілки.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge -s ours mundo
Merge made by the 'ours' strategy.
$ git diff HEAD HEAD~
$</code></pre>
</div>
</div>
<div class="paragraph">
<p>Як бачите, між гілкою, на якій ви були, та результатом зливання немає ніякої різниці.</p>
</div>
<div class="paragraph">
<p>Це може бути корисним для введення Git в оману, бо він буде вважати, що гілка вже злита при подальших зливаннях.
Наприклад, якщо ви відгалузили гілку <code>release</code>, та зробили якусь роботу в ній, яку ви потім забажаєте злити до гілки <code>master</code>.
У той же час, якесь виправлення з <code>master</code> має бути додано до вашої гілки <code>release</code>.
Ви можете злити виправлення до гілки <code>release</code> і також <code>merge -s ours</code> ту ж гілку до гілки <code>master</code> (хоча виправлення вже там), тоді при подальшому зливанні гілки <code>release</code>, ніяких конфліктів від цього виправлення не виникне.</p>
</div>
</div>
<div class="sect4">
<h4 id="_subtree_merge">Зливання піддерев</h4>
<div class="paragraph">
<p>Ідея зливання піддерева в тому, що у вас два проекти, один з яких відповідає піддиректорії іншого.
Коли ви використовуєте зливання піддерев, Git зазвичай достатньо розумний, щоб визначити, що одне є піддеревом іншого та злити відповідно.</p>
</div>
<div class="paragraph">
<p>Ми розглянемо приклад додавання окремого проекту до вже існуючого, та зливання коду з другого до піддиректорії першого.</p>
</div>
<div class="paragraph">
<p>Спочатку, ми додамо застосунок Rack до вашого проекту.
Ми додамо проект Rack у якості віддаленого посилання до нашого проекту, а потім отримаємо його в окрему гілку:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add rack_remote https://github.com/rack/rack
$ git fetch rack_remote --no-tags
warning: no common commits
remote: Counting objects: 3184, done.
remote: Compressing objects: 100% (1465/1465), done.
remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.
Resolving deltas: 100% (1952/1952), done.
From https://github.com/rack/rack
 * [new branch]      build      -&gt; rack_remote/build
 * [new branch]      master     -&gt; rack_remote/master
 * [new branch]      rack-0.4   -&gt; rack_remote/rack-0.4
 * [new branch]      rack-0.9   -&gt; rack_remote/rack-0.9
$ git checkout -b rack_branch rack_remote/master
Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.
Switched to a new branch "rack_branch"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Тепер у нас є корінь проекту Rack у гілці <code>rack_branch</code> та наш власний проект у гілці <code>master</code>.
Якщо переключитись на одну, а потім на іншу, можна побачити, що в них різні корені:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ls
AUTHORS         KNOWN-ISSUES   Rakefile      contrib         lib
COPYING         README         bin           example         test
$ git checkout master
Switched to branch "master"
$ ls
README</code></pre>
</div>
</div>
<div class="paragraph">
<p>Це дещо дивна концепція.
Не всі гілки вашого репозиторія насправді мають бути гілками одного проекту.
Це не поширено, адже зрідка корисно, проте мати гілки, що містять цілковито різні історії, доволі легко.</p>
</div>
<div class="paragraph">
<p>У даному випадку, ми хочемо втягнути проект Rack до нашого проекту <code>master</code> в якості піддиректорії.
Ми можемо зробити це в Git за допомогою <code>git read-tree</code>.
Ви дізнаєтесь більше про <code>read-tree</code>, та йому подібних, у <a href="{{< relurl "book/uk/v2/ch00/ch10-git-internals" >}}">Git зсередини</a>, проте, покищо знайте, що вона зчитує корінь дерева однієї гілки до вашого поточного індексу та робочої директорії.
Ми щойно переключились назад до вашої гілки <code>master</code>, та втягуємо гілку <code>rack_branch</code> до піддиректорії нашої гілки <code>master</code> нашого головного проекту:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git read-tree --prefix=rack/ -u rack_branch</code></pre>
</div>
</div>
<div class="paragraph">
<p>Коли ми збережемо коміт, здається, ніби всі файли Rack є в тій піддиректорії – нібито ми скопіювали їх з архіву.
Цікаво те, що ми легко можемо зливати зміни з однієї гілки в іншу.
Отже, якщо проект Rack буде оновлено, ми зможемо отримати останні зміни, коли переключимося на ту гілку та виконаємо <code>pull</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout rack_branch
$ git pull</code></pre>
</div>
</div>
<div class="paragraph">
<p>Потім, ми можемо злити ці зміни назад до нашої гілки <code>master</code>.
Щоб взяти зміни та отримати заповненим повідомлення коміту, використайте опцію <code>--squash</code>, а також опцію <code>-Xsubstree</code> стратегії зливання <code>recursive</code>.
(Рекурсивна стратегія зливання є типовою, проте ми включили її для ясності.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
$ git merge --squash -s recursive -Xsubtree=rack rack_branch
Squash commit -- not updating HEAD
Automatic merge went well; stopped before committing as requested</code></pre>
</div>
</div>
<div class="paragraph">
<p>Усі зміни з проекту Rack злиті та готові до збереження в локальному коміті.
Ви можете робити й навпаки – зберігати зміни у піддиректорії <code>rack</code> вашої гілки master та потім зливати їх до гілки <code>rack_branch</code>, щоб пізніше відправити їх до супроводжувачів або надсилання до джерела проекту.</p>
</div>
<div class="paragraph">
<p>Це надає спосіб мати процес роботи схожий на процес роботи з підмодулями без використання підмодулів (які ми розглянемо в <a href="{{< relurl "book/uk/v2/ch00/_git_submodules" >}}">Підмодулі</a>).
Ми можемо зберігати гілки інших повʼязаних проектів у нашому репозиторії та іноді робити зливання піддерев з ними.
Це мило з якогось боку, наприклад, весь код збережено в одному місці.
Проте, є інші недоліки: це трохи складніше, та легше наробити помилок при реінтеграції змін або випадково надіслати гілку до геть не того репозиторія.</p>
</div>
<div class="paragraph">
<p>Ще одна трохи дивна річ: щоб отримати різницю між вашою піддиректорією <code>rack</code> та кодом у вашій гілці <code>rack_branch</code> – щоб побачити, чи треба їх зливати – ви не можете використовувати звичайну команду <code>diff</code>.
Замість цього, ви маєте виконати <code>git diff-tree</code> з гілкою, яку ви бажаєте порівняти зі своєю:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff-tree -p rack_branch</code></pre>
</div>
</div>
<div class="paragraph">
<p>Або, щоб порівняти вашу піддиректорію <code>rack</code> зі змістом гілки <code>master</code>, що був на сервері, коли ви востаннє отримували звідти зміни, ви можете виконати:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff-tree -p rack_remote/master</code></pre>
</div>
</div>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>