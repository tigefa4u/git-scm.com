---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: uk
  chapter:
    title: Інструменти Git
    number: 7
  section:
    title: Rerere
    number: 9
    cs_number: '7.9'
    previous: book/uk/v2/Інструменти-Git-Складне-злиття
    next: book/uk/v2/Інструменти-Git-Зневадження-з-Git
title: Git - Rerere
url: "/book/uk/v2/Інструменти-Git-Rerere.html"
---
<h2 id="ref_rerere">Rerere</h2>
<div class="paragraph">
<p>Можливості <code>git rerere</code> є трохи прихованими.
Назва походить від “використовуй записані розвʼязання” (reuse recorded resolution) та, як зрозуміло з назви, дозволяє вам попросити Git запамʼятати, як ви розвʼязали конфлікт шматків (hunk), щоб наступного разу Git міг автоматично розвʼязати такий самий конфлікт для вас.</p>
</div>
<div class="paragraph">
<p>Є декілька ситуацій, в яких цей функціонал може бути дуже доречним.
Одна з таких ситуацій згадується в документації: коли ви бажаєте переконатись, що довготривала тематична гілка зіллється переважно чисто, проте не бажаєте, щоб купа проміжних комітів злиття засмічували історію.
Якщо <code>rerere</code> увімкнено, ви можете іноді зливати, розвʼязувати конфлікти, а потім припиняти злиття.
Якщо робити це постійно, то останнє злиття має бути простим, адже <code>rerere</code> може просто зробити за вас все автоматично.</p>
</div>
<div class="paragraph">
<p>Таку саму тактику можна використовувати, якщо ви бажаєте тримати гілку перебазованою, щоб не доводилося мати справу з однаковими конфліктами перебазування щоразу, як ви його робите.
Або якщо ви бажаєте взяти гілку, яку ви зливали та виправили купу конфліктів, а потім вирішили замість цього зробити перебазування — імовірно вам не доведеться знову виправляти всі ці конфлікти.</p>
</div>
<div class="paragraph">
<p>Ще однин приклад застосування <code>rerere</code>: коли ви іноді зливаєте купу незавершених тематичних гілок разом, щоб перевірити результат, як сам проект Git часто робить.
Якщо тести провалились, ви можете скасувати зливання та зробити їх знову без тематичної гілки, що спричинила проблему, без необхідності знову розвʼязувати конфлікти.</p>
</div>
<div class="paragraph">
<p>Щоб увімкнути функціональність <code>rerere</code>, треба просто виконати це налаштування конфігурації:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global rerere.enabled true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Також його можна ввімкнути, якщо створити директорію <code>.git/rr-cache</code> в окремому репозиторії, проте налаштування конфігурації ясніше, та вмикає цей функціонал глобально.</p>
</div>
<div class="paragraph">
<p>Тепер погляньмо на простий приклад, схожий на попередній.
Скажімо, у нас є файл <code>hello.rb</code>, що виглядає так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
  puts 'hello world'
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>В одній гілці ми змінюємо слово “hello” на “holf”, потім в іншій гілці змінюємо “world” на “mundo”, як і раніше.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/uk/v2/images/rerere1.png" >}}" alt="rerere1">
</div>
</div>
<div class="paragraph">
<p>Коли ми зіллємо ці дві гілки разом, ми отримаємо конфлікт злиття:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge i18n-world
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Recorded preimage for 'hello.rb'
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Зверніть тут увагу на новий рядок <code>Recorded preimage for FILE</code> (записано предвідбиток для ФАЙЛУ).
Решта виглядає так само, як і звичайний конфлікт зливання.
Наразі, <code>rerere</code> знає декілька речей.
Зазвичай, ви зараз виконали б <code>git status</code>, щоб побачити всі конфлікти:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
# On branch master
# Unmerged paths:
#   (use "git reset HEAD &lt;file&gt;..." to unstage)
#   (use "git add &lt;file&gt;..." to mark resolution)
#
#	both modified:      hello.rb
#</code></pre>
</div>
</div>
<div class="paragraph">
<p>Однак, <code>git rerere</code> також скаже вам, що він записав стан до злиття, якщо виконати <code>git rerere status</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rerere status
hello.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>А <code>git rerere diff</code> покаже поточний стан розвʼязання — з чого почалось розвʼязання та як ви його розвʼязали.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rerere diff
--- a/hello.rb
+++ b/hello.rb
@@ -1,11 +1,11 @@
 #! /usr/bin/env ruby

 def hello
-&lt;&lt;&lt;&lt;&lt;&lt;&lt;
-  puts 'hello mundo'
-=======
+&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
   puts 'hola world'
-&gt;&gt;&gt;&gt;&gt;&gt;&gt;
+=======
+  puts 'hello mundo'
+&gt;&gt;&gt;&gt;&gt;&gt;&gt; i18n-world
 end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Також (і це насправді не повʼязано з <code>rerere</code>), ви можете використати <code>git ls-files -u</code>, щоб побачити файли конфлікту та попередню, ліву та праву версії:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git ls-files -u
100644 39804c942a9c1f2c03dc7c5ebcd7f3e3a6b97519 1	hello.rb
100644 a440db6e8d1fd76ad438a49025a9ad9ce746f581 2	hello.rb
100644 54336ba847c3758ab604876419607e9443848474 3	hello.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Тепер ви можете розвʼязати конфлікт щоб було <code>puts 'hola mundo'</code> та знову виконати команду <code>git rerere diff</code>, щоб побачити, що запамʼятає rerere:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rerere diff
--- a/hello.rb
+++ b/hello.rb
@@ -1,11 +1,7 @@
 #! /usr/bin/env ruby

 def hello
-&lt;&lt;&lt;&lt;&lt;&lt;&lt;
-  puts 'hello mundo'
-=======
-  puts 'hola world'
-&gt;&gt;&gt;&gt;&gt;&gt;&gt;
+  puts 'hola mundo'
 end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Це нам каже, що коли Git побачить конфлікт шмату (hunk) у файлі <code>hello.rb</code>, де з одного боку “hello mundo”, а з іншого “hola world”, він розвʼяже конфлікт рядком “hola mundo”.</p>
</div>
<div class="paragraph">
<p>Тепер ми можемо позначити його розвʼязаним та зберегти у коміті:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add hello.rb
$ git commit
Recorded resolution for 'hello.rb'.
[master 68e16e5] Merge branch 'i18n'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Зверніть увагу на "Recorded resolution for FILE" (Записано розвʼязок для ФАЙЛУ).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/uk/v2/images/rerere2.png" >}}" alt="rerere2">
</div>
</div>
<div class="paragraph">
<p>Тепер, скасуймо це злиття та замість нього перебазуймо нашу гілку поверху master.
Ми можемо пересунути нашу гілку назад за допомогою <code>git reset</code>, як ми бачили в <a href="{{< relurl "book/uk/v2/ch00/_git_reset" >}}">Усвідомлення скидання (reset)</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git reset --hard HEAD^
HEAD is now at ad63f15 i18n the hello</code></pre>
</div>
</div>
<div class="paragraph">
<p>Наше злиття скасовано.
Тепер перебазуймо тематичну гілку.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout i18n-world
Switched to branch 'i18n-world'

$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: i18n one word
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved 'hello.rb' using previous resolution.
Failed to merge in the changes.
Patch failed at 0001 i18n one word</code></pre>
</div>
</div>
<div class="paragraph">
<p>Тепер, ми отримали саме такий конфлікт зливання, як очікували, проте погляньте на рядок <code>Resolved FILE using previous resolution</code> (Розвʼязали ФАЙЛ за допомогою попереднього розвʼязку).
Якщо ми відкриємо файл, то побачимо, що він вже розвʼязаний, там більше немає позначок конфлікту.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
  puts 'hola mundo'
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Також, <code>git diff</code> покаже вам, як конфлікт був знову розвʼязаний автоматично:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --cc hello.rb
index a440db6,54336ba..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/uk/v2/images/rerere3.png" >}}" alt="rerere3">
</div>
</div>
<div class="paragraph">
<p>Ви також можете повернути файл до стану конфлікту за допомогою <code>git checkout</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout --conflict=merge hello.rb
$ cat hello.rb
#! /usr/bin/env ruby

def hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; ours
  puts 'hola world'
=======
  puts 'hello mundo'
&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ми бачили приклад цього в <a href="{{< relurl "book/uk/v2/ch00/_advanced_merging" >}}">Складне злиття</a>.
Проте зараз, розвʼяжімо його знову: для цього треба просто виконати <code>git rerere</code> знов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rerere
Resolved 'hello.rb' using previous resolution.
$ cat hello.rb
#! /usr/bin/env ruby

def hello
  puts 'hola mundo'
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ми знову розвʼязали файл автоматично за допомогою збереженого <code>rerere</code> розвʼязок.
Тепер ви можете проіндексувати файл та продовжити перебазування, щоб завершити його.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add hello.rb
$ git rebase --continue
Applying: i18n one word</code></pre>
</div>
</div>
<div class="paragraph">
<p>Отже, якщо ви робите багато повторних зливань, або бажаєте зберігати тематичну гілку у відповідності з гілкою master без численних зливань, або часто перебазовуєте, то можете увімкнути <code>rerere</code>, щоб трохи полегшити собі життя.</p>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>