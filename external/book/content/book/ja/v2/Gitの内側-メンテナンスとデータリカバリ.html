---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: ja
  chapter:
    title: Gitの内側
    number: 10
  section:
    title: メンテナンスとデータリカバリ
    number: 7
    cs_number: '10.7'
    previous: book/ja/v2/Gitの内側-転送プロトコル
    next: book/ja/v2/Gitの内側-環境変数
title: Git - メンテナンスとデータリカバリ
url: "/book/ja/v2/Gitの内側-メンテナンスとデータリカバリ.html"
---
<h2 id="_メンテナンスとデータリカバリ">メンテナンスとデータリカバリ</h2>
<div class="paragraph">
<p>たまには、ちょっとしたお掃除 – リポジトリを圧縮したり、インポートしたリポジトリをクリーンアップしたり、失われた成果物をもとに戻したり – が必要になるかもしれません。
このセクションではこれらのシナリオのいくつかについて取り上げます。</p>
</div>
<div class="sect3">
<h3 id="r_git_gc">メンテナンス</h3>
<div class="paragraph">
<p>Gitは時々 “auto gc” と呼ばれるコマンドを自動的に実行します。
大抵の場合、このコマンドは何もしません。
ですが、緩いオブジェクト（packfileの中に入っていないオブジェクト）やpackfileがあまりに多い場合は、Gitは完全な（full-fledged）<code>git gc</code> コマンドを起動します。
“gc” はガベージコレクト（garbage collect）を意味します。このコマンドは幾つものことを行います。すべての緩いオブジェクトを集めてpackfileに入れ、複数のpackfileをひとつの大きなpackfileに統合し、さらにどのコミットからも到達が不可能かつ数ヶ月間更新がないオブジェクトを削除します。</p>
</div>
<div class="paragraph">
<p>次のように手動でauto gcを実行することもできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git gc --auto</code></pre>
</div>
</div>
<div class="paragraph">
<p>繰り返しますが、これは通常は何も行いません。
約7,000個もの緩いオブジェクトがあるか、または50以上のpackfileがある場合でないと、Gitは実際にgcコマンドを開始しません。
これらのリミットはそれぞれ設定ファイルの <code>gc.auto</code> と <code>gc.autopacklimit</code> で変更できます。</p>
</div>
<div class="paragraph">
<p>その他に <code>gc</code> が行うこととしては、複数の参照を1つのファイルにパックすることが挙げられます。
リポジトリに、次のようなブランチとタグが含まれているとしましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ find .git/refs -type f
.git/refs/heads/experiment
.git/refs/heads/master
.git/refs/tags/v1.0
.git/refs/tags/v1.1</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>git gc</code> を実行すると、これらのファイルは <code>refs</code> ディレクトリからなくなります。
効率化のため、Gitはそれらのファイルの内容を、以下のような <code>.git/packed-refs</code> という名前のファイルに移します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .git/packed-refs
# pack-refs with: peeled fully-peeled
cac0cab538b970a37ea1e769cbbde608743bc96d refs/heads/experiment
ab1afef80fac8e34258ff41fc1b867c702daa24b refs/heads/master
cac0cab538b970a37ea1e769cbbde608743bc96d refs/tags/v1.0
9585191f37f7b0fb9444f35a9bf50de191beadc2 refs/tags/v1.1
^1a410efbd13591db07496601ebc7a059dd55cfe9</code></pre>
</div>
</div>
<div class="paragraph">
<p>ただ、ここで参照を更新しても、Gitはこのファイルを編集せず、その代わりに <code>refs/heads</code> に新しいファイルを書き込みます。
とある参照に対する適切なSHA-1ハッシュを得るために、Gitは <code>refs</code> ディレクトリ内でその参照をチェックした上で、見つからなかった場合の代替として <code>packed-refs</code> ファイルをチェックします。
一方、 <code>refs</code> ディレクトリ内で参照が見つけられない場合は、それはおそらく <code>packed-refs</code> ファイル内にあります。</p>
</div>
<div class="paragraph">
<p>ファイルの最後の行に注意してください。 <code>^</code> という文字で始まっています。
これは、この行のすぐ上にあるタグは注釈付き版のタグであり、この行はそのタグが指しているコミットであるということを意味しています。</p>
</div>
</div>
<div class="sect3">
<h3 id="r_data_recovery">データリカバリ</h3>
<div class="paragraph">
<p>Gitを使っていく過程のある時点で、誤ってコミットを失ってしまうことがあるかもしれません。
このようなことが起こりがちなのは、成果物が入っていたブランチをforce-deleteしたけれど、その後結局そのブランチが必要になったときか、あるいはブランチをhard-resetしたために、何か必要なものが入っているコミットがそのブランチから切り離されてしまったときです。
このようなことが起きたとして、どうやったらコミットを取り戻せるでしょうか？</p>
</div>
<div class="paragraph">
<p>以下に示す例では、testリポジトリ内のmasterブランチを古いコミットにhard-resetして、それから失ったコミットを復元します。
まず、今の時点でリポジトリがどのような状況にあるのか調べてみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --pretty=oneline
ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
484a59275031909e19aadb7c92262719cfcdf19a added repo.rb
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>ここで、<code>master</code> ブランチを真ん中のコミットの時点まで戻します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git reset --hard 1a410efbd13591db07496601ebc7a059dd55cfe9
HEAD is now at 1a410ef third commit
$ git log --pretty=oneline
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>これで、一番上にあった2つのコミットは、事実上失われたことになります。これらのコミットに辿り着けるブランチがないためです。
そのため、最後のコミットのSHA-1ハッシュを調べた上で、そこを指すブランチを追加する必要があります。
ここでポイントとなるのは、最後のコミットのSHA-1ハッシュを見つける方法です。ハッシュ値を記憶してます、なんてことはないですよね？</p>
</div>
<div class="paragraph">
<p>大抵の場合、最も手っ取り早いのは、<code>git reflog</code> というツールを使う方法です。
あなたが作業をしている間、HEADを変更する度に、HEADがどこを指しているかをGitは裏で記録しています。
コミットをしたり、ブランチを変更したりする度に、reflogは更新されます。
また、reflogは <code>git update-ref</code> コマンドによっても更新されます。refファイルに書かれたSHA-1ハッシュ値を直に編集せずに、このコマンドを使って編集すべき理由の1つがこれです（詳しくは <a href="{{< relurl "book/ja/v2/ch00/r_git_refs" >}}">Gitの参照</a> で取り上げました）。
<code>git reflog</code> を実行することで、ある時点で自分がどこにいたのかを知ることができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git reflog
1a410ef HEAD@{0}: reset: moving to 1a410ef
ab1afef HEAD@{1}: commit: modified repo.rb a bit
484a592 HEAD@{2}: commit: added repo.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>このとおり、チェックアウトした2つのコミットが見つかりました。ですが、それ以上の情報は表示されていません。
同じ情報をもっと有用な形式で表示するには <code>git log -g</code> を実行します。これはreflogを通常のログ出力と同じ形式で出力してくれます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -g
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Reflog: HEAD@{0} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: updating HEAD
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:22:37 2009 -0700

		third commit

commit ab1afef80fac8e34258ff41fc1b867c702daa24b
Reflog: HEAD@{1} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: updating HEAD
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:15:24 2009 -0700

       modified repo.rb a bit</code></pre>
</div>
</div>
<div class="paragraph">
<p>一番下にあるコミットが、失われたコミットのようです。そこから新しいブランチを作成すれば、失ったコミットを取り戻せます。
例えば、そのコミット（ab1afef）を起点に <code>recover-branch</code> という名前のブランチを作成できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch recover-branch ab1afef
$ git log --pretty=oneline recover-branch
ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
484a59275031909e19aadb7c92262719cfcdf19a added repo.rb
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>やった！ – <code>master</code> ブランチがかつて存在した場所に、 <code>recover-branch</code> という名前のブランチが作られて、最初の2つのコミットは再び到達可能になりました。
さて次は、失われたコミットが何らかの理由でreflogの中にもなかった場合を考えましょう – <code>recover-branch</code> を取り除き、reflogを削除することによって、擬似的にその状況を作り出すことができます。
これで、最初の2つのコミットは、今どこからも到達不能になりました。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch -D recover-branch
$ rm -Rf .git/logs/</code></pre>
</div>
</div>
<div class="paragraph">
<p>reflogのデータは <code>.git/logs/</code> ディレクトリに保存されるため、これでreflogは事実上なくなりました。
この時点で、どうしたら失われたコミットを復元できるでしょうか?
ひとつの方法として、 <code>git fsck</code> ユーティリティーを使用してデータベースの完全性をチェックする方法があります。
<code>--full</code> オプションを付けて実行すると、他のどのオブジェクトからも指されていないオブジェクトをすべて表示します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git fsck --full
Checking object directories: 100% (256/256), done.
Checking objects: 100% (18/18), done.
dangling blob d670460b4b4aece5915caf5c68d12f560a9fe3e4
dangling commit ab1afef80fac8e34258ff41fc1b867c702daa24b
dangling tree aea790b9a58f6cf6f2804eeac9f0abbe9631e4c9
dangling blob 7108f7ecb345ee9d0084193f147cdad4d2998293</code></pre>
</div>
</div>
<div class="paragraph">
<p>このケースでは、 “dangling commit” という文字列の後に失われたコミットが表示されています。
前と同様にこのSHA-1ハッシュを指すブランチを作成すれば、失われたコミットを取り戻せます。</p>
</div>
</div>
<div class="sect3">
<h3 id="r_removing_objects">オブジェクトの削除</h3>
<div class="paragraph">
<p>Gitには素晴らしい点がたくさんありますが、問題となり得る特徴がひとつあります。それは、 <code>git clone</code> がすべてのファイルのすべてのバージョンを含んだプロジェクトの歴史全体をダウンロードしてしまうということです。
保存されているのがソースコードだけなら、特に問題はありません。なぜなら、Gitはそのようなデータを効率良く圧縮することに高度に最適化されているからです。
しかし、もし誰かがある時点でプロジェクトの歴史に非常に大きなファイルを1つ加えると、以降のクローンではすべて、その大きなファイルのダウンロードを強いられることになります。これは、直後のコミットでそのファイルをプロジェクトから削除したとしても変わりません。
なぜなら、そのファイルは履歴から到達可能であり、常にそこに存在し続けるためです。</p>
</div>
<div class="paragraph">
<p>SubversionやPerforceのリポジトリをGitに変換するときに、これは大きな問題になり得ます。
なぜなら、それらのシステムではすべての履歴をダウンロードする必要がないため、非常に大きなファイルを追加してもほとんど悪影響がないからです。
別のシステムからリポジトリをインポートした場合や、リポジトリがあるべき状態よりもずっと大きくなっている場合に、大きなオブジェクトを見つけて取り除く方法を以下に示します。</p>
</div>
<div class="paragraph">
<p><strong>注意: この操作はコミット履歴を破壊的に変更します。</strong>
この操作では、大きなファイルへの参照を取り除くため、修正が必要な一番古いツリーから、以降すべてのコミットオブジェクトを再書き込みします。
インポートの直後、そのコミットをベースとして誰かが作業を始める前にこの操作を行った場合は問題ありません。そうでない場合は、作業中の内容を新しいコミットにリベースしなければならないことを、すべての関係者に知らせる必要があります。</p>
</div>
<div class="paragraph">
<p>実演のため、testリポジトリに大きなファイルを追加して、次のコミットでそれを取り除いた上で、リポジトリからそのファイルを探し出し、そしてリポジトリからそれを完全に削除します。
まず、あなたの歴史に大きなオブジェクトを追加します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ curl https://www.kernel.org/pub/software/scm/git/git-2.1.0.tar.gz &gt; git.tgz
$ git add git.tgz
$ git commit -m 'add git tarball'
[master 7b30847] add git tarball
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 git.tgz</code></pre>
</div>
</div>
<div class="paragraph">
<p>おっと、誤ってプロジェクトに非常に大きなtarボールを追加してしまいました。取り除いたほうがいいでしょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rm git.tgz
rm 'git.tgz'
$ git commit -m 'oops - removed large tarball'
[master dadf725] oops - removed large tarball
 1 file changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 git.tgz</code></pre>
</div>
</div>
<div class="paragraph">
<p>次に、データベースに対して <code>gc</code> を実行します。その後、どれくらいのスペースを使用しているのかを見てみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git gc
Counting objects: 17, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (13/13), done.
Writing objects: 100% (17/17), done.
Total 17 (delta 1), reused 10 (delta 0)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>count-objects</code> コマンドを実行すると、どれくらいのスペースを使用しているのかをすぐに見ることができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git count-objects -v
count: 7
size: 32
in-pack: 17
packs: 1
size-pack: 4868
prune-packable: 0
garbage: 0
size-garbage: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>size-pack</code> エントリにはpackfileのサイズがキロバイト単位で表示されていて、約5MB使用していることがわかります。
大きなファイルを追加するコミットの前に使用していたのは、2KB程度でした – 明らかに、直近のコミットで行ったファイルの削除では、歴史からファイルが削除されていません。
誤って大きなファイルを追加してしまったがために、誰かがこのリポジトリをクローンするたび、この小さなプロジェクトを取得するだけのために5MBすべてをクローンしなければならなくなってしまいました。
この大きなファイルを削除しましょう。</p>
</div>
<div class="paragraph">
<p>最初に、その大きなファイルを見つけなければなりません。
この例では、どのファイルがそれかは既に分かっています。
しかし、それが分からない場合、どうやって多くのスペースを占めているファイルを特定するのでしょうか？
<code>git gc</code> を実行すると、すべてのオブジェクトがpackfileに格納されます。
そのため、別の配管コマンド <code>git verify-pack</code> を実行し、その出力を3つ目のフィールド（ファイルサイズ）でソートすれば、大きなオブジェクトを特定できます。
関心の対象になるのは最も大きなファイル数個だけなので、その出力をパイプで <code>tail</code> コマンドに通してもよいでしょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git verify-pack -v .git/objects/pack/pack-29…69.idx \
  | sort -k 3 -n \
  | tail -3
dadf7258d699da2c8d89b09ef6670edb7d5f91b4 commit 229 159 12
033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   22044 5792 4977696
82c99a3e86bb1267b236a4b6eff7868d97489af1 blob   4975916 4976258 1438</code></pre>
</div>
</div>
<div class="paragraph">
<p>探していた大きなオブジェクトは、一番下の5MBのものです。
そのオブジェクトが何のファイルなのかを知るには <a href="{{< relurl "book/ja/v2/ch00/r_enforcing_commit_message_format" >}}">特定のコミットメッセージ書式の強制</a> で少し使用した <code>rev-list</code> コマンドを使用します。
<code>--objects</code> を <code>rev-list</code> に渡すと、すべてのコミットのSHA-1ハッシュに加えて、すべてのブロブのSHA-1ハッシュと、そのブロブに関連付けられたファイルのパスを一覧表示します。
これは、ブロブの名前を特定するのに使えます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rev-list --objects --all | grep 82c99a3
82c99a3e86bb1267b236a4b6eff7868d97489af1 git.tgz</code></pre>
</div>
</div>
<div class="paragraph">
<p>次に、過去のすべてのツリーからこのファイルを削除する必要があります。
このファイルを変更したのがどのコミットかは簡単に分かります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --branches -- git.tgz
dadf725 oops - removed large tarball
7b30847 add git tarball</code></pre>
</div>
</div>
<div class="paragraph">
<p>Gitリポジトリからこのファイルを完全に削除するには、 <code>7b30847</code> の下流にあるすべてのコミットを修正しなければなりません。
そのためには、 <a href="{{< relurl "book/ja/v2/ch00/r_rewriting_history" >}}">歴史の書き換え</a> で使用した <code>filter-branch</code> を使用します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git filter-branch --index-filter \
  'git rm --ignore-unmatch --cached git.tgz' -- 7b30847^..
Rewrite 7b30847d080183a1ab7d18fb202473b3096e9f34 (1/2)rm 'git.tgz'
Rewrite dadf7258d699da2c8d89b09ef6670edb7d5f91b4 (2/2)
Ref 'refs/heads/master' was rewritten</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>--index-filter</code> オプションは <a href="{{< relurl "book/ja/v2/ch00/r_rewriting_history" >}}">歴史の書き換え</a> で使用した <code>--tree-filter</code> オプションに似ていますが、ディスク上のチェックアウトされたファイルを変更するコマンドを渡すのではなく、コミット毎にステージングエリアまたはインデックスを変更する点が異なります。</p>
</div>
<div class="paragraph">
<p>ここでは、あるファイルを <code>rm file</code> で削除するのではなく、 <code>git rm --cached</code> で削除する必要があります。つまり、ディスクではなくインデックスからファイルを削除しなければなりません。
このようにする理由はスピードです。この場合、Gitがフィルタを実行する前に各リビジョンをディスク上へチェックアウトする必要がないので、プロセスをもっともっと速くすることができます。
お望みなら、同様のタスクは <code>--tree-filter</code> でも行えます。
<code>git rm</code> に渡している <code>--ignore-unmatch</code> オプションは、削除しようとするパターンに合うファイルがない場合に、エラーを出力しないようにします。
最後に、<code>filter-branch</code> に、コミット <code>7b30847</code> 以降の履歴のみを修正するように伝えています。なぜなら、問題が発生した場所がここだと分かっているからです。
そうでない場合は、歴史の先頭から処理を開始することになり、不必要に長い時間がかかるでしょう。</p>
</div>
<div class="paragraph">
<p>これで、歴史から大きなファイルへの参照がなくなりました。
しかし、 <code>.git/refs/original</code> の下で <code>filter-branch</code> を行ったときにGitが新しく追加したrefsには、まだ参照が含まれています。reflogについても同様です。それらを削除した上で、データベースを再パックしなければなりません。
再パックの前に、それら古いコミットへのポインタを持つものをすべて削除する必要があります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ rm -Rf .git/refs/original
$ rm -Rf .git/logs/
$ git gc
Counting objects: 15, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (11/11), done.
Writing objects: 100% (15/15), done.
Total 15 (delta 1), reused 12 (delta 0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>どれくらいのスペースが節約されたかを見てみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git count-objects -v
count: 11
size: 4904
in-pack: 15
packs: 1
size-pack: 8
prune-packable: 0
garbage: 0
size-garbage: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>パックされたリポジトリのサイズは8KBに下がり、当初の5MBよりもずっとよくなりました。
サイズの値を見ると、緩いオブジェクトの中には大きなオブジェクトが残っており、無くなったわけではないことが分かります。ですが、プッシュや以降のクローンで転送されることはもうありません。ここが重要な点です。
お望みなら、 <code>git prune</code> に <code>--expire</code> オプションを指定すれば、オブジェクトを完全に削除することもできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git prune --expire now
$ git count-objects -v
count: 0
size: 0
in-pack: 15
packs: 1
size-pack: 8
prune-packable: 0
garbage: 0
size-garbage: 0</code></pre>
</div>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>