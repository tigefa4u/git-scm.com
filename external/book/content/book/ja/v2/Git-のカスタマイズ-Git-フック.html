---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: ja
  chapter:
    title: Git のカスタマイズ
    number: 8
  section:
    title: Git フック
    number: 3
    cs_number: '8.3'
    previous: book/ja/v2/Git-のカスタマイズ-Git-の属性
    next: book/ja/v2/Git-のカスタマイズ-Git-ポリシーの実施例
title: Git - Git フック
url: "/book/ja/v2/Git-のカスタマイズ-Git-フック.html"
---
<h2 id="r_git_hooks">Git フック</h2>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>他のバージョンコントロールシステムと同じように、Gitにも特定のアクションが発生した時にカスタムスクリプトを叩く方法があります。
このようなフックは、クライアントサイドとサーバーサイドの二つのグループに分けられます。
クライアントサイドフックはコミットやマージといったクライアントでの操作の際に、サーバーサイドフックはプッシュされたコミットの受け取りといったネットワーク操作の際に、それぞれ実行されます。
これらのフックは、さまざまな目的に用いることができます。</p>
</div>
<div class="sect3">
<h3 id="_フックをインストールする">フックをインストールする</h3>
<div class="paragraph">
<p>フックは、Gitディレクトリの <code>hooks</code> サブディレクトリ（一般的なプロジェクトでは、<code>.git/hooks</code> ）に格納されています。
<code>git init</code> で新しいリポジトリを初期化する時には、Gitに同梱されているスクリプトのサンプルがこの hooks ディレクトリに格納されます。サンプルの多くはそのままでも十分有用ですし、また、各スクリプトの入力値に関するドキュメントもついています。
サンプルは全てシェルスクリプトで書かれており、その中の一部では Perl も使われています。ですが、どんなスクリプトでも、実行可能かつ適切に命名されてさえいれば、問題なく動きます。Ruby や Python などで書くこともできます。
これら同梱のフックスクリプトを使用する場合は、ファイル名の末尾が <code>.sample</code> となっていますので適宜リネームしてください。</p>
</div>
<div class="paragraph">
<p>フックスクリプトを有効にするには、Gitディレクトリの <code>hooks</code> サブディレクトリに、実行可能なファイルを適切な名前（拡張子は使えません）で配置すれば、以降そのファイルが呼び出されます。
ここでは重要なフックファイル名をいくつか取り上げます。</p>
</div>
</div>
<div class="sect3">
<h3 id="_クライアントサイドフック">クライアントサイドフック</h3>
<div class="paragraph">
<p>クライアントサイドフックにはたくさんの種類があります。
ここではコミットワークフローフック、Eメールワークフロースクリプト、その他クライアントサイドフックに分類します。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">注記</div>
</td>
<td class="content">
<div class="paragraph">
<p>特筆すべき点として、クライアントサイドフックはリポジトリをクローンする際には <strong>コピーされません</strong> 。
スクリプトを使って何らかのポリシーを強制したいのなら、サーバサイドで行う方がよいでしょう。サンプルが <a href="{{< relurl "book/ja/v2/ch00/r_an_example_git_enforced_policy" >}}">Git ポリシーの実施例</a> にあります。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h4 id="_コミットワークフローフック">コミットワークフローフック</h4>
<div class="paragraph">
<p>最初の4つのフックはコミットプロセスに関するものです。</p>
</div>
<div class="paragraph">
<p><code>pre-commit</code> フックは、コミットメッセージが入力される前に実行されます。
これは、いまからコミットされるスナップショットを検査したり、何かし忘れた事がないか確認したり、テストが実行できるか確認したり、何かしらコードを検査する目的で使用されます。
このフックがゼロでない値を返すと、コミットが中断されます。また、この検査は <code>git commit --no-verify</code> で飛ばすこともできます。
ここではコーディングスタイルの検査（lintを実行するなど）や、行末の空白文字の検査（デフォルトのフックがまさにそうです）、新しく追加されたメソッドのドキュメントが正しいかどうかの検査といったことが可能です。</p>
</div>
<div class="paragraph">
<p><code>prepare-commit-msg</code> フックは、コミットメッセージエディターが起動する直前、デフォルトメッセージが生成された直後に実行されます。
このフックでは、デフォルトメッセージを、コミットの作者の目に触れる前に編集できます。
このフックにはパラメータがあり、その時点でのコミットメッセージを保存したファイルへのパス、コミットのタイプ、さらにamendされたコミットの場合はコミットの SHA-1 をパラメータとして取ります。
このフックは普段のコミットにおいてはあまり有用ではありませんが、テンプレートが用意されているコミットメッセージ・mergeコミット・squashコミット・amendコミットのような、デフォルトメッセージが自動生成されるコミットにおいて効果を発揮します。
コミットメッセージのテンプレートと組み合わせれば、プログラムで情報を動的に挿入できます。</p>
</div>
<div class="paragraph">
<p><code>commit-msg</code> フックは、開発者の書いたコミットメッセージを保存した一時ファイルへのパスをパラメータに取ります。
このスクリプトがゼロ以外の値を返した場合、Git はコミットプロセスを中断します。これを使えば、コミットを許可して処理を進める前に、プロジェクトの状態やコミットメッセージを検査できます。
この章の最後のセクションでは、このフックを使用してコミットメッセージが要求された様式に沿っているか検査するデモンストレーションを行います。</p>
</div>
<div class="paragraph">
<p>コミットプロセスが全て完了した後には、 <code>post-commit</code> フックが実行されます。
このフックはパラメータを取りませんが、 <code>git log -1 HEAD</code> を実行することで直前のコミットを簡単に取り出すことができます。
一般的にこのスクリプトは何かしらの通知といった目的に使用されます。</p>
</div>
</div>
<div class="sect4">
<h4 id="r_email_hooks">Eメールワークフローフック</h4>
<div class="paragraph">
<p>Eメールを使ったワークフロー用として、三種類のクライアントサイドフックを設定できます。
これらはすべて <code>git am</code> コマンドに対して起動されるものなので、ふだんのワークフローでこのコマンドを使っていない場合は次のセクションまで読み飛ばしてもかまいません。
<code>git format-patch</code> で作ったパッチを受け取ることがあるなら、ここで説明する内容の中に有用なものがあるかもしれません。</p>
</div>
<div class="paragraph">
<p>最初に実行されるフックは <code>applypatch-msg</code> です。
これは引数をひとつ（コミットメッセージを含む一時ファイル名）だけ受け取ります。
このスクリプトがゼロ以外の戻り値で終了した場合、Git はパッチの処理を強制終了させます。
このフックを使うと、コミットメッセージの書式が正しいかどうかを確認したり、スクリプトで正しい書式に手直ししたりできます。</p>
</div>
<div class="paragraph">
<p><code>git am</code> でパッチを適用するときに二番目に実行されるフックは <code>pre-applypatch</code> です。
少々ややこしいのですが、このフックはパッチが <em>適用された後</em> 、コミットが作成される前に実行されます。そのため、このフックでは、スナップショットの内容を、コミットする前に調べることができます。
このスクリプトを使えば、テストを実行したり、ワーキングツリーの調査をしたりといったことが行えます。
なにか抜けがあったりテストが失敗したりした場合はスクリプトをゼロ以外の戻り値で終了させます。そうすれば、<code>git am</code> はパッチをコミットせずに強制終了します。</p>
</div>
<div class="paragraph">
<p><code>git am</code> において最後に実行されるフックは <code>post-applypatch</code> です。このフックは、コミットが作成された後に実行されます。
これを使うと、特定のグループのメンバーや、プルしたパッチの作者に対して、処理の完了を伝えることができます。
このスクリプトでは、パッチの適用を中断させることはできません。</p>
</div>
</div>
<div class="sect4">
<h4 id="r_other_client_hooks">その他のクライアントフック</h4>
<div class="paragraph">
<p><code>pre-rebase</code> フックは何かをリベースする前に実行され、ゼロ以外を返せばその処理を中断できます。
このフックを使うと、既にプッシュ済みのコミットのリベースを却下できます。
Git に同梱されているサンプルの <code>pre-rebase</code> フックがこの処理を行いますが、このフックの前提となっている条件のなかには読者のワークフローに合わないものもあるでしょう。</p>
</div>
<div class="paragraph">
<p><code>post-rewrite</code> フックは、既存のコミットを書き換えるコマンド、例えば <code>git commit --amend</code> や <code>git rebase</code> を実行した際に実行されます（ただし <code>git filter-branch</code> では実行されません）。
引数はひとつで、コミットの書き換えを行ったコマンドを引数に取ります。また、書き換えを行ったファイルのリストを <code>stdin</code> から受け取ります。
このフックは <code>post-checkout</code> や <code>post-merge</code> といったフックと同じ用途に使えます。</p>
</div>
<div class="paragraph">
<p><code>git checkout</code> が正常に終了すると、<code>post-checkout</code> フックが実行されます。これを使うと、作業ディレクトリを自分のプロジェクトの環境にあわせて設定できます。
たとえば、バージョン管理対象外の巨大なバイナリファイルを作業ディレクトリに取り込んだり、ドキュメントを自動生成したりといった処理が行えます。</p>
</div>
<div class="paragraph">
<p><code>post-merge</code> フックは、<code>merge</code> コマンドが正常に終了したときに実行されます。
これを使うと、Git では追跡できないパーミッション情報などを作業ツリーに復元できます。
作業ツリーに変更が加わったときに取り込みたい Git の管理対象外のファイルの存在確認などにも使えます。</p>
</div>
<div class="paragraph">
<p><code>pre-push</code> フックは、 <code>git push</code> を実行した際、リモート参照が更新された後、オブジェクトの転送が始まる前に実行されます。
このフックはリモートの名前と場所を引数に取ります。また、これから更新する参照のリストを <code>stdin</code> から受け取ります。
このフックは、プッシュを行う前に、更新される参照を検査するのに使用できます（ゼロ以外の値を返すとプッシュが中断されます）。</p>
</div>
<div class="paragraph">
<p>Git は通常の操作の一環として、時折 <code>git gc --auto</code> を実行してガベージコレクションを行います。
<code>pre-auto-gc</code> フックは、ガベージコレクションが実行される直前に呼び出されます。このフックは、ガベージコレクションが実行されることを通知したり、タイミングが悪い場合にガベージコレクションを中断したりするのに使用できます。</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_サーバーサイドフック">サーバーサイドフック</h3>
<div class="paragraph">
<p>システム管理者としてプロジェクトのポリシーを強制させる際には、クライアントサイドフックに加え、いくつかのサーバーサイドフックを使うこともできます。
これらのスクリプトは、サーバへのプッシュの前後に実行されます。
pre フックをゼロ以外の値で終了させると、プッシュを却下してエラーメッセージをクライアントに返すことができます。つまり、プッシュに関して、好きなだけ複雑なポリシーを設定できるということです。</p>
</div>
<div class="sect4">
<h4 id="_pre_receive"><code>pre-receive</code></h4>
<div class="paragraph">
<p>クライアントからのプッシュを処理するときに最初に実行されるスクリプトが <code>pre-receive</code> です。
このスクリプトは、プッシュされた参照のリストを標準入力から受け取ります。ゼロ以外の値で終了させると、これらはすべて却下されます。
このフックを使うと、更新内容がすべてfast-forwardであることをチェックしたり、プッシュによって変更されるファイルや参照に対するアクセス制御を行ったりできます。</p>
</div>
</div>
<div class="sect4">
<h4 id="_update"><code>update</code></h4>
<div class="paragraph">
<p><code>update</code> スクリプトは <code>pre-receive</code> スクリプトと似ていますが、プッシュしてきた人が更新しようとしているブランチごとに実行されるという点が異なります。
複数のブランチへのプッシュがあったときに <code>pre-receive</code> が実行されるのは一度だけですが、update はブランチ単位でそれぞれ一度ずつ実行されます。
このスクリプトは、標準入力を読み込むのではなく三つの引数を受け取ります。参照 (ブランチ) の名前、プッシュ前を指す参照の SHA-1、そしてプッシュしようとしている参照の SHA-1 です。
update スクリプトをゼロ以外で終了させると、その参照のみが却下されます。それ以外の参照はそのまま更新を続行します。</p>
</div>
</div>
<div class="sect4">
<h4 id="_post_receive"><code>post-receive</code></h4>
<div class="paragraph">
<p><code>post-receive</code> フックは処理が終了した後で実行されるもので、他のサービスの更新やユーザーへの通知などに使えます。
このフックは、 <code>pre-receive</code> フックと同じデータを標準入力から受け取ります。
サンプルのスクリプトには、リストをメールしたり、継続的インテグレーションサーバーへ通知したり、チケット追跡システムを更新したりといった処理が含まれています。コミットメッセージを解析して、チケットのオープン・修正・クローズなどの必要性を調べることもできます。
このスクリプトではプッシュの処理を中断させることはできませんが、クライアント側ではこのスクリプトが終了するまで接続を切断できません。このスクリプトで時間のかかる処理をさせるときには十分注意しましょう。</p>
</div>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>