---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: sl
  chapter:
    title: Orodja Git
    number: 7
  section:
    title: Podmoduli
    number: 11
    cs_number: '7.11'
    previous: book/sl/v2/Orodja-Git-Razhroščevanje-z-Gitom
    next: book/sl/v2/Orodja-Git-Povezovanje-v-pakete
title: Git - Podmoduli
---
<h2 id="_git_submodules">Podmoduli</h2>
<div class="paragraph">
<p>Pogostokrat se zgodi, da med delom na enem projektu potrebujete uporabo drugega projekta znotraj tega.
Morda gre za knjižnico, ki jo je razvil tretji ponudnik, ali pa jo razvijate ločeno in jo uporabljate v več nadrejenih projektih.
V teh primerih se pogosto pojavijo težave: želite, da se lahko dva projekta obravnavata ločeno, hkrati pa lahko uporabite enega znotraj drugega.</p>
</div>
<div class="paragraph">
<p>Tukaj je primer.
Predpostavimo, da razvijate spletno stran in ustvarjate vire Atom.
Namesto da bi pisali svojo lastno kodo za generiranje Atomov, se odločite za uporabo knjižnice.
Verjetno boste morali vključiti to kodo iz skupne knjižnice, kot je namestitev CPAN ali Ruby gem, ali pa kopirati izvorno kodo v svoje projektno drevo.
Težava pri vključevanju knjižnice je, da jo je težko prilagoditi na kakršen koli način in pogosto jo je težje implementirati, saj morate poskrbeti, da je knjižnica na voljo vsakemu odjemalcu.
Težava pri kopiranju kode v lasten projekt pa je, da so kakršne koli prilagojene spremembe, ki jih naredite, težke za združevanje, ko postanejo na voljo spremembe izvornega projekta.</p>
</div>
<div class="paragraph">
<p>Git naslavlja to težavo s pomočjo podmodulov.
Podmoduli vam omogočajo, da ohranite repozitorij Git kot podmapo drugega repozitorija Git.
To vam omogoča, da klonirate drug repozitorij v svoj projekt in ohranite svoje potrditve ločene.</p>
</div>
<div class="sect3">
<h3 id="_starting_submodules">Začetek s podmoduli</h3>
<div class="paragraph">
<p>Pojasnili bomo, kako razviti preprost projekt, ki je razdeljen na glavni projekt in nekaj podprojektov.</p>
</div>
<div class="paragraph">
<p>Začnimo tako, da dodamo obstoječi repozitorij Git kot podmodul repozitorija, na katerem delamo.
Za dodajanje novega podmodula uporabite ukaz <code>git submodule add</code> z absolutnim ali relativnim URL-jem projekta, ki ga želite začeti slediti.
V tem primeru bomo dodali knjižnico, imenovano »DbConnector«.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git submodule add https://github.com/chaconinc/DbConnector
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Privzeto bodo podmoduli dodani v mapo imenovano enako kot repozitorij, v tem primeru »DbConnector«.
Če želite, da gre kam drugam, lahko na koncu ukaza določite drugačno pot.</p>
</div>
<div class="paragraph">
<p>Če zdaj zaženete ukaz <code>git status</code>, boste opazili nekaj stvari.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

	new file:   .gitmodules
	new file:   DbConnector</code></pre>
</div>
</div>
<div class="paragraph">
<p>Najprej bi morali opaziti novo datoteko <code>.gitmodules</code>.
To je konfiguracijska datoteka, ki hrani preslikavo med URL-jem projekta in lokalno podmapo, v katero ste ga povlekli:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">[submodule "DbConnector"]
	path = DbConnector
	url = https://github.com/chaconinc/DbConnector</code></pre>
</div>
</div>
<div class="paragraph">
<p>Če imate več podmodulov, boste imeli več vnosov v tej datoteki.
Pomembno je opozoriti, da je ta datoteka nadzorovana z različicami skupaj z drugimi datotekami, kot je vaša <code>.gitignore</code> datoteka.
Ta se potiska in vleče skupaj s preostalim projektom.
To je način, kako drugi ljudje, ki klonirajo ta projekt, vedo, kje dobiti projekte podmodulov.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Opomba</div>
</td>
<td class="content">
<div class="paragraph">
<p>Ker je URL v datoteki <code>.gitmodules</code> tisto, kar bodo drugi najprej poskusili klonirati/pridobiti, poskrbite, da boste uporabili URL, ki je drugim dostopen, če je to mogoče.
Na primer, če uporabljate drugačen URL za potiskanje, kot ga drugi uporabljajo za pridobivanje, uporabite tistega, do katerega imajo drugi dostop.
To vrednost lahko lokalno prepišete z <code>git config submodule.DbConnector.url PRIVATE_URL</code> za lastno uporabo.
V določenih primerih je lahko koristen relativen URL.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Drugi vnos v izpisu <code>git status</code> je vnos mape projekta.
Če na tem zaženete <code>git diff</code>, boste videli nekaj zanimivega:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --cached DbConnector
diff --git a/DbConnector b/DbConnector
new file mode 160000
index 0000000..c3f01dc
--- /dev/null
+++ b/DbConnector
@@ -0,0 +1 @@
+Subproject commit c3f01dc8862123d317dd46284b05b6892c7b29bc</code></pre>
</div>
</div>
<div class="paragraph">
<p>Čeprav je <code>DbConnector</code> podmapa v vašem delovnem imeniku, jo Git vidi kot podmodul in ne spremlja njenih vsebin, ko se ne nahajate v tej mapi.
Namesto tega Git vidi to kot določeno potrditev iz tega repozitorija.</p>
</div>
<div class="paragraph">
<p>Če želite malo lepši izpis diff, lahko ukazu <code>git diff</code> predložite možnost <code>--submodule</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --cached --submodule
diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 0000000..71fc376
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,3 @@
+[submodule "DbConnector"]
+       path = DbConnector
+       url = https://github.com/chaconinc/DbConnector
Submodule DbConnector 0000000...c3f01dc (new submodule)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ko potrdite, boste videli nekaj takega:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git commit -am 'Add DbConnector module'
[master fb9093c] Add DbConnector module
 2 files changed, 4 insertions(+)
 create mode 100644 .gitmodules
 create mode 160000 DbConnector</code></pre>
</div>
</div>
<div class="paragraph">
<p>Opazite način <code>160000</code> za vnos <code>DbConnector</code>.
To je poseben način v Gitu, ki v bistvu pomeni, da zapisujete potrditev kot vnos v mapi namesto podmape ali datoteke.</p>
</div>
<div class="paragraph">
<p>Na koncu potisnite te spremembe:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git push origin master</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_cloning_submodules">Kloniranje projekta s podmoduli</h3>
<div class="paragraph">
<p>Tu bomo klonirali projekt, ki vsebuje podmodul.
Ko klonirate tak projekt, boste privzeto dobili direktorije, ki vsebujejo podmodule, vendar znotraj njih ni še nobene datoteke:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone https://github.com/chaconinc/MainProject
Cloning into 'MainProject'...
remote: Counting objects: 14, done.
remote: Compressing objects: 100% (13/13), done.
remote: Total 14 (delta 1), reused 13 (delta 0)
Unpacking objects: 100% (14/14), done.
Checking connectivity... done.
$ cd MainProject
$ ls -la
total 16
drwxr-xr-x   9 schacon  staff  306 Sep 17 15:21 .
drwxr-xr-x   7 schacon  staff  238 Sep 17 15:21 ..
drwxr-xr-x  13 schacon  staff  442 Sep 17 15:21 .git
-rw-r--r--   1 schacon  staff   92 Sep 17 15:21 .gitmodules
drwxr-xr-x   2 schacon  staff   68 Sep 17 15:21 DbConnector
-rw-r--r--   1 schacon  staff  756 Sep 17 15:21 Makefile
drwxr-xr-x   3 schacon  staff  102 Sep 17 15:21 includes
drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 scripts
drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 src
$ cd DbConnector/
$ ls
$</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mapa <code>DbConnector</code> obstaja, vendar je prazna.
Zagnati morate dve ukaza: <code>git submodule init</code>, da inicializirate lokalno konfiguracijsko datoteko, in <code>git submodule update</code>, da pridobite vse podatke iz tega projekta in izvlečete ustrezno potrditev v nadrejenem projektu:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git submodule init
Submodule 'DbConnector' (https://github.com/chaconinc/DbConnector) registered for path 'DbConnector'
$ git submodule update
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
Submodule path 'DbConnector': checked out 'c3f01dc8862123d317dd46284b05b6892c7b29bc'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sedaj je vaša podmapa <code>DbConnector</code> v natančno enakem stanju kot ob vašem prejšnjem potrjevanju.</p>
</div>
<div class="paragraph">
<p>Obstaja še drug način, ki pa je nekoliko preprostejši.
Če ukazu <code>git clone</code> dodate <code>--recurse-submodules</code>, se bodo vsi podmoduli v repozitoriju samodejno inicializirali in posodobili, vključno z vgrajenimi podmoduli, če ima kateri od podmodulov v repozitoriju svoje podmodule.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone --recurse-submodules https://github.com/chaconinc/MainProject
Cloning into 'MainProject'...
remote: Counting objects: 14, done.
remote: Compressing objects: 100% (13/13), done.
remote: Total 14 (delta 1), reused 13 (delta 0)
Unpacking objects: 100% (14/14), done.
Checking connectivity... done.
Submodule 'DbConnector' (https://github.com/chaconinc/DbConnector) registered for path 'DbConnector'
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
Submodule path 'DbConnector': checked out 'c3f01dc8862123d317dd46284b05b6892c7b29bc'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Če ste že klonirali projekt in pozabili na <code>--recurse-submodules</code>, lahko koraka <code>git submodule init</code> in <code>git submodule update</code> združite tako, da zaženete <code>git submodule update --init</code>.
Če želite inicializirati, pridobiti in izvleči tudi vse vgrajene podmodule, lahko uporabite enostaven ukaz <code>git submodule update --init --recursive</code>.</p>
</div>
</div>
<div class="sect3">
<h3 id="_delo_na_projektu_s_podmoduli">Delo na projektu s podmoduli</h3>
<div class="paragraph">
<p>Zdaj imamo kopijo projekta z vgrajenimi podmoduli in sodelovali bomo s svojimi sodelavci na glavnem projektu in podprojektu.</p>
</div>
<div class="sect4">
<h4 id="_povlek_zgornjih_sprememb_iz_daljave_podmodula">Povlek zgornjih sprememb iz daljave podmodula</h4>
<div class="paragraph">
<p>Najenostavnejši model uporabe podmodulov v projektu bi bil, če bi enostavno uporabljali podprojekt in občasno želeli dobiti njegove posodobitve, vendar ga dejansko ne bi nikakor spreminjali pri vašem izvleku.
Pojdimo tu skozi enostaven primer.</p>
</div>
<div class="paragraph">
<p>Če želite preveriti novo delo v podmodulu, lahko greste v direktorij in poženete <code>git fetch</code> in <code>git merge</code>, da posodobite vejo povratnega toka in posodobite svojo lokalno kodo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git fetch
From https://github.com/chaconinc/DbConnector
   c3f01dc..d0354fc  master     -&gt; origin/master
$ git merge origin/master
Updating c3f01dc..d0354fc
Fast-forward
 scripts/connect.sh | 1 +
 src/db.c           | 1 +
 2 files changed, 2 insertions(+)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Če greste sedaj nazaj v svoj glavni projekt in poženete <code>git diff --submodule</code>, lahko vidite, da je bil podmodul posodobljen in dobite seznam vseh potrditev, ki so mu bile dodane.
Če ne želite vsakič vpisovati <code>--submodule</code>, ko poženete <code>git diff</code>, lahko možnost nastavite kot privzeti format z nastavitvijo konfiguracijske vrednosti <code>diff.submodule</code> na »log«.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global diff.submodule log
$ git diff
Submodule DbConnector c3f01dc..d0354fc:
  &gt; more efficient db routine
  &gt; better connection routine</code></pre>
</div>
</div>
<div class="paragraph">
<p>Če v tem trenutku potrdite, boste podmodul zaklenili, da ima novo kodo, ko bodo drugi posodabljali.</p>
</div>
<div class="paragraph">
<p>Da to naredite, obstaja enostavnejša pot, če imate raje ročno prenašanje in združevanje v poddirektoriju.
Če poženete <code>git submodule update --remote</code>, bo šel Git v vaše podmodule in vam jih prenesel ter posodobil.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git submodule update --remote DbConnector
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   3f19983..d0354fc  master     -&gt; origin/master
Submodule path 'DbConnector': checked out 'd0354fc054692d3906c85c3af05ddce39a1c0644'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ta ukaz bo privzeto predvideval, da želite posodobiti izvlek na privzeto vejo oddaljenega podmodula (tistega, na katerega kaže <code>HEAD</code> na oddaljenem mestu).
Vendar če želite, lahko to nastavite na nekaj drugega.
Na primer, če želite, da podmodul <code>DbConnector</code> sledi veji »stable« tega repozitorija, lahko to nastavite v datoteki <code>.gitmodules</code> (tako, da jo spremljajo tudi drugi), ali pa v lokalni datoteki <code>.git/config</code>.
Nastavimo jo v datoteki <code>.gitmodules</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git config -f .gitmodules submodule.DbConnector.branch stable

$ git submodule update --remote
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   27cf5d3..c87d55d  stable -&gt; origin/stable
Submodule path 'DbConnector': checked out 'c87d55d4c6d4b05ee34fbc8cb6f7bf4585ae6687'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Če izpustite <code>-f .gitmodules</code>, bo naredil samo spremembo za vas, vendar je morda bolj smotrno, da sledite tej informaciji z repozitorijem, da lahko to naredi tudi vsakdo drug.</p>
</div>
<div class="paragraph">
<p>Ko v tem trenutku poženemo <code>git status</code>, nam bo Git pokazal, da imamo v podmodulu »nove potrditve«.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

  modified:   .gitmodules
  modified:   DbConnector (new commits)

no changes added to commit (use "git add" and/or "git commit -a")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Če nastavite konfiguracijsko nastavitev <code>status.submodulesummary</code>, vam bo Git tudi pokazal kratek povzetek sprememb na vaših podmodulih:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git config status.submodulesummary 1

$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

	modified:   .gitmodules
	modified:   DbConnector (new commits)

Submodules changed but not updated:

* DbConnector c3f01dc...c87d55d (4):
  &gt; catch non-null terminated lines</code></pre>
</div>
</div>
<div class="paragraph">
<p>Če v tem trenutku poženete <code>git diff</code>, lahko vidimo, da imamo spremenjeno tako našo datoteko <code>.gitmodules</code> kot tudi, da je veliko potrditev, ki smo jih povlekli, in so pripravljene za potrditev v našem projektu podmodula.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git diff
diff --git a/.gitmodules b/.gitmodules
index 6fc0b3d..fd1cc29 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,4 @@
 [submodule "DbConnector"]
        path = DbConnector
        url = https://github.com/chaconinc/DbConnector
+       branch = stable
 Submodule DbConnector c3f01dc..c87d55d:
  &gt; catch non-null terminated lines
  &gt; more robust error handling
  &gt; more efficient db routine
  &gt; better connection routine</code></pre>
</div>
</div>
<div class="paragraph">
<p>To je kar odlično, saj lahko dejansko vidimo dnevnik potrditev, ki jih bomo ravno potrdili v našem podmodulu.
Ko je enkrat potrjeno, lahko vidimo te informacije tudi po tem, kot tudi, ko poženete <code>git log -p</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git log -p --submodule
commit 0a24cfc121a8a3c118e0105ae4ae4c00281cf7ae
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Wed Sep 17 16:37:02 2014 +0200

    updating DbConnector for bug fixes

diff --git a/.gitmodules b/.gitmodules
index 6fc0b3d..fd1cc29 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,4 @@
 [submodule "DbConnector"]
        path = DbConnector
        url = https://github.com/chaconinc/DbConnector
+       branch = stable
Submodule DbConnector c3f01dc..c87d55d:
  &gt; catch non-null terminated lines
  &gt; more robust error handling
  &gt; more efficient db routine
  &gt; better connection routine</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ko poženete <code>git submodule update --remote</code>, bo Git privzeto poskusil posodobiti <strong>vse</strong> vaše podmodule.
Če jih imate veliko, boste morda želeli podati tudi ime samo tistega podmodula, ki ga želite posodobiti.</p>
</div>
</div>
<div class="sect4">
<h4 id="_povlek_zgornjih_sprememb_iz_daljave_projekta">Povlek zgornjih sprememb iz daljave projekta</h4>
<div class="paragraph">
<p>Postavimo se sedaj v vašega sodelavca, ki ima svoj lokalni klon repozitorija MainProject.
Enostaven pogon <code>git pull</code>, da dobite svoje nove potrjene spremembe, ni dovolj:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git pull
From https://github.com/chaconinc/MainProject
   fb9093c..0a24cfc  master     -&gt; origin/master
Fetching submodule DbConnector
From https://github.com/chaconinc/DbConnector
   c3f01dc..c87d55d  stable     -&gt; origin/stable
Updating fb9093c..0a24cfc
Fast-forward
 .gitmodules         | 2 +-
 DbConnector         | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

$ git status
 On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

	modified:   DbConnector (new commits)

Submodules changed but not updated:

* DbConnector c87d55d...c3f01dc (4):
  &lt; catch non-null terminated lines
  &lt; more robust error handling
  &lt; more efficient db routine
  &lt; better connection routine

no changes added to commit (use "git add" and/or "git commit -a")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Privzeto ukaz <code>git pull</code> rekurzivno pridobi spremembe v podmodulih, kar lahko vidimo v izpisu prvega zgoraj navedenega ukaza.
Vendar ne <strong>posodobi</strong> podmodulov.
To kaže izpis ukaza <code>git status</code>, ki prikazuje, da je podmodul »spremenjen« in ima »nove potrditve«.
Poleg tega oklepaji, ki kažejo nove potrditve, kažejo levo (<code>&lt;</code>), kar kaže, da so te potrditve zabeležene v glavnem projektu, vendar niso prisotne v lokalnem izvleku <code>DbConnector</code>.
Da dokončate posodobitev, morate zagnati <code>git submodule update</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git submodule update --init --recursive
Submodule path 'vendor/plugins/demo': checked out '48679c6302815f6c76f1fe30625d795d9e55fc56'

$ git status
 On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working tree clean</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bodite pozorni, da ste na varni strani, saj bi morali zagnati ukaz <code>git submodule update</code> z zastavico <code>--init</code>, če ste pravkar pridobili spremembe v glavnem projektu, ki so dodale nove podmodule, in z zastavico <code>--recursive</code>, če imajo podmoduli vdelane podmodule.</p>
</div>
<div class="paragraph">
<p>Če želite ta postopek avtomatizirati, lahko ukazu <code>git pull</code> dodate zastavico <code>--recurse-submodules</code> (od Git 2.14 dalje).
To bo Gitu omogočilo, da takoj po potegu zažene ukaz <code>git submodule update</code> in podmodule postavi v pravilno stanje.
Če želite vedno uporabljati <code>--recurse-submodules</code> za <code>git pull</code>, lahko nastavite konfiguracijsko možnost <code>submodule.recurse</code> na <code>true</code> (to deluje za <code>git pull</code> od verzije Git 2.15 dalje).
Ta možnost bo Gitu omogočila, da uporabi zastavico <code>--recurse-submodules</code> za vse ukaze, ki to podpirajo (razen <code>clone</code>).</p>
</div>
<div class="paragraph">
<p>Obstaja posebna situacija, ki se lahko zgodi med posodabljanjem nadrejenega projekta: lahko se zgodi, da je oddaljeni repozitorij spremenil URL podmodula v datoteki <code>.gitmodules</code> v eni od potrditev, ki ste jo povlekli.
To se lahko zgodi, na primer, če se projekt podmodula spremeni na drugo gostiteljsko platformo.
V takem primeru lahko <code>git pull --recurse-submodules</code> ali <code>git submodule update</code> spodleti, če se nadrejeni projekt sklicuje na potrditev podmodula, ki je ni mogoče najti v oddaljenem podmodulu, ki je lokalno konfiguriran v vašem repozitoriju.
Da bi rešili to situacijo, je potreben ukaz <code>git submodule sync</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console"># copy the new URL to your local config
$ git submodule sync --recursive
# update the submodule from the new URL
$ git submodule update --init --recursive</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_delo_na_podmodulu">Delo na podmodulu</h4>
<div class="paragraph">
<p>Verjetno uporabljate podmodule, ker resnično želite delati na kodi v podmodulu istočasno, ko delate na glavni kodi (ali med več podmoduli).
Drugače bi verjetno namesto tega uporabljali preprostejši sistem upravljanja odvisnosti (kot sta Maven ali Rubygems).</p>
</div>
<div class="paragraph">
<p>Pojdimo skozi primer spreminjanja podmodula istočasno z glavnim projektom ter hkratnega potrjevanja in objavljanja teh sprememb.</p>
</div>
<div class="paragraph">
<p>Do sedaj, ko smo zagnali ukaz <code>git submodule update</code>, da dobimo spremembe iz podmodulov, Git dobi spremembe in posodobi datoteke v poddirektoriju, vendar pusti podrepozitorij v »stanju ločene glave« (angl. <em>detached HEAD state</em>).
To pomeni, da ni lokalne delovne veje (kot je na primer <code>master</code>), ki bi sledila spremembam.
Če ni delovne veje, ki spremlja spremembe, to pomeni, da bodo spremembe, ki jih potrdite v podmodulu, verjetno izgubljene, ko naslednjič zaženete <code>git submodule update</code>.
Za sledenje spremembam v podmodulu morate opraviti nekaj dodatnih korakov.</p>
</div>
<div class="paragraph">
<p>Da bi lažje začeli urejati podmodul, morate storiti dve stvari.
Morate iti v vsak podmodul in izbrati vejo, na kateri boste delali.
Nato morate Gitu povedati, kaj naj naredi, če ste naredili spremembe, in <code>git submodule update --remote</code> povleče nove spremembe od povratnega toka.
Možnosti so, da jih lahko združite s svojim lokalnim delom, ali pa lahko poskusite postaviti svoje lokalno delo na vrh novih sprememb.</p>
</div>
<div class="paragraph">
<p>Najprej pojdimo v svoj imenik podmodula in si izvlecimo vejo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cd DbConnector/
$ git checkout stable
Switched to branch 'stable'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Poskusimo posodobiti naš podmodul z možnostjo »združevanja«.
Da ga ročno določimo, lahko enostavno dodamo možnost <code>--merge</code> našemu klicu <code>update</code>.
Tu bomo videli, da je bila za ta podmodul sprememba na strežniku in da je združena.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ cd ..
$ git submodule update --remote --merge
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   c87d55d..92c7337  stable     -&gt; origin/stable
Updating c87d55d..92c7337
Fast-forward
 src/main.c | 1 +
 1 file changed, 1 insertion(+)
Submodule path 'DbConnector': merged in '92c7337b30ef9e0893e758dac2459d07362ab5ea'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Če gremo v direktorij <code>DbConnector</code>, imamo nove spremembe že združene v našo lokalno vejo <code>stable</code>.
Sedaj poglejmo, kaj se zgodi, ko naredimo na knjižnici svoje lastne lokalne spremembe in nekdo drug istočasno potisne drugo spremembo na povratni tok.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cd DbConnector/
$ vim src/db.c
$ git commit -am 'Unicode support'
[stable f906e16] Unicode support
 1 file changed, 1 insertion(+)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Če sedaj posodobimo naše podmodule, lahko vidimo, kaj se zgodi, če imamo tako lokalno kot tudi zgornjo spremembo, ki jo moramo vdelati.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cd ..
$ git submodule update --remote --rebase
First, rewinding head to replay your work on top of it...
Applying: Unicode support
Submodule path 'DbConnector': rebased into '5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Če pozabite <code>--rebase</code> ali <code>--merge</code>, bo Git posodobil samo podmodul na karkoli je na strežniku in ponastavil vaš projekt na »stanje ločene glave« (angl. <em>detached HEAD state</em>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git submodule update --remote
Submodule path 'DbConnector': checked out '5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Če se to zgodi, ne skrbite, enostavno lahko greste nazaj v direktorij in ponovno izvlečete svojo vejo (ki bo še vedno vsebovala vaše delo) ter ročno združite, ali ponovno bazirate glede na <code>origin/stable</code> (ali katero koli oddaljeno vejo želite).</p>
</div>
<div class="paragraph">
<p>Če niste potrdili vaših sprememb v vašem podmodulu in poženete <code>submodule update</code>, ki bi povzročil težave, bo Git prenesel spremembe, vendar ne bo prepisal neshranjenega dela v vašem direktoriju podmodula.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git submodule update --remote
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 4 (delta 0), reused 4 (delta 0)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   5d60ef9..c75e92a  stable     -&gt; origin/stable
error: Your local changes to the following files would be overwritten by checkout:
	scripts/setup.sh
Please, commit your changes or stash them before you can switch branches.
Aborting
Unable to checkout 'c75e92a2b3855c9e5b66f915308390d9db204aca' in submodule path 'DbConnector'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Če ste naredili spremembe, ki so v konfliktu z nečim iz povratnega toka, vas bo Git obvestil, da poženete posodobitev.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git submodule update --remote --merge
Auto-merging scripts/setup.sh
CONFLICT (content): Merge conflict in scripts/setup.sh
Recorded preimage for 'scripts/setup.sh'
Automatic merge failed; fix conflicts and then commit the result.
Unable to merge 'c75e92a2b3855c9e5b66f915308390d9db204aca' in submodule path 'DbConnector'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lahko greste v direktorij podmodula in popravite konflikt, kot bi to običajno storili.</p>
</div>
</div>
<div class="sect4">
<h4 id="_publishing_submodules">Objavljanje sprememb podmodulov</h4>
<div class="paragraph">
<p>Sedaj imamo nekaj sprememb v našem direktoriju podmodula.
Nekatere od teh so bile prinesene iz povratnega toka z našimi posodobitvami, ostale pa so bile narejene lokalno in niso še nikomur na voljo, saj jih še nismo potisnili.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git diff
Submodule DbConnector c87d55d..82d2ad3:
  &gt; Merge from origin/stable
  &gt; Update setup script
  &gt; Unicode support
  &gt; Remove unnecessary method
  &gt; Add new option for conn pooling</code></pre>
</div>
</div>
<div class="paragraph">
<p>Če naredimo potrditev v glavnem projektu in jo potisnemo navzgor, ne da bi hkrati potisnili tudi spremembe podmodulov, bodo imeli drugi ljudje, ki poskušajo prenesti naše spremembe, težave, saj ne bodo imeli načina, da dobijo spremembe podmodulov, od katerih so odvisni.
Te spremembe bodo obstajale samo v naši lokalni kopiji.</p>
</div>
<div class="paragraph">
<p>Da se to ne zgodi, lahko Git zaprosite, da preveri, ali so bili vsi podmoduli pravilno potisnjeni, preden potisnete glavni projekt.
Ukaz <code>git push</code> sprejme argument <code>--recurse-submodules</code>, ki ga lahko nastavimo na »check« ali »on-demand«.
Možnost »check« bo naredila, da bo ukaz <code>push</code> preprosto spodletel, če niso bile potisnjene vse potrjene spremembe podmodulov.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git push --recurse-submodules=check
The following submodule paths contain changes that can
not be found on any remote:
  DbConnector

Please try

	git push --recurse-submodules=on-demand

or cd to the path and use

	git push

to push them to a remote.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Kot vidite, nam prav tako ponuja nekaj koristnih nasvetov o tem, kaj bi morda želeli storiti naslednje.
Preprosta možnost je, da vstopite v vsak podmodul in ročno potisnete na oddaljene strežnike, da se prepričate, da so na voljo od zunaj, nato pa poskusite ta potisk znova.
Če želite, da se ta »check« zgodi za vse potiske, lahko to obnašanje nastavite kot privzeto z ukazom <code>git config push.recurseSubmodules check</code>.</p>
</div>
<div class="paragraph">
<p>Druga možnost je uporaba vrednosti »on-demand«, ki bo to poskušala storiti namesto vas.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git push --recurse-submodules=on-demand
Pushing submodule 'DbConnector'
Counting objects: 9, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (8/8), done.
Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.
Total 9 (delta 3), reused 0 (delta 0)
To https://github.com/chaconinc/DbConnector
   c75e92a..82d2ad3  stable -&gt; stable
Counting objects: 2, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (2/2), 266 bytes | 0 bytes/s, done.
Total 2 (delta 1), reused 0 (delta 0)
To https://github.com/chaconinc/MainProject
   3d6d338..9a377d1  master -&gt; master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Kot vidite, je šel Git v modul <code>DbConnector</code> in ga potisnil, preden je potisnil glavni projekt.
Če ta poskus potiska podmodula zaradi nekega razloga spodleti, bo spodletelo tudi potiskanje glavnega projekta.
To obnašanje lahko nastavite kot privzeto z ukazom <code>git config push.recurseSubmodules on-demand</code>.</p>
</div>
</div>
<div class="sect4">
<h4 id="_združevanje_sprememb_podmodulov">Združevanje sprememb podmodulov</h4>
<div class="paragraph">
<p>Če spremenite referenco podmodula istočasno kot nekdo drug, lahko naletite na nekaj težav.
To je, če so se zgodovine podmodulov razšle in so bile potrjene v različnih vejah v nadrejenem projektu, bo morda potrebno nekaj dela, da jih popravite.</p>
</div>
<div class="paragraph">
<p>Če je ena od oddaj neposreden prednik druge (združitev fast-forward), bo Git preprosto izbral slednjo za združitev, zato to deluje brez težav.</p>
</div>
<div class="paragraph">
<p>Git vam vendarle ne bo poskušal narediti niti trivialnega združevanja.
Če se potrditve podmodulov razlikujejo in jih je treba združiti, boste dobili nekaj takega:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git pull
remote: Counting objects: 2, done.
remote: Compressing objects: 100% (1/1), done.
remote: Total 2 (delta 1), reused 2 (delta 1)
Unpacking objects: 100% (2/2), done.
From https://github.com/chaconinc/MainProject
   9a377d1..eb974f8  master     -&gt; origin/master
Fetching submodule DbConnector
warning: Failed to merge submodule DbConnector (merge following commits not found)
Auto-merging DbConnector
CONFLICT (submodule): Merge conflict in DbConnector
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Torej, kar se je tu zgodilo, je, da je Git ugotovil, da se točke v zgodovini podmodula v dveh vejah razhajajo in da jih je treba združiti.
Pojasni, kot »združitve naslednjih potrditev niso bile najdene«, kar je zmedeno, vendar bomo to pojasnili malo kasneje.</p>
</div>
<div class="paragraph">
<p>Za rešitev problema morate ugotoviti, v katerem stanju naj bo podmodul.
Presenetljivo Git ne ponuja veliko informacij, ki bi pomagale pri tem, niti SHA-1 potrditev obeh strani zgodovine.
Na srečo je to preprosto ugotoviti.
Če zaženete <code>git diff</code>, lahko dobite SHA-1 potrditve, posnete v obeh vejah, ki jih poskušate združiti.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --cc DbConnector
index eb41d76,c771610..0000000
--- a/DbConnector
+++ b/DbConnector</code></pre>
</div>
</div>
<div class="paragraph">
<p>Torej v tem primeru je potrditev <code>eb41d76</code> v našem podmodulu in <code>c771610</code> je potrditev, ki jo ima zgornji nivo.
Če gremo v podmapo podmodula, bi ta že morala biti na <code>eb41d76</code>, saj združevanje ni vplivalo nanj.
Če ni, lahko preprosto ustvarite in preklopite na vejo, da kaže nanj.</p>
</div>
<div class="paragraph">
<p>Pomembno je, da uporabimo SHA-1 potrditve na drugi strani.
To je potrditev, ki jo bomo morali združiti in rešiti morebitne konflikte.
Lahko poskusite neposredno združiti s SHA-1, ali pa ustvarite novo vejo in poskusite združiti z njo.
Priporočljivo je slednje, tudi če samo zaradi boljše opisne sporočilnosti potrditve združitve.</p>
</div>
<div class="paragraph">
<p>Zato bomo šli v podmapo podmodula, ustvarili vejo z imenom »try-merge« na podlagi drugega SHA-1 zapisa iz <code>git diff</code> in jo ročno združili.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ cd DbConnector

$ git rev-parse HEAD
eb41d764bccf88be77aced643c13a7fa86714135

$ git branch try-merge c771610

$ git merge try-merge
Auto-merging src/main.c
CONFLICT (content): Merge conflict in src/main.c
Recorded preimage for 'src/main.c'
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tu dobimo dejansko konflikt pri združevanju, torej če ga rešimo in potrdimo, lahko potem enostavno posodobimo glavni projekt z rezultatom.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ vim src/main.c <b class="conum">(1)</b>
$ git add src/main.c
$ git commit -am 'merged our changes'
Recorded resolution for 'src/main.c'.
[master 9fd905e] merged our changes

$ cd .. <b class="conum">(2)</b>
$ git diff <b class="conum">(3)</b>
diff --cc DbConnector
index eb41d76,c771610..0000000
--- a/DbConnector
+++ b/DbConnector
@@@ -1,1 -1,1 +1,1 @@@
- Subproject commit eb41d764bccf88be77aced643c13a7fa86714135
 -Subproject commit c77161012afbbe1f58b5053316ead08f4b7e6d1d
++Subproject commit 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a
$ git add DbConnector <b class="conum">(4)</b>

$ git commit -m "Merge Tom's Changes" <b class="conum">(5)</b>
[master 10d2c60] Merge Tom's Changes</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Najprej rešimo konflikt.</p>
</li>
<li>
<p>Nato se vrnemo v glavno mapo projekta.</p>
</li>
<li>
<p>Ponovno lahko preverimo vrednosti SHA-1.</p>
</li>
<li>
<p>Rešimo konflikt v vnosu podmodula.</p>
</li>
<li>
<p>Izvedemo potrditev našega združevanja.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Morda je malo zmedeno, vendar ni zelo težko.</p>
</div>
<div class="paragraph">
<p>Zanimivo je, da Git obravnava še en primer.
Če v podmapi obstaja potrditev združitve, ki vsebuje obe zgodovinski potrditvi, jih Git predlaga kot možno rešitev.
Vidi, da je nekdo v podmapi projektov združil veji s tema dvema potrditvama, zato je morda to tisto, kar želite.</p>
</div>
<div class="paragraph">
<p>Zato je sporočilo o napaki od prej »združitve naslednjih potrditev niso bile najdene«, ker <strong>tega</strong> ni mogel storiti.
Zmeda, saj kdo bi pričakoval, da bo <strong>poskusil</strong> narediti to?</p>
</div>
<div class="paragraph">
<p>Če najde eno samo potrditev združitve, ki je sprejemljiva, boste videli nekaj takega:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git merge origin/master
warning: Failed to merge submodule DbConnector (not fast-forward)
Found a possible merge resolution for the submodule:
 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a: &gt; merged our changes
If this is correct simply add it to the index for example
by using:

  git update-index --cacheinfo 160000 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a "DbConnector"

which will accept this suggestion.
Auto-merging DbConnector
CONFLICT (submodule): Merge conflict in DbConnector
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Predlagan ukaz, ki ga Git ponuja, bo posodobil indeks tako, kot bi to storili z ukazom <code>git add</code> (ki odpravlja konflikt), nato bo naredil potrditev.
Verjetno tega ne bi smeli storiti.
Prav tako lahko enostavno vstopite v imenik podmodula, preverite, kakšna je razlika, hitro previjete naprej (fast-forward) na to potrditev, jo ustrezno preizkusite in nato potrdite.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cd DbConnector/
$ git merge 9fd905e
Updating eb41d76..9fd905e
Fast-forward

$ cd ..
$ git add DbConnector
$ git commit -am 'Fast forward to a common submodule child'</code></pre>
</div>
</div>
<div class="paragraph">
<p>To doseže enako stvar, vendar tako vsaj lahko preverite, da deluje in da imate kodo v vašem direktoriju podmodula, ko končate.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_nasveti_za_podmodule">Nasveti za podmodule</h3>
<div class="paragraph">
<p>Obstaja nekaj stvari, ki jih lahko naredite za malo enostavnejše delo s podmoduli.</p>
</div>
<div class="sect4">
<h4 id="_foreach_za_podmodule">Foreach za podmodule</h4>
<div class="paragraph">
<p>Obstaja ukaz podmodulov <code>foreach</code>, ki izvede neki poljuben ukaz v vsakem podmodulu.
To je lahko koristno, če imate veliko podmodulov v istem projektu.</p>
</div>
<div class="paragraph">
<p>Na primer, recimo, da želimo začeti novo lastnost ali popraviti hrošča, in imamo delo v teku na nekaj podmodulih.
Enostavno lahko damo vso delo v vseh naših podmodulih v shrambo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git submodule foreach 'git stash'
Entering 'CryptoLibrary'
No local changes to save
Entering 'DbConnector'
Saved working directory and index state WIP on stable: 82d2ad3 Merge from origin/stable
HEAD is now at 82d2ad3 Merge from origin/stable</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nato lahko ustvarimo novo vejo in preklopimo nanjo v vseh naših podmodulih.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git submodule foreach 'git checkout -b featureA'
Entering 'CryptoLibrary'
Switched to a new branch 'featureA'
Entering 'DbConnector'
Switched to a new branch 'featureA'</code></pre>
</div>
</div>
<div class="paragraph">
<p>To je razumljivo.
Ena izmed resnično uporabnih stvari, ki jo lahko naredite, je, da izdelate dobro poenoteno razliko tega, kar se je spremenilo v vašem glavnem projektu in tudi v vseh vaših podprojektih.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git diff; git submodule foreach 'git diff'
Submodule DbConnector contains modified content
diff --git a/src/main.c b/src/main.c
index 210f1ae..1f0acdc 100644
--- a/src/main.c
+++ b/src/main.c
@@ -245,6 +245,8 @@ static int handle_alias(int *argcp, const char ***argv)

      commit_pager_choice();

+     url = url_decode(url_orig);
+
      /* build alias_argv */
      alias_argv = xmalloc(sizeof(*alias_argv) * (argc + 1));
      alias_argv[0] = alias_string + 1;
Entering 'DbConnector'
diff --git a/src/db.c b/src/db.c
index 1aaefb6..5297645 100644
--- a/src/db.c
+++ b/src/db.c
@@ -93,6 +93,11 @@ char *url_decode_mem(const char *url, int len)
        return url_decode_internal(&amp;url, len, NULL, &amp;out, 0);
 }

+char *url_decode(const char *url)
+{
+       return url_decode_mem(url, strlen(url));
+}
+
 char *url_decode_parameter_name(const char **query)
 {
        struct strbuf out = STRBUF_INIT;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tu lahko vidimo, da smo definirali funkcijo v podmodulu in jo kličemo v glavnem projektu.
To je očitno poenostavljen primer, vendar upamo, da vam da idejo, kako je lahko to koristno.</p>
</div>
</div>
<div class="sect4">
<h4 id="_uporabni_aliasi">Uporabni aliasi</h4>
<div class="paragraph">
<p>Morda želite nastaviti nekatere bližnjice za nekatere od teh ukazov, saj so lahko precej dolgi in večine od njih ne morete nastaviti kot privzete možnosti konfiguracije.
Nastavljanje bližnjic za Git smo že obravnavali v <a href="{{< relurl "book/sl/v2/ch00/_git_aliases" >}}">Aliasi Git</a>, vendar vam tukaj predstavljamo primer, kaj lahko nastavite, če nameravate veliko delati s podmoduli v Gitu.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config alias.sdiff '!'"git diff &amp;&amp; git submodule foreach 'git diff'"
$ git config alias.spush 'push --recurse-submodules=on-demand'
$ git config alias.supdate 'submodule update --remote --merge'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Na ta način lahko enostavno poženete <code>git supdate</code>, ko želite posodobiti vaše podmodule, ali <code>git spush</code>, da jih potisnete s preverjanjem odvisnosti podmodula.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_težave_s_podmoduli">Težave s podmoduli</h3>
<div class="paragraph">
<p>Vendar pa uporaba podmodulov ni brez težav.</p>
</div>
<div class="sect4">
<h4 id="_preklapljanje_vej">Preklapljanje vej</h4>
<div class="paragraph">
<p>Na primer, preklapljanje vej s podmoduli v njimi je lahko malo zapleteno z različicami Gita starejšimi od 2.13.
Če ustvarite novo vejo, dodate tja podmodul in nato preklopite nazaj na vejo brez podmodula, boste še vedno imeli podmodul v direktoriju kot nesledeni direktorij:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git --version
git version 2.12.2

$ git checkout -b add-crypto
Switched to a new branch 'add-crypto'

$ git submodule add https://github.com/chaconinc/CryptoLibrary
Cloning into 'CryptoLibrary'...
...

$ git commit -am 'Add crypto library'
[add-crypto 4445836] Add crypto library
 2 files changed, 4 insertions(+)
 create mode 160000 CryptoLibrary

$ git checkout master
warning: unable to rmdir CryptoLibrary: Directory not empty
Switched to branch 'master'
Your branch is up-to-date with 'origin/master'.

$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)

	CryptoLibrary/

nothing added to commit but untracked files present (use "git add" to track)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Odstranjevanje direktorija ni težavno, vendar je lahko malo nerazumljivo imeti to tam.
Če ga odstranite in nato preklopite nazaj na vejo, ki ima ta podmodul, boste morali pognati <code>submodule update --init</code>, da ga ponovno zapolnite.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clean -ffdx
Removing CryptoLibrary/

$ git checkout add-crypto
Switched to branch 'add-crypto'

$ ls CryptoLibrary/

$ git submodule update --init
Submodule path 'CryptoLibrary': checked out 'b8dda6aa182ea4464f3f3264b11e0268545172af'

$ ls CryptoLibrary/
Makefile	includes	scripts		src</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ponovno, ni resnično težavno, vendar je lahko malenkost nerazumljivo.</p>
</div>
<div class="paragraph">
<p>Novejše različice Git (Git &gt;= 2.13) vse to poenostavijo z dodatkom zastavice <code>--recurse-submodules</code> pri ukazu <code>git checkout</code>, kar poskrbi za podajanje podmodulov v pravo stanje za vsako vejo, na katero preklapljate.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git --version
git version 2.13.3

$ git checkout -b add-crypto
Switched to a new branch 'add-crypto'

$ git submodule add https://github.com/chaconinc/CryptoLibrary
Cloning into 'CryptoLibrary'...
...

$ git commit -am 'Add crypto library'
[add-crypto 4445836] Add crypto library
 2 files changed, 4 insertions(+)
 create mode 160000 CryptoLibrary

$ git checkout --recurse-submodules master
Switched to branch 'master'
Your branch is up-to-date with 'origin/master'.

$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

nothing to commit, working tree clean</code></pre>
</div>
</div>
<div class="paragraph">
<p>Uporaba zastavice <code>--recurse-submodules</code> ukaza <code>git checkout</code> lahko prav tako pride prav, ko delate na več vejah v nadrejenem projektu in ima vsaka vaš podmodul usmerjen na različne potrditve.
Če torej preklopite med vejami, ki beležijo podmodul na različnih potrditvah, se bo ob izvajanju ukaza <code>git status</code> podmodul pojavil kot »spremenjen« (angl. <em>modified</em>) in bo označeval »nove potrditve« (angl. <em>new commits</em>).
To je zato, ker privzeto stanje podmodula ni preneseno med preklopi vej.</p>
</div>
<div class="paragraph">
<p>To vas lahko zelo zmede, zato je vedno dobra ideja, da uporabite <code>git checkout --recurse-submodules</code>, kadar vaš projekt vsebuje podmodule.
Za starejše različice Git, ki nimajo zastavice <code>--recurse-submodules</code>, lahko po izvleku uporabite <code>git submodule update --init --recursive</code>, da postavite podmodule v pravilno stanje.</p>
</div>
<div class="paragraph">
<p>Na srečo lahko Git (&gt;=2.14) vedno uporablja zastavico <code>--recurse-submodules</code>, če nastavite konfiguracijsko možnost <code>submodule.recurse</code>: <code>git config submodule.recurse true</code>.
Kot je omenjeno zgoraj, bo to povzročilo, da se bo Git ponovno pogreznil v podmodule za vsak ukaz, ki ima možnost <code>--recurse-submodules</code> (razen <code>git clone</code>).</p>
</div>
</div>
<div class="sect4">
<h4 id="_prehod_iz_podimenikov_v_podmodule">Prehod iz podimenikov v podmodule</h4>
<div class="paragraph">
<p>Druga velika težava, s katero se srečuje veliko ljudi, se nanaša na prehajanje iz podimenikov v podmodule.
Če ste spremljali datoteke v svojem projektu in jih želite premakniti v podmodul, morate biti previdni, saj vam Git ne bo naklonjen.
Predpostavimo, da imate datoteke v podmapi svojega projekta in jih želite preklopiti v podmodul.
Če izbrišete podmapo in nato zaženete <code>submodule add</code>, vam Git javi napako:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ rm -Rf CryptoLibrary/
$ git submodule add https://github.com/chaconinc/CryptoLibrary
'CryptoLibrary' already exists in the index</code></pre>
</div>
</div>
<div class="paragraph">
<p>Direktorij <code>CryptoLibrary</code> morate najprej odstraniti iz področja priprave.
Nato lahko dodate podmodul:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rm -r CryptoLibrary
$ git submodule add https://github.com/chaconinc/CryptoLibrary
Cloning into 'CryptoLibrary'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Recimo, da ste to storili v veji.
Če poskušate preklopiti nazaj v vejo, kjer so te datoteke še vedno v dejanskem drevesu namesto v podmodulu, boste prejeli to napako:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
error: The following untracked working tree files would be overwritten by checkout:
  CryptoLibrary/Makefile
  CryptoLibrary/includes/crypto.h
  ...
Please move or remove them before you can switch branches.
Aborting</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spremembo lahko prisilite s <code>checkout -f</code>, vendar bodite previdni, da v tej mapi nimate neshranjenih sprememb, saj bi jih lahko ta ukaz prepisal.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -f master
warning: unable to rmdir CryptoLibrary: Directory not empty
Switched to branch 'master'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nato, ko se vrnete nazaj, boste iz neznanega razloga dobili prazno mapo <code>CryptoLibrary</code> in tudi <code>git submodule update</code> morda ne bo pomagal.
Morda boste morali iti v podmapo podmodula in zagnati <code>git checkout .</code>, da dobite vse datoteke nazaj.
To lahko za več podmodulov zaženete v skriptu <code>submodule foreach</code>.</p>
</div>
<div class="paragraph">
<p>Pomembno je opozoriti, da podmoduli dandanes ohranjajo vse svoje podatke Git v direktoriju <code>.git</code> glavnega projekta, tako da v primerjavi z veliko starejšimi različicami Git izbris podmodula ne bo izgubil nobenih oddanih potrditev ali vej.</p>
</div>
<div class="paragraph">
<p>Z uporabo teh orodij lahko podmoduli predstavljajo precej preprost in učinkovit način za razvoj več povezanih, a še vedno ločenih projektov hkrati.</p>
</div>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>