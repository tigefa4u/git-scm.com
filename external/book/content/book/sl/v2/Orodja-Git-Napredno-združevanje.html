---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: sl
  chapter:
    title: Orodja Git
    number: 7
  section:
    title: Napredno združevanje
    number: 8
    cs_number: '7.8'
    previous: book/sl/v2/Orodja-Git-Demistifikacija-ponastavitve
    next: book/sl/v2/Orodja-Git-Rerere
title: Git - Napredno združevanje
url: "/book/sl/v2/Orodja-Git-Napredno-združevanje.html"
---
<h2 id="_advanced_merging">Napredno združevanje</h2>
<div class="paragraph">
<p>Združevanje v Gitu je običajno precej enostavno.
Ker Git omogoča večkratno združevanje druge veje, imate lahko zelo dolgotrajno vejo, vendar jo lahko vzdržujete tako, da pogosto rešujete majhne konflikte, namesto da vas na koncu preseneti ogromen konflikt.</p>
</div>
<div class="paragraph">
<p>Vendar včasih se pojavijo zapleteni konflikti.
V primerjavi z nekaterimi drugimi sistemi za upravljanje različic, Git ne poskuša biti preveč pameten pri reševanju konfliktov združevanja.
Gitova filozofija je, da je pameten pri določanju, kdaj je združevanje nedvoumno, vendar če obstaja konflikt, ga ne poskuša avtomatsko rešiti.
Zato se lahko srečate s težavami, če predolgo čakate na združevanje dveh hitro razhajajočih se vej.</p>
</div>
<div class="paragraph">
<p>V tem razdelku bomo pregledali nekatere od teh težav in orodja, ki jih Git ponuja za pomoč pri reševanju teh bolj zapletenih situacij.
Pokrili bomo tudi nekatere različne, nestandardne vrste združevanja ter videli, kako se lahko umaknemo iz opravljenih združevanj.</p>
</div>
<div class="sect3">
<h3 id="_konflikti_združevanja">Konflikti združevanja</h3>
<div class="paragraph">
<p>Medtem ko smo v razdelku <a href="{{< relurl "book/sl/v2/ch00/_basic_merge_conflicts" >}}">Konflikti osnovnega združevanja</a> predstavili nekaj osnov reševanja konfliktov med združevanjem, Git ponuja nekaj orodij za pomoč pri reševanju bolj zapletenih konfliktov.</p>
</div>
<div class="paragraph">
<p>Preden opravite združevanje, ki bi lahko povzročilo konflikte, poskusite najprej poskrbeti, da je delovni imenik čist.
Če imate delo v teku, ga shranite v začasno vejo, ali pa ga dajte v shrambo na varno (angl. <em>stash</em>).
Tako lahko razveljavite <strong>karkoli</strong>, kar tukaj poskušate.
Če imate v delovnem imeniku neshranjene spremembe, ko poskusite združevati, vam lahko nekaj teh nasvetov pomaga pri ohranjanju tega dela.</p>
</div>
<div class="paragraph">
<p>Pojdimo skozi zelo preprost primer.
Imamo zelo preprosto datoteko Ruby, ki izpiše <code>hello world</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
  puts 'hello world'
end

hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>V svojem repozitoriju ustvarimo novo vejo, imenovano <code>whitespace</code> in nadaljujemo s spreminjanjem vseh končnic vrstic Unix v končnice vrstic DOS, torej dejansko spremenimo vsako vrstico datoteke, vendar le s praznimi znaki.
Nato spremenimo vrstico »hello world« v »hello mundo«.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git checkout -b whitespace
Switched to a new branch 'whitespace'

$ unix2dos hello.rb
unix2dos: converting file hello.rb to DOS format ...
$ git commit -am 'Convert hello.rb to DOS'
[whitespace 3270f76] Convert hello.rb to DOS
 1 file changed, 7 insertions(+), 7 deletions(-)

$ vim hello.rb
$ git diff -b
diff --git a/hello.rb b/hello.rb
index ac51efd..e85207e 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,7 @@
 #! /usr/bin/env ruby

 def hello
-  puts 'hello world'
+  puts 'hello mundo'^M
 end

 hello()

$ git commit -am 'Use Spanish instead of English'
[whitespace 6d338d2] Use Spanish instead of English
 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sedaj preklopimo nazaj na našo vejo <code>master</code> in dodamo nekaj dokumentacije za funkcijo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git checkout master
Switched to branch 'master'

$ vim hello.rb
$ git diff
diff --git a/hello.rb b/hello.rb
index ac51efd..36c06c8 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello world'
 end

$ git commit -am 'Add comment documenting the function'
[master bec6336] Add comment documenting the function
 1 file changed, 1 insertion(+)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sedaj poskusimo združiti v našo vejo <code>whitespace</code> in dobimo konflikte zaradi sprememb praznih znakov.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git merge whitespace
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="sect4">
<h4 id="_abort_merge">Prekinitev združevanja</h4>
<div class="paragraph">
<p>Zdaj imamo nekaj možnosti.
Najprej se pogovorimo, kako iz te situacije priti ven.
Če niste pričakovali konfliktov in se z njimi ne želite spopasti, lahko preprosto razveljavite združevanje z <code>git merge --abort</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git status -sb
## master
UU hello.rb

$ git merge --abort

$ git status -sb
## master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Možnost <code>git merge --abort</code> poskuša vrniti vaše stanje na tisto pred zagonom združevanja.
Edini primeri, ko morda ne bo mogla tega storiti popolnoma, so, če ste imeli ob zagonu neshranjene in nepotrjene spremembe v delovnem imeniku, sicer bi moralo delovati v redu.</p>
</div>
<div class="paragraph">
<p>Če želite iz nekega razloga preprosto začeti znova, lahko zaženete tudi <code>git reset --hard HEAD</code> in vaš repozitorij se bo vrnil v zadnje potrjeno stanje.
Ne pozabite, da bodo izgubljene vse nepotrjene spremembe, zato preverite, da ne želite ohraniti nobenih sprememb.</p>
</div>
</div>
<div class="sect4">
<h4 id="_ignoriranje_praznih_znakov">Ignoriranje praznih znakov</h4>
<div class="paragraph">
<p>V tem konkretnem primeru so konflikti povezani s praznimi znaki.
To vemo, ker je primer preprost, a je tudi v resničnih primerih precej enostavno ugotoviti, ko gledamo konflikt, saj je na eni strani odstranjena vsaka vrstica in na drugi strani spet dodana.
Privzeto Git vidi vse te vrstice kot spremembe, zato datoteke ne more združiti.</p>
</div>
<div class="paragraph">
<p>Privzeta strategija združevanja lahko sprejme tudi argumente, nekaj med njimi pa se jih nanaša na ustrezno ignoriranje sprememb praznih znakov.
Če ugotovite, da imate v združevanju veliko težav s praznimi znaki, ga lahko preprosto prekinete in ga ponovno zaženete, tokrat z uporabo <code>-Xignore-all-space</code> ali <code>-Xignore-space-change</code>.
Prva možnost <strong>povsem</strong> ignorira prazne znake pri primerjanju vrstic, druga pa obravnava zaporedja enega ali več praznih znakov kot enakovredna.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge -Xignore-space-change whitespace
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ker v tem primeru dejanske spremembe datoteke niso konfliktne, ko enkrat prezremo spremembe praznih znakov, se vse združi brez težav.</p>
</div>
<div class="paragraph">
<p>To je rešitelj življenj, če imate na svoji ekipi nekoga, ki rad občasno preoblikuje vse iz presledkov v tabulatorje ali obratno.</p>
</div>
</div>
<div class="sect4">
<h4 id="_manual_remerge">Ročno ponovno združevanje datotek</h4>
<div class="paragraph">
<p>Čeprav se Git dobro spopada s predobdelavo praznih znakov, obstajajo drugi tipi sprememb, ki jih morda Git ne more samodejno obdelati, vendar so pa skriptni popravki.
Kot primer si predstavljamo, da Git ni mogel obdelati spremembe praznih znakov in jo moramo opraviti ročno.</p>
</div>
<div class="paragraph">
<p>Tisto, kar resnično potrebujemo, je, da datoteko, ki jo želimo združiti, poženemo skozi program <code>dos2unix</code>, preden poskusimo dejansko združitev datoteke.
Kako bi to storili?</p>
</div>
<div class="paragraph">
<p>Najprej se znajdemo v stanju konflikta združevanja.
Nato želimo dobiti kopije svoje različice datoteke, njihove različice (iz veje, ki jo združujemo) in skupne različice (od koder sta se obe strani odcepili).
Nato želimo popraviti bodisi njihovo stran bodisi svojo stran in ponovno poskusimo združiti samo to eno datoteko.</p>
</div>
<div class="paragraph">
<p>Dobivanje treh različic datoteke je dejansko precej enostavno.
Git vse te različice shrani v indeksu pod »stopnjami«, kjer ima vsaka številko povezano z njo.
Stopnja 1 je skupni prednik, stopnja 2 je vaša različica in stopnja 3 je iz <code>MERGE_HEAD</code>, različica, ki jo združujete (»theirs«).</p>
</div>
<div class="paragraph">
<p>Kopijo vsake od teh različic konfliktne datoteke lahko izvlečete s pomočjo ukaza <code>git show</code> in posebne sintakse.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show :1:hello.rb &gt; hello.common.rb
$ git show :2:hello.rb &gt; hello.ours.rb
$ git show :3:hello.rb &gt; hello.theirs.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Če želite biti malo bolj hard core, lahko uporabite ukaz <code>ls-files -u</code>, da dobite dejanske vrednosti SHA-1 blobov Git za vsako od teh datotek.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git ls-files -u
100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1	hello.rb
100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2	hello.rb
100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3	hello.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>:1:hello.rb</code> je samo bližnjica za iskanje tega bloba SHA-1.</p>
</div>
<div class="paragraph">
<p>Sedaj, ko imamo vsebine vseh treh stopenj v svojem delovnem imeniku, lahko njihovo težavo praznih znakov ročno popravimo in poskusimo ponovno združiti datoteko z manj znanim ukazom <code>git merge-file</code>, ki počne ravno to.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ dos2unix hello.theirs.rb
dos2unix: converting file hello.theirs.rb to Unix format ...

$ git merge-file -p \
    hello.ours.rb hello.common.rb hello.theirs.rb &gt; hello.rb

$ git diff -b
diff --cc hello.rb
index 36c06c8,e85207e..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,8 -1,7 +1,8 @@@
  #! /usr/bin/env ruby

 +# prints out a greeting
  def hello
-   puts 'hello world'
+   puts 'hello mundo'
  end

  hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>V tem trenutku smo lepo združili datoteko.
Pravzaprav to deluje bolje kot možnost <code>ignore-space-change</code>, saj dejansko popravi spremembe praznih znakov pred združitvijo, namesto da jih preprosto ignorira.
Pri združitvi z možnostjo <code>ignore-space-change</code> smo dejansko dobili nekaj vrstic s koncem vrstice DOS, kar je povzročilo zmedo.</p>
</div>
<div class="paragraph">
<p>Če želite pred dokončanjem te potrditve dobiti idejo o tem, kaj se je dejansko spremenilo med enim ali drugim delom, lahko uporabite ukaz <code>git diff</code>, da primerjate, kaj je v vašem delovnem direktoriju, ki ga želite potrditi kot rezultat združitve na katerokoli od teh stopenj.
Pojdi skozi vse.</p>
</div>
<div class="paragraph">
<p>Da primerjate svoj rezultat s tistim, kar ste imeli v svoji veji pred združitvijo, z drugimi besedami, da vidite, kaj je združitev uvedla, lahko zaženete <code>git diff --ours</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git diff --ours
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index 36c06c8..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -2,7 +2,7 @@

 # prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tukaj lahko jasno vidimo, da se je v naši veji spremenila samo ta ena vrstica in to vnesemo v to datoteko z združevanjem.</p>
</div>
<div class="paragraph">
<p>Če želimo videti, kako se je rezultat združevanja razlikoval od tistega, kar je bilo na njihovi strani, lahko zaženemo <code>git diff --theirs</code>.
V tem in naslednjem primeru moramo uporabiti <code>-b</code>, da odstranimo prazne znake, ker primerjamo s tem, kar je v Gitu in ne z našo očiščeno datoteko <code>hello.theirs.rb</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git diff --theirs -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index e85207e..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello mundo'
 end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Na koncu lahko z <code>git diff --base</code> vidite, kako se je datoteka spremenila iz obeh strani.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git diff --base -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index ac51efd..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,8 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>V tem trenutku lahko uporabimo ukaz <code>git clean</code>, da počistimo dodatne datoteke, ki smo jih ustvarili pri ročnem združevanju in jih ne potrebujemo več.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clean -f
Removing hello.common.rb
Removing hello.ours.rb
Removing hello.theirs.rb</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_checking_out_conflicts">Preverjanje konfliktov</h4>
<div class="paragraph">
<p>Morda iz nekega razloga nismo zadovoljni z rešitvijo v tem trenutku, ali pa je morda ročno urejanje ene ali obeh strani še vedno slabo delovalo in potrebujemo več konteksta.</p>
</div>
<div class="paragraph">
<p>Naj malo spremenimo primer.
V tem primeru imamo dve dolgotrajni veji, kjer ima vsaka od njiju nekaj potrditev, vendar ob združevanju ustvarita legitimni konflikt vsebine.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --graph --oneline --decorate --all
* f1270f7 (HEAD, master) Update README
* 9af9d3b Create README
* 694971d Update phrase to 'hola world'
| * e3eb223 (mundo) Add more tests
| * 7cff591 Create initial testing script
| * c3ffff1 Change text to 'hello mundo'
|/
* b7dcc89 Initial hello world code</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sedaj imamo tri unikatne potrditve, ki se nahajajo samo v veji <code>master</code> ter tri ostale, ki se nahajajo v veji <code>mundo</code>.
Če poskusimo združiti vejo <code>mundo</code>, dobimo konflikt.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Videti bi želeli, za kateri konflikt združevanja gre.
Če odpremo datoteko, bomo videli nekaj takega:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
  puts 'hola world'
=======
  puts 'hello mundo'
&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo
end

hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Obe strani združevanja sta dodali vsebino v to datoteko, vendar nekaj potrditev je spremenilo datoteko na istem mestu, kar je povzročilo ta konflikt.</p>
</div>
<div class="paragraph">
<p>Raziščimo nekaj orodij, ki so vam na voljo, da ugotovite, kako je prišlo do tega konflikta.
Morda ni očitno, kako točno bi ta konflikt morali rešiti.
Potrebujete več konteksta.</p>
</div>
<div class="paragraph">
<p>Eno izmed uporabnih orodij je <code>git checkout</code> z možnostjo <code>--conflict</code>.
To bo ponovno izvleklo datoteko in zamenjalo oznake konfliktov med združevanjem.
To je lahko koristno, če želite ponastaviti oznake in poskusiti znova rešiti konflikte.</p>
</div>
<div class="paragraph">
<p>Možnost <code>--conflict</code> lahko podate <code>diff3</code> ali <code>merge</code> (kar je privzeto).
Če jo podate <code>diff3</code>, bo Git uporabil nekoliko drugačno različico oznak konfliktov, ki vam ne bodo dale samo »naših« in »njihovih« različic, ampak tudi »osnovno« različico, ki vam bo dala več konteksta.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout --conflict=diff3 hello.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ko enkrat to poženemo, bo datoteka videti takole:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; ours
  puts 'hola world'
||||||| base
  puts 'hello world'
=======
  puts 'hello mundo'
&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs
end

hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Če vam je ta oblika ustrezna, jo lahko nastavite kot privzeto za prihodnje konflikte združevanja z nastavitvijo <code>merge.conflictstyle</code> pri <code>diff3</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global merge.conflictstyle diff3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ukaz <code>git checkout</code> lahko uporabimo tudi z možnostima <code>--ours</code> in <code>--theirs</code>, kar je zelo hiter način izbire samo ene strani brez združevanja.</p>
</div>
<div class="paragraph">
<p>To je lahko posebej uporabno za konflikte binarnih datotek, kjer lahko preprosto izberete eno stran, ali pa za združevanje določenih datotek iz druge veje — izvedete lahko združevanje in nato preprosto izvlečete določene datoteke z ene strani ali druge, preden izvedete potrditev.</p>
</div>
</div>
<div class="sect4">
<h4 id="_merge_log">Dnevnik združevanja</h4>
<div class="paragraph">
<p>Drugo uporabno orodje pri reševanju konfliktov združevanja je <code>git log</code>.
To vam lahko pomaga dobiti kontekst o tem, kaj je lahko prispevalo h konfliktom.
Včasih lahko zelo pomaga pregledati nekaj zgodovine, da se spomnite, zakaj sta se dve vrstici razvoja dotaknili istega dela kode.</p>
</div>
<div class="paragraph">
<p>Če želimo dobiti popoln seznam vseh edinstvenih potrditev, ki so bile vključene v katerokoli vejo, ki sodeluje pri tem združevanju, lahko uporabimo sintakso »trojne pike«, ki smo se je naučili v <a href="{{< relurl "book/sl/v2/ch00/_triple_dot" >}}">Trojna pika</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git log --oneline --left-right HEAD...MERGE_HEAD
&lt; f1270f7 Update README
&lt; 9af9d3b Create README
&lt; 694971d Update phrase to 'hola world'
&gt; e3eb223 Add more tests
&gt; 7cff591 Create initial testing script
&gt; c3ffff1 Change text to 'hello mundo'</code></pre>
</div>
</div>
<div class="paragraph">
<p>To je dober seznam šestih vključenih skupnih potrditev, kot tudi na kateri vrsti razvoja je bila vsaka od teh potrditev.</p>
</div>
<div class="paragraph">
<p>To lahko še bolj poenostavimo, da dobimo natančnejši kontekst.
Če dodamo ukazu <code>git log</code> možnost <code>--merge</code>, bo prikazal samo tiste potrditve na vsaki strani združevanja, ki se dotikajo datoteke, ki je trenutno v konfliktu.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git log --oneline --left-right --merge
&lt; 694971d Update phrase to 'hola world'
&gt; c3ffff1 Change text to 'hello mundo'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Če to zaženete z možnostjo <code>-p</code>, dobite samo razlike v datoteki, ki so povzročile konflikt.
To lahko zelo pomaga, saj vam hitro zagotovi kontekst, ki ga potrebujete, da razumete, zakaj je nekaj v konfliktu in kako ga bolj inteligentno rešiti.</p>
</div>
</div>
<div class="sect4">
<h4 id="_kombinirana_oblika_razlike">Kombinirana oblika razlike</h4>
<div class="paragraph">
<p>Ker Git osnuje vsako uspešno združitev, ko se izvaja ukaz <code>git diff</code> v stanju konflikta združevanja, se prikaže samo tisto, kar je trenutno še vedno v konfliktu.
To lahko pomaga pri ogledu tega, kar morate še rešiti.</p>
</div>
<div class="paragraph">
<p>Ko zaženete <code>git diff</code> neposredno po konfliktnem združevanju, vam bo dala informacije v dokaj edinstveni obliki izpisa diff.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,11 @@@
  #! /usr/bin/env ruby

  def hello
++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
 +  puts 'hola world'
++=======
+   puts 'hello mundo'
++&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo
  end

  hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Format imenovan »Combined Diff« vam da dva stolpca podatkov poleg vsake vrstice.
Prvi stolpec vam pokaže, ali je ta vrstica drugačna (dodana ali odstranjena) med vejo »ours« in datoteko v vašem delovnem imeniku, drugi stolpec pa naredi enako med vejo »theirs« in kopijo vašega delovnega imenika.</p>
</div>
<div class="paragraph">
<p>Tako lahko v tem primeru vidite, da sta vrstici <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> in <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> v delovni kopiji, vendar nista bili na nobeni strani združitve.
To ima smisel, saj jih je orodje za združevanje tam postavilo za naš kontekst, pričakuje pa se, da jih bomo odstranili.</p>
</div>
<div class="paragraph">
<p>Če rešimo konflikt in znova zaženemo <code>git diff</code>, bomo videli isto stvar, vendar je to nekoliko bolj uporabno.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ vim hello.rb
$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>To bi nam pokazalo, da je »hola world« obstajal v naši veji vendar ne v delovni kopiji, »hello mundo« je obstajal v njihovi veji vendar ne v delovni kopiji in »hola mundo« ni obstajal v nobeni veji, vendar je sedaj v delovni kopiji.
To lahko pomaga pri pregledu pred potrditvijo rešitve.</p>
</div>
<div class="paragraph">
<p>To lahko dobite tudi iz <code>git log</code> za vsako združitev, da vidite, kako je bila neka težava v resnici rešena.
Git bo izpisal to obliko, če na potrditvi združitve zaženete <code>git show</code>, ali pa če dodate možnost <code>--cc</code> h <code>git log -p</code> (ki privzeto prikazuje popravke samo za potrditve nezdružitev).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git log --cc -p -1
commit 14f41939956d80b9e17bb8721354c33f8d5b5a79
Merge: f1270f7 e3eb223
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Sep 19 18:14:49 2014 +0200

    Merge branch 'mundo'

    Conflicts:
        hello.rb

diff --cc hello.rb
index 0399cd5,59727f0..e1d0799
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_undoing_merges">Razveljavitev združitev</h3>
<div class="paragraph">
<p>Ko sedaj znate ustvariti potrditev združitve, jih boste verjetno naredili nekaj po pomoti.
Ena izmed dobrih stvari pri delu z Gitom je, da je v redu narediti napake, saj jih je mogoče (in v mnogih primerih enostavno) popraviti.</p>
</div>
<div class="paragraph">
<p>Potrditve združitev niso nič drugačne.
Recimo, da ste začeli delati na tematski veji, jo po nesreči združili v <code>master</code> in zdaj je vaša zgodovina potrditev videti takole:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/sl/v2/images/undomerge-start.png" >}}" alt="Nenamerna potrditev združitve">
</div>
<div class="title">Slika 155. Nenamerna potrditev združitve</div>
</div>
<div class="paragraph">
<p>Na voljo sta dva načina za pristop k temu problemu, odvisno od tega, kaj je vaš željeni izid.</p>
</div>
<div class="sect4">
<h4 id="_popravek_referenc">Popravek referenc</h4>
<div class="paragraph">
<p>Če je neželena potrditev združitve prisotna samo v vašem lokalnem repozitoriju, je najlažja in najboljša rešitev premik vej tako, da kažejo, kamor jih želite.
V večini primerov bo sledenje nepravilnemu ukazu <code>git merge</code> z <code>git reset --hard HEAD~</code> ponastavilo kazalnike vej, tako da bodo videti takole:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/sl/v2/images/undomerge-reset.png" >}}" alt="Zgodovina po `git reset --hard HEAD~`">
</div>
<div class="title">Slika 156. Zgodovina po <code>git reset --hard HEAD~</code>
</div>
</div>
<div class="paragraph">
<p><code>reset</code> smo pokrili v razdelku <a href="{{< relurl "book/sl/v2/ch00/_git_reset" >}}">Demistifikacija ponastavitve</a>, zato ne bi smelo biti pretežko razumeti, kaj se tu dogaja.
Tukaj je hitra osvežitev: <code>reset --hard</code> običajno opravi tri korake:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Premakne kazalec HEAD veje.
V tem primeru želimo premakniti <code>master</code> tja, kjer je bila pred potrditvijo združitve (<code>C6</code>).</p>
</li>
<li>
<p>Naredi, da je indeks videti kot HEAD.</p>
</li>
<li>
<p>Naredi, da je delovni imenik videti kot indeks.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Slaba stran tega pristopa je, da se prepisuje zgodovina, kar lahko predstavlja težave z deljenim repozitorijem.
Preverite <a href="{{< relurl "book/sl/v2/ch00/_rebase_peril" >}}">Nevarnosti ponovnega baziranja</a> za več o tem, kaj se lahko zgodi; na kratko, če imajo druge osebe potrditve, ki jih prepisujete, se je treba izogibati uporabi <code>reset</code>.
Ta pristop prav tako ne bo deloval, če so bile ustvarjene druge potrditve od časa združitve; premikanje referenc bi dejansko izgubilo te spremembe.</p>
</div>
</div>
<div class="sect4">
<h4 id="_reverse_commit">Preklicane potrditve</h4>
<div class="paragraph">
<p>Če vam premikanje kazalcev vej ne bo delovalo, vam Git omogoča možnost ustvarjanja nove potrditve, ki razveljavi vse spremembe obstoječe.
Git to operacijo imenuje »revert« in v tem posebnem scenariju bi to sprožili takole:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git revert -m 1 HEAD
[master b1d8379] Revert "Merge branch 'topic'"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Zastavica <code>-m 1</code> kaže na to, da je nadrejeni »mainline« in bi se moral obdržati.
Ko kličete združitev v <code>HEAD</code> (<code>git merge topic</code>), ima nova potrditev dve nadrejeni: prva je <code>HEAD</code> (<code>C6</code>), druga pa vrh veje, ki se združuje (<code>C4</code>).
V tem primeru želimo razveljaviti vse spremembe, ki jih je uvedla združitev druge nadrejene (<code>C4</code>), hkrati pa ohraniti vsebino nadrejene #1 (<code>C6</code>).</p>
</div>
<div class="paragraph">
<p>Zgodovina s preklicano potrditvijo združitve je videti tako:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/sl/v2/images/undomerge-revert.png" >}}" alt="Zgodovina po `git revert -m 1`">
</div>
<div class="title">Slika 157. Zgodovina po <code>git revert -m 1</code>
</div>
</div>
<div class="paragraph">
<p>Nova potrditev <code>^M</code> ima enake vsebine kot <code>C6</code>, zato je od tu dalje, kot da se združitev ni nikoli zgodila, razen, da so zdaj nezdružene potrditve še vedno v zgodovini <code>HEAD</code>.
Git bo zmeden, če boste poskusili znova združiti <code>topic</code> v <code>master</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge topic
Already up-to-date.</code></pre>
</div>
</div>
<div class="paragraph">
<p>V <code>topic</code> ni ničesar, kar ne bi bilo že dosegljivo iz <code>master</code>.
Kar je še huje, če dodate delo v <code>topic</code> in znova združite, bo Git prinesel samo spremembe <em>od</em> razveljavitve združitve:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/sl/v2/images/undomerge-revert2.png" >}}" alt="Zgodovina s slabo združitvijo">
</div>
<div class="title">Slika 158. Zgodovina s slabo združitvijo</div>
</div>
<div class="paragraph">
<p>Najboljši način za rešitev tega problema je razveljavitev prvotne združitve, saj želite zdaj uvoziti spremembe, ki so bile razveljavljene, in nato ustvariti novo potrditev združitve:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git revert ^M
[master 09f0126] Revert "Revert "Merge branch 'topic'""
$ git merge topic</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/sl/v2/images/undomerge-revert3.png" >}}" alt="Zgodovina po ponovni združitvi preklicane združitve">
</div>
<div class="title">Slika 159. Zgodovina po ponovni združitvi preklicane združitve</div>
</div>
<div class="paragraph">
<p>V tem primeru sta <code>^M</code> in <code>^M</code> preklicana.
<code>^^M</code> se učinkovito združi v spremembe iz <code>C3</code> in <code>C4</code> ter <code>C8</code> se združi v spremembe iz <code>C7</code>, tako da je sedaj veja <code>topic</code> polno združena.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_druge_vrste_združitev">Druge vrste združitev</h3>
<div class="paragraph">
<p>Do sedaj smo pogledali običajno združitev dveh vej, kar se ponavadi izvede s t. i. »rekurzivno« strategijo združevanja.
Vendar pa obstajajo še drugi načini združevanja vej skupaj.
Poglejmo na hitro nekaj od njih.</p>
</div>
<div class="sect4">
<h4 id="_naša_ali_njihova_želja">Naša ali njihova želja</h4>
<div class="paragraph">
<p>Najprej imamo na voljo še eno uporabno funkcionalnost normalnega »rekurzivnega« načina združevanja vej.
Videli smo že možnosti <code>ignore-all-space</code> in <code>ignore-space-change</code>, ki se podajata s parametrom <code>-X</code>, lahko pa Gitu tudi povemo, naj v primeru konflikta raje izbere eno ali drugo stran.</p>
</div>
<div class="paragraph">
<p>Privzeto Git, ko naleti na konflikt med dvema vejama, ki ju poskuša združiti, v kodo doda oznake konflikta ter datoteko označi kot konfliktno, da lahko uporabnik konflikt reši ročno.
Če bi raje, da Git izbere določeno stran in ignorira drugo stran, namesto da bi ročno reševali konflikt, lahko ukazu <code>merge</code> podate <code>-Xours</code> ali <code>-Xtheirs</code>.</p>
</div>
<div class="paragraph">
<p>Če Git to zazna, ne bo dodal oznak konflikta.
Vse razlike, ki so združljive, jih bo združil.
Vse razlike, ki se konfliktno prekrivajo, bo preprosto izbral celotno stran, ki ste jo določili, vključno z binarnimi datotekami.</p>
</div>
<div class="paragraph">
<p>Če se vrnemo na primer »hello world«, ki smo ga uporabljali prej, lahko vidimo, da združitev naše veje povzroči konflikt.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved 'hello.rb' using previous resolution.
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Vendar, če ga zaženemo z <code>-Xours</code> ali <code>-Xtheirs</code>, se to ne zgodi.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge -Xours mundo
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 test.sh  | 2 ++
 2 files changed, 3 insertions(+), 1 deletion(-)
 create mode 100644 test.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>V tem primeru namesto tega, da bi dobili oznake za konflikt v datoteki s »hello mundo« na eni strani in »hola world« na drugi, bo preprosto izbral »hola world«.
Vendar pa so vse druge nekonfliktne spremembe na tisti veji uspešno združene.</p>
</div>
<div class="paragraph">
<p>Ta možnost se lahko poda tudi ukazu <code>git merge-file</code>, ki smo ga videli prej, tako da za posamezne združitve datotek zaženete nekaj podobnega kot <code>git merge-file --ours</code>.</p>
</div>
<div class="paragraph">
<p>Če želite narediti nekaj takega, vendar ne želite, da Git poskuša združiti sprememb iz druge strani, obstaja še bolj stroga možnost, kar je združitvena <em>strategija</em> »ours«.
To je drugačno od možnosti rekurzivnega združevanja »ours«.</p>
</div>
<div class="paragraph">
<p>To bo v bistvu naredilo ponarejeno združevanje.
Posnelo bo novo potrditev združitve z obema vejama kot nadrejeno, vendar ne bo niti pogledalo veje, ki jo združujete.
Za rezultat združitve bo preprosto posnelo natančno kodo na vaši trenutni veji.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge -s ours mundo
Merge made by the 'ours' strategy.
$ git diff HEAD HEAD~
$</code></pre>
</div>
</div>
<div class="paragraph">
<p>Vidite, da ni razlike med vejo, na kateri smo bili, in rezultatom združevanja.</p>
</div>
<div class="paragraph">
<p>To je lahko pogosto uporabno, da preprosto prevarate Git, da misli, da je veja že združena, ko pozneje izvajate združevanje.
Na primer, recimo, da ste razvejali vejo <code>release</code> in na njej opravili nekaj dela, ki ga boste nekega dne želeli združiti nazaj v svojo vejo <code>master</code>.
V tem času je iz veje <code>master</code> potrebno prenesti nazaj popravek napake na vejo <code>release</code>.
Lahko združite vejo z odpravo napake v vejo <code>release</code> in enako vejo tudi združite z <code>merge -s ours</code> v vašo vejo <code>master</code> (čeprav je popravek že tam), tako da pozneje, ko spet združite vejo <code>release</code>, ni konfliktov zaradi odprave napake.</p>
</div>
</div>
<div class="sect4">
<h4 id="_subtree_merge">Združevanje poddreves (angl. <em>subtree merge</em>)</h4>
<div class="paragraph">
<p>Ideja združevanja poddreves je, da imate dva projekta in eden izmed projektov je preslikan v poddirektorij drugega.
Ko določite združitev poddreves, je Git pogostokrat dovolj pameten, da ugotovi, da je eno poddrevo drugega in ju ustrezno združi.</p>
</div>
<div class="paragraph">
<p>Šli bomo skozi primer dodajanja ločenega projekta v obstoječi projekt in nato združili kodo drugega v poddirektorij prvega.</p>
</div>
<div class="paragraph">
<p>Najprej bomo v svoj projekt dodali aplikacijo Rack.
Dodali bomo projekt Rack kot oddaljeno referenco v svojem lastnem projektu in ga nato izvlekli v svojo lastno vejo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git remote add rack_remote https://github.com/rack/rack
$ git fetch rack_remote --no-tags
warning: no common commits
remote: Counting objects: 3184, done.
remote: Compressing objects: 100% (1465/1465), done.
remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.
Resolving deltas: 100% (1952/1952), done.
From https://github.com/rack/rack
 * [new branch]      build      -&gt; rack_remote/build
 * [new branch]      master     -&gt; rack_remote/master
 * [new branch]      rack-0.4   -&gt; rack_remote/rack-0.4
 * [new branch]      rack-0.9   -&gt; rack_remote/rack-0.9
$ git checkout -b rack_branch rack_remote/master
Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.
Switched to a new branch "rack_branch"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sedaj imamo vrh projekta Rack v naši veji <code>rack_branch</code> in naš lastni projekt v veji <code>master</code>.
Če izpišete enega in nato drugega, lahko vidite, da imata različna vrha projektov:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ls
AUTHORS         KNOWN-ISSUES   Rakefile      contrib         lib
COPYING         README         bin           example         test
$ git checkout master
Switched to branch "master"
$ ls
README</code></pre>
</div>
</div>
<div class="paragraph">
<p>To je nekako čudna zasnova.
Ni potrebno, da so vse veje v vašem repozitoriju dejansko veje istega projekta.
Ni pogosto, saj je redkokdaj koristno, vendar je precej enostavno imeti veje, ki vsebujejo popolnoma različne zgodovine.</p>
</div>
<div class="paragraph">
<p>V tem primeru želimo povleči projekt Rack v naš projekt <code>master</code> kot poddirektorij.
To lahko naredimo v Gitu z <code>git read-tree</code>.
Več o <code>read-tree</code> in njegovih prijateljih se boste naučili v <a href="{{< relurl "book/sl/v2/ch00/ch10-git-internals" >}}">Notranjost Gita</a>, vendar za sedaj vedite, da prebere vrh drevesa ene veje v vaše trenutno področje priprave in delovni direktorij.
Smo ravno preklopili nazaj na vašo vejo <code>master</code> in povlečemo vejo <code>rack_branch</code> v poddirektorij <code>rack</code> naše veje <code>master</code> našega glavnega projekta:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git read-tree --prefix=rack/ -u rack_branch</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ko naredimo potrditev, je videti, kot da imamo vse datoteke Rack pod tem poddirektorijem — kakor da bi jih kopirali iz stisnjega arhiva tar (angl. <em>tarball</em>).
Kar postane zanimivo, je, da lahko precej enostavno združimo spremembe iz ene veje v drugo.
Torej, če se projekt Rack posodobi, lahko povlečemo zgornje spremembe s preklopom na tisto vejo in povlekom:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout rack_branch
$ git pull</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nato lahko združimo te spremembe nazaj v našo vejo <code>master</code>.
Da povlečemo spremembe in vnaprej napolnimo sporočilo potrditve, uporabimo možnost <code>--squash</code> kot tudi rekurzivno združevanje strategije možnosti <code>-Xsubtree</code>.
Rekurzivna strategija je tu privzeta, vendar jo dodajamo zaradi večje jasnosti.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console?prompt=$" data-lang="console?prompt=$">$ git checkout master
$ git merge --squash -s recursive -Xsubtree=rack rack_branch
Squash commit -- not updating HEAD
Automatic merge went well; stopped before committing as requested</code></pre>
</div>
</div>
<div class="paragraph">
<p>Vse spremembe iz projekta Rack so združene in pripravljene za lokalno potrditev.
Lahko naredite tudi nasprotno — naredite spremembe v poddirektoriju <code>rack</code> vaše veje <code>master</code> in jih nato kasneje združite v vašo vejo <code>rack_branch</code>, da jih pošljete vzdrževalcem ali potisnete navzgor.</p>
</div>
<div class="paragraph">
<p>To nam da način, da imamo potek dela, ki je nekako podoben tistemu s podmoduli, le brez uporabe podmudolov (kar bomo pokrili v <a href="{{< relurl "book/sl/v2/ch00/_git_submodules" >}}">Podmoduli</a>).
Obdržimo lahko veje z ostalimi povezanimi projekti v svojem repozitoriju in jih občasno poddrevesno združimo v svoj projekt.
Na neki način je dobro, na primer, da je vsa koda potrjena na enem mestu.
Vendar ima ostale slabosti v tem, da je malo bolj kompleksno in hitro se naredi napake pri ponovnem integriranju sprememb, ali pa se po nesreči potisne veja v nepovezani repozitorij.</p>
</div>
<div class="paragraph">
<p>Druga nekoliko čudna stvar je, da za dobiti razliko med tem, kar imate v vašem poddirektoriju <code>rack</code> in kodi v vaši veji <code>rack_branch</code> — da vidite, če jih morate združiti — ne morete uporabiti običajnega ukaza <code>diff</code>.
Namesto tega morate pognati <code>git diff-tree</code> z vejo, ki jo želite primerjati:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff-tree -p rack_branch</code></pre>
</div>
</div>
<div class="paragraph">
<p>Da primerjate, kaj je v vašem poddirektoriju <code>rack</code> s tem, kakšna je bila veja <code>master</code> na strežniku nazadnje, ko ste prenašali, lahko poženete:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff-tree -p rack_remote/master</code></pre>
</div>
</div>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>