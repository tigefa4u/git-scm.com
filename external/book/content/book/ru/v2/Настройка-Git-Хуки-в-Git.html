---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: ru
  chapter:
    title: Настройка Git
    number: 8
  section:
    title: Хуки в Git
    number: 3
    cs_number: '8.3'
    previous: book/ru/v2/Настройка-Git-Атрибуты-Git
    next: book/ru/v2/Настройка-Git-Пример-принудительной-политики-Git
title: Git - Хуки в Git
url: "/book/ru/v2/Настройка-Git-Хуки-в-Git.html"
---
<h2 id="r_git_hooks">Хуки в Git</h2>
<div class="paragraph">
<p>
Как и многие другие системы контроля версий, Git предоставляет возможность запуска пользовательских скриптов в случае возникновения определённых событий.
Такие действия называются хуками и разделяются на две группы: серверные и клиентские.
Если хуки на стороне клиента запускаются такими операциями как слияние или создание коммита, то на стороне сервера они инициируются сетевыми операциями, такими как получение отправленного коммита.
Хуки часто используются для широкого круга задач.</p>
</div>
<div class="sect3">
<h3 id="_установка_хука">Установка хука</h3>
<div class="paragraph">
<p>Хуки хранятся в подкаталоге <code>hooks</code> относительно основного каталога Git.
Для большинства проектов это <code>.git/hooks</code>.
Когда вы инициализируете новый репозиторий командой <code>git init</code>, Git наполняет каталог <code>hooks</code> примерами скриптов, большинство из которых готовы к использованию, при этом каждый из них содержит документацию по используемым входным данным.
Все примеры представлены в виде шелл скриптов, содержащими код на Perl, но вы можете использовать любой язык для написания скриптов — главное правильно именовать исполняемые файлы.
Если вы решите использовать какой-либо из предустановленных скриптов, то достаточно его просто переименовать, убрав суффикс <code>.sample</code>.</p>
</div>
<div class="paragraph">
<p>Для подключения собственного скрипта достаточно задать ему соответствующее имя, поместить в подкаталог <code>hooks</code> основного каталога Git и сделать его исполняемым.
Далее, мы рассмотрим наиболее часто используемые хуки.</p>
</div>
</div>
<div class="sect3">
<h3 id="_клиентские_хуки">Клиентские Хуки</h3>
<div class="paragraph">
<p>Для клиента существует множество различных хуков.
В этой главе они разделены на хуки уровня коммита, уровня e-mail и прочие.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Примечание</div>
</td>
<td class="content">
<div class="paragraph">
<p>Необходимо отметить, что клиентские хуки <strong>НЕ</strong> копируются при клонировании репозитория.
Если вы намерены использовать такие скрипты для обеспечения соблюдения политики, то вам следует использовать серверные хуки; например <a href="{{< relurl "book/ru/v2/ch00/r_an_example_git_enforced_policy" >}}">Пример принудительной политики Git</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h4 id="_хуки_уровня_коммита">Хуки уровня коммита</h4>
<div class="paragraph">
<p>Первые четыре хука работают во время создания коммитов.</p>
</div>
<div class="paragraph">
<p>Первым запускается <code>pre-commit</code> хук, до того как вы напечатаете сообщение коммита.
Он используется для проверки данных перед созданием коммита и позволяет увидеть если вы что-то забыли, запустить тесты, или выполнить другую необходимую проверку кода.
Создание коммита будет отменено если выполнение хука завершится с кодом отличным от нуля.
Пропустить выполнение хука можно с помощью <code>git commit --no-verify</code>.
С помощью этого хука можно проверять стиль кода (запустить <code>lint</code> или аналог), проверять наличие пробелов в конце строк (именно это делает стандартный хук) или проверять наличие документации для новых методов.</p>
</div>
<div class="paragraph">
<p>Хук <code>prepare-commit-msg</code> запускается до вызова редактора сообщения коммита, но после создания стандартного сообщения.
Это позволяет вам изменить стандартное сообщение коммита до того, как автор коммита увидит его.
Хук принимает несколько параметров: путь к файлу, содержащему сообщение коммита, тип коммита и SHA-1-хеш, если текущий коммит является исправлением существующего.
Для обычных коммитов этот хук бесполезен, однако находит своё применение для коммитов, где сообщение генерируется автоматически, например, для сообщений на основе шаблонов, коммитов слияния, сжимаемых и исправляемых коммитов.
Его можно использовать для программного заполнения шаблона коммита необходимой информацией.</p>
</div>
<div class="paragraph">
<p>Хук <code>commit-msg</code> принимает один параметр — путь к временному файлу, содержащему указанное разработчиком сообщение коммита.
Если скрипт завершается с ненулевым кодом, то Git отменяет создание коммита, поэтому вы можете использовать этот хук для валидации состояния проекта или сообщения коммита до того как он будет создан.
В последнем разделе этой главы мы покажем как использовать этот хук для проверки сообщения коммита на соответствие заданному шаблону.</p>
</div>
<div class="paragraph">
<p>Хук <code>post-commit</code> запускается после того, как коммит создан.
Он не принимает никаких параметров, но вы можете легко получить информацию о последнем коммите выполнив <code>git log -1 HEAD</code>.
Обычно, этот скрипт используется для уведомлений или чего-то подобного.</p>
</div>
</div>
<div class="sect4">
<h4 id="r_email_hooks">Хуки для рабочего процесса на основе E-mail</h4>
<div class="paragraph">
<p>Для рабочего процесса на основе e-mail на стороне клиента можно задать три хука.
Все они вызываются командой <code>git am</code>, поэтому если вы не используете её в своём рабочем процессе, то можете смело перейти к следующему разделу.
Если вы получаете по почте патчи, подготовленные командой <code>git format-patch</code>, то найдёте здесь немного полезной информации.</p>
</div>
<div class="paragraph">
<p>В первую очередь запускается хук <code>applypatch-msg</code>.
Он принимает единственный аргумент: имя временного файла, содержащее предлагаемое сообщение коммита.
Git отменит патч если этот скрипт завершится с ненулевым кодом.
Этот хук можно использовать для проверки формата сообщения или для его нормализации, если ваш скрипт умеет редактировать сообщение коммита.</p>
</div>
<div class="paragraph">
<p>Следующим запускается хук <code>pre-applypatch</code>.
Здесь всё немного запутанно: хук запускается <em>после</em> применения патча, но перед созданием коммита, что позволяет проверить состояние кода до создания коммита.
В этот момент можно запустить тесты или другим способом проверить состояние проекта.
Если что-то пропущено или тесты не пройдены, скрипт должен завершиться с ненулевым кодом, что остановит выполнение команды <code>git am</code>, а коммит не будет создан.</p>
</div>
<div class="paragraph">
<p>Последним запускается хук <code>post-applypatch</code>, который вызывается уже после того как коммит создан.
Вы можете его использовать для уведомления группы или автора патча о его применении.
С помощью этого хука вы не можете прервать процесс применения патча.</p>
</div>
</div>
<div class="sect4">
<h4 id="r_other_client_hooks">Прочие хуки на стороне клиента</h4>
<div class="paragraph">
<p>Хук <code>pre-rebase</code> выполняется при попытке перебазирования и может остановить процесс вернув ненулевой код.
Его можно использовать для запрета перебазирования уже отправленных коммитов.
Git устанавливается с примером такого скрипта, однако он делает некоторые допущения, которые могут не соответствовать вашему рабочему процессу.</p>
</div>
<div class="paragraph">
<p>Хук <code>post-rewrite</code> запускается командами, которые заменяют коммиты: <code>git commit --amend</code> и <code>git rebase</code> (но не <code>git filter-branch</code>).
Его единственный аргумент — команда, которая инициировала перезапись, а список перезаписанных изменений передаётся через <code>stdin</code>.
Его применение практически аналогично хукам <code>post-checkout</code> и <code>post-merge</code>.</p>
</div>
<div class="paragraph">
<p>После успешного выполнения <code>git checkout</code> запускается хук <code>post-checkout</code>; его можно использовать для настройки рабочего каталога в соответствии с требованиями проекта.
Например, перемещение в рабочий каталог больших бинарных файлов, которые не должны отслеживаться, автогенерация документации и тому подобное.</p>
</div>
<div class="paragraph">
<p>Хук <code>post-merge</code> запускается после успешного выполнения команды <code>merge</code>.
Его можно использовать для восстановления данных в рабочем каталоге, которые Git не может отслеживать, такие как права доступа.
Так же этот хук может проверять наличие внешних по отношению к Git файлов, которые вы захотите скопировать при внесении изменений.</p>
</div>
<div class="paragraph">
<p>Хук <code>pre-push</code> выполняется во время работы команды <code>git push</code>: после обновления удалённых ссылок, но до непосредственной отправки данных.
Он принимает название и путь удалённого репозитория как параметры, а список изменений для отправки через <code>stdin</code>.
Его можно использовать для валидации набора изменений до их реальной отправки (ненулевой код отменяет отправку изменений).</p>
</div>
<div class="paragraph">
<p>Время от времени, как часть нормальной работы, Git выполняет сборку мусора вызовом команды <code>git gc --auto</code>.
Хук <code>pre-auto-gc</code> вызывается непосредственно перед выполнением операции сборки мусора и может быть использован для уведомления о её запуске или для её отмены, если сейчас не самое подходящее для этого время.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_хуки_на_сервере">Хуки на сервере</h3>
<div class="paragraph">
<p>В дополнение к хукам на стороне клиента, как системный администратор вы можете использовать несколько важных хуков на сервере для вашего проекта, тем самым обеспечив выполнение практически любой политики.
Эти скрипты выполняются до и после отправки на сервер.
Pre-хуки могут возвращать ненулевой код в любой момент, что отменит передачу и отправит сообщение об ошибке клиенту; таким образом вы можете реализовать сколь угодно сложную политику.</p>
</div>
<div class="sect4">
<h4 id="_pre_receive"><code>pre-receive</code></h4>
<div class="paragraph">
<p>Хук <code>pre-receive</code> запускается первым при старте получения данных от клиента.
Он получает на <code>stdin</code> список отправленных изменений и если завершается ненулевым кодом, то ни одно из них принято не будет.
Этот хук можно использовать для того, чтобы убедиться что все изменения можно применить методом перемотки вперёд, а так же для проверки прав доступа.</p>
</div>
</div>
<div class="sect4">
<h4 id="_update"><code>update</code></h4>
<div class="paragraph">
<p>Хук <code>update</code> очень похож на <code>pre-receive</code>, за исключением того, что он выполняется для каждой ветки, которую отправитель пытается обновить.
Если отправитель пытается отправить изменения в несколько веток, то <code>pre-receive</code> хук будет вызван однократно, а <code>update</code> выполнен для каждой изменяемой ветки.
Вместо чтения из <code>stdin</code>, хук принимает три аргумента: название ссылки (ветка), SHA-1-хеш, на который указывала ссылка до отправки, и SHA-1-хеш коммита, отправляемого пользователем.
Если скрипт завершается ненулевым кодом, то отклоняются все изменения только для текущей ветки, при этом изменения для других веток всё ещё могут быть применены.</p>
</div>
</div>
<div class="sect4">
<h4 id="_post_receive"><code>post-receive</code></h4>
<div class="paragraph">
<p>Хук <code>post-receive</code> вызывается после окончания всего процесса и может быть использован для обновления других сервисов или уведомления пользователей.
Он принимает на <code>stdin</code> те же данные, что и хук <code>pre-receive</code>.
Использовать его можно, например, для e-mail рассылки, для уведомления сервера непрерывной интеграции или обновления системы управления задачами — разобрав сообщение коммита, можно определить необходимость создания, изменения или закрытия каких либо задач.
Этот хук не может прервать процесс, но клиент остаётся подключённым пока он не завершится, поэтому избегайте выполнения длительных операций.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Подсказка</div>
</td>
<td class="content">
<div class="paragraph">
<p>Если вы пишете сценарий/хук, который другие должны будут прочитать, используйте длинные версии параметров командной строки; через шесть месяцев вы будете нас благодарить.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>