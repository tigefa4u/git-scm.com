---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: ru
  chapter:
    title: Ветвление в Git
    number: 3
  section:
    title: Перебазирование
    number: 6
    cs_number: '3.6'
    previous: book/ru/v2/Ветвление-в-Git-Удалённые-ветки
    next: book/ru/v2/Ветвление-в-Git-Заключение
title: Git - Перебазирование
url: "/book/ru/v2/Ветвление-в-Git-Перебазирование.html"
---
<h2 id="r_rebasing">Перебазирование</h2>
<div class="paragraph">
<p>
В Git есть два способа внести изменения из одной ветки в другую: слияние и перебазирование.
В этом разделе вы узнаете, что такое перебазирование, как его осуществлять и в каких случаях этот удивительный инструмент использовать не следует.</p>
</div>
<div class="sect3">
<h3 id="_простейшее_перебазирование">Простейшее перебазирование</h3>
<div class="paragraph">
<p>Если вы вернётесь к более раннему примеру из <a href="{{< relurl "book/ru/v2/ch00/r_basic_merging" >}}">Основы слияния</a>, вы увидите, что разделили свою работу и сделали коммиты в две разные ветки.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ru/v2/images/basic-rebase-1.png" >}}" alt="История коммитов простого разделения">
</div>
<div class="title">Рисунок 35. История коммитов простого разделения</div>
</div>
<div class="paragraph">
<p>Как мы выяснили ранее, простейший способ выполнить слияние двух веток — это команда <code>merge</code>.
Она осуществляет трёхстороннее слияние между двумя последними снимками сливаемых веток (<code>C3</code> и <code>C4</code>) и самого недавнего общего для этих веток родительского снимка (<code>C2</code>), создавая новый снимок (и коммит).</p>
</div>
<div id="r_rebasing-merging-example" class="imageblock">
<div class="content">
<img src="{{< relurl "book/ru/v2/images/basic-rebase-2.png" >}}" alt="Слияние разделённой истории коммитов">
</div>
<div class="title">Рисунок 36. Слияние разделённой истории коммитов</div>
</div>
<div class="paragraph">
<p>Тем не менее есть и другой способ: вы можете взять те изменения, что были представлены в <code>C4</code>, и применить их поверх <code>C3</code>.
В Git это называется <em>перебазированием</em>.
С помощью команды <code>rebase</code> вы можете взять все коммиты из одной ветки и в том же порядке применить их к другой ветке.</p>
</div>
<div class="paragraph">
<p>В данном примере переключимся на ветку <code>experiment</code> и перебазируем её относительно ветки <code>master</code> следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command</code></pre>
</div>
</div>
<div class="paragraph">
<p>Это работает следующим образом: берётся общий родительский снимок двух веток (текущей, и той, поверх которой вы выполняете перебазирование), определяется дельта каждого коммита текущей ветки и сохраняется во временный файл, текущая ветка устанавливается на последний коммит ветки, поверх которой вы выполняете перебазирование, а затем по очереди применяются дельты из временных файлов.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ru/v2/images/basic-rebase-3.png" >}}" alt="Перебазирование изменений из `C4` поверх `C3`">
</div>
<div class="title">Рисунок 37. Перебазирование изменений из <code>C4</code> поверх <code>C3</code>
</div>
</div>
<div class="paragraph">
<p>После этого вы можете переключиться обратно на ветку <code>master</code> и выполнить слияние перемоткой.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
$ git merge experiment</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ru/v2/images/basic-rebase-4.png" >}}" alt="Перемотка ветки `master`">
</div>
<div class="title">Рисунок 38. Перемотка ветки <code>master</code>
</div>
</div>
<div class="paragraph">
<p>Теперь снимок, на который указывает <code>C4'</code> абсолютно такой же, как тот, на который указывал <code>C5</code> в <a href="{{< relurl "book/ru/v2/ch00/r_rebasing-merging-example" >}}">примере с трёхсторонним слиянием</a>.
Нет абсолютно никакой разницы в конечном результате между двумя показанными примерами, но перебазирование делает историю коммитов чище.
Если вы взглянете на историю перебазированной ветки, то увидите, что она выглядит абсолютно линейной: будто все операции были выполнены последовательно, даже если изначально они совершались параллельно.</p>
</div>
<div class="paragraph">
<p>Часто вы будете делать так для уверенности, что ваши коммиты могут быть бесконфликтно слиты в удалённую ветку — возможно, в проекте, куда вы пытаетесь внести вклад, но владельцем которого вы не являетесь.
В этом случае вам следует работать в своей ветке и затем перебазировать вашу работу поверх <code>origin/master</code>, когда вы будете готовы отправить свои изменения в основной проект.
Тогда владельцу проекта не придётся делать никакой лишней работы — всё решится простой перемоткой или бесконфликтным слиянием.</p>
</div>
<div class="paragraph">
<p>Учтите, что снимок, на который ссылается ваш последний коммит — является ли он последним коммитом после перебазирования или коммитом слияния после слияния — в обоих случаях это один и тот же снимок, отличаются только истории коммитов.
Перебазирование повторяет изменения из одной ветки поверх другой в том порядке, в котором эти изменения были сделаны, в то время как слияние берёт две конечные точки и сливает их вместе.</p>
</div>
</div>
<div class="sect3">
<h3 id="_более_интересные_перемещения">Более интересные перемещения</h3>
<div class="paragraph">
<p>Также возможно сделать так, чтобы при перебазировании воспроизведение коммитов применялось к совершенно другой ветке.
Для примера возьмём <a href="{{< relurl "book/ru/v2/ch00/rrbdiag_e" >}}">История разработки с тематической веткой, ответвлённой от другой тематической ветки</a>.
Вы создаёте тематическую ветку <code>server</code>, чтобы добавить в проект некоторую функциональность для серверной части, и делаете коммит.
Затем вы выполнили ответвление, чтобы сделать изменения для клиентской части, и создали несколько коммитов.
Наконец, вы вернулись на ветку <code>server</code> и сделали ещё несколько коммитов.</p>
</div>
<div id="rrbdiag_e" class="imageblock">
<div class="content">
<img src="{{< relurl "book/ru/v2/images/interesting-rebase-1.png" >}}" alt="История разработки с тематической веткой, ответвлённой от другой тематической ветки">
</div>
<div class="title">Рисунок 39. История разработки с тематической веткой, ответвлённой от другой тематической ветки</div>
</div>
<div class="paragraph">
<p>Предположим, вы решили, что хотите внести изменения клиентской части в основную линию разработки для релиза, но при этом не хотите добавлять изменения серверной части до полного тестирования.
Вы можете взять изменения из ветки <code>client</code>, которых нет в <code>server</code> (<code>C8</code> и <code>C9</code>), и применить их на ветке <code>master</code> при помощи опции <code>--onto</code> команды <code>git rebase</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rebase --onto master server client</code></pre>
</div>
</div>
<div class="paragraph">
<p>В этой команде говорится: «Переключись на ветку <code>client</code>, найди изменения относительно ветки <code>server</code> и примени их для ветки <code>master</code>».
Несмотря на некоторую сложность этого способа, результат впечатляет.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ru/v2/images/interesting-rebase-2.png" >}}" alt="Перемещение тематической ветки, ответвлённой от другой тематической ветки">
</div>
<div class="title">Рисунок 40. Перемещение тематической ветки, ответвлённой от другой тематической ветки</div>
</div>
<div class="paragraph">
<p>Теперь вы можете выполнить перемотку (fast-forward) для ветки <code>master</code> (см <a href="{{< relurl "book/ru/v2/ch00/rrbdiag_g" >}}">Перемотка ветки <code>master</code> для добавления изменений из ветки <code>client</code></a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
$ git merge client</code></pre>
</div>
</div>
<div id="rrbdiag_g" class="imageblock">
<div class="content">
<img src="{{< relurl "book/ru/v2/images/interesting-rebase-3.png" >}}" alt="Перемотка ветки `master` для добавления изменений из ветки `client`">
</div>
<div class="title">Рисунок 41. Перемотка ветки <code>master</code> для добавления изменений из ветки <code>client</code>
</div>
</div>
<div class="paragraph">
<p>Представим, что вы решили добавить наработки и из ветки <code>server</code>.
Вы можете выполнить перебазирование ветки <code>server</code> относительно ветки <code>master</code> без предварительного переключения на неё при помощи команды <code>git rebase &lt;basebranch&gt; &lt;topicbranch&gt;</code>, которая извлечёт тематическую ветку (в данном случае <code>server</code>) и применит изменения в ней к базовой ветке (<code>master</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rebase master server</code></pre>
</div>
</div>
<div class="paragraph">
<p>Это повторит работу, сделанную в ветке <code>server</code> поверх ветки <code>master</code>, как показано на рисунке:</p>
</div>
<div id="rrbdiag_h" class="imageblock">
<div class="content">
<img src="{{< relurl "book/ru/v2/images/interesting-rebase-4.png" >}}" alt="Перебазирование ветки `server` на вершину ветки `master`">
</div>
<div class="title">Рисунок 42. Перебазирование ветки <code>server</code> на вершину ветки <code>master</code>
</div>
</div>
<div class="paragraph">
<p>После чего вы сможете выполнить перемотку основной ветки (<code>master</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
$ git merge server</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь вы можете удалить ветки <code>client</code> и <code>server</code>, поскольку весь ваш прогресс уже интегрирован и тематические ветки больше не нужны, а полную историю вашего рабочего процесса отражает рисунок <a href="{{< relurl "book/ru/v2/ch00/rrbdiag_i" >}}">Окончательная история коммитов</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch -d client
$ git branch -d server</code></pre>
</div>
</div>
<div id="rrbdiag_i" class="imageblock">
<div class="content">
<img src="{{< relurl "book/ru/v2/images/interesting-rebase-5.png" >}}" alt="Окончательная история коммитов">
</div>
<div class="title">Рисунок 43. Окончательная история коммитов</div>
</div>
</div>
<div class="sect3">
<h3 id="r_rebase_peril">Опасности перемещения</h3>
<div class="paragraph">
<p>
Но даже перебазирование, при всех своих достоинствах, не лишено недостатков, которые можно выразить одной строчкой:</p>
</div>
<div class="paragraph">
<p><strong>Не перемещайте коммиты, уже отправленные в публичный репозиторий</strong></p>
</div>
<div class="paragraph">
<p>Если вы будете придерживаться этого правила, всё будет хорошо.
Если не будете, люди возненавидят вас, а ваши друзья и семья будут вас презирать.</p>
</div>
<div class="paragraph">
<p>Когда вы что-то перемещаете, вы отменяете существующие коммиты и создаёте новые, <strong>похожие</strong> на старые, но являющиеся другими.
Если вы куда-нибудь отправляете свои коммиты и другие люди забирают их себе и в дальнейшем основывают на них свою работу, а затем вы переделываете эти коммиты командой <code>git rebase</code> и выкладываете их снова, то ваши коллеги будут вынуждены заново выполнять слияние для своих наработок.
В итоге, когда вы в очередной раз попытаетесь включить их работу в свою, вы получите путаницу.</p>
</div>
<div class="paragraph">
<p>Давайте рассмотрим пример того, как перемещение публично доступных наработок может вызвать проблемы.
Предположим, вы клонировали репозиторий с сервера и сделали какую-то работу.
И ваша история коммитов выглядит так:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ru/v2/images/perils-of-rebasing-1.png" >}}" alt="Клонирование репозитория и выполнение в нём какой-то работы">
</div>
<div class="title">Рисунок 44. Клонирование репозитория и выполнение в нём какой-то работы</div>
</div>
<div class="paragraph">
<p>Теперь кто-то другой внёс свои изменения, слил их и отправил на сервер.
Вы стягиваете их к себе, включая новую удалённую ветку, что изменяет вашу историю следующим образом:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ru/v2/images/perils-of-rebasing-2.png" >}}" alt="Извлекаем ещё коммиты и сливаем их со своей работой">
</div>
<div class="title">Рисунок 45. Извлекаем ещё коммиты и сливаем их со своей работой</div>
</div>
<div class="paragraph">
<p>Затем автор коммита слияния решает вернуться назад и перебазировать свою ветку; выполнив <code>git push --force</code>, он перезаписывает историю на сервере.
При получении изменений с сервера вы получите и новые коммиты.</p>
</div>
<div id="r_pre_merge_rebase_work" class="imageblock">
<div class="content">
<img src="{{< relurl "book/ru/v2/images/perils-of-rebasing-3.png" >}}" alt="Кто-то выложил перебазированные коммиты, отменяя коммиты, на которых основывалась ваша работа">
</div>
<div class="title">Рисунок 46. Кто-то выложил перебазированные коммиты, отменяя коммиты, на которых основывалась ваша работа</div>
</div>
<div class="paragraph">
<p>Теперь вы оба в неловком положении.
Если вы выполните <code>git pull</code>, вы создадите коммит слияния, включающий обе линии истории, и ваш репозиторий будет выглядеть следующим образом:</p>
</div>
<div id="r_merge_rebase_work" class="imageblock">
<div class="content">
<img src="{{< relurl "book/ru/v2/images/perils-of-rebasing-4.png" >}}" alt="Вы снова выполняете слияние для той же самой работы в новый коммит слияния">
</div>
<div class="title">Рисунок 47. Вы снова выполняете слияние для той же самой работы в новый коммит слияния</div>
</div>
<div class="paragraph">
<p>Если вы посмотрите <code>git log</code> в этот момент, вы увидите два коммита с одинаковыми авторами, датой и сообщением, что может сбить с толку.
Помимо этого, если вы отправите свою историю на удалённый сервер в таком состоянии, вы вернёте все эти перебазированные коммиты на сервер, что ещё больше всех запутает.
Логично предположить, что разработчик не хочет, чтобы <code>C4</code> и <code>C6</code> были в истории, и именно поэтому она перебазируется в первую очередь.</p>
</div>
</div>
<div class="sect3">
<h3 id="r_rebase_rebase">Меняя базу, меняй основание</h3>
<div class="paragraph">
<p>Если вы попали в такую ситуацию, у Git есть особая магия чтобы вам помочь.
Если кто-то в вашей команде форсирует отправку изменений на сервер, переписывающих работу, на которых базировалась ваша работа, то ваша задача будет состоять в определении того, что именно было ваше, а что было переписано <strong>ими</strong>.</p>
</div>
<div class="paragraph">
<p>Оказывается, что помимо контрольной суммы коммита SHA-1, Git также вычисляет контрольную сумму отдельно для патча, входящего в этот коммит.
Это контрольная сумма называется «patch-id».</p>
</div>
<div class="paragraph">
<p>Если вы скачаете перезаписанную историю и перебазируете её поверх новых коммитов вашего коллеги, в большинстве случаев Git успешно определит, какие именно изменения были внесены вами, и применит их поверх новой ветки.</p>
</div>
<div class="paragraph">
<p>К примеру, если в предыдущем сценарии вместо слияния в <a href="{{< relurl "book/ru/v2/ch00/r_pre_merge_rebase_work" >}}">Кто-то выложил перебазированные коммиты, отменяя коммиты, на которых основывалась ваша работа</a> мы выполним <code>git rebase teamone/master</code>, Git будет:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Определять, какая работа уникальна для вашей ветки (C2, C3, C4, C6, C7)</p>
</li>
<li>
<p>Определять, какие коммиты не были коммитами слияния (C2, C3, C4)</p>
</li>
<li>
<p>Определять, что не было перезаписано в основной ветке (только C2 и C3, поскольку C4 — это тот же патч, что и C4')</p>
</li>
<li>
<p>Применять эти коммиты к ветке <code>teamone/master</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Таким образом, вместо результата, который мы можем наблюдать на <a href="{{< relurl "book/ru/v2/ch00/r_merge_rebase_work" >}}">Вы снова выполняете слияние для той же самой работы в новый коммит слияния</a>, у нас получилось бы что-то вроде <a href="{{< relurl "book/ru/v2/ch00/r_rebase_rebase_work" >}}">Перемещение в начало force-pushed перемещённой работы</a>.</p>
</div>
<div id="r_rebase_rebase_work" class="imageblock">
<div class="content">
<img src="{{< relurl "book/ru/v2/images/perils-of-rebasing-5.png" >}}" alt="Перемещение в начало force-pushed перемещённой работы">
</div>
<div class="title">Рисунок 48. Перемещение в начало force-pushed перемещённой работы</div>
</div>
<div class="paragraph">
<p>Это возможно, если <code>C4</code> и <code>C4'</code> фактически являются одним и тем же патчем, который был сделан вашим коллегой.
В противном случае <code>rebase</code> не сможет определить дубликат и создаст ещё один патч, подобный C4 (который с большой вероятностью не удастся применить чисто, поскольку в нём уже присутствуют некоторые изменения).</p>
</div>
<div class="paragraph">
<p>Вы можете это упростить, применив <code>git pull --rebase</code> вместо обычного <code>git pull</code>.
Или сделать это вручную с помощью <code>git fetch</code>, а затем <code>git rebase teamone/master</code>.</p>
</div>
<div class="paragraph">
<p>Если вы используете <code>git pull</code> и хотите использовать <code>--rebase</code> по умолчанию, вы можете установить соответствующее значение конфигурации <code>pull.rebase</code> с помощью команды <code>git config --global pull.rebase true</code>.</p>
</div>
<div class="paragraph">
<p>Если вы рассматриваете перебазирование как способ наведения порядка и работаете с коммитами локально до их отправки или ваши коммиты никогда не будут доступны публично — у вас всё будет хорошо.
Однако, если вы перемещаете коммиты, отправленные в публичный репозиторий, и есть вероятность, что работа некоторых людей основывается на этих коммитах, то ваши действия могут вызвать существенные проблемы, а вы — вызвать презрение вашей команды.</p>
</div>
<div class="paragraph">
<p>Если в какой-то момент вы или ваш коллега находите необходимость в этом, убедитесь, что все знают, как применять команду <code>git pull --rebase</code> для минимизации последствий от подобных действий.</p>
</div>
</div>
<div class="sect3">
<h3 id="_перемещение_vs_слияние">Перемещение vs. Слияние</h3>
<div class="paragraph">
<p>
Теперь, когда вы увидели перемещение и слияние в действии, вы можете задаться вопросом, что из них лучше.
Прежде чем ответить на этот вопрос, давайте вернёмся немного назад и поговорим о том, что означает история.</p>
</div>
<div class="paragraph">
<p>Одна из точек зрения заключается в том, что история коммитов в вашем репозитории — это <strong>запись того, что на самом деле произошло</strong>.
Это исторический документ, ценный сам по себе, и его нельзя подделывать.
С этой точки зрения изменение истории коммитов практически кощунственно; вы <em>лжёте</em> о том, что на самом деле произошло.
Но что, если произошла путаница в коммитах слияния?
Если это случается, репозиторий должен сохранить это для потомков.</p>
</div>
<div class="paragraph">
<p>Противоположная точка зрения заключается в том, что история коммитов — это <strong>история того, как был сделан ваш проект</strong>.
Вы не публикуете первый черновик книги или инструкции по поддержке вашего программного обеспечения, так как это нуждается в тщательном редактировании.
Сторонники этого лагеря считают использование инструментов <code>rebase</code> и <code>filter-branch</code> способом рассказать историю проекта наилучшим образом для будущих читателей.</p>
</div>
<div class="paragraph">
<p>Теперь к вопросу о том, что лучше — слияние или перебазирование: надеюсь, вы видите, что это не так просто.
Git — мощный инструмент, позволяющий вам делать многое с вашей историей, однако каждая команда и каждый проект индивидуален.
Теперь, когда вы знаете, как работают оба эти приёма, выбор — какой из них будет лучше в вашей ситуации — зависит от вас.</p>
</div>
<div class="paragraph">
<p>При этом, вы можете взять лучшее от обоих миров: использовать перебазирование для наведения порядка в истории ваших локальных изменений, но никогда не применять его для уже отправленных куда-нибудь изменений.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>