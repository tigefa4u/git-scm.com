---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: ru
  chapter:
    title: Git изнутри
    number: 10
  section:
    title: Протоколы передачи данных
    number: 6
    cs_number: '10.6'
    previous: book/ru/v2/Git-изнутри-Спецификации-ссылок
    next: book/ru/v2/Git-изнутри-Обслуживание-репозитория-и-восстановление-данных
title: Git - Протоколы передачи данных
url: "/book/ru/v2/Git-изнутри-Протоколы-передачи-данных.html"
---
<h2 id="_протоколы_передачи_данных">Протоколы передачи данных</h2>
<div class="paragraph">
<p>Git умеет передавать данные между репозиториями двумя способами: используя «глупый» и «умный» протоколы.
В этой главе мы рассмотрим, как они работают.</p>
</div>
<div class="sect3">
<h3 id="_глупый_протокол">Глупый протокол</h3>
<div class="paragraph">
<p>Если вы разрешили доступ на чтение к вашему репозиторию через HTTP, то скорее всего будет использован «глупый» протокол.
Протокол назвали «глупым», потому что для его работы не требуется выполнение специфичных для Git операций на стороне сервера: весь процесс получения данных представляет собой серию HTTP <code>GET</code> запросов, при этом клиент ожидает наличия на сервере структуры каталогов аналогичной Git репозиторию.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Примечание</div>
</td>
<td class="content">
<div class="paragraph">
<p>Глупый протокол довольно редко используется в наши дни.
При использовании глупого протокола сложно обеспечить безопасность передачи и приватность данных, поэтому большинство Git серверов (как облачных, так и тех, что требуют установки) откажутся работать через него.
Рекомендуется использовать умный протокол, который мы рассмотрим далее.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Давайте рассмотрим процесс получения данных из репозитория <code>simplegit-progit</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone http://server/simplegit-progit.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Первым делом будет загружен файл <code>info/refs</code>.
Данный файл записывается командой <code>update-server-info</code>, поэтому для корректной работы HTTP-транспорта необходимо выполнять её в <code>post-receive</code> триггере.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET info/refs
ca82a6dff817ec66f44342007202690a93763949     refs/heads/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь у нас имеется список удалённых веток и их хеши.
Далее, надо посмотреть, куда ссылается HEAD, чтобы знать на что переключиться после завершения работы команды.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET HEAD
ref: refs/heads/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Итак, нужно переключится на ветку <code>master</code> после окончания работы.
На данном этапе можно начинать обход репозитория.
Начальной точкой является коммит <code>ca82a6</code>, о чём мы узнали из файла <code>info/refs</code>, поэтому мы начинаем с его загрузки:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET objects/ca/82a6dff817ec66f44342007202690a93763949
(179 bytes of binary data)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Объект получен, он был в рыхлом формате на сервере, и мы получили его по HTTP, используя GET-запрос.
Теперь можно его разархивировать, обрезать заголовок и посмотреть на содержимое:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -p ca82a6dff817ec66f44342007202690a93763949
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
author Scott Chacon &lt;schacon@gmail.com&gt; 1205815931 -0700
committer Scott Chacon &lt;schacon@gmail.com&gt; 1240030591 -0700

Change version number</code></pre>
</div>
</div>
<div class="paragraph">
<p>Далее, необходимо загрузить ещё два объекта: дерево <code>cfda3b</code> — содержимое только что загруженного коммита, и <code>085bb3</code> — родительский коммит:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET objects/08/5bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
(179 bytes of data)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вот мы и получили следующий объект коммита.
Теперь получим содержимое коммита:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET objects/cf/da3bf379e4f8dba8717dee55aab78aef7f4daf
(404 - Not Found)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Упс, похоже, этого дерева нет на сервере в рыхлом формате, поэтому мы получили ответ 404.
Возможны два варианта: объект в другом репозитории или в упакованном файле текущего репозитория.
Сначала Git проверяет список альтернативных репозиториев:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET objects/info/http-alternates
(empty file)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если бы этот запрос вернул непустой список альтернатив, Git проверил бы указанные репозитории на наличие файла в «рыхлом» формате — довольно полезная возможность для проектов-форков, позволяющая устранить дублирование объектов на диске.
Так как в данном случае альтернатив нет, объект должен быть упакован в pack-файле.
Чтобы посмотреть доступные на сервере pack-файлы, нужно скачать файл <code>objects/info/packs</code>, содержащий их список (также генерируется командой <code>update-server-info</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET objects/info/packs
P pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack</code></pre>
</div>
</div>
<div class="paragraph">
<p>На сервере имеется только один pack-файл, поэтому объект точно там, но необходимо проверить индексный файл, чтобы в этом убедиться.
Если бы на сервере было несколько pack-файлов, загрузив сначала индексы, мы смогли бы определить, в каком именно pack-файле находится нужный нам объект:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.idx
(4k of binary data)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Так как в индексе содержится список SHA-1 хешей объектов и соответствующих им смещений объектов внутри pack-файла, то можно проверить наличие объекта в этом pack-файле.
Наш объект там присутствует, так что продолжим и скачаем весь pack-файл:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack
(13k of binary data)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Итак, мы получили наше дерево, можно продолжить обход списка коммитов.
Все они содержатся внутри только что скачанного pack-файла, так что снова обращаться к серверу не надо.
Git извлекает рабочую копию ветки <code>master</code>, так как на неё указывает ссылка <code>HEAD</code>, которая была скачана в самом начале.</p>
</div>
</div>
<div class="sect3">
<h3 id="_умный_протокол">Умный протокол</h3>
<div class="paragraph">
<p>Глупый протокол прост, но неэффективен и не позволяет производить запись в удалённые репозитории.
Гораздо чаще для обмена данными используют «умный» протокол, но это требует наличия на сервере специального процесса, знающего о структуре Git репозитория, умеющего выяснять, какие данные необходимо отправить клиенту и генерирующего отдельный pack-файл с недостающими изменениями для него.
Работу умного протокола обеспечивают несколько процессов: два для отправки данных на сервер и два для загрузки с него.</p>
</div>
<div class="sect4">
<h4 id="_загрузка_данных_на_сервер">Загрузка данных на сервер</h4>
<div class="paragraph">
<p>
Для загрузки данных на удалённый сервер используются процессы <code>send-pack</code> и <code>receive-pack</code>.
Процесс <code>send-pack</code> запускается на клиенте и подключается к <code>receive-pack</code> на сервере.</p>
</div>
<div class="sect5">
<h6 id="_ssh">SSH</h6>
<div class="paragraph">
<p>Допустим, вы выполняете <code>git push origin master</code> и <code>origin</code> задан как URL, использующий протокол SSH.
Git запускает процесс <code>send-pack</code>, который устанавливает соединение с сервером по протоколу SSH.
Он пытается запустить команду на удалённом сервере через вызов SSH команды, который выглядит следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ssh -x git@server "git-receive-pack 'simplegit-progit.git'"
00a5ca82a6dff817ec66f4437202690a93763949 refs/heads/master report-status \
	delete-refs side-band-64k quiet ofs-delta \
	agent=git/2:2.1.1+github-607-gfba4028 delete-refs
0000</code></pre>
</div>
</div>
<div class="paragraph">
<p>Команда <code>git-receive-pack</code> тут же посылает в ответ по одной строке на каждую из имеющихся в наличии ссылок — в данном случае только ветку <code>master</code> и её SHA-1.
Первая строка также содержит список возможностей сервера (здесь это <code>report-status</code>, <code>delete-refs</code> и парочка других, включая идентификатор клиента).</p>
</div>
<div class="paragraph">
<p>Данные передаются пакетами.
Каждый пакет начинается с 4-байтового шестнадцатеричного значения, определяющего его размер (включая эти 4 байта).
Пакеты обычно содержат одну строку данных и завершающий символ переноса строки.
Первый пакет начинается с 00a5, что в десятичной системе равно 165 и означает, что размер пакета составляет 165 байт.
Следующий пакет начинается с 0000, что говорит об окончании передачи списка ссылок сервером.</p>
</div>
<div class="paragraph">
<p>Теперь, когда <code>send-pack</code> выяснил состояние сервера, он определяет коммиты, которые есть локально, но отсутствуют на сервере.
Эту информацию процесс <code>send-pack</code> передаёт процессу <code>receive-pack</code> по каждой ссылке, которая подлежит отправке.
Например, если мы обновляем ветку <code>master</code> и добавляем ветку <code>experiment</code>, ответ <code>send-pack</code> будет выглядеть следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>0076ca82a6dff817ec66f44342007202690a93763949 15027957951b64cf874c3557a0f3547bd83b3ff6 \
	refs/heads/master report-status
006c0000000000000000000000000000000000000000 cdfdb42577e2506715f8cfeacdbabc092bf63e8d \
	refs/heads/experiment
0000</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для каждой обновляемой ссылки Git посылает по строке, содержащей собственную длину, старый хеш, новый хеш и имя ссылки.
В первой строке также посылаются возможности клиента.
Хеш, состоящий из нулей, говорит о том, что раньше такой ссылки не было — вы ведь добавляете новую ветку <code>experiment</code>.
При удалении ветки всё было бы наоборот: нули были бы справа.</p>
</div>
<div class="paragraph">
<p>Затем клиент посылает pack-файл c объектами, которых нет на сервере.
Наконец, сервер передаёт статус операции — успех или ошибка:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>000eunpack ok</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_https">HTTP(S)</h6>
<div class="paragraph">
<p>Этот процесс похож на HTTP, но установка соединения слегка отличается.
Всё начинается с такого запроса:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET http://server/simplegit-progit.git/info/refs?service=git-receive-pack
001f# service=git-receive-pack
000000ab6c5f0e45abd7832bf23074a333f739977c9e8188 refs/heads/master \
	report-status delete-refs side-band-64k quiet ofs-delta \
	agent=git/2:2.1.1~vmg-bitmaps-bugaloo-608-g116744e
0000</code></pre>
</div>
</div>
<div class="paragraph">
<p>Это всё, что передаётся в ответ на первый запрос.
Затем клиент делает второй запрос, на этот раз <code>POST</code>, передавая данные, полученные от команды <code>git-upload-pack</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; POST http://server/simplegit-progit.git/git-receive-pack</code></pre>
</div>
</div>
<div class="paragraph">
<p>Этот запрос включает в себя результаты <code>send-pack</code> и собственно pack-файлы.
Сервер, используя код состояния HTTP, возвращает результат операции.</p>
</div>
<div class="paragraph">
<p>Имейте ввиду, что HTTP протокол может дополнительно кодировать данные внутри каждого пакета.</p>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_скачивание_данных">Скачивание данных</h4>
<div class="paragraph">
<p>
Для получения данных из удалённых репозиториев используются процессы <code>fetch-pack</code> и <code>upload-pack</code>.
Клиент запускает процесс <code>fetch-pack</code>, который подключается к процессу <code>upload-pack</code> на сервере для определения подлежащих передаче данных.</p>
</div>
<div class="sect5">
<h6 id="_ssh_2">SSH</h6>
<div class="paragraph">
<p>Если вы работаете через SSH, <code>fetch-pack</code> выполняет примерно такую команду:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ssh -x git@server "git-upload-pack 'simplegit-progit.git'"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Как только <code>fetch-pack</code> подключается к <code>upload-pack</code>, тот отсылает обратно следующее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>00dfca82a6dff817ec66f44342007202690a93763949 HEAD\0multi_ack thin-pack \
	side-band side-band-64k ofs-delta shallow no-progress include-tag \
	multi_ack_detailed symref=HEAD:refs/heads/master \
	agent=git/2:2.1.1+github-607-gfba4028
003fe2409a098dc3e53539a9028a94b6224db9d6a6b6 refs/heads/master
0000</code></pre>
</div>
</div>
<div class="paragraph">
<p>Это очень похоже на ответ <code>receive-pack</code>, но только возможности другие.
Вдобавок <code>upload-pack</code> отсылает обратно ссылку HEAD (<code>symref=HEAD:refs/heads/master</code>), чтобы клиент понимал, на какую ветку переключиться, если выполняется клонирование.</p>
</div>
<div class="paragraph">
<p>На данном этапе процесс <code>fetch-pack</code> смотрит на имеющиеся в наличии объекты, а для недостающих объектов отвечает словом «want» с указанием SHA-1 необходимого объекта.
Для каждого из имеющихся объектов процесс отправляет слово «have» с указанием SHA-1 объекта.
В конце списка он пишет «done», что указывает процессу <code>upload-pack</code> начать отправлять pack-файл с необходимыми данными:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>003cwant ca82a6dff817ec66f44342007202690a93763949 ofs-delta
0032have 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
0009done
0000</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_https_2">HTTP(S)</h6>
<div class="paragraph">
<p>«Рукопожатие» для процесса получения недостающих данных занимает два HTTP запроса.
Первый — это <code>GET</code> запрос на тот же URL, что и в случае глупого протокола:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET $GIT_URL/info/refs?service=git-upload-pack
001e# service=git-upload-pack
00e7ca82a6dff817ec66f44342007202690a93763949 HEAD\0multi_ack thin-pack \
	side-band side-band-64k ofs-delta shallow no-progress include-tag \
	multi_ack_detailed no-done symref=HEAD:refs/heads/master \
	agent=git/2:2.1.1+github-607-gfba4028
003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master
0000</code></pre>
</div>
</div>
<div class="paragraph">
<p>Это очень похоже на использование <code>git-upload-pack</code> по SSH, вот только обмен данными производится отдельным запросом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; POST $GIT_URL/git-upload-pack HTTP/1.0
0032want 0a53e9ddeaddad63ad106860237bbf53411d11a7
0032have 441b40d833fdfa93eb2908e52742248faf0ee993
0000</code></pre>
</div>
</div>
<div class="paragraph">
<p>Используется тот же формат, что и ранее.
В ответ сервер посылает статус операции и сгенерированный pack-файл.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_заключение_15">Заключение</h3>
<div class="paragraph">
<p>В этом разделе мы вкратце рассмотрели протоколы передачи данных.
Протоколы обмена данных в Git включают в себя множество возможностей, таких как <code>multi_ack</code> или <code>side-band</code>, но их рассмотрение выходит за пределы этой книги.
Мы описали формат сообщений между клиентом и сервером не вдаваясь в детали, если хотите покопаться в этой теме глубже — обратитесь к исходному коду Git.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>