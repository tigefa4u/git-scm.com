---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: ru
  chapter:
    title: Введение
    number: 1
  section:
    title: Что такое Git?
    number: 3
    cs_number: '1.3'
    previous: book/ru/v2/Введение-Краткая-история-Git
    next: book/ru/v2/Введение-Командная-строка
title: Git - Что такое Git?
url: "/book/ru/v2/Введение-Что-такое-Git?.html"
aliases:
- "/book/ru/v2/Введение-Что-такое-Git.html"
---
<h2 id="what_is_git_section">Что такое Git?</h2>
<div class="paragraph">
<p>Что же такое Git, если говорить коротко?
Очень важно понять эту часть материала, потому что если вы поймёте, что такое Git и основы того, как он работает, тогда, возможно, вам будет гораздо проще его использовать.
Пока вы изучаете Git, попробуйте забыть всё, что вы знаете о других системах контроля версий, таких как Subversion и Perforce.
Это позволит вам избежать определённых проблем при использовании инструмента.
Git хранит и использует информацию совсем иначе по сравнению с другими системами, даже несмотря на то, что интерфейс пользователя достаточно похож, и понимание этих различий поможет вам избежать путаницы во время использования.</p>
</div>
<div class="sect3">
<h3 id="_снимки_а_не_различия">Снимки, а не различия</h3>
<div class="paragraph">
<p>Основное отличие Git от любой другой системы контроля версий (включая Subversion и её собратьев) — это подход к работе со своими данными.
Концептуально, большинство других систем хранят информацию в виде списка изменений в файлах.
Эти системы (CVS, Subversion, Perforce, Bazaar и т. д.) представляют хранимую информацию в виде набора файлов и изменений, сделанных в каждом файле, по времени (обычно это называют контролем версий, <em>основанным на различиях</em>).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ru/v2/images/deltas.png" >}}" alt="Хранение данных как набора изменений относительно первоначальной версии каждого из файлов">
</div>
<div class="title">Рисунок 4. Хранение данных как набора изменений относительно первоначальной версии каждого из файлов</div>
</div>
<div class="paragraph">
<p>Git не хранит и не обрабатывает данные таким способом.
Вместо этого, подход Git к хранению данных больше похож на набор снимков миниатюрной файловой системы.
Каждый раз, когда вы делаете коммит, то есть сохраняете состояние своего проекта в Git, система запоминает, как выглядит каждый файл в этот момент, и сохраняет ссылку на этот снимок.
Для увеличения эффективности, если файлы не были изменены, Git не запоминает эти файлы вновь, а только создаёт ссылку на предыдущую версию идентичного файла, который уже сохранён.
Git представляет свои данные как, скажем, <strong>поток снимков</strong>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ru/v2/images/snapshots.png" >}}" alt="Хранение данных как снимков проекта во времени">
</div>
<div class="title">Рисунок 5. Хранение данных как снимков проекта во времени</div>
</div>
<div class="paragraph">
<p>Это очень важное различие между Git и почти любой другой системой контроля версий.
Git переосмысливает практически все аспекты контроля версий, которые были скопированы из предыдущего поколения большинством других систем.
Это делает Git больше похожим на миниатюрную файловую систему с удивительно мощными утилитами, надстроенными над ней, нежели просто на VCS.
Когда мы будем рассматривать управление ветками в главе <a href="{{< relurl "book/ru/v2/ch00/ch03-git-branching" >}}">Ветвление в Git</a>, мы увидим, какие преимущества вносит такой подход к работе с данными в Git.</p>
</div>
</div>
<div class="sect3">
<h3 id="_почти_все_операции_выполняются_локально">Почти все операции выполняются локально</h3>
<div class="paragraph">
<p>Для работы большинства операций в Git достаточно локальных файлов и ресурсов — в основном, системе не нужна никакая информация с других компьютеров в вашей сети.
Если вы привыкли к централизованным системам контроля версий, где большинство операций страдают от задержек из-за работы с сетью, то этот аспект Git заставит вас думать, что боги скорости наделили Git несказанной мощью.
Так как вся история проекта хранится прямо на вашем локальном диске, большинство операций кажутся чуть ли не мгновенными.</p>
</div>
<div class="paragraph">
<p>Для примера, чтобы посмотреть историю проекта, Git не нужно соединяться с сервером для её получения и отображения — система просто считывает данные напрямую из локальной базы данных.
Это означает, что вы увидите историю проекта практически моментально.
Если вам необходимо посмотреть изменения, сделанные между текущей версией файла и версией, созданной месяц назад, Git может найти файл месячной давности и локально вычислить изменения, вместо того, чтобы запрашивать удалённый сервер выполнить эту операцию, либо вместо получения старой версии файла с сервера и выполнения операции локально.</p>
</div>
<div class="paragraph">
<p>Это также означает, что есть лишь небольшое количество действий, которые вы не сможете выполнить, если вы находитесь оффлайн или не имеете доступа к VPN в данный момент.
Если вы в самолёте или в поезде и хотите немного поработать, вы сможете создавать коммиты без каких-либо проблем (в вашу <em>локальную</em> копию, помните?): когда будет возможность подключиться к сети, все изменения можно будет синхронизировать.
Если вы ушли домой и не можете подключиться через VPN, вы всё равно сможете работать.
Добиться такого же поведения во многих других системах либо очень сложно, либо вовсе невозможно.
В Perforce, для примера, если вы не подключены к серверу, вам не удастся сделать многого; в Subversion и CVS вы можете редактировать файлы, но вы не сможете сохранить изменения в базу данных (потому что вы не подключены к БД).
Всё это может показаться не таким уж и значимым, но вы удивитесь, какое большое значение это может иметь.</p>
</div>
</div>
<div class="sect3">
<h3 id="_целостность_git">Целостность Git</h3>
<div class="paragraph">
<p>В Git для всего вычисляется хеш-сумма, и только потом происходит сохранение.
В дальнейшем обращение к сохранённым объектам происходит по этой хеш-сумме.
Это значит, что невозможно изменить содержимое файла или каталога так, чтобы Git не узнал об этом.
Данная функциональность встроена в Git на низком уровне и является неотъемлемой частью его философии.
Вы не потеряете информацию во время её передачи и не получите повреждённый файл без ведома Git.</p>
</div>
<div class="paragraph">
<p>Механизм, которым пользуется Git при вычислении хеш-сумм, называется SHA-1 хеш.
Это строка длиной в 40 шестнадцатеричных символов (0-9 и a-f), она вычисляется на основе содержимого файла или структуры каталога.
SHA-1 хеш выглядит примерно так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>24b9da6552252987aa493b52f8696cd6d3b00373</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вы будете постоянно встречать хеши в Git, потому что он использует их повсеместно.
На самом деле, Git сохраняет все объекты в свою базу данных не по имени, а по хеш-сумме содержимого объекта.</p>
</div>
</div>
<div class="sect3">
<h3 id="_git_обычно_только_добавляет_данные">Git обычно только добавляет данные</h3>
<div class="paragraph">
<p>Когда вы производите какие-либо действия в Git, практически все из них только <em>добавляют</em> новые данные в базу Git.
Очень сложно заставить систему удалить данные либо сделать что-то, что нельзя впоследствии отменить.
Как и в любой другой системе контроля версий, вы можете потерять или испортить свои изменения, пока они не зафиксированы, но после того, как вы зафиксируете снимок в Git, будет очень сложно что-либо потерять, особенно, если вы регулярно синхронизируете свою базу с другим репозиторием.</p>
</div>
<div class="paragraph">
<p>Всё это превращает использование Git в одно удовольствие, потому что мы знаем, что можем экспериментировать, не боясь серьёзных проблем.
Для более глубокого понимания того, как Git хранит свои данные и как вы можете восстановить данные, которые кажутся утерянными, см. <a href="{{< relurl "book/ru/v2/ch00/r_undoing" >}}">Операции отмены</a>.</p>
</div>
</div>
<div class="sect3">
<h3 id="_три_состояния">Три состояния</h3>
<div class="paragraph">
<p>Теперь слушайте внимательно.
Это самая важная вещь, которую нужно запомнить о Git, если вы хотите, чтобы остаток процесса обучения прошёл гладко.
У Git есть три основных состояния, в которых могут находиться ваши файлы: <em>изменён</em> (modified), <em>индексирован</em> (staged) и <em>зафиксирован</em> (committed):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>К изменённым относятся файлы, которые поменялись, но ещё не были зафиксированы.</p>
</li>
<li>
<p>Индексированный — это изменённый файл в его текущей версии, отмеченный для включения в следующий коммит.</p>
</li>
<li>
<p>Зафиксированный значит, что файл уже сохранён в вашей локальной базе.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Мы подошли к трём основным секциям проекта Git: рабочая копия (working tree), область индексирования (staging area) и каталог Git (Git directory).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ru/v2/images/areas.png" >}}" alt="Рабочая копия, область индексирования и каталог Git">
</div>
<div class="title">Рисунок 6. Рабочая копия, область индексирования и каталог Git</div>
</div>
<div class="paragraph">
<p>Рабочая копия является снимком одной версии проекта.
Эти файлы извлекаются из сжатой базы данных в каталоге Git и помещаются на диск, для того чтобы их можно было использовать или редактировать.</p>
</div>
<div class="paragraph">
<p>Область индексирования — это файл, обычно находящийся в каталоге Git, в нём содержится информация о том, что попадёт в следующий коммит.
Её техническое название на языке Git — «индекс», но фраза «область индексирования» также работает.</p>
</div>
<div class="paragraph">
<p>Каталог Git — это то место, где Git хранит метаданные и базу объектов вашего проекта.
Это самая важная часть Git и это та часть, которая копируется при <em>клонировании</em> репозитория с другого компьютера.</p>
</div>
<div class="paragraph">
<p>Базовый подход в работе с Git выглядит так:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Изменяете файлы вашей рабочей копии.</p>
</li>
<li>
<p>Выборочно добавляете в индекс только те изменения, которые должны попасть в следующий коммит, добавляя тем самым снимки <em>только</em> этих изменений в индекс.</p>
</li>
<li>
<p>Когда вы делаете коммит, используются файлы из индекса как есть, и этот снимок сохраняется в ваш каталог Git.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Если определённая версия файла есть в каталоге Git, эта версия считается <em>зафиксированной</em> (committed).
Если файл был изменён и добавлен в индекс, значит, он <em>индексирован</em> (staged).
И если файл был изменён с момента последнего распаковывания из репозитория, но не был добавлен в индекс, он считается <em>изменённым</em> (modified).
В главе <a href="{{< relurl "book/ru/v2/ch00/ch02-git-basics-chapter" >}}">Основы Git</a> вы узнаете больше об этих состояниях и какую пользу вы можете извлечь из них или как полностью пропустить часть с индексом.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>