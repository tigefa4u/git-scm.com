---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: ru
  chapter:
    title: Основы Git
    number: 2
  section:
    title: Запись изменений в репозиторий
    number: 2
    cs_number: '2.2'
    previous: book/ru/v2/Основы-Git-Создание-Git-репозитория
    next: book/ru/v2/Основы-Git-Просмотр-истории-коммитов
title: Git - Запись изменений в репозиторий
url: "/book/ru/v2/Основы-Git-Запись-изменений-в-репозиторий.html"
---
<h2 id="_запись_изменений_в_репозиторий">Запись изменений в репозиторий</h2>
<div class="paragraph">
<p>Итак, у вас имеется настоящий Git-репозиторий и рабочая копия файлов для некоторого проекта.
Вам нужно делать некоторые изменения и фиксировать «снимки» состояния (snapshots) этих изменений в вашем репозитории каждый раз, когда проект достигает состояния, которое вам хотелось бы сохранить.</p>
</div>
<div class="paragraph">
<p>Запомните, каждый файл в вашем рабочем каталоге может находиться в одном из двух состояний: под версионным контролем (отслеживаемые) и нет (неотслеживаемые).
Отслеживаемые файлы — это те файлы, которые были в последнем снимке состояния проекта; они могут быть неизменёнными, изменёнными или подготовленными к коммиту.
Если кратко, то отслеживаемые файлы — это те файлы, о которых знает Git.</p>
</div>
<div class="paragraph">
<p>Неотслеживаемые файлы — это всё остальное, любые файлы в вашем рабочем каталоге, которые не входили в ваш последний снимок состояния и не подготовлены к коммиту.
Когда вы впервые клонируете репозиторий, все файлы будут отслеживаемыми и неизменёнными, потому что Git только что их извлёк и вы ничего пока не редактировали.</p>
</div>
<div class="paragraph">
<p>Как только вы отредактируете файлы, Git будет рассматривать их как изменённые, так как вы изменили их с момента последнего коммита.
Вы индексируете эти изменения, затем фиксируете все проиндексированные изменения, а затем цикл повторяется.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ru/v2/images/lifecycle.png" >}}" alt="Жизненный цикл состояний файлов">
</div>
<div class="title">Рисунок 8. Жизненный цикл состояний файлов</div>
</div>
<div class="sect3">
<h3 id="r_checking_status">Определение состояния файлов</h3>
<div class="paragraph">
<p>Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся — это команда <code>git status</code>.
Если вы выполните эту команду сразу после клонирования, вы увидите что-то вроде этого:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working tree clean</code></pre>
</div>
</div>
<div class="paragraph">
<p>Это означает, что у вас чистый рабочий каталог, другими словами — в нём нет отслеживаемых изменённых файлов.
Git также не обнаружил неотслеживаемых файлов, в противном случае они бы были перечислены здесь.
Наконец, команда сообщает вам на какой ветке вы находитесь и сообщает вам, что она не расходится с веткой на сервере.
Пока что это всегда ветка <code>master</code>, ветка по умолчанию; в этой главе это не важно.
В главе <a href="{{< relurl "book/ru/v2/ch00/ch03-git-branching" >}}">Ветвление в Git</a> будут рассмотрены ветки и ссылки более детально.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Примечание</div>
</td>
<td class="content">
<div class="paragraph">
<p>В 2020 году GitHub изменил имя ветки по умолчанию с <code>master</code> на <code>main</code>, другие же git-хостинг платформы последовали этому примеру.
Поэтому, вы можете обнаружить, что ветка по умолчанию для новых репозиториев — <code>main</code>, а не <code>master</code>.
Более того, имя ветки по умолчанию можно изменить (как вы видели в <a href="{{< relurl "book/ru/v2/ch00/ru_new_default_branch" >}}">Настройка ветки по умолчанию</a>), поэтому вам может встретиться и другое имя.
При этом Git продолжает использовать имя <code>master</code>, поэтому далее в книге мы используем именно его.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Предположим, вы добавили в свой проект новый файл, простой файл <code>README</code>.
Если этого файла раньше не было, и вы выполните <code>git status</code>, вы увидите свой неотслеживаемый файл вот так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 'My Project' &gt; README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)

    README

nothing added to commit but untracked files present (use "git add" to track)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Понять, что новый файл <code>README</code> неотслеживаемый можно по тому, что он находится в секции «Untracked files» в выводе команды <code>status</code>.
Статус <code>Untracked</code> означает, что Git видит файл, которого не было в предыдущем снимке состояния (коммите); Git не станет добавлять его в ваши коммиты, пока вы его явно об этом не попросите.
Это предохранит вас от случайного добавления в репозиторий сгенерированных бинарных файлов или каких-либо других, которые вы и не думали добавлять.
Мы хотели добавить README, так давайте сделаем это.</p>
</div>
</div>
<div class="sect3">
<h3 id="r_tracking_files">Отслеживание новых файлов</h3>
<div class="paragraph">
<p>Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл, используется команда <code>git add</code>.
Чтобы начать отслеживание файла <code>README</code>, вы можете выполнить следующее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add README</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если вы снова выполните команду <code>status</code>, то увидите, что файл <code>README</code> теперь отслеживаемый и добавлен в индекс:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git restore --staged &lt;file&gt;..." to unstage)

    new file:   README</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вы можете видеть, что файл проиндексирован, так как он находится в секции «Changes to be committed».
Если вы выполните коммит в этот момент, то версия файла, существовавшая на момент выполнения вами команды <code>git add</code>, будет добавлена в историю снимков состояния.
Как вы помните, когда вы ранее выполнили <code>git init</code>, затем вы выполнили <code>git add (файлы)</code> — это было сделано для того, чтобы добавить файлы в вашем каталоге под версионный контроль.
Команда <code>git add</code> принимает параметром путь к файлу или каталогу, если это каталог, команда рекурсивно добавляет все файлы из указанного каталога в индекс.</p>
</div>
</div>
<div class="sect3">
<h3 id="_индексация_изменённых_файлов">Индексация изменённых файлов</h3>
<div class="paragraph">
<p>Давайте модифицируем файл, уже находящийся под версионным контролем.
Если вы измените отслеживаемый файл <code>CONTRIBUTING.md</code> и после этого снова выполните команду <code>git status</code>, то результат будет примерно следующим:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    new file:   README

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>Файл <code>CONTRIBUTING.md</code> находится в секции «Changes not staged for commit» — это означает, что отслеживаемый файл был изменён в рабочем каталоге, но пока не проиндексирован.
Чтобы проиндексировать его, необходимо выполнить команду <code>git add</code>.
Это многофункциональная команда, она используется для добавления под версионный контроль новых файлов, для индексации изменений, а также для других целей, например для указания файлов с исправленным конфликтом слияния.
Вам может быть понятнее, если вы будете думать об этом как «добавить этот контент в следующий коммит», а не как «добавить этот файл в проект».
Выполним <code>git add</code>, чтобы проиндексировать <code>CONTRIBUTING.md</code>, а затем снова выполним <code>git status</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь оба файла проиндексированы и войдут в следующий коммит.
В этот момент вы, предположим, вспомнили одно небольшое изменение, которое вы хотите сделать в <code>CONTRIBUTING.md</code> до коммита.
Вы открываете файл, вносите и сохраняете необходимые изменения и вроде бы готовы к коммиту.
Но давайте-ка ещё раз выполним <code>git status</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ vim CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>Что за чёрт?
Теперь <code>CONTRIBUTING.md</code> отображается как проиндексированный и непроиндексированный одновременно.
Как такое возможно?
Такая ситуация наглядно демонстрирует, что Git индексирует файл в точности в том состоянии, в котором он находился, когда вы выполнили команду  <code>git add</code>.
Если вы выполните коммит сейчас, то файл <code>CONTRIBUTING.md</code> попадёт в коммит в том состоянии, в котором он находился, когда вы последний раз выполняли команду <code>git add</code>, а не в том, в котором он находится в вашем рабочем каталоге в момент выполнения <code>git commit</code>.
Если вы изменили файл после выполнения <code>git add</code>, вам придётся снова выполнить <code>git add</code>, чтобы проиндексировать последнюю версию файла:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_сокращённый_вывод_статуса">Сокращённый вывод статуса</h3>
<div class="paragraph">
<p>Вывод команды <code>git status</code> довольно всеобъемлющий и многословный.
Git также имеет флаг вывода сокращённого статуса, так что вы можете увидеть изменения в более компактном виде.
Если вы выполните <code>git status -s</code> или <code>git status --short</code> вы получите гораздо более упрощённый вывод:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>Новые неотслеживаемые файлы помечены <code>??</code> слева от них, файлы добавленные в отслеживаемые помечены <code>A</code>, отредактированные файлы помечены <code>M</code> и так далее.
В выводе содержится два столбца — в левом указывается статус файла, а в правом модифицирован ли он после этого.
К примеру в нашем выводе, файл <code>README</code> модифицирован в рабочем каталоге, но не проиндексирован, а файл <code>lib/simplegit.rb</code> модифицирован и проиндексирован.
Файл <code>Rakefile</code> модифицирован, проиндексирован и ещё раз модифицирован, таким образом на данный момент у него есть те изменения, которые попадут в коммит, и те, которые не попадут.</p>
</div>
</div>
<div class="sect3">
<h3 id="r_ignoring">Игнорирование файлов</h3>
<div class="paragraph">
<p>Зачастую, у вас имеется группа файлов, которые вы не только не хотите автоматически добавлять в репозиторий, но и видеть в списках неотслеживаемых.
К таким файлам обычно относятся автоматически генерируемые файлы (различные логи, результаты сборки программ и т. п.).
В таком случае, вы можете создать файл <code>.gitignore</code>. с перечислением шаблонов соответствующих таким файлам.
Вот пример файла <code>.gitignore</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .gitignore
*.[oa]
*~</code></pre>
</div>
</div>
<div class="paragraph">
<p>Первая строка предписывает Git игнорировать любые файлы заканчивающиеся на «.o» или «.a» — объектные и архивные файлы, которые могут появиться во время сборки кода.
Вторая строка предписывает игнорировать все файлы заканчивающиеся на тильду (<code>~</code>), которая используется во многих текстовых редакторах, например Emacs, для обозначения временных файлов.
Вы можете также включить каталоги log, tmp или pid; автоматически создаваемую документацию; и т. д. и т. п.
Хорошая практика заключается в настройке файла <code>.gitignore</code> до того, как начать серьёзно работать, это защитит вас от случайного добавления в репозиторий файлов, которых вы там видеть не хотите.</p>
</div>
<div class="paragraph">
<p>К шаблонам в файле <code>.gitignore</code> применяются следующие правила:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Пустые строки, а также строки, начинающиеся с <code>#</code>, игнорируются.</p>
</li>
<li>
<p>Стандартные шаблоны являются глобальными и применяются рекурсивно для всего дерева каталогов.</p>
</li>
<li>
<p>Чтобы избежать рекурсии используйте символ слеш (/) в начале шаблона.</p>
</li>
<li>
<p>Чтобы исключить каталог добавьте слеш (/) в конец шаблона.</p>
</li>
<li>
<p>Можно инвертировать шаблон, использовав восклицательный знак (!) в качестве первого символа.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Glob-шаблоны представляют собой упрощённые регулярные выражения, используемые командными интерпретаторами.
Символ (<code>*</code>) соответствует 0 или более символам; последовательность <code>[abc]</code> — любому символу из указанных в скобках (в данном примере a, b или c); знак вопроса (<code>?</code>) соответствует одному символу; и квадратные скобки, в которые заключены символы, разделённые дефисом (<code>[0-9]</code>), соответствуют любому символу из интервала (в данном случае от 0 до 9).
Вы также можете использовать две звёздочки, чтобы указать на вложенные каталоги: <code>a/**/z</code> соответствует <code>a/z</code>, <code>a/b/z</code>, <code>a/b/c/z</code>, и так далее.</p>
</div>
<div class="paragraph">
<p>Вот ещё один пример файла <code>.gitignore</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code># Исключить все файлы с расширением .a
*.a

# Но отслеживать файл lib.a даже если он подпадает под исключение выше
!lib.a

# Исключить файл TODO в корневом каталоге, но не файл в subdir/TODO
/TODO

# Игнорировать все файлы в каталоге build/
build/

# Игнорировать файл doc/notes.txt, но не файл doc/server/arch.txt
doc/*.txt

# Игнорировать все .txt файлы в каталоге doc/
doc/**/*.txt</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Подсказка</div>
</td>
<td class="content">
<div class="paragraph">
<p>GitHub поддерживает довольно полный список примеров <code>.gitignore</code> файлов для множества проектов и языков <a href="https://github.com/github/gitignore" class="bare" target="_blank" rel="noopener">https://github.com/github/gitignore</a> это может стать отправной точкой для <code>.gitignore</code> в вашем проекте.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Примечание</div>
</td>
<td class="content">
<div class="paragraph">
<p>В простейшем случае репозиторий будет иметь один файл <code>.gitignore</code> в корневом каталоге, правила из которого будут рекурсивно применяться ко всем подкаталогам.
Так же возможно использовать <code>.gitignore</code> файлы в подкаталогах.
Правила из этих файлов будут применяться только к каталогам, в которых они находятся.
Например, репозиторий исходного кода ядра Linux содержит 206 файлов <code>.gitignore</code>.</p>
</div>
<div class="paragraph">
<p>Детальное рассмотрение использования нескольких <code>.gitignore</code> файлов выходит за пределы этой книги; детали доступны в справке <code>man gitignore</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h3 id="r_git_diff_staged">Просмотр индексированных и неиндексированных изменений</h3>
<div class="paragraph">
<p>Если результат работы команды <code>git status</code> недостаточно информативен для вас — вам хочется знать, что конкретно поменялось, а не только какие файлы были изменены — вы можете использовать команду <code>git diff</code>.
Позже мы рассмотрим команду <code>git diff</code> подробнее; вы, скорее всего, будете использовать эту команду для получения ответов на два вопроса: что вы изменили, но ещё не проиндексировали, и что вы проиндексировали и собираетесь включить в коммит.
Если <code>git status</code> отвечает на эти вопросы в самом общем виде, перечисляя имена файлов, <code>git diff</code> показывает вам непосредственно добавленные и удалённые строки — патч как он есть.</p>
</div>
<div class="paragraph">
<p>Допустим, вы снова изменили и проиндексировали файл <code>README</code>, а затем изменили файл <code>CONTRIBUTING.md</code> без индексирования.
Если вы выполните команду <code>git status</code>, вы опять увидите что-то вроде:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    modified:   README

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы увидеть, что же вы изменили, но пока не проиндексировали, наберите <code>git diff</code> без аргументов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if you patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's</code></pre>
</div>
</div>
<div class="paragraph">
<p>Эта команда сравнивает содержимое вашего рабочего каталога с содержимым индекса.
Результат показывает ещё не проиндексированные изменения.</p>
</div>
<div class="paragraph">
<p>Если вы хотите посмотреть, что вы проиндексировали и что войдёт в следующий коммит, вы можете выполнить <code>git diff --staged</code>.
Эта команда сравнивает ваши проиндексированные изменения с последним коммитом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+My Project</code></pre>
</div>
</div>
<div class="paragraph">
<p>Важно отметить, что <code>git diff</code> сама по себе не показывает все изменения сделанные с последнего коммита — только те, что ещё не проиндексированы.
Такое поведение может сбивать с толку, так как если вы проиндексируете все свои изменения, то <code>git diff</code> ничего не вернёт.</p>
</div>
<div class="paragraph">
<p>Другой пример: вы проиндексировали файл <code>CONTRIBUTING.md</code> и затем изменили его, вы можете использовать <code>git diff</code> для просмотра как проиндексированных изменений в этом файле, так и тех, что пока не проиндексированы.
Если наше окружение выглядит вот так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add CONTRIBUTING.md
$ echo '# test line' &gt;&gt; CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>Используйте <code>git diff</code> для просмотра непроиндексированных изменений</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 643e24f..87f08c8 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -119,3 +119,4 @@ at the
 ## Starter Projects

 See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).
+# test line</code></pre>
</div>
</div>
<div class="paragraph">
<p>а так же <code>git diff --cached</code> для просмотра проиндексированных изменений (<code>--staged</code> и <code>--cached</code> синонимы):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --cached
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if you patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Примечание</div>
</td>
<td class="content">
<div class="title">Git Diff во внешних инструментах</div>
<div class="paragraph">
<p>Мы будем продолжать использовать команду <code>git diff</code> различными способами на протяжении всей книги.
Существует ещё один способ просматривать эти изменения, если вы предпочитаете графический просмотр или внешнюю программу просмотра различий, вместо консоли.
Выполнив команду <code>git difftool</code> вместо <code>git diff</code>, вы сможете просмотреть изменения в файле с помощью таких программ как emerge, vimdiff и других (включая коммерческие продукты).
Выполните <code>git difftool --tool-help</code> чтобы увидеть какие из них уже установлены в вашей системе.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h3 id="r_committing_changes">Коммит изменений</h3>
<div class="paragraph">
<p>Теперь, когда ваш индекс находится в таком состоянии, как вам и хотелось, вы можете зафиксировать свои изменения.
Запомните, всё, что до сих пор не проиндексировано — любые файлы, созданные или изменённые вами, и для которых вы не выполнили <code>git add</code> после редактирования — не войдут в этот коммит.
Они останутся изменёнными файлами на вашем диске.
В нашем случае, когда вы в последний раз выполняли <code>git status</code>, вы видели что всё проиндексировано, и вот, вы готовы к коммиту.
Простейший способ зафиксировать изменения — это набрать <code>git commit</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Эта команда откроет выбранный вами текстовый редактор.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Примечание</div>
</td>
<td class="content">
<div class="paragraph">
<p>Редактор устанавливается переменной окружения <code>EDITOR</code> — обычно это vim или emacs, хотя вы можете установить любой другой с помощью команды <code>git config --global core.editor</code>, как было показано в главе <a href="{{< relurl "book/ru/v2/ch00/ch01-getting-started" >}}">Введение</a>).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>В редакторе будет отображён следующий текст (это пример окна Vim):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code># Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Your branch is up-to-date with 'origin/master'.
#
# Changes to be committed:
#	new file:   README
#	modified:   CONTRIBUTING.md
#
~
~
~
".git/COMMIT_EDITMSG" 9L, 283C</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вы можете видеть, что комментарий по умолчанию для коммита содержит закомментированный результат работы команды <code>git status</code> и ещё одну пустую строку сверху.
Вы можете удалить эти комментарии и набрать своё сообщение или же оставить их для напоминания о том, что вы фиксируете.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Примечание</div>
</td>
<td class="content">
<div class="paragraph">
<p>Для ещё более подробного напоминания, что же именно вы поменяли, можете передать аргумент <code>-v</code> в команду <code>git commit</code>.
Это приведёт к тому, что в комментарий будет также помещена дельта/diff изменений, таким образом вы сможете точно увидеть все изменения которые вы совершили.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Когда вы выходите из редактора, Git создаёт для вас коммит с этим сообщением, удаляя комментарии и вывод команды <code>diff</code>.</p>
</div>
<div class="paragraph">
<p>Есть и другой способ — вы можете набрать свой комментарий к коммиту в командной строке вместе с командой <code>commit</code> указав его после параметра <code>-m</code>, как в следующем примере:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git commit -m "Story 182: fix benchmarks for speed"
[master 463dc4f] Story 182: fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README</code></pre>
</div>
</div>
<div class="paragraph">
<p>Итак, вы создали свой первый коммит!
Вы можете видеть, что коммит вывел вам немного информации о себе: на какую ветку вы выполнили коммит (<code>master</code>), какая контрольная сумма SHA-1 у этого коммита (<code>463dc4f</code>), сколько файлов было изменено, а также статистику по добавленным/удалённым строкам в этом коммите.</p>
</div>
<div class="paragraph">
<p>Запомните, что коммит сохраняет снимок состояния вашего индекса.
Всё, что вы не проиндексировали, так и висит в рабочем каталоге как изменённое; вы можете сделать ещё один коммит, чтобы добавить эти изменения в репозиторий.
Каждый раз, когда вы делаете коммит, вы сохраняете снимок состояния вашего проекта, который позже вы можете восстановить или с которым можно сравнить текущее состояние.</p>
</div>
</div>
<div class="sect3">
<h3 id="_игнорирование_индексации">Игнорирование индексации</h3>
<div class="paragraph">
<p>
Несмотря на то, что индекс может быть удивительно полезным для создания коммитов именно такими, как вам и хотелось, он временами несколько сложнее, чем вам нужно в процессе работы.
Если у вас есть желание пропустить этап индексирования, Git предоставляет простой способ.
Добавление параметра <code>-a</code> в команду <code>git commit</code> заставляет Git автоматически индексировать каждый уже отслеживаемый на момент коммита файл, позволяя вам обойтись без <code>git add</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

no changes added to commit (use "git add" and/or "git commit -a")
$ git commit -a -m 'Add new benchmarks'
[master 83e38c7] Add new benchmarks
 1 file changed, 5 insertions(+), 0 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обратите внимание, что в данном случае перед коммитом вам не нужно выполнять <code>git add</code> для файла <code>CONTRIBUTING.md</code>, потому что флаг <code>-a</code> включает все файлы.
Это удобно, но будьте осторожны: флаг <code>-a</code> может включить в коммит нежелательные изменения.</p>
</div>
</div>
<div class="sect3">
<h3 id="r_removing_files">Удаление файлов</h3>
<div class="paragraph">
<p>
Для того чтобы удалить файл из Git, вам необходимо удалить его из отслеживаемых файлов (точнее, удалить его из вашего индекса) а затем выполнить коммит.
Это позволяет сделать команда <code>git rm</code>, которая также удаляет файл из вашего рабочего каталога, так что в следующий раз вы не увидите его как «неотслеживаемый».</p>
</div>
<div class="paragraph">
<p>Если вы просто удалите файл из своего рабочего каталога, он будет показан в секции «Changes not staged for commit» (изменённые, но не проиндексированные) вывода команды <code>git status</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add/rm &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

        deleted:    PROJECTS.md

no changes added to commit (use "git add" and/or "git commit -a")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Затем, если вы выполните команду <code>git rm</code>, удаление файла попадёт в индекс:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rm PROJECTS.md
rm 'PROJECTS.md'
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    deleted:    PROJECTS.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>После следующего коммита файл исчезнет и больше не будет отслеживаться.
Если вы изменили файл и уже проиндексировали его, вы должны использовать принудительное удаление с помощью параметра <code>-f</code>.
Это сделано для повышения безопасности, чтобы предотвратить ошибочное удаление данных, которые ещё не были записаны в снимок состояния и которые нельзя восстановить из Git.</p>
</div>
<div class="paragraph">
<p>Другая полезная штука, которую вы можете захотеть сделать — это удалить файл из индекса, оставив его при этом в рабочем каталоге.
Другими словами, вы можете захотеть оставить файл на жёстком диске, но перестать отслеживать изменения в нём.
Это особенно полезно, если вы забыли добавить что-то в файл <code>.gitignore</code> и по ошибке проиндексировали, например, большой файл с логами, или кучу промежуточных файлов компиляции.
Чтобы сделать это, используйте опцию <code>--cached</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rm --cached README</code></pre>
</div>
</div>
<div class="paragraph">
<p>В команду <code>git rm</code> можно передавать файлы, каталоги или шаблоны.
Это означает, что вы можете сделать что-то вроде:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rm log/\*.log</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обратите внимание на обратный слеш (<code>\</code>) перед <code>*</code>.
Он необходим из-за того, что Git использует свой собственный обработчик имён файлов вдобавок к обработчику вашего командного интерпретатора.
Эта команда удаляет все файлы, имеющие расширение <code>.log</code> и находящиеся в каталоге <code>log/</code>.
Или же вы можете сделать вот так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rm \*~</code></pre>
</div>
</div>
<div class="paragraph">
<p>Эта команда удаляет все файлы, имена которых заканчиваются на <code>~</code>.</p>
</div>
</div>
<div class="sect3">
<h3 id="r_git_mv">Перемещение файлов</h3>
<div class="paragraph">
<p>
В отличие от многих других систем контроля версий, Git не отслеживает перемещение файлов явно.
Когда вы переименовываете файл в Git, в нём не сохраняется никаких метаданных, говорящих о том, что файл был переименован.
Однако, Git довольно умён в плане обнаружения перемещений постфактум — мы рассмотрим обнаружение перемещения файлов чуть позже.</p>
</div>
<div class="paragraph">
<p>Таким образом, наличие в Git команды <code>mv</code> выглядит несколько странным.
Если вам хочется переименовать файл в Git, вы можете сделать что-то вроде:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git mv file_from file_to</code></pre>
</div>
</div>
<div class="paragraph">
<p>и это отлично сработает.
На самом деле, если вы выполните что-то вроде этого и посмотрите на статус, вы увидите, что Git считает, что произошло переименование файла:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git mv README.md README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    renamed:    README.md -&gt; README</code></pre>
</div>
</div>
<div class="paragraph">
<p>Однако, это эквивалентно выполнению следующих команд:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ mv README.md README
$ git rm README.md
$ git add README</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git неявно определяет, что произошло переименование, поэтому неважно, переименуете вы файл так или используя команду <code>mv</code>.
Единственное отличие состоит лишь в том, что <code>mv</code> — одна команда вместо трёх — это функция для удобства.
Важнее другое — вы можете использовать любой удобный способ для переименования файла, а затем воспользоваться командами <code>add</code> или <code>rm</code> перед коммитом.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>