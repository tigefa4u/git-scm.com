---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: ru
  chapter:
    title: Git изнутри
    number: 10
  section:
    title: Ссылки в Git
    number: 3
    cs_number: '10.3'
    previous: book/ru/v2/Git-изнутри-Объекты-Git
    next: book/ru/v2/Git-изнутри-Pack-файлы
title: Git - Ссылки в Git
url: "/book/ru/v2/Git-изнутри-Ссылки-в-Git.html"
---
<h2 id="r_git_refs">Ссылки в Git</h2>
<div class="paragraph">
<p>Если вас интересует история репозитория начиная с определённого коммита, например <code>1a410e</code>, то для её отображения вы можете воспользоваться командой <code>git log 1a410e</code>, однако при этом вам всё ещё необходимо помнить хеш коммита <code>1a410e</code>, который является начальной точкой истории.
Было бы неплохо, если бы существовал файл, в который можно было бы сохранить значение SHA-1 под простым именем, а затем использовать это имя вместо хеша SHA-1.</p>
</div>
<div class="paragraph">
<p>В Git такие файлы называются ссылками («references» или, сокращённо, «refs») и расположены в каталоге <code>.git/refs</code>.
В нашем проекте этот каталог пока пуст, но в нём уже прослеживается некая структура:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ find .git/refs
.git/refs
.git/refs/heads
.git/refs/tags
$ find .git/refs -type f</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы создать новую ссылку, которая поможет вам запомнить SHA-1 последнего коммита, технически, достаточно выполнить примерно следующее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 1a410efbd13591db07496601ebc7a059dd55cfe9 &gt; .git/refs/heads/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь в командах Git вместо SHA-1 можно использовать только что созданную ссылку:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --pretty=oneline master
1a410efbd13591db07496601ebc7a059dd55cfe9 Third commit
cac0cab538b970a37ea1e769cbbde608743bc96d Second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d First commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Тем не менее, редактировать файлы ссылок вручную не рекомендуется, вместо этого Git предоставляет более безопасную команду <code>update-ref</code> на случай, если вам потребуется изменить ссылку:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вот что такое, по сути, ветка в Git — простой указатель или ссылка на последний коммит в цепочке.
Для создания ветки, соответствующей предыдущему коммиту, можно выполнить следующее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git update-ref refs/heads/test cac0ca</code></pre>
</div>
</div>
<div class="paragraph">
<p>Данная ветка будет содержать лишь коммиты по указанный, но не те, что были созданы после него:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --pretty=oneline test
cac0cab538b970a37ea1e769cbbde608743bc96d Second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d First commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь база данных Git схематично выглядит так, как показано на рисунке:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ru/v2/images/data-model-4.png" >}}" alt="Объекты в каталоге .git, а также указатели на вершины веток">
</div>
<div class="title">Рисунок 150. Объекты в каталоге .git, а также указатели на вершины веток</div>
</div>
<div class="paragraph">
<p>При выполнении команды <code>git branch &lt;branch&gt;</code>, в действительности Git запускает команду <code>update-ref</code>, которая добавляет SHA-1 хеш последнего коммита текущей ветки в файл с именем указанной ветки.</p>
</div>
<div class="sect3">
<h3 id="r_the_head">HEAD</h3>
<div class="paragraph">
<p>Как же Git получает хеш последнего коммита при выполнении <code>git branch &lt;имя ветки&gt;</code>?
Ответ кроется в файле HEAD.</p>
</div>
<div class="paragraph">
<p>Файл HEAD — это символическая ссылка на текущую ветку.
Символическая ссылка отличается от обычной тем, что она содержит не сам хеш SHA-1, а указатель на другую ссылку.</p>
</div>
<div class="paragraph">
<p>В некоторых случаях файл HEAD может содержать SHA-1 хеш какого-либо объекта.
Это происходит при извлечении тега, коммита или удалённой ветки, что приводит репозиторий в состояние <a href="https://git-scm.com/docs/git-checkout#_detached_head" target="_blank" rel="noopener">"detached HEAD"</a>.</p>
</div>
<div class="paragraph">
<p>Если вы заглянете внутрь HEAD, то увидите следующее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .git/HEAD
ref: refs/heads/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если выполнить <code>git checkout test</code>, Git обновит содержимое файла:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .git/HEAD
ref: refs/heads/test</code></pre>
</div>
</div>
<div class="paragraph">
<p>При выполнении <code>git commit</code> Git создаёт коммит, указывая его родителем объект, SHA-1 которого содержится в файле, на который ссылается HEAD.</p>
</div>
<div class="paragraph">
<p>При желании, можно вручную редактировать этот файл, но лучше использовать команду <code>symbolic-ref</code>.
Получить значение HEAD этой командой можно так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git symbolic-ref HEAD
refs/heads/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Изменить значение HEAD можно так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git symbolic-ref HEAD refs/heads/test
$ cat .git/HEAD
ref: refs/heads/test</code></pre>
</div>
</div>
<div class="paragraph">
<p>Символическую ссылку на файл вне <code>.git/refs</code> поставить нельзя:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git symbolic-ref HEAD test
fatal: Refusing to point HEAD outside of refs/</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_теги">Теги</h3>
<div class="paragraph">
<p>Мы рассмотрели три основных типа объектов Git, но есть ещё один.
Объект тега очень похож на объект коммита: он содержит имя своего автора, дату, сообщение и указатель.
Разница же в том, что объект тега указывает на коммит, а не на дерево.
Он похож на ветку, которая никогда не перемещается: он всегда указывает на один и тот же коммит, просто давая ему понятное имя.</p>
</div>
<div class="paragraph">
<p>Как мы знаем из главы <a href="{{< relurl "book/ru/v2/ch00/ch02-git-basics-chapter" >}}">Основы Git</a>, теги бывают двух типов: аннотированные и легковесные.
Легковесный тег можно создать следующей командой:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вот и всё, легковесный тег — это ветка, которая никогда не перемещается.
Аннотированный тег имеет более сложную структуру.
При создании аннотированного тега Git создаёт специальный объект и указывающую на него ссылку, а не просто указатель на коммит.
Мы можем увидеть это, создав аннотированный тег, используя опцию <code>-a</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m 'Test tag'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вот значение SHA-1 созданного объекта:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .git/refs/tags/v1.1
9585191f37f7b0fb9444f35a9bf50de191beadc2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь выполним <code>git cat-file -p</code> для этого хеша:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2
object 1a410efbd13591db07496601ebc7a059dd55cfe9
type commit
tag v1.1
tagger Scott Chacon &lt;schacon@gmail.com&gt; Sat May 23 16:48:58 2009 -0700

Test tag</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обратите внимание, что в поле <code>object</code> записан SHA-1 помеченного коммита.
Также стоит отметить, что это поле не обязательно должно указывать на коммит; вы можете пометить любой объект в Git.
Например, в исходниках Git сопровождающий проекта добавил свой публичный GPG-ключ в блоб и пометил его.
Увидеть этот ключ можно, выполнив команду:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file blob junio-gpg-pub</code></pre>
</div>
</div>
<div class="paragraph">
<p>В репозитории ядра Linux также есть тег, указывающий не на коммит: самый первый тег указывает на дерево первичного импорта.</p>
</div>
</div>
<div class="sect3">
<h3 id="_ссылки_на_удалённые_ветки">Ссылки на удалённые ветки</h3>
<div class="paragraph">
<p>Третий тип ссылок, который мы рассмотрим — ссылки на удалённые ветки.
Если вы добавили удалённый репозиторий и отправили в него какие-нибудь изменения, Git сохранит последнее отправленное значение SHA-1 в каталоге <code>refs/remotes</code> для каждой отправленной ветки.
Например, можно добавить удалённый репозиторий <code>origin</code> и отправить туда ветку <code>master</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add origin git@github.com:schacon/simplegit-progit.git
$ git push origin master
Counting objects: 11, done.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (7/7), 716 bytes, done.
Total 7 (delta 2), reused 4 (delta 1)
To git@github.com:schacon/simplegit-progit.git
  a11bef0..ca82a6d  master -&gt; master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Позже вы сможете посмотреть, где находилась ветка <code>master</code> с сервера <code>origin</code> во время последней синхронизации с ним, заглянув в файл <code>refs/remotes/origin/master</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .git/refs/remotes/origin/master
ca82a6dff817ec66f44342007202690a93763949</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ссылки на удалённые ветки отличаются от веток (ссылок в <code>refs/heads</code>) тем, что они считаются неизменяемыми.
Это означает, что вы можете переключиться на любую из таких веток с помощью <code>git checkout</code>, но Git не установит HEAD на неё, а значит вы не сможете фиксировать свои изменения в ней с помощью <code>git commit</code>.
Git воспринимает удалённые ветки как закладки на последние известные состояния веток на удалённых серверах.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>