---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: ru
  chapter:
    title: Git на сервере
    number: 4
  section:
    title: Протоколы
    number: 1
    cs_number: '4.1'
    previous: book/ru/v2/Ветвление-в-Git-Заключение
    next: book/ru/v2/Git-на-сервере-Установка-Git-на-сервер
title: Git - Протоколы
url: "/book/ru/v2/Git-на-сервере-Протоколы.html"
---
<p>
К этому моменту вы уже должны уметь делать большую часть повседневных задач, для которых вы будете использовать Git.
Однако, для совместной работы в Git, вам необходим удалённый репозиторий.
Несмотря на то, что технически вы можете отправлять и забирать изменения непосредственно из личных репозиториев, делать это не рекомендуется.
Вы легко можете испортить то, над чем работают другие, если не будете аккуратны.
К тому же, вам бы наверняка хотелось, чтобы остальные имели доступ к репозиторию даже если ваш компьютер выключен, поэтому наличие более надёжного репозитория обычно весьма полезно.
Предпочтительный метод взаимодействия с кем-либо — это создание промежуточного репозитория, к которому вы оба будете иметь доступ, и отправка и получение изменений через него.</p><p>Запустить Git-сервер достаточно просто.
Для начала следует выбрать протокол, который вы будете использовать для связи с сервером.
Доступные протоколы с их достоинствами и недостатками описываются в первой части этой главы.
Следующие части освещают базовые конфигурации с использованием этих протоколов, а также настройку вашего сервера для работы с ними.
Далее мы рассмотрим несколько вариантов готового хостинга, которые можно использовать, если вы не против разместить ваш код на чужом сервере и не хотите мучиться с настройками и поддержкой вашего собственного сервера.</p><p>Если вас не интересует настройка собственного сервера, вы можете перейти сразу к последней части этой главы для настройки аккаунта на Git-хостинге, а затем перейти к следующей главе, где мы обсудим различные аспекты работы с распределённой системой контроля версий.</p><p>Удалённый репозиторий — это обычно <em>голый (чистый, bare) репозиторий</em> — репозиторий Git, не имеющий рабочего каталога.
Поскольку этот репозиторий используется только для обмена, то нет причин создавать рабочую копию файлов на диске — достаточно хранить только данные Git.</p><p>Проще говоря, голый репозиторий содержит только каталог <code>.git</code> вашего проекта и ничего больше.</p>
<h2 id="_протоколы">Протоколы</h2>
<div class="paragraph">
<p>Git умеет работать с четырьмя сетевыми протоколами для передачи данных: локальный, HTTP, Secure Shell (SSH) и Git.
В этой части мы обсудим каждый из них и в каких случаях стоит или не стоит его использовать.</p>
</div>
<div class="sect3">
<h3 id="_локальный_протокол">Локальный протокол</h3>
<div class="paragraph">
<p>
Базовым протоколом является <em>Локальный протокол</em>, для которого удалённый репозиторий — это другой каталог на диске.
Наиболее часто он используется, если все члены команды имеют доступ к общей файловой системе, например к <a href="https://ru.wikipedia.org/wiki/Network_File_System" target="_blank" rel="noopener">NFS</a>, или, что менее вероятно, когда все работают на одном компьютере.
Последний вариант не идеален, поскольку все копии вашего репозитория находятся на одном компьютере, что резко увеличивает вероятность потерять всё.</p>
</div>
<div class="paragraph">
<p>Если у вас смонтирована общая файловая система, вы можете клонировать, отправлять и получать изменения из локального репозитория.
Чтобы клонировать такой репозиторий или добавить его в качестве удалённого в существующий проект, используйте путь к репозиторию в качестве URL.
Например, для клонирования локального репозитория вы можете выполнить что-то вроде этого:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone /srv/git/project.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Или этого:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone file:///srv/git/project.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git работает немного по-другому, если вы явно укажете префикс <code>file://</code> в начале вашего URL.
Когда вы просто указываете путь, Git пытается использовать жёсткие ссылки или копировать необходимые файлы.
Если вы указываете <code>file://</code>, Git работает с данными так же, как при использовании сетевых протоколов, что снижает эффективность передачи данных.
Причиной для использования <code>file://</code> может быть необходимость создания чистой копии репозитория без лишних внешних ссылок и объектов, обычно после импорта из другой системы управления версиями или чего-то похожего (задачи по обслуживанию рассмотрены в главе <a href="{{< relurl "book/ru/v2/ch00/ch10-git-internals" >}}">Git изнутри</a>).
Мы будем использовать обычные пути, поскольку это практически всегда быстрее.</p>
</div>
<div class="paragraph">
<p>Чтобы добавить локальный репозиторий в существующий проект, вы можете воспользоваться командой:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add local_proj /srv/git/project.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь вы можете отправлять и получать изменения из этого репозитория так, как вы это делали по сети.</p>
</div>
<div class="sect4">
<h4 id="_достоинства">Достоинства</h4>
<div class="paragraph">
<p>Преимущества основанных на файлах репозиториев в том, что они просты и используют существующие разграничения прав на файлы и сетевой доступ.
Если у вас уже есть общая файловая система, доступ к которой имеет вся команда, настройка репозитория очень проста.
Вы помещаете голый репозиторий туда, куда все имеют доступ, и выставляете права на чтение и запись, как вы бы это сделали для любого другого общего каталога.
Мы обсудим, как экспортировать голую копию репозитория для этой цели, в следующем разделе: <a href="{{< relurl "book/ru/v2/ch00/r_git_on_the_server" >}}">Установка Git на сервер</a>.</p>
</div>
<div class="paragraph">
<p>Также это хорошая возможность быстро получить наработки из чьего-то рабочего репозитория.
Если вы и ваш коллега работаете над одним и тем же проектом, и он хочет, чтобы вы что-то проверили, то запуск команды вроде <code>git pull /home/john/project</code> зачастую проще, чем отправлять и забирать с удалённого сервера.</p>
</div>
</div>
<div class="sect4">
<h4 id="_недостатки">Недостатки</h4>
<div class="paragraph">
<p>Недостаток этого метода в том, что общий доступ обычно сложнее настроить и получить из разных мест, чем простой сетевой доступ.
Если вы хотите отправлять со своего ноутбука находясь дома, вы должны смонтировать удалённый диск, что может оказаться сложнее и медленнее, чем доступ по сети.</p>
</div>
<div class="paragraph">
<p>Также важно упомянуть, что не всегда использование общей точки монтирования является быстрейшим вариантом.
Локальный репозиторий быстр, только если вы имеете быстрый доступ к данным.
Репозиторий на NFS часто медленнее, чем репозиторий через SSH на том же сервере, позволяющий Git использовать на полную локальные диски на каждой системе.</p>
</div>
<div class="paragraph">
<p>Наконец, этот протокол не защищает репозиторий от случайного повреждения.
Все пользователи имеют доступ к «удалённому» каталогу и ничего не мешает изменению или удалению внутренних файлов Git и, как следствие, повреждению репозитория.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_протоколы_http">Протоколы HTTP</h3>
<div class="paragraph">
<p>Git может работать через HTTP в двух различных режимах.
До версии Git 1.6.6 был только один режим, очень простой и предназначенный только для чтения.
В версии 1.6.6 появился новый, более умный режим, позволяющий Git более интеллектуально определять необходимость передачи данных, наподобие того, как это происходит при использовании SSH.
В последние годы новый протокол стал очень популярен, так как он проще для пользователя и более эффективен.
Новая версия часто называется <em>Умным</em> (<em>Smart</em>) HTTP, а старая <em>Тупым</em> (<em>Dumb</em>) HTTP.
Сначала мы рассмотрим Умный протокол.</p>
</div>
<div class="sect4">
<h4 id="_умный_http">Умный HTTP</h4>
<div class="paragraph">
<p>
«Умный» протокол HTTP работает схожим с SSH или Git-протоколами образом, но поверх стандартных HTTP/S портов и может использовать различные механизмы аутентификации HTTP, это часто проще для пользователя, чем что-то вроде SSH, так как можно использовать аутентификацию по логину/паролю вместо установки SSH-ключей.</p>
</div>
<div class="paragraph">
<p>Наверное, сейчас он стал наиболее популярным способом использования Git, так как может использоваться и для анонимного доступа как протокол <code>git://</code>, и для отправки изменений с аутентификацией и шифрованием как протокол SSH.
Вместо использования разных адресов URL для этих целей, можно использовать один URL адрес для всего.
Если вы пытаетесь отослать изменения и репозиторий требует аутентификации (обычно так и есть), сервер может спросить логин и пароль.
То же касается и доступа на чтение.</p>
</div>
<div class="paragraph">
<p>На самом деле для сервисов вроде GitHub, адрес URL, который вы используете для просмотра репозитория в браузере (например, <a href="https://github.com/schacon/simplegit" class="bare" target="_blank" rel="noopener">https://github.com/schacon/simplegit</a>), можно использовать для клонирования или, если у вас есть доступ, для отправки изменений.</p>
</div>
</div>
<div class="sect4">
<h4 id="_тупой_http">Тупой HTTP</h4>
<div class="paragraph">
<p>
Если сервер не отвечает на умный запрос Git по HTTP, клиент Git попытается откатиться на более простой <em>Тупой</em> HTTP-протокол.
Тупой протокол ожидает, что голый репозиторий Git будет обслуживаться веб-сервером как набор файлов.
Прелесть тупого протокола HTTP — в простоте настройки.
По сути, всё, что необходимо сделать — поместить голый репозиторий в корневой каталог HTTP и установить обработчик <code>post-update</code> (смотри <a href="{{< relurl "book/ru/v2/ch00/r_git_hooks" >}}">Хуки в Git</a>).
Теперь каждый может клонировать репозиторий, если имеет доступ к веб-серверу, на котором он был размещен.
Таким образом, чтобы открыть доступ на чтение к вашему репозиторию посредством HTTP, нужно сделать что-то наподобие этого:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cd /var/www/htdocs/
$ git clone --bare /path/to/git_project gitproject.git
$ cd gitproject.git
$ mv hooks/post-update.sample hooks/post-update
$ chmod a+x hooks/post-update</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вот и всё.
Обработчик <code>post-update</code>, входящий в состав Git по умолчанию, выполняет необходимую команду (<code>git update-server-info</code>), чтобы получение изменений и клонирование по HTTP работали правильно.
Эта команда выполняется, когда вы отправляете изменения в репозиторий (возможно посредством SSH); затем остальные могут клонировать его командой</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone https://example.com/gitproject.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>В рассмотренном примере мы использовали каталог <code>/var/www/htdocs</code>, обычно используемый сервером Apache, но вы можете использовать любой веб-сервер, отдающий статические данные, расположив голый репозиторий в нужном каталоге.
Данные Git представляют собой обычные файлы (в главе <a href="{{< relurl "book/ru/v2/ch00/ch10-git-internals" >}}">Git изнутри</a> приведены детали отдачи таких файлов).</p>
</div>
<div class="paragraph">
<p>Чаще всего вы будете использовать Умный HTTP для чтения/записи, либо Тупой только для чтения.
Случай совместного их использования встречаются редко.</p>
</div>
</div>
<div class="sect4">
<h4 id="_достоинства_2">Достоинства</h4>
<div class="paragraph">
<p>Мы сосредоточимся на преимуществах Умной версии протокола HTTP.</p>
</div>
<div class="paragraph">
<p>Простота использования одного адреса URL для всех типов доступа и аутентификации только при необходимости упрощает работу для конечного пользователя.
Возможность аутентификации посредством логина и пароля также даёт преимущество перед SSH, так как пользователям перед использованием не нужно создавать SSH-ключи и загружать публичный ключ на сервер.
Для неопытных пользователей или пользователей систем, где SSH мало распространён, это большой плюс.
Это также очень быстрый и эффективный протокол, сравнимый с SSH.</p>
</div>
<div class="paragraph">
<p>Вы также можете предоставлять доступ к своим репозиториям только для чтения по HTTPS, шифруя содержимое передачи; или вы можете зайти так далеко, что клиенты будут использовать персональные подписанные SSL-сертификаты.</p>
</div>
<div class="paragraph">
<p>Другой плюс в том, что HTTP/S очень распространённые протоколы и корпоративные брандмауэры часто настроены для разрешения их работы.</p>
</div>
</div>
<div class="sect4">
<h4 id="_недостатки_2">Недостатки</h4>
<div class="paragraph">
<p>На некоторых серверах Git поверх HTTP/S может быть немного сложнее в настройке по сравнению с SSH.
Кроме этого, преимущества других протоколов доступа к Git перед Умным HTTP незначительны.</p>
</div>
<div class="paragraph">
<p>Если вы используете HTTP для аутентифицированной отправки изменений, ввод учётных данных зачастую сложнее, чем при использовании SSH-ключей.
Но есть несколько инструментов для кеширования учётных данных, включая Keychain access на OSX и Credential Manager на Windows, которые вы можете использовать для упрощения процесса.
В разделе <a href="{{< relurl "book/ru/v2/ch00/r_credential_caching" >}}">Хранилище учётных данных</a> главы 7 рассказывается как настроить безопасное кэширование пароля в вашей системе.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_протокол_ssh">Протокол SSH</h3>
<div class="paragraph">
<p>
Часто используемый транспортный протокол для самостоятельного хостинга Git — это SSH.
Причина этого в том, что доступ по SSH уже есть на многих серверах, а если его нет, то его очень легко настроить.
К тому же, SSH — протокол с аутентификацией, и его благодаря распространённости обычно легко настроить и использовать.</p>
</div>
<div class="paragraph">
<p>Чтобы клонировать Git-репозиторий по SSH, вы можете указать префикс <code>ssh://</code> в URL, например:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone ssh://[user@]server/project.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Или можно использовать для протокола SSH краткий синтаксис наподобие scp:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone [user@]server:project.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Также вы можете не указывать имя пользователя, Git будет использовать то, под которым вы вошли в систему.</p>
</div>
<div class="sect4">
<h4 id="_достоинства_3">Достоинства</h4>
<div class="paragraph">
<p>SSH имеет множество достоинств.
Во-первых, SSH достаточно легко настроить — демоны SSH распространены, многие системные администраторы имеют опыт работы с ними и во многих дистрибутивах они предустановлены или есть утилиты для управления ими.
Далее, доступ по SSH безопасен — данные передаются зашифрованными по авторизованным каналам.
Наконец, так же как и протоколы HTTP/S, Git и локальный протокол, SSH эффективен благодаря максимальному сжатию данных перед передачей.</p>
</div>
</div>
<div class="sect4">
<h4 id="_недостатки_3">Недостатки</h4>
<div class="paragraph">
<p>Недостаток SSH в том, что, используя его, вы не можете обеспечить анонимный доступ к репозиторию.
Клиенты <em>должны</em> иметь доступ к машине по SSH, даже для работы в режиме только на чтение, что делает SSH неподходящим для проектов с открытым исходным кодом.
Если вы используете Git только внутри корпоративной сети, то, возможно, SSH — единственный протокол, с которым вам придётся иметь дело.
Если же вам нужен анонимный доступ на чтение для своих проектов, придётся настроить SSH для себя, чтобы выкладывать изменения, и что-нибудь другое для других, для скачивания.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_git_протокол">Git-протокол</h3>
<div class="paragraph">
<p>
Следующий протокол — Git-протокол.
Вместе с Git поставляется специальный демон, который слушает отдельный порт (9418) и предоставляет сервис, схожий с протоколом SSH, но абсолютно без аутентификации.
Чтобы использовать Git-протокол для репозитория, вы должны создать файл <code>git-export-daemon-ok</code>, иначе демон не будет работать с этим репозиторием, но следует помнить, что в протоколе отсутствуют средства безопасности.
Соответственно, любой репозиторий в Git может быть либо доступен для клонирования всем, либо нет.
Как следствие, обычно отправлять изменения по этому протоколу нельзя.
Вы можете открыть доступ на запись, но из-за отсутствия аутентификации в этом случае кто угодно, зная URL вашего проекта, сможет его изменить.
В общем, это редко используемая возможность.</p>
</div>
<div class="sect4">
<h4 id="_достоинства_4">Достоинства</h4>
<div class="paragraph">
<p>Git-протокол ― часто самый быстрый из доступных протоколов.
Если у вас проект с публичным доступом и большой трафик, или у вас очень большой проект, для которого не требуется аутентификация пользователей для чтения, вам стоит настроить демон Git для вашего проекта.
Он использует тот же механизм передачи данных, что и протокол SSH, но без дополнительных затрат на шифрование и аутентификацию.</p>
</div>
</div>
<div class="sect4">
<h4 id="_недостатки_4">Недостатки</h4>
<div class="paragraph">
<p>Недостатком Git-протокола является отсутствие аутентификации.
Поэтому обычно не следует использовать этот протокол как единственный способ доступа к вашему проекту.
Обычно он используется в паре с SSH или HTTPS для нескольких разработчиков, имеющих доступ на запись, тогда как все остальные используют <code>git://</code> с доступом только на чтение.
Кроме того, это, вероятно, самый сложный для настройки протокол.
Вы должны запустить отдельный демон, для чего необходимо дополнительно настраивать <code>xinetd</code> или <code>systemd</code> или им подобные, что не всегда легко сделать.
Также необходимо, чтобы сетевой экран позволял доступ на порт 9418, который не относится к стандартным портам, всегда разрешённым в корпоративных брандмауэрах.
За сетевыми экранами крупных корпораций этот неизвестный порт часто заблокирован.</p>
</div>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>