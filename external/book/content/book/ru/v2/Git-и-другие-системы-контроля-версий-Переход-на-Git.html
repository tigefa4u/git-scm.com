---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: ru
  chapter:
    title: Git и другие системы контроля версий
    number: 9
  section:
    title: Переход на Git
    number: 2
    cs_number: '9.2'
    previous: book/ru/v2/Git-и-другие-системы-контроля-версий-Git-как-клиент
    next: book/ru/v2/Git-и-другие-системы-контроля-версий-Заключение
title: Git - Переход на Git
url: "/book/ru/v2/Git-и-другие-системы-контроля-версий-Переход-на-Git.html"
---
<h2 id="r_migrating">Переход на Git</h2>
<div class="paragraph">
<p>
Если у вас уже есть кодовая база в другой системе контроля версий, но вы решили начать использовать Git, вам необходимо перенести проект тем или иным способом.
В этом разделе описаны некоторые существующие варианты импорта для распространённых систем, а затем показано, как разрабатывать собственные нестандартные варианты импорта.
Вы узнаете, как импортировать данные из некоторых основных профессионально используемых систем контроля версий, так как они используются большинством разработчиков, желающих переключиться на использование Git, а так же для них легко найти качественные инструменты миграции.</p>
</div>
<div class="sect3">
<h3 id="_subversion">Subversion</h3>
<div class="paragraph">
<p>

Если вы читали предыдущий раздел про использование <code>git svn</code>, вы уже должны знать, как использовать команду <code>git svn clone</code> чтобы клонировать Subversion репозиторий.
После этого вы можете прекратить использовать Subversion и перейти на Git.
Сразу же после клонирования вам будет доступна вся история репозитория, хотя сам процесс получения копии может затянуться.</p>
</div>
<div class="paragraph">
<p>Вдобавок к этому, импортирование не идеально, так что вы, возможно, захотите сделать его как можно более правильно с первой попытки.
И первая проблема — это информация об авторстве.
В Subversion на каждого участника рабочего процесса заведён пользователь, информация о пользователе сохраняется вместе с каждой ревизией.
В предыдущем разделе вы могли видеть пользователя <code>schacon</code> в некоторых местах, типа вывода команды <code>blame</code> или <code>git svn log</code>.
Если вы хотите видеть подробную информацию об авторстве в Git, вам потребуется задать соответствие между пользователями Subversion и авторами в Git.
Создайте файл <code>users.txt</code> со следующим содержимым:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>schacon = Scott Chacon &lt;schacon@geemail.com&gt;
selse = Someo Nelse &lt;selse@geemail.com&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы получить список имён пользователей в SVN, выполните следующее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ svn log --xml --quiet | grep author | sort -u | \
  perl -pe 's/.*&gt;(.*?)&lt;.*/$1 = /'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Эта команда выводит историю коммитов в формате XML, затем оставляет только строки с информацией об авторе, удаляет дубликаты и обрезает XML-теги.
Естественно, она сработает только на компьютерах с установленными <code>grep</code>, <code>sort</code> и <code>perl</code>.
Перенаправив вывод этой команды в файл <code>users.txt</code>, вам останется только дописать в каждой строке соответствующих авторов для Git.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Примечание</div>
</td>
<td class="content">
<div class="paragraph">
<p>Если вы пытаетесь выполнить это на компьютере с Windows, то у вас может возникнуть ряд проблем.
Однако, Microsoft предоставила несколько полезных советов по миграции <a href="https://docs.microsoft.com/en-us/azure/devops/repos/git/perform-migration-from-svn-to-git" class="bare" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/azure/devops/repos/git/perform-migration-from-svn-to-git</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Для точного сопоставления авторов коммитов передайте файл <code>users.txt</code> команде <code>git svn</code>.
Добавив флаг <code>--no-metadata</code> в команды <code>clone</code> или <code>init</code>, можно указать <code>git svn</code> исключить импорт метаданных, которые импортируются по умолчанию.
Как часть метаданных, <code>git-svn-id</code> включается в каждое сообщение коммита, генерируемое Git при импорте, что может привести к необоснованному увеличению истории и сделать её более запутанной.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Примечание</div>
</td>
<td class="content">
<div class="paragraph">
<p>Метаданные следует сохранять, если вы планируете отправлять коммиты из Git обратно в SVN репозиторий.
Если полной синхронизации не требуется, то спокойно добавляйте параметр <code>--no-metadata</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>В результате, команда <code>import</code> примет вид:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn clone http://my-project.googlecode.com/svn/ \
      --authors-file=users.txt --no-metadata --prefix "" -s my_project
$ cd my_project</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь у вас будет красивая копия репозитория Subversion в каталоге <code>my_project</code>.
Вместо коммитов типа</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>commit 37efa680e8473b615de980fa935944215428a35a
Author: schacon &lt;schacon@4c93b258-373f-11de-be05-5f7a86268029&gt;
Date:   Sun May 3 00:12:22 2009 +0000

    fixed install - go to trunk

    git-svn-id: https://my-project.googlecode.com/svn/trunk@94 4c93b258-373f-11de-
    be05-5f7a86268029</code></pre>
</div>
</div>
<div class="paragraph">
<p>вы получите следующее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>commit 03a8785f44c8ea5cdb0e8834b7c8e6c469be2ff2
Author: Scott Chacon &lt;schacon@geemail.com&gt;
Date:   Sun May 3 00:12:22 2009 +0000

    fixed install - go to trunk</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь не только поле <code>Author</code> выглядит лучше, но и <code>git-svn-id</code> не мозолит глаза.</p>
</div>
<div class="paragraph">
<p>Также вам следует немного почистить репозиторий сразу после импорта.
Во-первых, следует удалить ненужные ссылки, устанавливаемые <code>git svn</code>.
Для начала, переместим теги, потому как в действительности это теги, а не странные удалённые ветки; затем все удалённые ветки сделаем локальными.</p>
</div>
<div class="paragraph">
<p>Чтобы переместить теги, выполните следующую команду:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ for t in $(git for-each-ref --format='%(refname:short)' refs/remotes/tags); do git tag ${t/tags\//} $t &amp;&amp; git branch -D -r $t; done</code></pre>
</div>
</div>
<div class="paragraph">
<p>Эта команда берёт ссылки на удалённые ветки, которые располагаются в <code>refs/remotes/tags/</code>, и делает их настоящими (легковесными) тегами.</p>
</div>
<div class="paragraph">
<p>Затем, переместим оставшиеся ссылки из <code>refs/remotes</code>, чтобы сделать из них локальные ветки:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ for b in $(git for-each-ref --format='%(refname:short)' refs/remotes); do git branch $b refs/remotes/$b &amp;&amp; git branch -D -r $b; done</code></pre>
</div>
</div>
<div class="paragraph">
<p>Возможно, для одной ветки Subversion будут созданы дополнительные ветки с суффиксом <code>@xxx</code> (где ххх — это число).
Это связано с особенностью Subversion, которая называется «peg-revisions», для которой Git не имеет синтаксического аналога.
Поэтому, <code>git svn</code> просто добавляет номер версии svn в название ветки, точно так же как вы бы это сделали в svn при добавлении peg-revision для ветки.
Если эти ревизии вам больше не нужны, то просто удалите их используя команду:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ for p in $(git for-each-ref --format='%(refname:short)' | grep @); do git branch -D $p; done</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь все ветки стали настоящими Git ветками, а теги — настоящими Git тегами.</p>
</div>
<div class="paragraph">
<p>К сожалению, <code>git svn</code> создаёт дополнительную ветку с названием <code>trunk</code>, которая соответствует ветке по умолчанию в Subversion и аналогична ветке <code>master</code>.
Так как <code>master</code> больше подходит для Git, удалим лишнюю ветку:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch -d trunk</code></pre>
</div>
</div>
<div class="paragraph">
<p>Последнее, что нужно сделать — это добавить ваш Git сервер в качестве удалённого репозитория и залить данные на него.
Вот пример добавления удалённого репозитория:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add origin git@my-git-server:myrepository.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Так как вы хотите отправить все ваши ветки и теги, выполите следующие команды:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git push origin --all
$ git push origin --tags</code></pre>
</div>
</div>
<div class="paragraph">
<p>Наконец, все ваши ветки и теги перенесены на Git сервер и облагорожены!</p>
</div>
</div>
<div class="sect3">
<h3 id="_mercurial">Mercurial</h3>
<div class="paragraph">
<p>
Из-за того что Mercurial и Git обладают похожей моделью ветвления, а также из-за того что Git несколько более гибок, перенос репозитория из Mercurial в Git довольно прост; можете использовать инструмент <code>hg-fast-export</code>, который можно найти здесь:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone https://github.com/frej/fast-export.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Первым делом нужно получить полную копию интересующего Mercurial репозитория:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ hg clone &lt;remote repo URL&gt; /tmp/hg-repo</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следующим шагом создадим файл соответствия авторов.
Mercurial менее строг к данным об авторстве коммитов, так что придётся слегка навести порядок.
Вот однострочный скрипт на <code>bash</code>, который генерирует заготовку:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cd /tmp/hg-repo
$ hg log | grep user: | sort | uniq | sed 's/user: *//' &gt; ../authors</code></pre>
</div>
</div>
<div class="paragraph">
<p>Пройдёт несколько секунд, в зависимости от размера репозитория, и вы получите файл <code>/tmp/authors</code> со следующим содержимым:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>bob
bob@localhost
bob &lt;bob@company.com&gt;
bob jones &lt;bob &lt;AT&gt; company &lt;DOT&gt; com&gt;
Bob Jones &lt;bob@company.com&gt;
Joe Smith &lt;joe@company.com&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>В примере выше, один и тот же человек (Боб) вносил изменения под пятью различными именами, лишь одно из которых правильное, а одно и вовсе не соответствует формату Git.
<code>hg-fast-export</code> позволяет быстро исправить ситуацию, преобразовав каждую строку в правило: <code>"&lt;input&gt;"="&lt;output&gt;"</code>, где <code>&lt;input&gt;</code> преобразуется в <code>&lt;output&gt;</code>.
Строки <code>&lt;input&gt;</code> и <code>&lt;output&gt;</code> могут содержать экранированные последовательности, поддерживаемые кодировкой python <code>string_escape</code>.
Если файл сопоставлений авторов коммитов не содержит соответствующего <code>&lt;input&gt;</code>, то значение будет передано Git без модификации.
Если же все имена выглядят хорошо, этот файл и вовсе не потребуется.
В нашем примере мы хотим чтобы файл выглядел так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>"bob"="Bob Jones &lt;bob@company.com&gt;"
"bob@localhost"="Bob Jones &lt;bob@company.com&gt;"
"bob &lt;bob@company.com&gt;"="Bob Jones &lt;bob@company.com&gt;"
"bob jones &lt;bob &lt;AT&gt; company &lt;DOT&gt; com&gt;"="Bob Jones &lt;bob@company.com&gt;"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Аналогичные файлы применяются для переименования веток и тегов, когда сохранённое в Mercurial название недопустимо в Git.</p>
</div>
<div class="paragraph">
<p>Затем нужно создать Git репозиторий и запустить экспорт:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git init /tmp/converted
$ cd /tmp/converted
$ /tmp/fast-export/hg-fast-export.sh -r /tmp/hg-repo -A /tmp/authors</code></pre>
</div>
</div>
<div class="paragraph">
<p>Флаг <code>-r</code> указывает на подлежащий конвертации Mercurial репозиторий, а флаг <code>-A</code> задаёт файл с соответствиями между авторами.
Скрипт пробегается по наборам изменений Mercurial и преобразует их в скрипт для <code>fast-import</code> в Git (мы поговорим об этом инструменте чуть позже).
Процесс конвертации займёт некоторое время (хотя и <em>намного</em> меньше, чем при конвертации по сети), а мы пока можем наблюдать за подробным выводом в консоли:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ /tmp/fast-export/hg-fast-export.sh -r /tmp/hg-repo -A /tmp/authors
Loaded 4 authors
master: Exporting full revision 1/22208 with 13/0/0 added/changed/removed files
master: Exporting simple delta revision 2/22208 with 1/1/0 added/changed/removed files
master: Exporting simple delta revision 3/22208 with 0/1/0 added/changed/removed files
[…]
master: Exporting simple delta revision 22206/22208 with 0/4/0 added/changed/removed files
master: Exporting simple delta revision 22207/22208 with 0/2/0 added/changed/removed files
master: Exporting thorough delta revision 22208/22208 with 3/213/0 added/changed/removed files
Exporting tag [0.4c] at [hg r9] [git :10]
Exporting tag [0.4d] at [hg r16] [git :17]
[…]
Exporting tag [3.1-rc] at [hg r21926] [git :21927]
Exporting tag [3.1] at [hg r21973] [git :21974]
Issued 22315 commands
git-fast-import statistics:
---------------------------------------------------------------------
Alloc'd objects:     120000
Total objects:       115032 (    208171 duplicates                  )
      blobs  :        40504 (    205320 duplicates      26117 deltas of      39602 attempts)
      trees  :        52320 (      2851 duplicates      47467 deltas of      47599 attempts)
      commits:        22208 (         0 duplicates          0 deltas of          0 attempts)
      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)
Total branches:         109 (         2 loads     )
      marks:        1048576 (     22208 unique    )
      atoms:           1952
Memory total:          7860 KiB
       pools:          2235 KiB
     objects:          5625 KiB
---------------------------------------------------------------------
pack_report: getpagesize()            =       4096
pack_report: core.packedGitWindowSize = 1073741824
pack_report: core.packedGitLimit      = 8589934592
pack_report: pack_used_ctr            =      90430
pack_report: pack_mmap_calls          =      46771
pack_report: pack_open_windows        =          1 /          1
pack_report: pack_mapped              =  340852700 /  340852700
---------------------------------------------------------------------

$ git shortlog -sn
   369  Bob Jones
   365  Joe Smith</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вот, собственно, и всё.
Все Mercurial теги были преобразованы в теги Git, а ветки и закладки — в ветки Git.
Теперь можно отправить репозиторий на новый Git сервер:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add origin git@my-git-server:myrepository.git
$ git push origin --all</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_bazaar">Bazaar</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Bazaar — это распределённая система контроля версий очень похожая на Git, поэтому репозиторий Bazaar достаточно легко сконвертировать в репозиторий Git.
Для этого вам необходимо подключить плагин <code>bzr-fastimport</code>.</p>
</div>
<div class="sect4">
<h4 id="_установка_плагина_bzr_fastimport">Установка плагина bzr-fastimport</h4>
<div class="paragraph">
<p>Для UNIX подобных систем и Windows процедура установки плагина отличается.
В первом случае, самый простой способ это установить пакет <code>bzr-fastimport</code>, вместе с которым будут установлены все необходимые зависимости.</p>
</div>
<div class="paragraph">
<p>Например, для Debian и подобных, следует выполнить:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ sudo apt-get install bzr-fastimport</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для RHEL выполните следующую команду:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ sudo yum install bzr-fastimport</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для Fedora, начиная с версии 22, новый менеджер пакетов dnf:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ sudo dnf install bzr-fastimport</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если пакет отсутствует в репозитории для вашего дистрибутива, то вы можете установить его как плагин, используя следующие команды:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ mkdir --parents ~/.bazaar/plugins     # создаст необходимые каталоги для плагинов
$ cd ~/.bazaar/plugins
$ bzr branch lp:bzr-fastimport fastimport   # импортирует плагин fastimport
$ cd fastimport
$ sudo python setup.py install --record=files.txt   # установит плагин</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы плагин заработал, вам понадобится модуль Python <code>fastimport</code>.
Проверить наличие и установить его можно следующими командами:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ python -c "import fastimport"
Traceback (most recent call last):
  File "&lt;string&gt;", line 1, in &lt;module&gt;
ImportError: No module named fastimport
$ pip install fastimport</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если модуль недоступен, то его можно скачать по адресу <a href="https://pypi.python.org/pypi/fastimport/" class="bare" target="_blank" rel="noopener">https://pypi.python.org/pypi/fastimport/</a>.</p>
</div>
<div class="paragraph">
<p>Во втором случае (в Windows), <code>bzr-fastimport</code> устанавливается автоматически при стандартной установке (все галочки отмечены).
В таком случае дальнейших действий не требуется.</p>
</div>
<div class="paragraph">
<p>Процесс импорта Bazaar репозитория отличается в зависимости от того одна ветка в вашем репозитории или несколько.</p>
</div>
</div>
<div class="sect4">
<h4 id="_проект_с_одной_веткой">Проект с одной веткой</h4>
<div class="paragraph">
<p>Войдите в каталог, содержащий ваш Bazaar репозиторий и проинициализируйте Git репозиторий:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cd /path/to/the/bzr/repository
$ git init</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь, просто экспортируйте свой Bazaar репозиторий и сконвертируйте его в Git репозиторий используя следующую команду:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ bzr fast-export --plain . | git fast-import</code></pre>
</div>
</div>
<div class="paragraph">
<p>В зависимости от размера проекта, Git репозиторий будет готов через несколько секунд или минут.</p>
</div>
</div>
<div class="sect4">
<h4 id="_проект_с_основной_и_рабочей_ветками">Проект с основной и рабочей ветками</h4>
<div class="paragraph">
<p>Вы так же можете импортировать Bazaar репозиторий с несколькими ветками.
Предположим, что в вашем репозитории две ветки: одна является основной веткой проекта (myProject.trunk), другая — рабочей (myProject.work).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ls
myProject.trunk myProject.work</code></pre>
</div>
</div>
<div class="paragraph">
<p>Проинициализируйте Git репозиторий и перейдите в его каталог:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git init git-repo
$ cd git-repo</code></pre>
</div>
</div>
<div class="paragraph">
<p>Импортируйте в Git основную ветку с помощью команды:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ bzr fast-export --export-marks=../marks.bzr ../myProject.trunk | \
git fast-import --export-marks=../marks.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Импортируйте в Git рабочую ветку с помощью команды:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ bzr fast-export --marks=../marks.bzr --git-branch=work ../myProject.work | \
git fast-import --import-marks=../marks.git --export-marks=../marks.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь, команда <code>git branch</code> покажет вам две ветки: <code>master</code> и <code>work</code>.
Проверьте логи, чтобы убедиться в отсутствии ошибок, после этого можно удалить файлы <code>marks.bzr</code> и <code>marks.git</code>.</p>
</div>
</div>
<div class="sect4">
<h4 id="_синхронизация_индекса">Синхронизация индекса</h4>
<div class="paragraph">
<p>Вне зависимости от количества веток и выбранного метода импорта, индекс не синхронизируется с <code>HEAD</code>, а при импорте нескольких веток — так же не синхронизируется рабочий каталог.
Эту ситуацию можно легко исправить следующей командой:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git reset --hard HEAD</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_игнорирование_файлов_из_bzrignore">Игнорирование файлов из .bzrignore</h4>
<div class="paragraph">
<p>Теперь давайте посмотрим на файлы, которые следует игнорировать.
Первое, что нужно сделать — это переименовать <code>.bzrignore</code> в <code>.gitignore</code>.
Если файл <code>.bzrignore</code> содержит одну или несколько строк начинающихся с <code>!!</code> или <code>RE:</code>, нужно их изменить и, возможно, создать несколько файлов <code>.gitignore</code>, чтобы заставить Git игнорировать точно те же файлы, которые игнорируются Bazaar.</p>
</div>
<div class="paragraph">
<p>Наконец, создайте коммит со всеми изменениями, внесёнными во время миграции:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git mv .bzrignore .gitignore
$ # modify .gitignore if needed
$ git commit -am 'Migration from Bazaar to Git'</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_отправка_репозитория_на_сервер">Отправка репозитория на сервер</h4>
<div class="paragraph">
<p>Вот и всё!
Теперь вы можете отправить репозиторий на сервер в его новый дом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add origin git@my-git-server:mygitrepository.git
$ git push origin --all
$ git push origin --tags</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ваш Git репозиторий готов к использованию.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="r_perforce_import">Perforce</h3>
<div class="paragraph">
<p>
Следующей системой из которой мы импортируем репозиторий станет Perforce.
Вы уже знаете, что существует два способа подружить Git и Perforce: <code>git-p4</code> и Git Fusion.</p>
</div>
<div class="sect4">
<h4 id="_perforce_git_fusion">Perforce Git Fusion</h4>
<div class="paragraph">
<p>Git Fusion делает процесс переноса вполне безболезненным.
Просто настройте проект, соответствия между пользователями и ветки в конфигурационном файле как показано в <a href="{{< relurl "book/ru/v2/ch00/r_p4_git_fusion" >}}">Git Fusion</a> и клонируйте репозиторий.
В результате вы получите настоящий Git репозиторий, который, при желании, можно сразу же отправлять на удалённый Git сервер.
Вы даже можете использовать Perforce в качестве такового.</p>
</div>
</div>
<div class="sect4">
<h4 id="r_git_p4">Git-p4</h4>
<div class="paragraph">
<p><code>git-p4</code> также можно использовать для переноса репозитория.
В качестве примера мы импортируем проект «Jam» из публичного депо Perforce.</p>
</div>
<div class="paragraph">
<p>Вначале нужно указать адрес депо в переменной окружения <code>P4PORT</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ export P4PORT=public.perforce.com:1666</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Примечание</div>
</td>
<td class="content">
<div class="paragraph">
<p>Для дальнейших экспериментов вам понадобится доступ к Perforce депо.
Мы используем общедоступное депо на public.perforce.com, но вы можете взять любое другое, к которому у вас есть доступ.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>
Запустите команду <code>git p4 clone</code> чтобы импортировать проект «Jam» с Perforce сервера, передав ей путь к проекту в депо и каталог, в который хотите импортировать репозиторий:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git-p4 clone //guest/perforce_software/jam@all p4import
Importing from //guest/perforce_software/jam@all into p4import
Initialized empty Git repository in /private/tmp/p4import/.git/
Import destination: refs/remotes/p4/master
Importing revision 9957 (100%)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Конкретно этот проект имеет одну ветку, но если бы их было несколько, вы бы просто могли передать флаг <code>--detect-branches</code> в <code>git p4 clone</code>.
Перечитайте раздел <a href="{{< relurl "book/ru/v2/ch00/r_git_p4_branches" >}}">Ветвление</a> для подробностей.</p>
</div>
<div class="paragraph">
<p>На данном этапе репозиторий почти готов.
Если вы перейдёте в каталог <code>p4import</code> и выполните <code>git log</code>, вы увидите результат:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -2
commit e5da1c909e5db3036475419f6379f2c73710c4e6
Author: giles &lt;giles@giles@perforce.com&gt;
Date:   Wed Feb 8 03:13:27 2012 -0800

    Correction to line 355; change &lt;/UL&gt; to &lt;/OL&gt;.

    [git-p4: depot-paths = "//public/jam/src/": change = 8068]

commit aa21359a0a135dda85c50a7f7cf249e4f7b8fd98
Author: kwirth &lt;kwirth@perforce.com&gt;
Date:   Tue Jul 7 01:35:51 2009 -0800

    Fix spelling error on Jam doc page (cummulative -&gt; cumulative).

    [git-p4: depot-paths = "//public/jam/src/": change = 7304]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>git-p4</code> оставил идентификаторы в сообщениях всех коммитов.
Ничего страшного нет в том, чтобы оставить всё как есть, особенно если вы захотите сослаться на номер ревизии в Perforce в будущем.
Если же вы хотите убрать эти строки, теперь — прежде чем приступать к работе с репозиторием — самое время для этого.

Вы можете использовать <code>git filter-branch</code> чтобы удалить идентификаторы из всех сообщений одним махом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git filter-branch --msg-filter 'sed -e "/^\[git-p4:/d"'
Rewrite e5da1c909e5db3036475419f6379f2c73710c4e6 (125/125)
Ref 'refs/heads/master' was rewritten</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если вы сейчас выполните <code>git log</code>, вы увидите, что SHA-1 хеши коммитов изменились, а строки <code>git-p4</code> исчезли из сообщений:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -2
commit b17341801ed838d97f7800a54a6f9b95750839b7
Author: giles &lt;giles@giles@perforce.com&gt;
Date:   Wed Feb 8 03:13:27 2012 -0800

    Correction to line 355; change &lt;/UL&gt; to &lt;/OL&gt;.

commit 3e68c2e26cd89cb983eb52c024ecdfba1d6b3fff
Author: kwirth &lt;kwirth@perforce.com&gt;
Date:   Tue Jul 7 01:35:51 2009 -0800

    Fix spelling error on Jam doc page (cummulative -&gt; cumulative).</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь ваш репозиторий готов к отправке на Git сервер.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="r_custom_importer">Импорт произвольного репозитория</h3>
<div class="paragraph">
<p>

Если вы пользуетесь какой-либо другой системой контроля версий, не перечисленной выше, вам следует поискать инструмент для импорта в Сети — качественные решения доступны для CVS, Clear Case, Visual Source Safe и даже каталогов с архивами.
Если всё же существующие решения вам не подошли, вы пользуетесь менее известной системой контроля версий или вам нужно больше контроля над процессом импорта — используйте <code>git fast-import</code>.
Эта команда читает простые инструкции из потока ввода и записывает данные в Git.
Создать Git-объекты таким путём намного проще, чем через низкоуровневые Git-команды или пытаясь воссоздать их вручную (обратитесь к главе <a href="{{< relurl "book/ru/v2/ch00/ch10-git-internals" >}}">Git изнутри</a> за деталями).
Таким образом, вы можете написать небольшой скрипт, считывающий нужную информацию из вашего хранилища и выводящий инструкции в стандартный поток вывода.
Затем вы можете запустить эту программу и передать её вывод прямиком в <code>git fast-import</code>.</p>
</div>
<div class="paragraph">
<p>Для демонстрации, мы с вами напишем простой скрипт для импорта.
Предположим, вы работаете в каталоге <code>current</code> и периодически создаёте резервные копии в каталогах вида <code>back_YYYY_MM_DD</code>, и хотите перенести данные в Git.
Структура каталогов выглядит следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ls /opt/import_from
back_2014_01_02
back_2014_01_04
back_2014_01_14
back_2014_02_03
current</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы успешно импортировать репозиторий, давайте вспомним, как Git хранит данные.
Как вы наверное помните, Git по сути представляет собой связанный список ревизий, каждая из которых указывает на слепок состояния.
Всё что от вас требуется, это указать `fast-import’у на данные для создания слепков и порядок их применения.
Итак, мы пробежимся по всем слепкам, создадим коммит для каждого из них и свяжем каждый новый коммит с предыдущим.</p>
</div>
<div class="paragraph">
<p>Как и в разделе <a href="{{< relurl "book/ru/v2/ch00/r_an_example_git_enforced_policy" >}}">Пример принудительной политики Git</a> главы 8, мы проделаем это на Ruby, потому что это тот язык, с которым мы обычно работаем, и его легко читать.
Вы можете использовать любой другой язык — всё что требуется, это вывести нужную информацию в стандартный поток вывода.</p>
</div>
<div class="paragraph">
<p>Если вы работаете на Windows, будьте особо осторожными с переводами строк: <code>fast-import</code> ожидает лишь символы перевода строки (<code>LF</code>), но не возврат каретки + перевод строки (<code>CRLF</code>), как принято в Windows.</p>
</div>
<div class="paragraph">
<p>Для начала перейдём в исходный каталог и определим подкаталоги, содержащие состояния проекта в разные моменты времени, которые будут использованы для построения соответствующих коммитов.
Вы поочерёдно посетите каждую из них и выполните команды, необходимые для экспорта.
Примерно так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">last_mark = nil

# loop through the directories
Dir.chdir(ARGV[0]) do
  Dir.glob("*").each do |dir|
    next if File.file?(dir)

    # move into the target directory
    Dir.chdir(dir) do
      last_mark = print_export(dir, last_mark)
    end
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вы выполняете функцию <code>print_export</code> внутри каждого каталога.
Она принимает на вход текущий каталог и результат предыдущего вызова и помечает текущий каталог, возвращая данные для последующих вызовов, таким образом связывая коммиты.
Метки используются для связи коммитов вместе.
Итак, первым делом нужно сгенерировать метку по каталогу:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">mark = convert_dir_to_mark(dir)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Создадим массив каталогов и используем индекс каталога в нём как метку; это удобно, ведь метка должна быть целым числом.
Мы написали такой код:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">$marks = []
def convert_dir_to_mark(dir)
  if !$marks.include?(dir)
    $marks &lt;&lt; dir
  end
  ($marks.index(dir) + 1).to_s
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь, когда у нас есть целочисленная метка для коммита, нужна дата.
У нас она хранится в имени каталога, придётся достать её оттуда.
Следующая строка в <code>print_export</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">date = convert_dir_to_date(dir)</code></pre>
</div>
</div>
<div class="paragraph">
<p>где <code>convert_dir_to_date</code> определяется как</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">def convert_dir_to_date(dir)
  if dir == 'current'
    return Time.now().to_i
  else
    dir = dir.gsub('back_', '')
    (year, month, day) = dir.split('_')
    return Time.local(year, month, day).to_i
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Этот код вернёт целочисленное представление даты для каждого каталога.
И последний кусочек мозаики: автор изменений.
Это значение жёстко задано в глобальной переменной:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">$author = 'John Doe &lt;john@example.com&gt;'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь всё готово для вывода нужной `fast-import’у информации.
Нужно указать, что создаётся коммит на определённой ветке, затем вывести сгенерированную метку, автора и время изменений и ссылку на предыдущий коммит, если такой имеется.
Код выглядит следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby"># print the import information
puts 'commit refs/heads/master'
puts 'mark :' + mark
puts "committer #{$author} #{date} -0700"
export_data('imported from ' + dir)
puts 'from :' + last_mark if last_mark</code></pre>
</div>
</div>
<div class="paragraph">
<p>Для простоты, мы определили часовой пояс как -0700 прямо в выходной строке.
Часовой пояс задаётся как смещение от UTC.
Сообщение коммита задаётся следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>data (size)\n(contents)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Первым идёт слово <code>data</code>, затем длина сообщения, новая строка и, наконец, само сообщение.
Похожим образом задаётся и содержимое коммитов, поэтому создадим метод-помощник:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">def export_data(string)
  print "data #{string.size}\n#{string}"
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Осталось лишь задать содержимое каждого коммита.
Это довольно просто, потому что все данные хранятся в отдельных каталогах — достаточно напечатать команду <code>deleteall</code>, а следом за ней содержимое всех файлов каталога.
После этого Git запишет слепки:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">puts 'deleteall'
Dir.glob("**/*").each do |file|
  next if !File.file?(file)
  inline_data(file)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Замечание: многие системы работают с дельтами (разницами от одного состояния к последующему); <code>fast-import</code> имеет команды для задания изменений: какие файлы были добавлены, удалены или изменены.
Вы можете вычислять разницу между состояниями и передавать её в <code>fast-import</code>, но это довольно сложно, гораздо проще передавать Git все данные.
За полным описанием принимаемых форматов обратитесь к руководству <code>fast-import</code>.</p>
</div>
<div class="paragraph">
<p>Формат для указания нового содержимого или изменений следующий:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>M 644 inline path/to/file
data (size)
(file contents)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь <code>644</code> — это права доступа к файлу.
Если файл должен быть исполняемым, вам нужно определить это и передать <code>755</code>.
Слово <code>inline</code> говорит о том, что вы выведете содержимое файла после этой строки.
Таким образом, метод <code>inline_data</code> может выглядеть так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">def inline_data(file, code = 'M', mode = '644')
  content = File.read(file)
  puts "#{code} #{mode} inline #{file}"
  export_data(content)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Мы используем определённый ранее метод <code>export_data</code> потому что форматы содержимого коммитов и их сообщений одинаковы.</p>
</div>
<div class="paragraph">
<p>И последнее что нужно сделать — это вернуть метку для последующих вызовов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">return mark</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Примечание</div>
</td>
<td class="content">
<div class="paragraph">
<p>Если вы используете ОС Windows есть ещё кое-что.
Как мы упоминали ранее, Windows использует <code>CRLF</code> для новых строк, в то время как <code>git fast-import</code> ожидает только <code>LF</code>.
Чтобы исправить этот недостаток Windows и осчастливить <code>git fast-import</code>, просто прикажите Ruby использовать <code>LF</code> вместо <code>CRLF</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">$stdout.binmode</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Вот и всё.
Ниже приведён весь скрипт целиком:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#!/usr/bin/env ruby

$stdout.binmode
$author = "John Doe &lt;john@example.com&gt;"

$marks = []
def convert_dir_to_mark(dir)
    if !$marks.include?(dir)
        $marks &lt;&lt; dir
    end
    ($marks.index(dir)+1).to_s
end

def convert_dir_to_date(dir)
    if dir == 'current'
        return Time.now().to_i
    else
        dir = dir.gsub('back_', '')
        (year, month, day) = dir.split('_')
        return Time.local(year, month, day).to_i
    end
end

def export_data(string)
    print "data #{string.size}\n#{string}"
end

def inline_data(file, code='M', mode='644')
    content = File.read(file)
    puts "#{code} #{mode} inline #{file}"
    export_data(content)
end

def print_export(dir, last_mark)
    date = convert_dir_to_date(dir)
    mark = convert_dir_to_mark(dir)

    puts 'commit refs/heads/master'
    puts "mark :#{mark}"
    puts "committer #{$author} #{date} -0700"
    export_data("imported from #{dir}")
    puts "from :#{last_mark}" if last_mark

    puts 'deleteall'
    Dir.glob("**/*").each do |file|
        next if !File.file?(file)
        inline_data(file)
    end
    mark
end

# Loop through the directories
last_mark = nil
Dir.chdir(ARGV[0]) do
    Dir.glob("*").each do |dir|
        next if File.file?(dir)

        # move into the target directory
        Dir.chdir(dir) do
            last_mark = print_export(dir, last_mark)
        end
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Если вы выполните этот скрипт, он выведет примерно следующее:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ruby import.rb /opt/import_from
commit refs/heads/master
mark :1
committer John Doe &lt;john@example.com&gt; 1388649600 -0700
data 29
imported from back_2014_01_02deleteall
M 644 inline README.md
data 28
# Hello

This is my readme.
commit refs/heads/master
mark :2
committer John Doe &lt;john@example.com&gt; 1388822400 -0700
data 29
imported from back_2014_01_04from :1
deleteall
M 644 inline main.rb
data 34
#!/bin/env ruby

puts "Hey there"
M 644 inline README.md
(...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Чтобы импортировать репозиторий перенаправьте этот вывод в команду <code>git fast-import</code>, запущенную в каталоге с целевым Git-репозиторием.
Вы можете создать новый каталог, выполнить в нём <code>git init</code>, а затем запустить свой скрипт:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git init
Initialized empty Git repository in /opt/import_to/.git/
$ ruby import.rb /opt/import_from | git fast-import
git-fast-import statistics:
---------------------------------------------------------------------
Alloc'd objects:       5000
Total objects:           13 (         6 duplicates                  )
      blobs  :            5 (         4 duplicates          3 deltas of          5 attempts)
      trees  :            4 (         1 duplicates          0 deltas of          4 attempts)
      commits:            4 (         1 duplicates          0 deltas of          0 attempts)
      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)
Total branches:           1 (         1 loads     )
      marks:           1024 (         5 unique    )
      atoms:              2
Memory total:          2344 KiB
       pools:          2110 KiB
     objects:           234 KiB
---------------------------------------------------------------------
pack_report: getpagesize()            =       4096
pack_report: core.packedGitWindowSize = 1073741824
pack_report: core.packedGitLimit      = 8589934592
pack_report: pack_used_ctr            =         10
pack_report: pack_mmap_calls          =          5
pack_report: pack_open_windows        =          2 /          2
pack_report: pack_mapped              =       1457 /       1457
---------------------------------------------------------------------</code></pre>
</div>
</div>
<div class="paragraph">
<p>Как вы можете видеть, после успешного завершения <code>fast-import</code> выводит некоторую статистику о проделанной работе.
В этом случае, вы импортировали 13 объектов в 4-х коммитах одной ветки.
Теперь можете выполнить <code>git log</code> просмотреть созданную историю коммитов:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -2
commit 3caa046d4aac682a55867132ccdfbe0d3fdee498
Author: John Doe &lt;john@example.com&gt;
Date:   Tue Jul 29 19:39:04 2014 -0700

    imported from current

commit 4afc2b945d0d3c8cd00556fbe2e8224569dc9def
Author: John Doe &lt;john@example.com&gt;
Date:   Mon Feb 3 01:00:00 2014 -0700

    imported from back_2014_02_03</code></pre>
</div>
</div>
<div class="paragraph">
<p>Вот он: ваш новый классный Git репозиторий!
Обратите внимание, ваш рабочий каталог пуст, активная ветка не выбрана.
Переключимся на ветку <code>master</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ls
$ git reset --hard master
HEAD is now at 3caa046 imported from current
$ ls
README.md main.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Функциональность <code>fast-import</code> гораздо шире описанного: он поддерживает права доступа к файлам, двоичные файлы, множественные ветки и их слияния, метки, индикатор прогресса и ещё кучу вещей.
Несколько примеров более сложных сценариев использования <code>fast-import</code> можно найти в каталоге <code>contrib/fast-import</code> исходного кода Git.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>