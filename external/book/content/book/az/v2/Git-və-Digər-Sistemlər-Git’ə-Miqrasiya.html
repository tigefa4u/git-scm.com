---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: az
  chapter:
    title: Git və Digər Sistemlər
    number: 9
  section:
    title: Git’ə Miqrasiya
    number: 2
    cs_number: '9.2'
    previous: book/az/v2/Git-və-Digər-Sistemlər-Git-Müştəri-kimi
    next: book/az/v2/Git-və-Digər-Sistemlər-Qısa-Məzmun
title: Git - Git’ə Miqrasiya
url: "/book/az/v2/Git-və-Digər-Sistemlər-Git’ə-Miqrasiya.html"
---
<h2 id="_migrating">Git’ə Miqrasiya</h2>
<div class="paragraph">
<p>
Başqa bir VNS’də mövcud bir kod bazanız varsa, ancaq Git istifadə etməyə qərar verdiyiniz təqdirdə layihənizi bu və ya digər şəkildə köçürməlisiniz.
Bu bölmə ümumi sistemlər üçün bəzi idxalçıları nəzərdən keçirir və sonra öz xüsusi idxalatçısının necə inkişaf etdiriləcəyini göstərir.
Keçid edən istifadəçilərin əksəriyyətini təşkil etdiyindən və onlar üçün yüksək keyfiyyətli alətlərin gəlməsi asan olduğundan, peşəkarlıqla istifadə olunan bir neçə daha böyük SCM sistemindən məlumatları necə idxal edəcəyinizi öyrənəcəksiniz.</p>
</div>
<div class="sect3">
<h3 id="_subversion">Subversion</h3>
<div class="paragraph">
<p>

<code>git svn</code> istifadəsi ilə bağlı əvvəlki bölümü oxumusunuzsa, bu təlimatları asanlıqla <code>git svn clone</code> deposuna getmək üçün istifadə edə bilərsiniz; sonra, Subversion serverindən istifadəni dayandırın, yeni bir Git serverinə keçin və istifadə etməyə başlayın.
Tarixçəni istəsəniz, məlumatı Subversion serverindən çıxara bildiyiniz müddətdə (bir müddət ala bilər) bacara bilərsiniz.</p>
</div>
<div class="paragraph">
<p>Bununla birlikdə, idxal mükəmməl deyil; və çox uzun çəkəcəyi üçün bunu da edə bilərsiz.
İlk problem müəllif məlumatlarıdır.
Subversion-da, hər bir iş görən şəxsin sistemdə commit məlumatında qeyd olunan bir istifadəçisi var.
Əvvəlki hissədəki nümunələr, <code>blame</code> çıxışı və  <code>git svn log</code> kimi bəzi yerlərdə <code>schacon</code> göstərir.
Bunu daha yaxşı Git müəllif məlumatlarına uyğunlaşdırmaq istəyirsinizsə, Subversion istifadəçilərindən Git müəlliflərinə qədər bir xəritəyə ehtiyacınız var.
Bu istifadəçi şəklində belə bir formatda olan <code>users.txt</code> adlı bir fayl yaradın:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>schacon = Scott Chacon &lt;schacon@geemail.com&gt;
selse = Someo Nelse &lt;selse@geemail.com&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>SVN-nin istifadə etdiyi müəllif adlarının siyahısını əldə etmək üçün bunu edə bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ svn log --xml --quiet | grep author | sort -u | \
  perl -pe 's/.*&gt;(.*?)&lt;.*/$1 = /'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Gündəlik çıxışı XML formatında yaradır, sonra yalnız müəllif məlumatları olan sətirləri saxlayır, dublikatları atır, XML etiketlərini silir.
Aydındır ki, bu yalnız <code>grep</code>, <code>sort</code> və <code>perl</code> quraşdırılmış bir maşın üzərində işləyir.
Sonra, hər bir girişin yanına ekvivalent Git istifadəçi məlumatlarını əlavə edə bilmək üçün bu çıxışı <code>users.txt</code> faylınıza yönləndirin.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Bunu bir Windows maşınında sınayırsınızsa, problemlə qarşılaşacağınız nöqtə budur.
Microsoft,https://docs.microsoft.com/en-us/azure/devops/repos/git/perform-migration-from-svn-to-git[] saytında bəzi yaxşı məsləhətlər və nümunələr verir.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Müəllif məlumatlarını daha dəqiq bir şəkildə göstərməsinə kömək etmək üçün bu faylı <code>git svn</code>-ə təqdim edə bilərsiniz.
Ayrıca,<code>git svn</code>-ə Subversion-un normal olaraq idxal etdiyi meta məlumatları daxil etməməsini, <code>--no-metadata</code>-nı <code>clone</code> ya da  <code>init</code> əmrinə keçirməklə də deyə bilərsiniz.
Metadata, Gitin idxal zamanı meydana gətirəcəyi hər bir mesajın içərisində bir <code>git-svn-id</code> var.
Bu, Git log-unuzu şişirə bilər və bir az anlaşılmaz edə bilər.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Git deposundakı commit-ləri orijinal SVN deposuna qaytarmaq istədiyiniz zaman metadatanı saxlamalısınız.
Sinxronizasiyanı commit log-da istəmirsinizsə, <code>--no-metadata</code>  parametrini əlavə etməyə çəkinməyin.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Bu, <code>import</code> əmrinizi belə göstərir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn clone http://my-project.googlecode.com/svn/ \
      --authors-file=users.txt --no-metadata --prefix "" -s my_project
$ cd my_project</code></pre>
</div>
</div>
<div class="paragraph">
<p>İndi <code>my_project</code> qovluğunuzda daha yaxşı bir Subversion idxal etməlisiniz.
Buna bənzər commit-lər yerinə:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>commit 37efa680e8473b615de980fa935944215428a35a
Author: schacon &lt;schacon@4c93b258-373f-11de-be05-5f7a86268029&gt;
Date:   Sun May 3 00:12:22 2009 +0000

    fixed install - go to trunk

    git-svn-id: https://my-project.googlecode.com/svn/trunk@94 4c93b258-373f-11de-
    be05-5f7a86268029</code></pre>
</div>
</div>
<div class="paragraph">
<p>they look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>commit 03a8785f44c8ea5cdb0e8834b7c8e6c469be2ff2
Author: Scott Chacon &lt;schacon@geemail.com&gt;
Date:   Sun May 3 00:12:22 2009 +0000

    fixed install - go to trunk</code></pre>
</div>
</div>
<div class="paragraph">
<p>Müəllif sahəsi həm daha yaxşı görünür, həm də <code>git-svn-id</code> artıq yoxdur.
Ayrıca bir az post-import sonrası təmizləmə etməlisiniz.
Birincisi, <code>git svn</code> qurduğu qəribə referansları təmizləməlisiniz.
Əvvəlcə yazıları qəribə uzaq branch-lardan daha çox həqiqi etiket olduqları üçün daşıyacaqsınız, sonra qalan branch-ları local olduqları üçün köçürəcəksiniz.</p>
</div>
<div class="paragraph">
<p>Etiketləri uyğun Git etiketi olmaq üçün hərəkət etdirin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ for t in $(git for-each-ref --format='%(refname:short)' refs/remotes/tags); do git tag ${t/tags\//} $t &amp;&amp; git branch -D -r $t; done</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu, <code>refs/remotes/tags/</code> ilə başlayan uzaq branch-lar olan referansları alır və onları həqiqi (yüngül) etiketlər edir.
Ardından, referansların qalan hissəsini local branch-lar halına gətirmək üçün <code>refs/remotes</code> altına köçürün:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ for b in $(git for-each-ref --format='%(refname:short)' refs/remotes); do git branch $b refs/remotes/$b &amp;&amp; git branch -D -r $b; done</code></pre>
</div>
</div>
<div class="paragraph">
<p>Elə ola bilər ki, <code>@xxx</code> (harada ki xxx ədəddir) şəkilçisi olan bəzi əlavə branch-lar görərsiniz, Subversionda isə yalnız bir branch görürsünüz.
Bu, əslində Git üçün heç bir sintaktik həmkarı olmayan bir şey olan “peg-revisions” adlı Subversion xüsusiyyətidir.
Beləliklə, <code>git svn</code> branch-ın düzəldilməsini həll etmək üçün svn-də yazdığınız şəkildə svn versiya nömrəsini branch-ın adına əlavə edir.
Artıq peg-revisions düzəlişləri ilə maraqlanmırsınızsa, sadəcə onları silin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ for p in $(git for-each-ref --format='%(refname:short)' | grep @); do git branch -D $p; done</code></pre>
</div>
</div>
<div class="paragraph">
<p>İndi bütün köhnə branch-lar əsl Git branch-larıdır və bütün köhnə etiketlər əsl Git etiketləridir.
Təmizləmək üçün son bir şey var.
Təəssüf ki, <code>git svn</code>, Subversionun standart branch-ına uyğunlaşan <code>trunk</code> adlı əlavə bir branch yaradır, lakin <code>trunk</code> <code>master</code> ilə eyni yerə işarə edir.
<code>master</code> daha idiomatik olaraq Git olduğundan əlavə branch-ı necə silmək olar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch -d trunk</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ediləcək son şey yeni Git serverinizi bir remote olaraq əlavə edib ona push etməkdir.
Serverinizi məsafədən əlavə etmək üçün bir nümunə:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add origin git@my-git-server:myrepository.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bütün branch-larınızın və etiketlərinizin yuxarı qalxmasını istədiyiniz üçün indi bunu edə bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git push origin --all
$ git push origin --tags</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bütün branch-larınız və etiketləriniz təmiz bir idxalda yeni Git serverinizdə olmalıdır.</p>
</div>
</div>
<div class="sect3">
<h3 id="_mercurial">Mercurial</h3>
<div class="paragraph">
<p>
Mercurial və Git versiyalarını təmsil etmək üçün kifayət qədər oxşar modellərə sahib olduğundan və Git bir az daha çevik olduğundan, bir deponu Mercurial-dan Git-ə çevirmək kifayət qədər sadədir, bunun üçün "hg-fast-export" adlı bir vasitə istifadə etmək lazımdır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone https://github.com/frej/fast-export.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dönüşümün ilk addımı çevirmək istədiyiniz Mercurial deposunun tam bir klonunu əldə etməkdir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ hg clone &lt;remote repo URL&gt; /tmp/hg-repo</code></pre>
</div>
</div>
<div class="paragraph">
<p>Növbəti addım bir müəllif mapping faylı yaratmaqdır.
Mercurial, dəyişikliklər üçün müəllif sahəsinə qoyacaqlarına görə Gitdən biraz daha bağışlayır, buna görə də ev təmizləmək üçün yaxşı vaxtdır.
Bunu yaratmaq, <code>bash</code> shell-ində bir sətir əmridir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cd /tmp/hg-repo
$ hg log | grep user: | sort | uniq | sed 's/user: *//' &gt; ../authors</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu, layihənizin tarixinin nə qədər olacağına görə bir neçə saniyə çəkəcək və bundan sonra <code>/tmp/authors</code> faylı belə görünəcək:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>bob
bob@localhost
bob &lt;bob@company.com&gt;
bob jones &lt;bob &lt;AT&gt; company &lt;DOT&gt; com&gt;
Bob Jones &lt;bob@company.com&gt;
Joe Smith &lt;joe@company.com&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu nümunədə, eyni şəxs (Bob) biri fərqli görünən və biri Git commiti üçün tamamilə etibarsız olan dörd fərqli ad altında dəyişikliklər yaratdı.
Hg-fast-export hər sətri bir qaydaya çevirərək bunu düzəltməyimizə imkan verir: <code>"&lt;input&gt;"="&lt;output&gt;"</code>, <code>&lt;input&gt;</code> ilə <code>&lt;output&gt;</code> arasında mapping.
<code>&lt;input&gt;</code> və <code>&lt;output&gt;</code> string-lərinin içərisində, python <code>string_escape</code> kodlaması ilə başa düşülən bütün qaçış ardıcıllığı dəstəklənir.
Müəllif mapping faylında uyğun bir  <code>&lt;input&gt;</code> yoxdursa, o müəllif dəyişdirilmədən Git-ə göndəriləcək.
Bütün istifadəçi adları yaxşı görünürsə, bu fayla heç ehtiyacımız olmayacaq.
Bu nümunədə faylımızın belə görünməsini istəyirik:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>"bob"="Bob Jones &lt;bob@company.com&gt;"
"bob@localhost"="Bob Jones &lt;bob@company.com&gt;"
"bob &lt;bob@company.com&gt;"="Bob Jones &lt;bob@company.com&gt;"
"bob jones &lt;bob &lt;AT&gt; company &lt;DOT&gt; com&gt;"="Bob Jones &lt;bob@company.com&gt;"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Eyni növ mapping faylı, Mercurial adının Git tərəfindən icazə verilmədiyi zaman branch və etiketlərin adını dəyişdirmək üçün istifadə edilə bilər.</p>
</div>
<div class="paragraph">
<p>Növbəti addım yeni Git depomuzu yaratmaq və ixrac skriptini çalışdırmaqdır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git init /tmp/converted
$ cd /tmp/converted
$ /tmp/fast-export/hg-fast-export.sh -r /tmp/hg-repo -A /tmp/authors</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>-r</code> flag-ı hg-fast-export-ə çevirmək istədiyimiz Mercurial deposunu harada tapacağımızı və <code>-A</code> flag-ı isə  author-mapping faylını harada tapacağımızı bildirir (branch və etiket mapping faylları müvafiq olaraq <code>-B</code> və <code>-T</code> flag-ları ilə təyin olunur).
Skript Mercurial dəyişikliklərini təhlil edir və Git’in "fast-import" xüsusiyyəti üçün bir skriptə çevirir (bir az sonra ətraflı şəkildə müzakirə edəcəyik).</p>
</div>
<div class="paragraph">
<p>Bu bir az çəkir (baxmayaraq ki, şəbəkə üzərində olandan <em>daha çox</em> sürətli olur) və nəticə olduqca açıqdır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ /tmp/fast-export/hg-fast-export.sh -r /tmp/hg-repo -A /tmp/authors
Loaded 4 authors
master: Exporting full revision 1/22208 with 13/0/0 added/changed/removed files
master: Exporting simple delta revision 2/22208 with 1/1/0 added/changed/removed files
master: Exporting simple delta revision 3/22208 with 0/1/0 added/changed/removed files
[…]
master: Exporting simple delta revision 22206/22208 with 0/4/0 added/changed/removed files
master: Exporting simple delta revision 22207/22208 with 0/2/0 added/changed/removed files
master: Exporting thorough delta revision 22208/22208 with 3/213/0 added/changed/removed files
Exporting tag [0.4c] at [hg r9] [git :10]
Exporting tag [0.4d] at [hg r16] [git :17]
[…]
Exporting tag [3.1-rc] at [hg r21926] [git :21927]
Exporting tag [3.1] at [hg r21973] [git :21974]
Issued 22315 commands
git-fast-import statistics:
---------------------------------------------------------------------
Alloc'd objects:     120000
Total objects:       115032 (    208171 duplicates                  )
      blobs  :        40504 (    205320 duplicates      26117 deltas of      39602 attempts)
      trees  :        52320 (      2851 duplicates      47467 deltas of      47599 attempts)
      commits:        22208 (         0 duplicates          0 deltas of          0 attempts)
      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)
Total branches:         109 (         2 loads     )
      marks:        1048576 (     22208 unique    )
      atoms:           1952
Memory total:          7860 KiB
       pools:          2235 KiB
     objects:          5625 KiB
---------------------------------------------------------------------
pack_report: getpagesize()            =       4096
pack_report: core.packedGitWindowSize = 1073741824
pack_report: core.packedGitLimit      = 8589934592
pack_report: pack_used_ctr            =      90430
pack_report: pack_mmap_calls          =      46771
pack_report: pack_open_windows        =          1 /          1
pack_report: pack_mapped              =  340852700 /  340852700
---------------------------------------------------------------------

$ git shortlog -sn
   369  Bob Jones
   365  Joe Smith</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bunun üçün demək olar ki, hamısı var.
Mercurial etiketlərin hamısı Git etiketlərinə, Mercurial  branch-ları və bookmark-ları Git  branch-larına çevrilmişdir.
İndi deponu yeni server tərəfindəki evinə aparmağa hazırsınız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add origin git@my-git-server:myrepository.git
$ git push origin --all</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_bazaar">Bazaar</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Bazaar, Git kimi bir DVCS vasitədir və nəticədə bir Bazaar deposunu Git-ə çevirmək olduqca sadədir.
Bunu həyata keçirmək üçün <code>bzr-fastimport</code> pluginini idxal etməlisiniz.</p>
</div>
<div class="sect4">
<h4 id="_bzr_fastimport_pluginn_alınması">bzr-fastimport pluginn alınması</h4>
<div class="paragraph">
<p>Fastimport plugininin quraşdırılması proseduru UNIX kimi əməliyyat sistemlərində və Windows-da fərqlidir.
Birinci halda, ən sadə, lazım olan bütün asılılıqları quracaq olan <code>bzr-fastimport</code> paketinin quraşdırılmasıdır.</p>
</div>
<div class="paragraph">
<p>Məsələn, Debian və törəməsi ilə aşağıdakıları edərdiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ sudo apt-get install bzr-fastimport</code></pre>
</div>
</div>
<div class="paragraph">
<p>RHEL ilə aşağıdakıları edərdiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ sudo yum install bzr-fastimport</code></pre>
</div>
</div>
<div class="paragraph">
<p>Fedora ilə, 22 buraxılışından bəri yeni paket meneceri dnf:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ sudo dnf install bzr-fastimport</code></pre>
</div>
</div>
<div class="paragraph">
<p>Paket mövcud deyilsə, onu bir plugin kimi qura bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ mkdir --parents ~/.bazaar/plugins     # creates the necessary folders for the plugins
$ cd ~/.bazaar/plugins
$ bzr branch lp:bzr-fastimport fastimport   # imports the fastimport plugin
$ cd fastimport
$ sudo python setup.py install --record=files.txt   # installs the plugin</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu pluginin işləməsi üçün <code>fastimport</code> Python moduluna ehtiyacınız olacaq.
Mövcud olub olmadığını yoxlayıb aşağıdakı əmrlərlə quraşdıra bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ python -c "import fastimport"
Traceback (most recent call last):
  File "&lt;string&gt;", line 1, in &lt;module&gt;
ImportError: No module named fastimport
$ pip install fastimport</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mövcud deyilsə, <a href="https://pypi.python.org/pypi/fastimport/" class="bare">https://pypi.python.org/pypi/fastimport/</a> ünvanından yükləyə bilərsiniz.</p>
</div>
<div class="paragraph">
<p>İkinci halda (Windows-da)  <code>bzr-fastimport</code> avtomatik olaraq bağımsız versiya və standart quraşdırma ilə quraşdırılır (bütün checkbox-ların işarələnməsinə icazə verin).
Yəni bu vəziyyətdə sizin heç bir əlaqəniz yoxdur.</p>
</div>
<div class="paragraph">
<p>Bu nöqtədə, Bazaar deposun idxal etmək yolu tək bir branch-ınız olduğuna və ya bir neçə branch-ı olan bir depo ilə işlədiyinizə görə fərqlənir.</p>
</div>
</div>
<div class="sect4">
<h4 id="_tək_bir_branch_ilə_layihə">Tək bir branch ilə layihə</h4>
<div class="paragraph">
<p>İndi Bazaar deponuz olan qovluqda <code>cd</code> və Git deposunu işə salın:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cd /path/to/the/bzr/repository
$ git init</code></pre>
</div>
</div>
<div class="paragraph">
<p>İndi Bazaar deponuzu sadəcə ixrac edə və aşağıdakı əmrdən istifadə edərək Git deposuna çevirə bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ bzr fast-export --plain . | git fast-import</code></pre>
</div>
</div>
<div class="paragraph">
<p>Layihənin ölçüsündən asılı olaraq, Git deponuz bir neçə saniyədən bir neçə dəqiqəyə qədər sürətlə qurulur.</p>
</div>
</div>
<div class="sect4">
<h4 id="_əsas_branch_və_işləyən_bir_branch_olan_bir_layihə_işi">Əsas branch və işləyən bir branch olan bir layihə işi</h4>
<div class="paragraph">
<p>Branch-ları olan bir Bazaar deposunu da idxal edə bilərsiniz.
İki branch-nızın olduğunu düşünək: biri əsas branch-ı təmsil edir (myProject.trunk), digəri işləyən branch-dır (myProject.work).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ls
myProject.trunk myProject.work</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git deposunu və <code>cd</code>-ni yaradın:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git init git-repo
$ cd git-repo</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>master</code> branch-ını git-ə pull edin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ bzr fast-export --export-marks=../marks.bzr ../myProject.trunk | \
git fast-import --export-marks=../marks.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>İşləyən branch-ı Git-ə pull edin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ bzr fast-export --marks=../marks.bzr --git-branch=work ../myProject.work | \
git fast-import --import-marks=../marks.git --export-marks=../marks.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>İndi <code>git branch</code> sizə <code>work</code> branch-ını olduğu kimi <code>master</code> branch-ını da göstərir.
Tam olduğundan əmin olmaq üçün qeydləri yoxlayın və <code>marks.bzr</code> və <code>marks.git</code> fayllarından qurtulun.</p>
</div>
</div>
<div class="sect4">
<h4 id="_səhnələşdirmə_sahəsinin_sinxronlaşdırılması">Səhnələşdirmə sahəsinin sinxronlaşdırılması</h4>
<div class="paragraph">
<p>Sahib olduğunuz branch sayınız və istifadə etdiyiniz idxal metodundan asılı olmayaraq səhnələşdirmə sahəniz <code>HEAD</code> ilə sinxronizasiya edilmir və bir neçə branch-ın idxalı ilə iş qovluğunuz da sinxronizasiya edilmir.
Bu vəziyyət asanlıqla aşağıdakı əmrlə həll olunur:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git reset --hard HEAD</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_bzrignore_ilə_ignoring_edilmiş_faylları_ignore_etmək">.bzrignore ilə ignoring edilmiş faylları ignore etmək</h4>
<div class="paragraph">
<p>İndi ignore etmək üçün fayllara nəzər salaq.
Ediləcək ilk şey, <code>.bzrignore</code> adını <code>.gitignore</code> olaraq dəyişdirməkdir.
<code>.bzrignore</code> faylı "!!" ilə və ya "RE:" başlayan bir və ya bir neçə sətir varsa, onu dəyişdirməlisiniz və Bazaarın ignore etdiyi faylları ignore etmək üçün bəlkə də bir neçə <code>.gitignore</code> faylı yaratmalısınız.</p>
</div>
<div class="paragraph">
<p>Nəhayət, migrasiya üçün bu dəyişikliyi ehtiva edən bir commit yaratmalısınız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git mv .bzrignore .gitignore
$ # modify .gitignore if needed
$ git commit -am 'Migration from Bazaar to Git'</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_deponuzu_serverə_göndərmək">Deponuzu serverə göndərmək</h4>
<div class="paragraph">
<p>Budur!
İndi deponu yeni ev serverinə push edə bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add origin git@my-git-server:mygitrepository.git
$ git push origin --all
$ git push origin --tags</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git deponuz istifadəyə hazırdır.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_perforce_import">Perforce</h3>
<div class="paragraph">
<p>
İdxal etməyə baxacağınız növbəti sistem Perforce’dir.
Yuxarıda müzakirə etdiyimiz kimi, Git və Perforce-un bir-birlərinə danışmalarına icazə verməyin iki yolu var: git-p4 və Perforce Git Fusion.</p>
</div>
<div class="sect4">
<h4 id="_perforce_git_fusion">Perforce Git Fusion</h4>
<div class="paragraph">
<p>Git Fusion bu prosesi kifayət qədər ağrısız edir.
Bir konfiqurasiya sənədindən istifadə edərək layihə parametrlərinizi, istifadəçi xəritələrinizi və branch-larınızı konfiqurasiya etməyiniz kifayətdir (<a href="{{< relurl "book/az/v2/ch00/_p4_git_fusion" >}}">Git Fusion</a>-da müzakirə olunduğu kimi) və deponu klonlayın.
Git Fusion, yerli bir Git deposuna bənzər bir şey buraxır, daha sonra istəsəniz local bir Git hostuna push etməyə hazırdır.
İstəsəniz, Perforce’ı Git ev sahibi kimi istifadə edə bilərsiniz.</p>
</div>
</div>
<div class="sect4">
<h4 id="_git_p4">Git-p4</h4>
<div class="paragraph">
<p>Git-p4 idxal vasitəsi kimi də çıxış edə bilər.
Nümunə olaraq Jam layihəsini Perforce Public Depot-dan idxal edəcəyik.
Müştərinizi qurmaq üçün, Perforce deposuna işarə etmək üçün P4PORT mühit dəyişkənini ixrac etməlisiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ export P4PORT=public.perforce.com:1666</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Ardından izləmək üçün əlaqə qurmaq üçün bir Perforce deposuna ehtiyacınız var.
Nümunələrimiz üçün public.perforce.com saytındakı ictimai depodan istifadə edəcəyik, ancaq daxil olduğunuz hər hansı bir depodan istifadə edə bilərsiniz.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>
Depo və layihə yolunu və layihəni idxal etmək istədiyiniz yolu təmin edərək Perforce serverindən Jam layihəsini idxal etmək üçün <code>git p4 clone</code> əmrini işə salın:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git-p4 clone //guest/perforce_software/jam@all p4import
Importing from //guest/perforce_software/jam@all into p4import
Initialized empty Git repository in /private/tmp/p4import/.git/
Import destination: refs/remotes/p4/master
Importing revision 9957 (100%)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu xüsusi layihənin yalnız bir branch-ı var, ancaq branch görünüşləri ilə (və ya yalnız bir qovluq yığını) konfiqurasiya edilmiş branch-larınız varsa,
bütün layihə branch-larını da idxal etmək üçün <code>--detect-branches</code> flagını <code>git p4 clone</code> üçün istifadə edə bilərsiniz.
Bu barədə bir az daha ətraflı məlumat üçün <a href="{{< relurl "book/az/v2/ch00/_git_p4_branches" >}}">Branching</a> bölməsinə baxın.</p>
</div>
<div class="paragraph">
<p>Bu nöqtədə demək olar ki, bitirdiniz.
<code>p4import</code> qovluğuna gedib <code>git log</code>-ı işlətsəniz, idxal etdiyiniz işi görə bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -2
commit e5da1c909e5db3036475419f6379f2c73710c4e6
Author: giles &lt;giles@giles@perforce.com&gt;
Date:   Wed Feb 8 03:13:27 2012 -0800

    Correction to line 355; change &lt;/UL&gt; to &lt;/OL&gt;.

    [git-p4: depot-paths = "//public/jam/src/": change = 8068]

commit aa21359a0a135dda85c50a7f7cf249e4f7b8fd98
Author: kwirth &lt;kwirth@perforce.com&gt;
Date:   Tue Jul 7 01:35:51 2009 -0800

    Fix spelling error on Jam doc page (cummulative -&gt; cumulative).

    [git-p4: depot-paths = "//public/jam/src/": change = 7304]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hər git mesajında <code>git-p4</code> bir identifikator buraxdığını görə bilərsiniz.
Perforce dəyişiklik nömrəsinə daha sonra müraciət etməyiniz lazım olduğu təqdirdə bu identifikatoru orada saxlamaq yaxşıdır.
Bununla birlikdə, identifikatoru silmək istəsəniz, indi yeni depoda işə başlamazdan əvvəl bunu etməliyik.

Tanımlayıcı sətirləri kütləvi şəkildə silmək üçün <code>git filter-branch</code> istifadə edə bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git filter-branch --msg-filter 'sed -e "/^\[git-p4:/d"'
Rewrite e5da1c909e5db3036475419f6379f2c73710c4e6 (125/125)
Ref 'refs/heads/master' was rewritten</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>git log</code>-ı işə salırsınızsa, commit-lər üçün bütün SHA-1 hesablama cəmlərinin dəyişdiyini görə bilərsiniz, lakin <code>git-p4</code> string-ləri artıq commit mesajlarında yoxdur:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -2
commit b17341801ed838d97f7800a54a6f9b95750839b7
Author: giles &lt;giles@giles@perforce.com&gt;
Date:   Wed Feb 8 03:13:27 2012 -0800

    Correction to line 355; change &lt;/UL&gt; to &lt;/OL&gt;.

commit 3e68c2e26cd89cb983eb52c024ecdfba1d6b3fff
Author: kwirth &lt;kwirth@perforce.com&gt;
Date:   Tue Jul 7 01:35:51 2009 -0800

    Fix spelling error on Jam doc page (cummulative -&gt; cumulative).</code></pre>
</div>
</div>
<div class="paragraph">
<p>İdxalınız yeni Git serverinizə keçməyə hazırdır.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_git_tfs">TFS</h3>
<div class="paragraph">
<p>
Komandanız mənbə nəzarətini TFVC-dən Git-ə çevirirsə, əldə edə biləcəyiniz ən yüksək əslinə uyğun dönüşümünü istəyərsiniz.
Bu o deməkdir ki, interop bölməsi üçün həm git-tfs, həm də git-tf-ni əhatə etdiyimiz halda, yalnız bu hissə üçün git-tfs-i əhatə edəcəyik, çünki git-tfs branch-ları dəstəkləyir və bu git-tf istifadə etmək olduqca çətindir.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Bu, birtərəfli dönüşümdür.
Nəticədə Git deposu orijinal TFVC layihəsi ilə əlaqə qura bilməyəcək.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Ediləcək ilk şey istifadəçi adlarının xəritəsidir.
TFVC, dəyişikliklər üçün müəllif sahəsinə daxil olanlarla kifayət qədər sərbəstdir, lakin Git insan tərəfindən oxunaqlı bir ad və e-poçt ünvanı istəyir.
Bu məlumatı <code>tf</code> əmr sətrini müştərisindən ala bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-powershell" data-lang="powershell">PS&gt; tf history $/myproject -recursive &gt; AUTHORS_TMP</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu, layihənin tarixindəki bütün dəyişiklikləri tutur və <em>İstifadəçi</em> sütununun (ikincisi) məlumatlarını çıxarmaq üçün işləyəcəyimiz AUTHORS_TMP sənədinə qoyuruq.
Faylı açın və sütunun hansı işarədə başlayıb bitdiyini və yerini dəyişdirin, aşağıdakı əmr sətrində <code>cut</code> əmrini <code>11-20</code> parametrlərini tapılanlarla əvəz edin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-powershell" data-lang="powershell">PS&gt; cat AUTHORS_TMP | cut -b 11-20 | tail -n+3 | sort | uniq &gt; AUTHORS</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>cut</code> əmri hər sətirdən yalnız 11 ilə 20 arasındakı simvolları saxlayır.
<code>tail</code> əmri sahə başlıqları və ASCII-art vurğulayan ilk iki sətiri atlayır.
Bütün bunların nəticəsi, təkrarlamaları aradan qaldırmaq üçün <code>sort</code> və <code>uniq</code> şəkillərinə göndərilir və <code>AUTHORS</code> adlı bir faylda saxlanılır.
Növbəti addım manualdır; git-tfs-in bu fayldan səmərəli istifadə etməsi üçün hər sətir bu formatda olmalıdır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">DOMAIN\username = User Name &lt;email@address.com&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sol tərəfdəki hissə TFVC-dən “User” sahəsidir və bərabər işarəsinin sağ tərəfindəki hissə Git commit-ləri üçün istifadə ediləcək istifadəçi adıdır.</p>
</div>
<div class="paragraph">
<p>Bu faylı əldə etdikdən sonra bir sonrakı iş, maraqlandığınız TFVC layihəsinin tam bir klonunu yaratmaqdır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-powershell" data-lang="powershell">PS&gt; git tfs clone --with-branches --authors=AUTHORS https://username.visualstudio.com/DefaultCollection $/project/Trunk project_git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bundan sonra, commit mesajların altından <code>git-tfs-id</code> bölmələrini təmizləmək lazımdır.
Aşağıdakı əmr bunu edəcəkdir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-powershell" data-lang="powershell">PS&gt; git filter-branch -f --msg-filter 'sed "s/^git-tfs-id:.*$//g"' '--' --all</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu, “git-tfs-id:” ilə başlayan hər hansı bir sətri boşluqla əvəz etmək üçün Git-bash mühitindən  <code>sed</code> əmrini istifadə edir və Git bundan sonra ignore qalacaq.</p>
</div>
<div class="paragraph">
<p>Hamısı bitdikdən sonra yeni bir remote əlavə etməyə, bütün branch-larınızı yuxarıya qaldırmağa və komandanızın Git-dən işə başlamasına hazırsınız.</p>
</div>
</div>
<div class="sect3">
<h3 id="_custom_importer">Xüsusi İdxalçı</h3>
<div class="paragraph">
<p>

Sisteminiz yuxarıda göstərilənlərdən biri deyilsə, onlayn bir idxalçı axtarmalısınız - keyfiyyətli idxalçılar CVS, Clear Case, Visual Source Safe hətta arxivlər siyahısı daxil olmaqla bir çox digər sistemlər üçün mövcuddur.</p>
</div>
<div class="paragraph">
<p>Bu vasitələrdən heç biri sizin üçün işləmirsə, daha qaranlıq bir alətiniz varsa və ya başqa bir xüsusi idxal prosesinə ehtiyacınız varsa, <code>git fast-import</code> istifadə etməlisiniz.
Bu əmr, müəyyən Git məlumatlarını yazmaq üçün stdin-dən sadə təlimatları oxuyur.
Git obyektlərini bu şəkildə yaratmaq, xam Git əmrlərini işə salmaqdan və ya xam obyektləri yazmağa çalışmaqdan daha asandır (daha çox məlumat üçün <a href="{{< relurl "book/az/v2/ch00/ch10-git-internals" >}}">Git’in Daxili İşləri</a> bax).
Bu şəkildə, idxal etdiyiniz sistemdən lazımi məlumatları oxuyan və stdout üçün birbaşa təlimatları yazan bir idxal skriptini yaza bilərsiniz.
Daha sonra bu proqramı işə sala və nəticəsini <code>git fast-import</code> vasitəsilə ötürə bilərsiniz.</p>
</div>
<div class="paragraph">
<p>Sürətlə nümayiş etdirmək üçün sadə bir idxalçı yazacaqsınız.
Tutaq ki, <code>current</code>-də işləyirsiniz, zaman zaman qovluğu bir time-stamped <code>back_YYYY_MM_DD</code> ehtiyat qovluğuna kopyalayaraq proyektinizi backup edirsiniz və bunu Git-ə idxal etmək istəyirsiniz.
Qovluq quruluşunuz belə görünür:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ls /opt/import_from
back_2014_01_02
back_2014_01_04
back_2014_01_14
back_2014_02_03
current</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bir Git qovluğunu idxal etmək üçün Gitin məlumatlarını necə saxladığını nəzərdən keçirməlisiniz.
Xatırladığınız kimi, Git əsas etibarilə məzmunun bir snapshot-una işarə edən obyektlərin əlaqəli siyahısıdır.
Etməli olduğunuz şey məzmunun snpshot-larının nə olduğunu, məlumatları onlara yönəldən şeyləri və daxil olma qaydalarını  <code>fast-import</code> etməyinizdir.
Strategiyanız snapshot-lardan bir-bir keçmək və hər bir qovluğu əvvəlki ilə əlaqələndirərək hər bir kataloqun məzmunu ilə commit-lər yaratmaq olacaq.</p>
</div>
<div class="paragraph">
<p><a href="{{< relurl "book/az/v2/ch00/_an_example_git_enforced_policy" >}}">Git-Enforced Siyasət Nümunəsi</a>-də etdiyimiz kimi, bunu Ruby-də yazacağıq, çünki ümumiyyətlə işləmək və oxunması asan olur.
Bu nümunəni tanış olduğunuz hər hansı bir şeydə olduqca asanlıqla yaza bilərsiniz - yalnız müvafiq məlumatları <code>stdout</code>-a yazdırmaq lazımdır.
Və Windows üzərində işləyirsinizsə, bu, sətirlərinizin sonunda vaqon qayıtmalarını daxil etməməyə xüsusi diqqət yetirməli olduğunuz mənasını verir - <code>git fast-import</code> yalnız Windows istifadə etdiyi daşıyıcı xətləri (CRLF) deyil, yalnız xətt lentləri (LF) istəməyə gəldikdə çox dəqiqdir.</p>
</div>
<div class="paragraph">
<p>Başlamaq üçün hədəf qovluğunu dəyişəcəksiniz və hər biri commit olaraq idxal etmək istədiyiniz bir snapshot-u olan hər subdirectory-ni müəyyənləşdirəcəksiniz.
Hər subdirectory-ni keçib ixrac etmək üçün lazım olan əmrləri çap edəcəksiniz.
Əsas dövrəniz belə görünür:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">last_mark = nil

# loop through the directories
Dir.chdir(ARGV[0]) do
  Dir.glob("*").each do |dir|
    next if File.file?(dir)

    # move into the target directory
    Dir.chdir(dir) do
      last_mark = print_export(dir, last_mark)
    end
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hər bir qovluğun içərisində əvvəlki snapshot-un manifestini və işarəsini götürən və bunun manifestini və işarəsini qaytaran <code>print_export</code> işlədirsiniz; bu şəkildə onları düzgün bir şəkildə bağlaya bilərsiniz.
“Mark”  commit-ə verdiyiniz bir identifikator üçün <code>fast-import</code> terminidir; commit-lər yaradarkən, hər birinə digər commit-lərdən əlaqələndirmək üçün istifadə edə biləcəyiniz bir işarə verirsiniz.
Beləliklə, <code>print_export</code> metodunda ediləcək ilk şey qovluq adından bir işarənin yaradılmasıdır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">mark = convert_dir_to_mark(dir)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bunu bir dizin qovluğu yaratmaqla və indeks dəyərini işarə olaraq istifadə etməklə edəcəksiniz, çünki bir işarə tam olmalıdır.
Metodunuz belə görünür:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">$marks = []
def convert_dir_to_mark(dir)
  if !$marks.include?(dir)
    $marks &lt;&lt; dir
  end
  ($marks.index(dir) + 1).to_s
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Commit-inizin tam bir təmsilçiliyinə sahib olduğunuz üçün, commit meta məlumatları üçün bir tarixə ehtiyacınız var.
Tarix qovluq adına ifadə olunduğundan, onu təhlil edəcəksiniz.
<code>Print_export</code> falınızdakı növbəti sətir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">date = convert_dir_to_date(dir)</code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code>convert_dir_to_date</code> is defined as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">def convert_dir_to_date(dir)
  if dir == 'current'
    return Time.now().to_i
  else
    dir = dir.gsub('back_', '')
    (year, month, day) = dir.split('_')
    return Time.local(year, month, day).to_i
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu, hər bir qovluğun tarixi üçün bir tam dəyər qaytarır.
Hər bir commit üçün lazım olan son meta məlumat parçası, qlobal dəyişəndə sabit kodladığınız ötürmə məlumatlarıdır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">$author = 'John Doe &lt;john@example.com&gt;'</code></pre>
</div>
</div>
<div class="paragraph">
<p>İndi idxalçı üçün commit məlumatlarını çap etməyə başlamağa hazırsınız.
İlkin məlumatda commit obyektini və hansı branch-da olduğunuzu, sonra yaratdığınız işarəni, məlumat verən məlumatı və commit mesajını, sonra varsa əvvəlki commit-i təyin etdiyiniz bildirilir.
Kod belə görünür:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby"># print the import information
puts 'commit refs/heads/master'
puts 'mark :' + mark
puts "committer #{$author} #{date} -0700"
export_data('imported from ' + dir)
puts 'from :' + last_mark if last_mark</code></pre>
</div>
</div>
<div class="paragraph">
<p>Saat dilimini (-0700) kodlaşdırın, çünki bunu etmək asandır.
Başqa bir sistemdən idxal edirsinizsə, zaman zonasını ofset kimi göstərməlisiniz.
Commit mesajı xüsusi bir formatda ifadə olunmalıdır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>data (size)\n(contents)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Format məlumat sözündən, oxunacaq məlumatın ölçüsündən, yeni bir sətirdən və nəhayət məlumatdan ibarətdir.
Faylın məzmununu daha sonra müəyyənləşdirmək üçün eyni formatı istifadə etməlisiniz, çünki köməkçi bir metod, <code>export_data</code> yaradırsınız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">def export_data(string)
  print "data #{string.size}\n#{string}"
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Qalan yalnız hər bir snapshot üçün fayl məzmununun müəyyənləşdirilməsidir.
Bu çox asandır, çünki hər biriniz bir kataloqdadır - qovluqdakı hər bir sənədin məzmunu və ardından <code>deleteall</code> əmrini çap edə bilərsiniz.
Daha sonra Git hər bir snapshot-u uyğun şəkildə qeyd edəcək:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">puts 'deleteall'
Dir.glob("**/*").each do |file|
  next if !File.file?(file)
  inline_data(file)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Qeyd: Bir çox sistem öz reviziyalarını bir commit-dən digərinə dəyişiklik kimi qəbul etdiyini düşündüyündən, sürətli idxal da hər bir faylda hansı faylların əlavə olunduğunu, silindiyini və ya dəyişdirildiyini və yeni məzmununun nə olduğunu müəyyənləşdirmək üçün əmrlər götürə bilər.
Snapshot-lar arasındakı fərqləri hesablaya bilər və yalnız bu məlumatları verə bilərsiniz, ancaq bunu etmək daha mürəkkəbdir - Git-ə bütün məlumatları verə və onu başa düşməsinə icazə verə bilərsiniz.
Bu, məlumatlarınıza daha uyğun gəlirsə, məlumatlarınızı bu şəkildə necə təqdim edəcəyiniz barədə ətraflı məlumat üçün <code>fast-import</code> man page-ini yoxlayın.</p>
</div>
<div class="paragraph">
<p>Yeni fayl məzmununun siyahısı və ya dəyişdirilmiş bir sənədin yeni məzmunu ilə göstərilməsi formatı belədir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>M 644 inline path/to/file
data (size)
(file contents)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Budur, 644 rejimi (executable fyllarınız varsa, bunun əvəzinə 755-i aşkarlamalı və təyin etməlisiniz) və sətir içərisindəki məzmunu bu sətirdən dərhal sonra sadalayacağınızı söyləyir.
<code>inline_data</code> metodunuz belə görünür:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">def inline_data(file, code = 'M', mode = '644')
  content = File.read(file)
  puts "#{code} #{mode} inline #{file}"
  export_data(content)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Daha əvvəl müəyyənləşdirdiyiniz <code>export_data</code> metodundan təkrar istifadə edirsiniz, çünki bu, commit mesajı məlumatlarınızı təyin etməyinizlə eynidir.</p>
</div>
<div class="paragraph">
<p>Etməli olduğunuz son şey cari işarəni növbəti təkrarlamaya ötürmək üçün qaytarmaqdır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">return mark</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Windows-da işləyirsinizsə, əlavə bir addım əlavə etdiyinizə əmin olmalısınız.
Daha əvvəl də qeyd edildiyi kimi, Windows yeni sətir simvolları üçün CRLF istifadə edir, <code>git fast-import</code> isə yalnız LF gözləyir.
Bu problemi həll etmək və <code>git fast-import</code>-ı xoşbəxt etmək üçün ruby-ə CRLF əvəzinə LF istifadə etməsini söyləməlisiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">$stdout.binmode</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Bu qədər.
Budur skript bütövlükdə:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#!/usr/bin/env ruby

$stdout.binmode
$author = "John Doe &lt;john@example.com&gt;"

$marks = []
def convert_dir_to_mark(dir)
    if !$marks.include?(dir)
        $marks &lt;&lt; dir
    end
    ($marks.index(dir)+1).to_s
end

def convert_dir_to_date(dir)
    if dir == 'current'
        return Time.now().to_i
    else
        dir = dir.gsub('back_', '')
        (year, month, day) = dir.split('_')
        return Time.local(year, month, day).to_i
    end
end

def export_data(string)
    print "data #{string.size}\n#{string}"
end

def inline_data(file, code='M', mode='644')
    content = File.read(file)
    puts "#{code} #{mode} inline #{file}"
    export_data(content)
end

def print_export(dir, last_mark)
    date = convert_dir_to_date(dir)
    mark = convert_dir_to_mark(dir)

    puts 'commit refs/heads/master'
    puts "mark :#{mark}"
    puts "committer #{$author} #{date} -0700"
    export_data("imported from #{dir}")
    puts "from :#{last_mark}" if last_mark

    puts 'deleteall'
    Dir.glob("**/*").each do |file|
        next if !File.file?(file)
        inline_data(file)
    end
    mark
end

# Loop through the directories
last_mark = nil
Dir.chdir(ARGV[0]) do
    Dir.glob("*").each do |dir|
        next if File.file?(dir)

        # move into the target directory
        Dir.chdir(dir) do
            last_mark = print_export(dir, last_mark)
        end
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu skripti işlədirsinizsə, buna bənzər bir məzmun əldə edəcəksiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ruby import.rb /opt/import_from
commit refs/heads/master
mark :1
committer John Doe &lt;john@example.com&gt; 1388649600 -0700
data 29
imported from back_2014_01_02deleteall
M 644 inline README.md
data 28
# Hello

This is my readme.
commit refs/heads/master
mark :2
committer John Doe &lt;john@example.com&gt; 1388822400 -0700
data 29
imported from back_2014_01_04from :1
deleteall
M 644 inline main.rb
data 34
#!/bin/env ruby

puts "Hey there"
M 644 inline README.md
(...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>İmporter-i çalıştırmak üçün bu çıxışı idxal etmək istədiyiniz Git qovluğunda olarkən <code>git fast-import</code> vasitəsilə ilə ötürün.
Yeni bir qovluq yaradıb sonra bir başlanğıc nöqtəsi üçün içərisindəki <code>git init</code> -i işə sala və sonra skriptinizi işə sala bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git init
Initialized empty Git repository in /opt/import_to/.git/
$ ruby import.rb /opt/import_from | git fast-import
git-fast-import statistics:
---------------------------------------------------------------------
Alloc'd objects:       5000
Total objects:           13 (         6 duplicates                  )
      blobs  :            5 (         4 duplicates          3 deltas of          5 attempts)
      trees  :            4 (         1 duplicates          0 deltas of          4 attempts)
      commits:            4 (         1 duplicates          0 deltas of          0 attempts)
      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)
Total branches:           1 (         1 loads     )
      marks:           1024 (         5 unique    )
      atoms:              2
Memory total:          2344 KiB
       pools:          2110 KiB
     objects:           234 KiB
---------------------------------------------------------------------
pack_report: getpagesize()            =       4096
pack_report: core.packedGitWindowSize = 1073741824
pack_report: core.packedGitLimit      = 8589934592
pack_report: pack_used_ctr            =         10
pack_report: pack_mmap_calls          =          5
pack_report: pack_open_windows        =          2 /          2
pack_report: pack_mapped              =       1457 /       1457
---------------------------------------------------------------------</code></pre>
</div>
</div>
<div class="paragraph">
<p>Gördüyünüz kimi uğurla başa çatdıqda, həyata keçirdikləri barədə bir çox statistika verir.
Bu vəziyyətdə, 1 branch-a  4 commit üçün cəmi 13 obyekt idxal etdiniz.
İndi yeni tarixçənizi görmək üçün <code>git log</code>-u işə sala bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -2
commit 3caa046d4aac682a55867132ccdfbe0d3fdee498
Author: John Doe &lt;john@example.com&gt;
Date:   Tue Jul 29 19:39:04 2014 -0700

    imported from current

commit 4afc2b945d0d3c8cd00556fbe2e8224569dc9def
Author: John Doe &lt;john@example.com&gt;
Date:   Mon Feb 3 01:00:00 2014 -0700

    imported from back_2014_02_03</code></pre>
</div>
</div>
<div class="paragraph">
<p>Budur - gözəl, təmiz bir Git deposu.
Heç bir şeyin yoxlanılmadığını qeyd etmək vacibdir - əvvəlcə iş qovluğunda heç bir faylınız yoxdur.
Bunları əldə etmək üçün branchnızı <code>master</code>-i n olduğu yerə sıfırlamalısınız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ls
$ git reset --hard master
HEAD is now at 3caa046 imported from current
$ ls
README.md main.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>fast-import</code> aləti ilə daha çox şey edə bilərsiniz - fərqli rejimləri, ikili məlumatları, birdən çox branch-ı və birləşmə, etiketlər, irəliləyiş göstəriciləri və s.
Daha mürəkkəb ssenarilərin bir sıra nümunələri Git qaynaq kodunun <code>contrib/fast-import</code> qovluğunda mövcuddur.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>