---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: az
  chapter:
    title: Git Alətləri
    number: 7
  section:
    title: Stashing və Təmizləmə
    number: 3
    cs_number: '7.3'
    previous: book/az/v2/Git-Alətləri-Interaktiv-Səhnələşdirmə
    next: book/az/v2/Git-Alətləri-İşinizin-İmzalanması
title: Git - Stashing və Təmizləmə
url: "/book/az/v2/Git-Alətləri-Stashing-və-Təmizləmə.html"
---
<h2 id="_git_stashing">Stashing və Təmizləmə</h2>
<div class="paragraph">
<p>Tez-tez, layihənizin bir hissəsi üzərində işlədiyiniz zaman işlər qarışıq vəziyyətdədir və başqa bir şey üzərində işləmək üçün branch-ları biraz dəyişdirmək istəyirsiniz.
Məsələ burasındadır ki, bu məqama daha sonra qayıtmaq üçün yarımçıq iş görmək istəmirsiniz.
Bu məsələnin cavabı <code>git stash</code> əmridir.</p>
</div>
<div class="paragraph">
<p>Stashing iş qovluğunuzun çirkli vəziyyətini alır - yəni dəyişdirilmiş izlənilmiş sənədlərinizi və mərhələli dəyişikliklərinizi - və istənilən vaxt yenidən tətbiq edə biləcəyiniz tamamlanmamış dəyişikliklər yığınında saxlayır (fərqli bir branch-da da).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">
<code>git stash push</code>-ə köçmək</div>
<div class="paragraph">
<p>2017-ci il Oktyabr ayının sonundan etibarən Git poçt siyahısında geniş şəkildə müzakirələr aparıldı, burada <code>git stash save</code> əmri mövcud alternativ <code>git stash push</code> yerinə ləğv edildi.
Bunun əsas səbəbi, <code>git stash push</code>  seçilmiş <em>pathspecs</em>-ni saxlama seçimini təqdim etməsidir, <code>git stash save</code>-i dəstəkləmir.</p>
</div>
<div class="paragraph">
<p><code>git stash save</code> tezliklə getməyəcək, buna görə birdən yox olmasından narahat olmayın.
Ancaq yeni funksionallıq üçün <code>push</code> alternativinə keçməyə başlamaq istəyə bilərsiniz.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h3 id="_i̇şinizi_stashing_etmək">İşinizi Stashing Etmək</h3>
<div class="paragraph">
<p>Stashing-i nümayiş etdirmək üçün layihənizə girib bir neçə sənəd üzərində işləməyə başlayacaqsınız və ola bilsin dəyişikliklərdən birini səhnələşdirəsiniz.
<code>git status</code> işlədirsinizsə, çirkli vəziyyətinizi görə bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

	modified:   index.html

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

	modified:   lib/simplegit.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>İndi branch-ları dəyişdirmək istəyirsiniz, amma hələ işlədiyin şeyi etmək istəmirsiniz, buna görə də dəyişiklikləri gizlədəcəksiniz.
Yeni bir yığını yığınınıza göndərmək üçün <code>git stash</code> və ya <code>git stash push</code> əmrlərini işlədin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git stash
Saved working directory and index state \
  "WIP on master: 049d078 Create index file"
HEAD is now at 049d078 Create index file
(To restore them type "git stash apply")</code></pre>
</div>
</div>
<div class="paragraph">
<p>İndi iş qovluğunuzun təmiz olduğunu görə bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
# On branch master
nothing to commit, working directory clean</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu nöqtədə branch-ları dəyişə və başqa yerdə işləyə bilərsiniz; dəyişiklikləriniz stack-da saxlanılır.
Hansı zibil saxladığınızı görmək üçün <code>git stash list</code>-dən istifadə edə bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git stash list
stash@{0}: WIP on master: 049d078 Create index file
stash@{1}: WIP on master: c264051 Revert "Add file_size"
stash@{2}: WIP on master: 21d80a5 Add number to log</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu vəziyyətdə, əvvəl iki stash qeyd olundu, beləliklə üç fərqli stash işinə giriş əldə edə bilərsiniz.
Orijinal stash əmrinin kömək çıxışında göstərilən əmrdən istifadə edərək təzə saxladığınızı yenidən tətbiq edə bilərsiniz: <code>git stash apply</code>.</p>
</div>
<div class="paragraph">
<p>Daha köhnə işarələrdən birini tətbiq etmək istəyirsinizsə, onu belə adlandıraraq təyin edə bilərsiniz:<code>git stash apply stash@{2}</code>.
Bir saxlama yeri təyin etməsəniz, Git ən son stash-ı götürür və tətbiq etməyə çalışır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git stash apply
On branch master
Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

	modified:   index.html
	modified:   lib/simplegit.rb

no changes added to commit (use "git add" and/or "git commit -a")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git’in stash-ı saxladığınız zaman geri qaytardığınız faylları yenidən dəyişdirdiyini görə bilərsiniz.
Bu vəziyyətdə, stash-ı tətbiq etməyə çalışarkən təmiz bir iş qovluğuna sahib oldunuz və onu saxladığınız eyni branch-a tətbiq etməyə çalışdınız.
Təmiz bir iş qovluğuna sahib olmaq və eyni branch-da tətbiq etmək, bir stash-a müvəffəqiyyətlə tətbiq etmək üçün lazım deyil.
Bir branch-da bir stash saxlaya bilərsiniz, daha sonra başqa bir branch-a keçə və dəyişiklikləri yenidən tətbiq etməyə çalışa bilərsiniz.
Bir stash tətbiq edərkən iş qovluğunuzda dəyişdirilmiş və sənədləşdirilməmiş fayllara da sahib ola bilərsiniz - Git bir şeyi artıq təmiz bir şəkildə tətbiq etmirsə, konfliktləri birləşdirəcəkdir.</p>
</div>
<div class="paragraph">
<p>Fayllarınızdakı dəyişikliklər yenidən tətbiq edildi, lakin əvvəllər səhnələşdirdiyiniz fayl yenidən bərpa olunmadı.
Bunu etmək üçün  mərhələli dəyişiklikləri yenidən tətbiq etməyini demək üçün <code>--index</code> seçimi ilə <code>git stash apply</code> əmrini  çalıştırmalısınız.
Bunun əvəzinə işləsəniz, əvvəlki vəziyyətinizə qayıdardınız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git stash apply --index
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

	modified:   index.html

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

	modified:   lib/simplegit.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tətbiq etmə seçimi yalnız stash edilmiş işi tətbiq etməyə çalışır - onu stack-nızda saxlamağa davam edirsiniz.
Silmək üçün stash-ın adı ilə <code>git stash drop</code>-u işlədə bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git stash list
stash@{0}: WIP on master: 049d078 Create index file
stash@{1}: WIP on master: c264051 Revert "Add file_size"
stash@{2}: WIP on master: 21d80a5 Add number to log
$ git stash drop stash@{0}
Dropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Stash-ı tətbiq etmək üçün <code>git stash pop</code>-ı da işə sala və dərhal stack-a ata bilərsiniz.</p>
</div>
</div>
<div class="sect3">
<h3 id="_kreativ_stashing">Kreativ Stashing</h3>
<div class="paragraph">
<p>Faydalı ola biləcək bir neçə stash variantı var.
Kifayət qədər populyar olan ilk seçim, <code>git stash</code> əmrinə <code>--keep-index</code>  seçimidir.
Bu, Git-dən yalnız hazırlanmış bütün məzmunu yaratmaq üçün deyil, həm də indeksləşdirməsini tələb edir.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status -s
M  index.html
 M lib/simplegit.rb

$ git stash --keep-index
Saved working directory and index state WIP on master: 1b65b17 added the index file
HEAD is now at 1b65b17 added the index file

$ git status -s
M  index.html</code></pre>
</div>
</div>
<div class="paragraph">
<p>Stash ilə etmək istəyə biləcəyiniz başqa bir ümumi şey izlənilməmiş faylların yanında izlənilməmiş sənədləri də zibilə salmaqdır.
Varsayılan olaraq, <code>git stash</code> yalnız dəyişdirilmiş və səhnələşdirilmiş <em>tracked</em> fayllarını saxlayır.
Əgər <code>--include-untracked</code> və ya <code>-u</code> qeyd etsəniz, Git, yaradılan depoda izlənməmiş faylları əlavə edəcəkdir.
Bununla birlikdə, izlənməmiş faylları stash-a daxil etmək hələ açıq şəkildə <em>ignored</em> fayllarını daxil etməyəcək; əlavə olaraq məhəl qoyulmayan sənədləri daxil etmək üçün <code>--all</code> (və ya sadəcə <code>-a</code>) istifadə edin.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status -s
M  index.html
 M lib/simplegit.rb
?? new-file.txt

$ git stash -u
Saved working directory and index state WIP on master: 1b65b17 added the index file
HEAD is now at 1b65b17 added the index file

$ git status -s
$</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nəhayət, <code>--patch</code> flag-nı təyin etsəniz, Git dəyişdirilmiş hər şeyi stash etmiyəcək, əksinə dəyişiklərdən hansını saxlamağınızı və iş qovluğunuzda saxlamaq istədiyinizi interaktiv şəkildə təklif edəcəkdir.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git stash --patch
diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 66d332e..8bb5674 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -16,6 +16,10 @@ class SimpleGit
         return `#{git_cmd} 2&gt;&amp;1`.chomp
       end
     end
+
+    def show(treeish = 'master')
+      command("git show #{treeish}")
+    end

 end
 test
Stash this hunk [y,n,q,a,d,/,e,?]? y

Saved working directory and index state WIP on master: 1b65b17 added the index file</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_stash_dan_bir_branch_yaratmaq">Stash-dan bir Branch Yaratmaq</h3>
<div class="paragraph">
<p>İşin bir hissəsini saxlasanız, bir müddət orada qoyun və işi saxladığınız branch-da davam edin, işi yenidən tətbiq etməkdə çətinlik çəkə bilərsiniz.</p>
</div>
<div class="paragraph">
<p>Tətbiq dəyişdirdiyiniz bir faylı dəyişdirməyə çalışırsa, birləşmə konflikti yaranacaq və onu həll etməyə çalışmalı olacaqsınız.
Gizlənmiş dəyişiklikləri yenidən sınamaq üçün daha asan bir yol istəyirsinizsə, seçdiyiniz branch adı ilə sizin üçün yeni bir branch yaradan <code>git stash branch &lt;new branchname&gt;</code> düyməsini işə sala bilərsiniz. İşləyin, işinizi orada yenidən tətbiq edin və sonra müvəffəqiyyətlə tətbiq olunarsa saxlayın:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git stash branch testchanges
M	index.html
M	lib/simplegit.rb
Switched to a new branch 'testchanges'
On branch testchanges
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

	modified:   index.html

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

	modified:   lib/simplegit.rb

Dropped refs/stash@{0} (29d385a81d163dfd45a452a2ce816487a6b8b014)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu stashed işi asanlıqla bərpa etmək və yeni bir branch-da işləmək üçün gözəl bir qısayoldur.</p>
</div>
</div>
<div class="sect3">
<h3 id="_git_clean">İş Qovluğunuzun Təmizlənməsi</h3>
<div class="paragraph">
<p>Nəhayət, işinizdəki bəzi işləri və ya faylları saxlamaq istəməyəcəksiniz, o zaman sadəcə bunlardan qurtulun; <code>git clean</code> əmri bunun üçündür.</p>
</div>
<div class="paragraph">
<p>İş qovluğunuzu təmizləməyin bəzi ümumi səbəbləri birləşmə və ya xarici alətlər nəticəsində əmələ gələn qırıntıları aradan qaldırmaq və ya təmiz bir quruluşu idarə etmək üçün tikinti əsərlərini silmək ola bilər.</p>
</div>
<div class="paragraph">
<p>Bu əmrlə olduqca diqqətli olmaq istərdiniz, çünki işləmə qovluğundan izlənilməyən faylları silmək üçün hazırlanmışdır.
Fikrinizi dəyişirsinizsə, bu faylların məzmununun alınmasına çox vaxt rast gəlinmir.
Daha etibarlı bir seçim, hər şeyi aradan qaldırmaq, ancaq bir yerə yığmaq üçün <code>git stash --all</code> işlətməkdir.</p>
</div>
<div class="paragraph">
<p>Cruft fayllarını silmək və ya iş qovluğunuzu təmizləmək istədiyinizi düşünsək, bunu <code>git clean</code> ilə edə bilərsiniz.
İşləmə qovluğundakı bütün izlənilməmiş faylları silmək üçün, bütün faylları və nəticədə boş qalan subdirectory-ləri silən <code>git clean -f -d</code> düyməsini işə sala bilərsiniz.
<code>-f</code>, <em>force</em> və ya “həqiqətən bunu et” deməkdir və Git konfiqurasiya dəyişəninin <code>clean.requireForce</code> açıq şəkildə false olaraq ayarlanmadığı təqdirdə tələb olunur.</p>
</div>
<div class="paragraph">
<p>Nə edəcəyini görmək istəyirsinizsə, əmri <code>--dry-run</code> (və ya <code>-n</code>) seçimi ilə işlədə bilərsiniz, yəni “quru işləyin və nəyi çıxardığınızı mənə deyin.”.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clean -d -n
Would remove test.o
Would remove tmp/</code></pre>
</div>
</div>
<div class="paragraph">
<p>Varsayılan olaraq, <code>git clean</code> əmri yalnız göz ardı edilməyən yoxlanılmamış faylları siləcəkdir.
<code>.gitignore</code>-dakı bir nümunə ilə uyğun gələn hər hansı bir fayl silinməyəcək.
Bu faylları da silmək istəyirsinizsə, məsələn, bir yığımdan yaradılan bütün <code>.o</code> fayllarını silmək istəyirsinizsə, beləliklə tamamilə təmiz bir yığın yarada bilərsiniz, təmiz əmrinə <code>-x</code> əlavə edə bilərsiniz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status -s
 M lib/simplegit.rb
?? build.TMP
?? tmp/

$ git clean -n -d
Would remove build.TMP
Would remove tmp/

$ git clean -n -d -x
Would remove build.TMP
Would remove test.o
Would remove tmp/</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>git clean</code> əmrinin nə ediləcəyini bilmirsinizsə, <code>-n</code>-i <code>-f</code>-ə dəyişdirmədən və real olaraq yerinə yetirmədən əvvəl həmişə bir <code>-n</code> ilə işləyin.
Prosesə diqqətli olmağınızın başqa bir yolu, <code>-i</code> or “interactive” flag-la işlətməkdir.</p>
</div>
<div class="paragraph">
<p>Bu, təmiz əmri interaktiv bir rejimdə işlədəcəkdir.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clean -x -i
Would remove the following items:
  build.TMP  test.o
*** Commands ***
    1: clean                2: filter by pattern    3: select by numbers    4: ask each             5: quit
    6: help
What now&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu şəkildə hər bir faylı ayrı-ayrılıqda nəzərdən keçirə və ya interaktiv şəkildə silmək üçün nümunələri təyin edə bilərsiniz.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Git-dən iş qovluğunuzu təmizləməsini istəməyinizdə daha güclü olmanız lazım ola biləcəyi qəribə bir vəziyyət var.
Digər Git depolarını (bəlkə də submodul kimi) kopyaladığınız və ya klonladığınız bir iş qovluğundasınızsa, hətta <code>git clean -fd</code> bu qovluqları silməkdən imtina edəcəkdir.
Belə hallarda vurğu üçün ikinci bir <code>-f</code> seçimi əlavə etməlisiniz.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>