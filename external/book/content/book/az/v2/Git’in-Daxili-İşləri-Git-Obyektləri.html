---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: az
  chapter:
    title: Git’in Daxili İşləri
    number: 10
  section:
    title: Git Obyektləri
    number: 2
    cs_number: '10.2'
    previous: book/az/v2/Git’in-Daxili-İşləri-Plumbing-və-Porcelain
    next: book/az/v2/Git’in-Daxili-İşləri-Git-Referansları
title: Git - Git Obyektləri
url: "/book/az/v2/Git’in-Daxili-İşləri-Git-Obyektləri.html"
---
<h2 id="_objects">Git Obyektləri</h2>
<div class="paragraph">
<p>Git, məzmuna yönəldilə bilən bir sistemdir.
Əla.
Bəs bunun mənası nədir?
Bu, Git-in mərkəzində sadə bir əsas dəyər məlumat deposu olduğu deməkdir.
Bunun mənası budur ki, Git deposuna hər cür məzmun daxil edə bilərsiniz, bunun üçün Git bu məzmunu almaq üçün daha sonra istifadə edə biləcəyiniz unikal bir key-i geri qaytaracaqdır.</p>
</div>
<div class="paragraph">
<p>Nümayiş olaraq, bəzi məlumatları götürən, <code>.git/objects</code> qovluğunda (<em>object database</em>) saxlayan və indi buna istinad edən unikal key-i verən <code>git hash-object</code> plumbing əmrinə baxaq.</p>
</div>
<div class="paragraph">
<p>Əvvəlcə yeni bir Git deposunu işə salırsınız və <code>objects</code> qovluğunda (əvvəlcədən) heç bir şey olmadığını yoxlayırsınız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git init test
Initialized empty Git repository in /tmp/test/.git/
$ cd test
$ find .git/objects
.git/objects
.git/objects/info
.git/objects/pack
$ find .git/objects -type f</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git, <code>objects</code> qovluğunu işə saldı və içərisində <code>pack</code> və <code>info</code> alt qovluqlarını yaratdı, lakin orada normal fayllar yoxdur.
İndi yeni bir məlumat obyekti yaratmaq və onu yeni Git verilənlər bazasında manual şəkildə saxlamaq üçün <code>git hash-object</code>-dən istifadə edək:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 'test content' | git hash-object -w --stdin
d670460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ən sadə şəkildə, <code>git hash-object</code> verdiyiniz məzmunu alacaq və <em>would</em>-nin Git verilənlər bazasında saxlamaq üçün istifadə etdiyi unikal key-i qaytaracaqdı.
Daha sonra <code>-w</code> seçimi əmrə key-i sadəcə qaytarmağı deyil, həmin obyekti verilənlər bazasına yazmağı əmr edir.
Nəhayət, <code>--stdin</code> seçimi, <code>git hash-object</code>-ə məzmunun stdin-dən işlənməsinin alınmasını deyir; Əks təqdirdə, əmr, məzmunun daxil olduğu əmrin sonunda bir fayl adı arqumentinin istifadə olunacağını gözləyir.</p>
</div>
<div class="paragraph">
<p>Yuxarıda göstərilən əmrdən çıxan nəticə 40 simvollu bir cəmi hash-dir.
Bu SHA-1 hash-ı - saxladığınız məzmunun cəmi və üstəlik, bir azdan öyrənəcəyiniz bir başlıqdır.
İndi Git-in məlumatlarınızı necə saxladığını görə bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ find .git/objects -type f
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Əgər siz yenidən <code>objects</code> qovluğunu araşdırırsınızsa, indi o yeni məzmun üçün özündə bir fayl daxil etdiyini görə bilərsiniz.
Git əvvəlcə məzmunu onun SHA-1 nəzarət cəmi və onun başlığı ilə adlandırılan bir məzmuna görə tək bir fayl kimi saxlayır.
Alt qovluq SHA-1-in ilk 2 simvolu ilə adlanır və fayl adı qalan 38 simvoldur.</p>
</div>
<div class="paragraph">
<p>Verilənlər bazanızda bir məzmun olduqdan sonra, bu məzmunu <code>git cat-file</code> əmri ilə yoxlaya bilərsiniz.
Bu əmr, Git obyektlərini yoxlamaq üçün bir növ İsveçrə ordusu bıçağıdır.
<code>-P</code>, <code>cat-file</code> keçid əmrinə əvvəlcə məzmunun növünü müəyyənləşdirməyi, sonra isə uyğun şəkildə göstərməyi əmr edir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
test content</code></pre>
</div>
</div>
<div class="paragraph">
<p>İndi Git-ə məzmun əlavə edib yenidən geri pull edə bilərsiniz.
Bunu fayllardakı məzmunu ilə də edə bilərsiniz.
Məsələn, bir faylda bəzi sadə versiya nəzarəti edə bilərsiniz.
Əvvəlcə yeni bir fayl yaradın və məzmununu verilənlər bazanıza yazın:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 'version 1' &gt; test.txt
$ git hash-object -w test.txt
83baae61804e65cc73a7201a7252750c76066a30</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sonra bir neçə yeni məzmunu fayla yazın və yenidən qeyd edin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 'version 2' &gt; test.txt
$ git hash-object -w test.txt
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</code></pre>
</div>
</div>
<div class="paragraph">
<p>İndi obyekt verilənlər bazanızda bu yeni faylın hər iki versiyası da var (orada saxladığınız ilk məzmun kimi):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ find .git/objects -type f
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu nöqtədə, həmin <code>test.txt</code> faylının yerli nüsxəsini silə bilərsiniz, sonra ilk verilənlər bazasını saxladığınız obyekt verilənlər bazasından almaq üçün Git-dən istifadə edin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 &gt; test.txt
$ cat test.txt
version 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Və ya ikinci versiya:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a &gt; test.txt
$ cat test.txt
version 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ancaq faylınızın hər bir versiyası üçün SHA-1 key-ni xatırlamaq praktik deyil; üstəlik, sisteminizdə fayl adını deyil, yalnız məzmunu saxlayırsınız.
Bu obyekt növünə <em>blob</em> deyilir.</p>
</div>
<div class="paragraph">
<p>Git-dən SHA-1 key-ni nəzərə alaraq Git-dəki`git cat-file –t` ilə hər hansı bir obyektin növünü sizə izah etməsini istəyə bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
blob</code></pre>
</div>
</div>
<div class="sect3">
<h3 id="_tree_objects">Ağac Obyektləri</h3>
<div class="paragraph">
<p>Növbəti araşdıracağımız Git obyekt növü, fayl adının saxlanılması problemini həll edən və eyni zamanda bir qrup faylları birlikdə saxlamağınıza imkan verən <em>tree</em>-dir.
Git, məzmunu UNIX fayl sisteminə bənzər, lakin biraz sadələşdirilmiş şəkildə saxlayır.</p>
</div>
<div class="paragraph">
<p>Bütün məzmun ağac və blob obyektləri, UNIX qovluq girişlərinə uyğun olan ağaclar və inodes və ya fayl məzmununa az və ya çox uyğun gələn blob-larla saxlanılır.
Tək bir ağac obyekti, hər biri əlaqəli rejimi, növü və fayl adı ilə bir blob və ya alt ağacın SHA-1 hash olan bir və ya daha çox giriş daxil edir.
Məsələn, bir layihədəki ən son ağac belə görünə bilər:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -p master^{tree}
100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README
100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile
040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Master^{tree}</code> sintaksisiniz, <code>master</code> branch-nızdakı sonuncu işarə ilə göstərilən ağac obyektini müəyyənləşdirir.
Diqqət yetirin ki, <code>lib</code> alt kataloqu blok deyil, o başqa bir ağaca işarə edir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0
100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Hansı shell-dən istifadə etdiyinizə görə, <code>master^{tree}</code> sintaksisini istifadə edərkən səhvlərlə qarşılaşa bilərsiniz.</p>
</div>
<div class="paragraph">
<p>Windows-dakı CMD-də <code>^</code> işarəsi qaçmaq üçün istifadə olunur, buna görə bunun qarşısını almaq üçün onu ikiqat artırmalısınız: <code>git cat-file -p master^^{tree}".
PowerShell istifadə edərkən, parametrin səhv təhlil edilməməsi üçün {} simvoldan istifadə olunan parametrlərə istinad edilməlidir: `git cat-file -p 'master^{tree}'</code>.
ZSH istifadə edirsinizsə, <code>^</code> işarəsi globbing üçün istifadə olunur, buna görə bütün ifadəni dırnaq işarələrinə əlavə etməlisiniz: `git cat-file -p 'master^{tree}".</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Konseptual olaraq, Gitin saxladığı məlumatlar belə bir şeyə bənzəyir:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/az/v2/images/data-model-1.png" >}}" alt="Simple version of the Git data model">
</div>
<div class="title">Figure 149. Git data modelinin sadə versiyası</div>
</div>
<div class="paragraph">
<p>Öz ağacınızı olduqca asanlıqla yarada blərsiniz.
Git normal olaraq quruluş sahənizin və ya indeksinizin vəziyyətini götürərək ondan bir sıra ağac obyektlərini yazaraq bir ağac yaradır
Beləliklə, bir ağac obyekti yaratmaq üçün əvvəlcə bəzi sənədləri quraraq bir indeks qurmalısınız.
Single entry – ilə sadə indeks qurmaq üçün <code>test.txt</code> faylınızın ilk versiyası — <code>git update-index</code> plumbing əmrindən istifadə edə bilərsiniz.
Bu əmrdən süni şəkildə yeni bir səhnə sahəsinə <code>test.txt</code> faylının əvvəlki versiyasını əlavə etmək üçün istifadə edirsiniz.
Fayl hazırlama sahənizdə hələ olmadığı üçün <code>--add</code> seçimini keçməlisiniz (hələ də staging sahəniz qurulmayıbsa) və əlavə etdiyiniz fayl olmadığı üçün
<code>--cacheinfo</code> qovluğunuzda ancaq verilənlər bazanızdadır.
Sonra rejimi, SHA-1 və fayl adını təyin edirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git update-index --add --cacheinfo 100644 \
  83baae61804e65cc73a7201a7252750c76066a30 test.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu vəziyyətdə, <code>100644</code> rejimini təyin edirsiniz, yəni normal bir fayldır.
Digər seçimlər <code>100755</code>-dir, yəni icra edilə bilən bir fayldır; və simvolik bir əlaqəni ifadə edən `120000`seçimidir.
Rejim normal UNIX rejimlərindən götürülmüşdür, lakin daha az çevikdir - bu üç rejim Git-dəki fayllar (bloblar) üçün etibarlı olanlardır (baxmayaraq ki, digər rejimlər kitabçalar və alt modullar üçün istifadə olunur).</p>
</div>
<div class="paragraph">
<p>İndi quruluş sahəsini bir ağac obyektinə yazmaq üçün <code>git write-tree</code> istifadə edə bilərsiniz.
Heç bir <code>-w</code> seçiminə ehtiyac yoxdur - bu əmri çağırmaq avtomatik olaraq indiki vəziyyətdə bir ağac obyektini indeks vəziyyətindən yaradır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git write-tree
d8329fc1cc938780ffdd9f94e0d364e0ea74f579
$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579
100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>Daha əvvəl gördüyünüz eyni <code>git cat-file</code> əmrini istifadə edərək ağac obyekti olduğunu da doğrulaya bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579
tree</code></pre>
</div>
</div>
<div class="paragraph">
<p>İndi <code>test.txt</code>-in ikinci versiyası və yeni bir fayl ilə yeni bir ağac yaradacaqsınız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 'new file' &gt; new.txt
$ git update-index --add --cacheinfo 100644 \
  1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt
$ git update-index --add new.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>İndi səhnələşdirmə sahənizdə <code>test.txt</code>-in yeni versiyası ilə yanaşı yeni <code>new.txt</code> faylı var.
O ağacı yazın (staging sahəsinin və ya indeksin bir ağac obyektinə yazılmasına istinadən) və necə göründüyünə baxın:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git write-tree
0155eb4229851634a0f03eb265b69f5a2d56f341
$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>Diqqət yetirin ki, bu ağacın həm fayl girişləri, həm də <code>test.txt</code> SHA-1 əvvəldən qalan “version 2” SHA-1 (<code>1f7a7a</code>) versiyası var.
Yalnız əyləncə üçün ilk ağacı alt qovluq olaraq bu ağaca əlavə edəcəksiniz.
Quruluş sahənizə ağacları <code>git read-tree</code>-ni işə salaraq oxuya bilərsiniz.
Bu vəziyyətdə, mövcud əmri <code>--prefix</code> seçimindən istifadə edərək subtree olaraq quruluş sahənizə oxuya bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579
$ git write-tree
3c4e9cd789d88d8d89c1073707c3585e41b0e614
$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614
040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>Yeni yazdığınız ağacdan bir iş qovluğu yaratmışsanız, iş qovluğunun üst səviyyəsindəki iki faylı və <code>test.txt</code> sənədinin ilk versiyasını ehtiva edən <code>bak</code> adlı bir alt qovluğu əldə edəcəksiniz.
Git-in bu strukturlar üçün ehtiva etdiyi məlumatları belə hesab edə bilərsiniz:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/az/v2/images/data-model-2.png" >}}" alt="The content structure of your current Git data">
</div>
<div class="title">Figure 150. The content structure of your current Git data</div>
</div>
</div>
<div class="sect3">
<h3 id="_git_commit_objects">Commit Obyektləri</h3>
<div class="paragraph">
<p>Yuxarıda sadalananların hamısını etmisinizsə, indi izləmək istədiyiniz layihənizin fərqli anlarını əks etdirən üç ağacınız var, lakin əvvəlki problem yerində qalır: anlıq snapshot-ları xatırlamaq üçün hər üç SHA-1 dəyərini xatırlamalısınız.
Snapshot-ları kimin saxladığı, nə vaxt və ya nə üçün saxlandığı barədə heç bir məlumatınız isə yoxdur.
Commit obyektinin sizin üçün saxladığı əsas məlumatlar budur.</p>
</div>
<div class="paragraph">
<p>Bir öhdəlik obyekti yaratmaq üçün, <code>commit-tree</code> işə salırsınız və bir ağac SHA-1 təyin edirsiniz və əgər varsa, əvvəlcədən obyektlər yaradırsınız.
Yazdığınız ilk ağacdan başlayın:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 'First commit' | git commit-tree d8329f
fdf4fc3344e67ab068f836878b6c4951e3b15f3d</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Fərqli yaradılış müddəti və müəllif məlumatları səbəbindən fərqli bir hash dəyəri əldə edəcəksiniz.
Üstəlik, prinsip etibarilə hər hansı bir commit obyekti məlumatların verildiyi dəqiq şəkildə çoxaldıla bilsə də, bu kitabın inşaatının tarixi təfərrüatları, çap edilən commit-lərin verilmiş commit-lərə uyğun olmaya biləcəyini göstərir.
Bu bölmədə daha çox əmsal və etiket hash-lərini öz checksum-larınızla əvəz edin.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Artıq yeni commit-inizə <code>git cat-file</code>-dan baxa bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -p fdf4fc3
tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579
author Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700
committer Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700

First commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Commit obyekti üçün format sadədir: həmin nöqtədə layihənin snapshot-u üçün ən yüksək səviyyəli ağacı təyin edir; valideyn varsa, commit-i götürür (yuxarıda göstərilən commit obyektinin valideynləri yoxdur); author/committer məlumatı (istifadəçi adınız və istifadəçi poçtunuzun konfiqurasiya parametrlərindən və zaman damğasından istifadə edən); boş bir sətir və sonra commit mesajı.</p>
</div>
<div class="paragraph">
<p>Sonra, hər biri özündən əvvəl gələn commit-ə istinad edən digər iki commit obyektini yazacaqsınız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 'Second commit' | git commit-tree 0155eb -p fdf4fc3
cac0cab538b970a37ea1e769cbbde608743bc96d
$ echo 'Third commit'  | git commit-tree 3c4e9c -p cac0cab
1a410efbd13591db07496601ebc7a059dd55cfe9</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each of the three commit objects points to one of the three snapshot trees you created.
Oddly enough, you have a real Git history now that you can view with the <code>git log</code> command, if you run it on the last commit SHA-1:
Hər üç commit obyekti yaratdığınız üç snapshot ağacından birini göstərir.
Qəribədir ki, son olaraq SHA-1-də işləsəniz, <code>git log</code> əmri ilə baxa biləcəyiniz  gerçək bir Git tarixiniz var:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --stat 1a410e
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:15:24 2009 -0700

  Third commit

 bak/test.txt | 1 +
 1 file changed, 1 insertion(+)

commit cac0cab538b970a37ea1e769cbbde608743bc96d
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:14:29 2009 -0700

  Second commit

 new.txt  | 1 +
 test.txt | 2 +-
 2 files changed, 2 insertions(+), 1 deletion(-)

commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:09:34 2009 -0700

    First commit

 test.txt | 1 +
 1 file changed, 1 insertion(+)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Əla.
Front end əmrlərindən heç birini istifadə etmədən Git tarixçəsi yaratmaq üçün aşağı səviyyə əməliyyatları tamamlamısınız.</p>
</div>
<div class="paragraph">
<p>Siz <code>git add</code> və <code>git commit</code> əmrlərini çalışdırdığınızda Git bunu edir - dəyişən fayllar üçün blob-ları saxlayır, indeksləri yeniləyir, ağacları və üst səviyyə istinad obyektlərini və onlardan dərhal əvvəl gələn vəzifələri yazır.
Bu üç əsas Git obyekti — the blob, the tree və the commit — əvvəlcə <code>.git/objects</code> qovluğunda ayrı fayllar kimi saxlanılır.
İndi bütün obyektlər, içində saxladıqları şərh edilmiş şəkildə nümunələr qovluğundadır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ find .git/objects -type f
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bütün daxili göstəriciləri təqib etsəniz, belə bir obyekt qrafiki əldə edirsiniz:
.
Git qovluğunuzdakı bütün əlçatan obyektlər
image::images/data-model-3.png[All the reachable objects in your Git directory]</p>
</div>
</div>
<div class="sect3">
<h3 id="_object_deposu">Object Deposu</h3>
<div class="paragraph">
<p>Daha əvvəl Git obyekt verilənlər bazasına sadiq olduğunuz hər bir obyektlə birlikdə saxlanılan bir başlığın olduğunu qeyd etmişdik.
Git-in obyektlərini necə saxladığını görmək üçün bir dəqiqə ayıraq.
Blob obyektinin necə saxlandığını - bu halda “what is up, doc?”-- sətrini Ruby skript dilində interaktiv şəkildə görəcəksiniz.</p>
</div>
<div class="paragraph">
<p>İnteraktiv Ruby rejimini <code>irb</code> əmri ilə işə sala bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ irb
&gt;&gt; content = "what is up, doc?"
=&gt; "what is up, doc?"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git əvvəlcə obyekt tipini təyin etməklə başlayan bir başlıq qurur — bu halda bu bir blob sayılır.
Başlığın bu birinci hissəsinə Git, boşluğun ardından məzmunun bayt ölçüsünü və son sıfır baytını əlavə edir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">&gt;&gt; header = "blob #{content.bytesize}\0"
=&gt; "blob 16\u0000"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git, başlığı və orijinal məzmunu birləşdirir və sonra bu yeni məzmunun SHA-1 checksum cəmini hesablayır.
Ruby-də bir string-in SHA-1 dəyərini SHA1 toplama kitabxanasını <code>require</code> əmri ilə daxil edib daha sonra sətirlə <code>Digest::SHA1.hexdigest()</code> işə salaraq hesablaya bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">&gt;&gt; store = header + content
=&gt; "blob 16\u0000what is up, doc?"
&gt;&gt; require 'digest/sha1'
=&gt; true
&gt;&gt; sha1 = Digest::SHA1.hexdigest(store)
=&gt; "bd9dbf5aae1a3862dd1526723246b20206e5fc37"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Gəlin onu Git <code>hash-object</code> output-u ilə müqayisə edək.
Burada input-a yeni bir xətt əlavə edilməməsi üçün <code>echo –n</code> istifadə edirik.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo -n "what is up, doc?" | git hash-object --stdin
bd9dbf5aae1a3862dd1526723246b20206e5fc37</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git, zlib kitabxanası ilə Ruby-də edə biləcəyiniz yeni məzmunu zlib ilə sıxışdırır.
Əvvəlcə kitabxananı tələb etməlisiniz və sonra məzmunda <code>Zlib::Deflate.deflate()</code> işə salmalısınız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">&gt;&gt; require 'zlib'
=&gt; true
&gt;&gt; zlib_content = Zlib::Deflate.deflate(store)
=&gt; "x\x9CK\xCA\xC9OR04c(\xCFH,Q\xC8,V(-\xD0QH\xC9O\xB6\a\x00_\x1C\a\x9D"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nəhayət, zlib-deflated məzmununuzu diskdəki bir obyektə yazacaqsınız.
Yazmaq istədiyiniz obyektin path-ini təyin edəcəksiniz (SHA-1 dəyərinin ilk iki simvolu alt direktoriya adı və son 38 simvol həmin qovluqdakı fayl adıdır).
Ruby-də, mövcud olmadıqda alt qovluğu yaratmaq üçün <code>FileUtils.mkdir_p()</code> funksiyasından istifadə edə bilərsiniz.
Daha sonra, faylı <code>File.open()</code> ilə açın və əvvəlki zlib-compressed məzmunu nəticəsi ilə ortaya çıxan fayl sapı üzərinə bir <code>write()</code> çağırışı ilə yazın:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">&gt;&gt; path = '.git/objects/' + sha1[0,2] + '/' + sha1[2,38]
=&gt; ".git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37"
&gt;&gt; require 'fileutils'
=&gt; true
&gt;&gt; FileUtils.mkdir_p(File.dirname(path))
=&gt; ".git/objects/bd"
&gt;&gt; File.open(path, 'w') { |f| f.write zlib_content }
=&gt; 32</code></pre>
</div>
</div>
<div class="paragraph">
<p>Gəlin <code>git cat-file</code> istifadə edərək obyektin məzmununu yoxlayaq:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">---
$ git cat-file -p bd9dbf5aae1a3862dd1526723246b20206e5fc37
what is up, doc?
---</code></pre>
</div>
</div>
<div class="paragraph">
<p>Və budur – siz tamamlanmış bir Git blob obyekti yaratdınız.</p>
</div>
<div class="paragraph">
<p>Bütün Git obyektləri eyni şəkildə, yalnız fərqli növlər ilə saxlanılır – o, simvol bloku əvəzinə, commit başlığı və ya ağacla başlayacaq.
Blob məzmunu təxminən hər şey ola bilsə də, commit və ağac məzmunu çox xüsusi formatlandırılmışdır.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>