---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: az
  chapter:
    title: Git’i Fərdiləşdirmək
    number: 8
  section:
    title: Git Konfiqurasiyası
    number: 1
    cs_number: '8.1'
    previous: book/az/v2/Git-Alətləri-Qısa-Məzmun
    next: book/az/v2/Git’i-Fərdiləşdirmək-Git-Atributları
title: Git - Git Konfiqurasiyası
url: "/book/az/v2/Git’i-Fərdiləşdirmək-Git-Konfiqurasiyası.html"
---
<p>İndiyə qədər Git’in necə işlədiyini və necə istifadə ediləcəyini izah etdik və asanlıqla və səmərəli istifadə etməyiniz üçün Git’in təqdim etdiyi bir sıra vasitələri təqdim etdik.
Bu fəsildə bir neçə vacib konfiqurasiya parametrlərini və hook’lar sistemini təqdim edərək Git’i daha çox fərdi qaydada necə işlədə biləcəyinizi görəcəyik.
Bu vasitələrlə Git’in sizin, şirkətinizin və ya qrupunuzun ehtiyac duyduğu şəkildə işləməsini təmin etmək asandır.</p>
<h2 id="_git_config">Git Konfiqurasiyası</h2>
<div class="paragraph">
<p>
Qısa şəkildə <a href="{{< relurl "book/az/v2/ch00/ch01-getting-started" >}}">Başlanğıc</a>-da oxuduğumuz kimi, Git konfiqurasiyasını <code>git config</code> əmri ilə tənzimləyə bilərsiniz.
Etdiyiniz ilk işlərdən biri adınızı və e-poçt adresinizi qurmaq idi:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com</code></pre>
</div>
</div>
<div class="paragraph">
<p>İndi Git istifadənizi fərdiləşdirmək üçün bu şəkildə təyin edə biləcəyiniz daha maraqlı variantlardan bir neçəsini öyrənəcəksiniz.</p>
</div>
<div class="paragraph">
<p>Birincisi, sürətli bir nəzərdən keçirmə: Git, istəyə biləcəyiniz qeyri-standart davranışı təyin etmək üçün bir sıra konfiqurasiya fayllarından istifadə edir.</p>
</div>
<div class="paragraph">
<p>Git-in bu dəyərləri axtardığı ilk yer sistemdəki bütün istifadəçilərə və onların bütün depolarına tətbiq olunan parametrləri ehtiva edən sistem səviyyəsində <code>/etc/gitconfig</code> faylındadır.
<code>--system</code> seçimini <code>git config</code>-ə pass etsəniz, o xüsusilə bu fayldan oxuyur və yazır.</p>
</div>
<div class="paragraph">
<p>Git’in növbəti göründüyü yer hər bir istifadəçiyə xas olan <code>~/.gitconfig</code>  (və ya <code>~/.config/git/config</code>) faylıdır.
Git-i bu <code>--global</code> seçiminə pass edərək bu faylı oxumağa və yazmağa məcbur edə bilərsiniz.</p>
</div>
<div class="paragraph">
<p>Nəhayət, Git, istifadə etdiyiniz hər hansı bir deponun Git qovluğundakı (<code>.git/config</code>) konfiqurasiya faylındakı konfiqurasiya dəyərlərini axtarır.
Bu dəyərlər həmin tək olan depoya xasdır və <code>--local</code> seçiminin <code>git config</code>-ə pass edilməsini təmsil edir.
Hansı səviyyə ilə işləmək istədiyinizi müəyyənləşdirməmisinizsə, bu standartdır.</p>
</div>
<div class="paragraph">
<p>Bu “levels” (sistem, qlobal, yerli) hər biri əvvəlki səviyyə üzərində yazır, buna görə <code>.git/config</code>-dəki dəyərlər, məsələn, <code>/etc/gitconfig</code> dəki şeyləri qazanır.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Git-in konfiqurasiya sənədləri sadə mətndir, buna görə də bu dəyərləri faylı manual olaraq düzəldərək və düzgün sintaksisini əlavə edərək təyin edə bilərsiniz.
Hərçənd, <code>git config</code> əmrini çalışdırmaq ümumiyyətlə daha asandır.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h3 id="_sadə_müştəri_konfiqurasiyası">Sadə Müştəri Konfiqurasiyası</h3>
<div class="paragraph">
<p>Git tərəfindən tanınan konfiqurasiya seçimləri iki kateqoriyaya bölünür: müştəri və server tərəfi.
Seçimlərin əksəriyyəti müştəri tərəfli — configurating yəni şəxsi iş seçimlərinizdir.
Bir çox, <em>çox</em> konfiqurasiya variantı dəstəklənir, lakin bunların böyük bir hissəsi yalnız müəyyən kənar hallarda faydalıdır; burada ən çox yayılmış və faydalı variantları nəzərdən keçirəcəyik.
Git versiyanızın tanıdığı bütün seçimlərin siyahısını görmək istəyirsinizsə, aşağıdakıları edə bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ man git-config</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu əmrdə mövcud olan bütün seçimlər bir az ətraflı şəkildə sadalanır.
Bu istinad materialını <a href="https://git-scm.com/docs/git-config" class="bare">https://git-scm.com/docs/git-config</a> səhifəsində də tapa bilərsiniz.</p>
</div>
<div class="sect4">
<h4 id="_core_editor"><code>core.editor</code></h4>
<div class="paragraph">
<p>
Standart olaraq, Git, vizual mətn redaktoru olaraq təyin etdiyiniz hər şeyi <code>VISUAL</code> və ya <code>EDITOR</code> shell mühiti dəyişənlərindən biri vasitəsilə istifadə edir və ya commit-lərinizi düzəltmək və etiketləmək üçün <code>vi</code> redaktoruna qayıdır.
Standart olanı başqa bir şeyə dəyişdirmək üçün <code>core.editor</code> ayarını istifadə edə bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global core.editor emacs</code></pre>
</div>
</div>
<div class="paragraph">
<p>İndi, standart shell redaktorunuz kimi təyin olunmasından asılı olmayaraq, Git mesajları düzəltmək üçün Emacs-ı işə salacaq.</p>
</div>
</div>
<div class="sect4">
<h4 id="_commit_template"><code>commit.template</code></h4>
<div class="paragraph">
<p>
Bunu sisteminizdəki bir fayl path-a düzəltmisinizsə, Git bu fayldan commit götürdüyünüzdə ilkin mesaj olaraq istifadə edəcəkdir.
Xüsusi bir commit şablonu yaratmağın dəyəri, bir commit mesajı yaradarkən özünüzə (və ya başqalarına) uyğun format və üslubu xatırlatmaq üçün istifadə edə bilərsiniz.</p>
</div>
<div class="paragraph">
<p>Məsələn, <code>~/.gitmessage.txt</code> ünvanındakı bir şablon faylını nəzərdən keçirin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">Subject line (try to keep under 50 characters)

Multi-line description of commit,
feel free to be detailed.

[Ticket: X]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu commit şablonunun vəzifələndiriciyə mövzu sətrini qısa saxlamağı (<code>git log --oneline</code> çıxışı naminə), bunun altına daha çox təfərrüat əlavə etməsini və mövcud olduqda bir problemə və ya səhv izləyici bilet nömrəsinə istinad etməsini necə xatırlatdığına diqqət yetirin.</p>
</div>
<div class="paragraph">
<p>Git-ə, <code>git commit</code>-i işə saldığınız zaman redaktorunuzda görünən standart mesaj kimi istifadə etməsini söyləmək üçün, <code>commit.template</code> konfiqurasiya dəyərini təyin edin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global commit.template ~/.gitmessage.txt
$ git commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bundan sonra, redaktorunuz, commit zamanı placeholder commit mesajı üçün belə bir şey açacaq:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">Subject line (try to keep under 50 characters)

Multi-line description of commit,
feel free to be detailed.

[Ticket: X]
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#   (use "git reset HEAD &lt;file&gt;..." to unstage)
#
# modified:   lib/test.rb
#
~
~
".git/COMMIT_EDITMSG" 14L, 297C</code></pre>
</div>
</div>
<div class="paragraph">
<p>Komandanızın bir commit mesajı siyasəti varsa, bu siyasət üçün bir şablon sisteminizə qoymaq və Git’i standart olaraq istifadə etmək üçün konfiqurasiya etmək, bu siyasətin mütəmadi olaraq izlənmə şansını artırmağa kömək edə bilər.</p>
</div>
</div>
<div class="sect4">
<h4 id="_core_pager"><code>core.pager</code></h4>
<div class="paragraph">
<p>
Bu parametr, Git səhifələrinin <code>log</code> və <code>diff</code> kimi output-u zamanı hansı pager cihazının istifadə olunduğunu təyin edir.
Onu  <code>more</code> ya da sevdiyiniz pager cihazına qura bilərsiniz (standart olaraq, daha <code>less</code>-dir) və ya boş bir sətir quraraq söndürə bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global core.pager ''</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bunu işləsəniz, Git, nə qədər olmasına baxmayaraq bütün əmrlərin bütün output-nu səhifələndirəcəkdir.</p>
</div>
</div>
<div class="sect4">
<h4 id="_user_signingkey"><code>user.signingkey</code></h4>
<div class="paragraph">
<p>
İmzalı şərhli etiketlər düzəldirsinizsə (<a href="{{< relurl "book/az/v2/ch00/_signing" >}}">İşinizin İmzalanması</a> də müzakirə edildiyi kimi), GPG imzalama key-nizi konfiqurasiya ayarı olaraq təyin etmək işləri asanlaşdırır.
Key ID-nizi belə ayarlayın:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global user.signingkey &lt;gpg-key-id&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>İndi hər dəfə <code>git tag</code> əmri ilə key-nizi göstərmədən etiketlər imzalaya bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git tag -s &lt;tag-name&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_core_excludesfile"><code>core.excludesfile</code></h4>
<div class="paragraph">
<p>
Layihənizin <code>.gitignore</code> sənədinə nümunələr qoya bilərsiniz ki, Git onları izlənilməmiş fayllar kimi görməsin və ya <a href="{{< relurl "book/az/v2/ch00/_ignoring" >}}">Nəzərə Alınmayan Fayllar</a> də deyildiyi kimi onlara <code>git add</code> işlədərkən səhnələşdirməyə çalışın.</p>
</div>
<div class="paragraph">
<p>Ancaq bəzən işlədiyiniz bütün depolar üçün müəyyən sənədləri görməməzlikdən gəlmək istəyərsiniz.
Kompüterinizdə macOS işləyirsə, ehtimal ki, <code>.DS_Store</code> faylları ilə tanışsınız.
Tercih etdiyiniz redaktor Emacs və ya Vim-dirsə, <code>~</code> və ya <code>.swp</code> ilə bitən fayl adlarını da bilirsiniz.</p>
</div>
<div class="paragraph">
<p>Bu parametr bir növ qlobal <code>.gitignore</code> faylı yazmağınıza imkan verir.
Bu məzmunu olan bir <code>~/.gitignore_global</code>  faylı yaratsanız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">*~
.*.swp
.DS_Store</code></pre>
</div>
</div>
<div class="paragraph">
<p>…və <code>git config --global core.excludesfile ~/.gitignore_global</code> işə salsanız, Git bir daha bu fayllarla sizi narahat etməyəcəkdir.</p>
</div>
</div>
<div class="sect4">
<h4 id="_help_autocorrect"><code>help.autocorrect</code></h4>
<div class="paragraph">
<p>
Əgər əmri səhv yazsanız, sizə belə bir şey göstərəcək:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git chekcout master
git: 'chekcout' is not a git command. See 'git --help'.

Buna ən bənzər əmr checkout-dur.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git köməkliklə nə demək istədiyinizi anlamağa çalışır, amma yenə də bunu etməkdən imtina edir.
<code>help.autocorrect</code>-i 1 olaraq təyin etsəniz, Git bu əmri həqiqətən sizin üçün işlədəcək:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git chekcout master
DİQQƏT: Siz mövcud olmayan 'chekcout' adlı bir Git əmri çağırmısınız.
'Checkout' demək istədiyiniz fərziyyəsi ilə 0.1 saniyədə davam edin...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Qeyd edək ki, “0.1 seconds” işi
<code>help.autocorrect</code> əslində saniyənin onda birini təmsil edən bir tam rəqəmdir.
Buna görə 50-yə qoysanız, Git, avtomatik düzəliş əmrini yerinə yetirmədən əvvəl fikrinizi dəyişdirmək üçün 5 saniyə verəcəkdir.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_git_də_rənglər">Git-də Rənglər</h3>
<div class="paragraph">
<p>
Git, komanda çıxışını tez və asanlıqla vizual olaraq təhlil etməyə kömək edən rəngli terminal çıxışını tamamilə dəstəkləyir.
Bir sıra seçimlər rənglənməni seçiminizə uyğunlaşdırmağa kömək edə bilər.</p>
</div>
<div class="sect4">
<h4 id="_color_ui"><code>color.ui</code></h4>
<div class="paragraph">
<p>Git output-un çox hissəsini avtomatik olaraq rəngləndirir, ancaq bunu bəyənməsəniz, master-ə keçid var.
Bütün Gitin rəngli terminal output-nu söndürmək üçün bunu edin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global color.ui false</code></pre>
</div>
</div>
<div class="paragraph">
<p>Standart ayar <code>auto</code>-dur, hansı rənglər output-dursa, onda birbaşa terminala gedir, amma output bir pipe və ya bir fayla yönəldildikdə o zaman rəng nəzarət kodlarını nəzərdən buraxır.</p>
</div>
<div class="paragraph">
<p>Terminallar və pipe-lar arasındakı fərqi görməməzlikdən gəlmək üçün onu <code>always</code> olaraq da qura bilərsiniz.</p>
</div>
<div class="paragraph">
<p>Bunu nadir hallarda istəyəcəksiniz; əksər ssenarilərdə, yönləndirilmiş output-unuzda rəng kodları istəsəniz, bunun əvəzinə rəng kodlarını istifadə etməyə məcbur etmək üçün Git əmrinə bir <code>--color</code> flag-ını ötürə bilərsiniz.
Standart ayar demək olar ki, həmişə istədiyiniz şeydir.</p>
</div>
</div>
<div class="sect4">
<h4 id="_color"><code>color.*</code></h4>
<div class="paragraph">
<p>Hansı əmrlərin və necə rəngləndiyinə dair daha konkret olmaq istəyirsinizsə, Git verb-spesific rəngləmə parametrlərini təqdim edir.
Bunların hər biri <code>true</code>, <code>false</code> və ya <code>always</code> olaraq təyin edilə bilər:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>color.branch
color.diff
color.interactive
color.status</pre>
</div>
</div>
<div class="paragraph">
<p>Bundan əlavə, bunların hər birində, hər bir rəngin üstündən keçmək istəsəniz, output hissələri üçün xüsusi rənglər təyin etmək üçün istifadə edə biləcəyiniz alt parametrlər var.
Məsələn, fərqli çıxışınızdakı meta məlumatını mavi ön planda, qara fonda və qalın mətn olaraq təyin etmək üçün aşağıdakıları edə bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global color.diff.meta "blue black bold"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Rəngi aşağıdakı dəyərlərdən hər hansı birinə qura bilərsiniz: <code>normal</code>, <code>black</code>, <code>red</code>, <code>green</code>, <code>yellow</code>, <code>blue</code>, <code>magenta</code>, <code>cyan</code>, və ya <code>white</code>.
Əvvəlki nümunədəki kimi qalın bir atribut istəsəniz, <code>bold</code>, <code>dim</code>, <code>ul</code> (underline), <code>blink</code>, and <code>reverse</code> (swap foreground və background) seçə bilərsiniz.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_external_merge_tools">Xaricdən Birləşdirmə və Diff Vasitələri</h3>
<div class="paragraph">
<p>
Git’in bu kitabda göstərdiyimiz fərqli bir diff tətbiqinə sahib olmasına baxmayaraq bunun əvəzinə xarici bir vasitə qura bilərsiniz.
Konfliktləri manual şəkildə həll etmək əvəzinə qrafik merge-conflict-resolution vasitəsini də qura bilərsiniz.
Diff-lərinizi yerinə yetirmək və nəticələrinizi birləşdirmək üçün Perforce Visual Merge Tool (P4Merge) qurmağı nümayiş etdirəcəyik, çünki gözəl bir qrafik vasitədir və ödənişsizdir.
Bunu sınamaq istəyirsinizsə, P4Merge bütün əsas platformalarda işləyir, buna görə də bunu bacaracaqsınız.
MacOS və Linux sistemlərində işləyən nümunələrdə path adlarını istifadə edəcəyik; Windows üçün mühitinizdə  <code>/usr/local/bin</code>-i icra oluna bilən bir path-a dəyişdirməlisiniz.</p>
</div>
<div class="paragraph">
<p>Başlamaq üçün, <a href="https://www.perforce.com/product/components/perforce-visual-merge-and-diff-tools">download P4Merge from Perforce</a>.
Sonra, əmrlərinizi işə salmaq üçün xarici bağlama skriptlərini quracaqsınız.
İştifadə oluna bilənlər üçün macOS yolunu istifadə edəcəyik; digər sistemlərdə, <code>p4merge</code> ikilinizin quraşdırıldığı yer olacaq.
Verilən bütün arqumentlərlə ikili çağıran <code>extMerge</code> adlı birləşdirmə wrapper skriptini qurun:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat /usr/local/bin/extMerge
#!/bin/sh
/Applications/p4merge.app/Contents/MacOS/p4merge $*</code></pre>
</div>
</div>
<div class="paragraph">
<p>Diff wrapper yeddi arqumentin verildiyini yoxlayır və onlardan ikisini birləşmə ssenarinizə ötürür.
Standart olaraq, Git diff proqramına aşağıdakı arqumentləri ötürür:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>path old-file old-hex old-mode new-file new-hex new-mode</code></pre>
</div>
</div>
<div class="paragraph">
<p>Yalnız  <code>old-file</code> və <code>new-file</code> arqumentlərini istədiyiniz üçün ehtiyac duyduqlarınızı ötürmək üçün wrapper skriptindən istifadə edirsiniz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat /usr/local/bin/extDiff
#!/bin/sh
[ $# -eq 7 ] &amp;&amp; /usr/local/bin/extMerge "$2" "$5"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Həm də bu alətlərin icra oluna biləcəyinə əmin olmalısınız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ sudo chmod +x /usr/local/bin/extMerge
$ sudo chmod +x /usr/local/bin/extDiff</code></pre>
</div>
</div>
<div class="paragraph">
<p>İndi konfiqurasiya sənədinizi xüsusi birləşdirmə qərarından və diff alətlərindən istifadə etmək üçün qura bilərsiniz.
Bunun üçün bir sıra xüsusi ayarlar lazımdır: Git-ə hansı strategiyanı istifadə edəcəyini söyləmək üçün <code>merge.tool</code>,  <code>mergetool.&lt;tool&gt;.cmd</code> əmrinin necə işlədiləcəyini göstərmək üçün,  <code>mergetool.&lt;tool&gt;.trustExitCode</code>, Git-ə deyin. Bu proqramın çıxış kodu xüsusi birləşmə qərarını göstərir və ya göstərmirsə və Git-ə difflər üçün hansı əmri çalıştıracağını söyləmək üçün <code>diff.external</code> yoxlayın.
Beləliklə, dörd konfiqurasiya əmrini işə sala bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global merge.tool extMerge
$ git config --global mergetool.extMerge.cmd \
  'extMerge "$BASE" "$LOCAL" "$REMOTE" "$MERGED"'
$ git config --global mergetool.extMerge.trustExitCode false
$ git config --global diff.external extDiff</code></pre>
</div>
</div>
<div class="paragraph">
<p>Və ya bu sətirləri əlavə etmək üçün <code>~/.gitconfig</code> faylını yoxlaya bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">[merge]
  tool = extMerge
[mergetool "extMerge"]
  cmd = extMerge "$BASE" "$LOCAL" "$REMOTE" "$MERGED"
  trustExitCode = false
[diff]
  external = extDiff</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bütün bunlar qurulduqdan sonra, bu kimi diff əmrləri işlədirsinizsə:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff 32d1776b1^ 32d1776b1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Əmr sətrində diff output-u əldə etmək əvəzinə, Git P4Merge-i işə salır, buna bənzər bir şey görünür:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/az/v2/images/p4merge.png" >}}" alt="P4Merge">
</div>
<div class="title">Figure 143. P4Merge</div>
</div>
<div class="paragraph">
<p>İki branch-ı birləşdirməyə və daha sonra birləşmə konfliktlərinə sahib olsanız, <code>git mergetool</code> əmrini işə sala bilərsiniz; bu GUI vasitəsi ilə konfliktləri həll etməyiniz üçün P4Merge başladır.</p>
</div>
<div class="paragraph">
<p>Bu wrapper quruluşunun ən yaxşı tərəfi odur ki, diff-lərinizi dəyişə və alətlərinizi asanlıqla birləşdirə bilərsiniz.
Məsələn, bunun əvəzinə KDiff3 alətini işə salmaq üçün <code>extDiff</code> və <code>extMerge</code> alətlərinizi dəyişdirmək üçün yalnız <code>extMerge</code> sənədinizi düzəltməlisiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat /usr/local/bin/extMerge
#!/bin/sh
/Applications/kdiff3.app/Contents/MacOS/kdiff3 $*</code></pre>
</div>
</div>
<div class="paragraph">
<p>İndi Git, diff qərarını və konflikt həllini birləşdirmək üçün KDiff3 alətini istifadə edəcəkdir.</p>
</div>
<div class="paragraph">
<p>Git, cmd konfiqurasiyasını qurmadan bir sıra digər birləşmə qərarı alətlərindən istifadə etmək üçün əvvəlcədən hazırlanmışdır.
Dəstəklədiyi alətlərin siyahısını görmək üçün bunu sınayın:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git mergetool --tool-help
'git mergetool --tool=&lt;tool&gt;' may be set to one of the following:
        emerge
        gvimdiff
        gvimdiff2
        opendiff
        p4merge
        vimdiff
        vimdiff2

The following tools are valid, but not currently available:
        araxis
        bc3
        codecompare
        deltawalker
        diffmerge
        diffuse
        ecmerge
        kdiff3
        meld
        tkdiff
        tortoisemerge
        xxdiff

Some of the tools listed above only work in a windowed
environment. If run in a terminal-only session, they will fail.</code></pre>
</div>
</div>
<div class="paragraph">
<p>KDiff3-ü diff üçün istifadə etməklə maraqlanmırsınız, əksinə onu yalnız birləşdirmə həlli üçün istifadə etmək istəyirsinizsə və kdiff3 əmri sizin path-dadırsa, o zaman işə sala bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global merge.tool kdiff3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bunu <code>extMerge</code> və <code>extDiff</code> fayllarını qurmaq əvəzinə işlətsəniz, Git birləşmə qərarı üçün KDiff3’ü və difflər üçün normal Git diff alətini istifadə edəcəkdir.</p>
</div>
</div>
<div class="sect3">
<h3 id="_formatlama_və_whitespace">Formatlama və Whitespace</h3>
<div class="paragraph">
<p>
Formatlama və whitespace məsələləri, bir çox developer-in, xüsusilə cross-platform-da əməkdaşlıq edərkən qarşılaşdıqları daha əsəb pozucu və incə problemlərdən biridir.
Patch-lar və ya digər işlərdə incə whitespace dəyişikliklərini tətbiq etmək çox asandır, çünki redaktorlar səssizcə təqdim edirlər və sənədləriniz hər hansı bir Windows sisteminə toxunarsa, xətt uçları dəyişdirilə bilər.
Git-in bu məsələlərdə kömək edəcək bir neçə konfiqurasiya variantı var.</p>
</div>
<div class="sect4">
<h4 id="_core_autocrlf"><code>core.autocrlf</code></h4>
<div class="paragraph">
<p>
Windows-da proqram hazırlayırsınızsa və olmayan insanlarla işləyirsinizsə (və ya əksinə), ehtimal ki, bir nöqtədə sətir sonuna çatanda problemlərlə qarşılaşacaqsınız.
Bunun səbəbi, Windows-un fayllarında həm satır qayıtma xarakteri, həm də yeni xətlər üçün xətt xarakteri istifadə etməsi, MacOS və Linux sistemlərində isə yalnız xətt xarakteri istifadə etməsidir.
Bu, cross-platform işinin incə, lakin inanılmaz dərəcədə cansıxıcı bir həqiqətidir; Windows-dakı bir çox redaktor səssizcə mövcud LF stili sətir uclarını CRLF ilə əvəz edir və ya istifadəçi giriş düyməsini vurduqda hər iki sətir işarəsini əlavə edir.</p>
</div>
<div class="paragraph">
<p>Git, indeksə bir fayl əlavə etdiyiniz zaman CRLF sətir sonlarını avtomatik olaraq LF-ə çevirməklə və əksinə fayl sisteminizə kodu yoxladıqda bunu edə bilər.
Bu funksiyanı <code>core.autocrlf</code> ayarı ilə aça bilərsiniz.
Bir Windows qurğusundasınızsa, onu <code>true</code> olaraq ayarlayın - bu kodu yoxladığınız zaman LF sonluqlarını CRLF-ə çevirir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global core.autocrlf true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Əgər LF sətir sonluqlarından istifadə edən bir Linux və ya macOS sistemindəsinizsə, faylları yoxlayarkən Git-in onları avtomatik olaraq çevirməsini istəmirsiniz; Bununla birlikdə, CRLF sonlu bir fayl təsadüfən təqdim edilərsə, Git-in düzəltməsini istəyə bilərsiniz.
Git-ə, <code>core.autocrlf</code>-ni girişə ayarlayaraq CRLF-i commit götürdükdə LF-yə çevirməsini söyləyə bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global core.autocrlf input</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu quraşdırma sizi Windows checkout-larında CRLF sonları ilə qoymalıdır, lakin macOS və Linux sistemlərində və depoda LF sonluqlarıdır.</p>
</div>
<div class="paragraph">
<p>Yalnız bir Windows layihəsi həyata keçirən bir Windows proqramçısınızsa, konfiqurasiya dəyərini <code>false</code> olaraq təyin edərək daşıma ehtiyatını depoda qeyd edərək bu funksiyanı söndürə bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global core.autocrlf false</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_core_whitespace"><code>core.whitespace</code></h4>
<div class="paragraph">
<p>Git, bəzi whitespace problemlərini aşkarlamaq və düzəltmək üçün əvvəlcədən hazırlanmışdır.
O, altı əsas whitespace məsələsinə baxa bilər - üçü standart olaraq aktivdir və söndürülə bilər və üçü standart olaraq deaktivdir, lakin aktivləşdirilə bilər.
Standart olaraq açılan üçü bir sətrin sonunda boşluq axtaran <code>blank-at-eol</code>; bir sənədin sonunda boş sətirləri görən <code>blank-at-eof</code>; və bir sətrin əvvəlindəki nişanlardan əvvəl boşluqlar axtaran <code>space-before-tab</code>.</p>
</div>
<div class="paragraph">
<p>Standart olaraq deaktiv edilmiş, lakin açıla bilən üç nişanlar əvəzinə boşluqlarla başlayan sətirləri axtaran (və <code>tabwidth</code> seçimi ilə idarə olunan) olan <code>indent-with-non-tab</code>-dir; bir sətrin girinti hissəsindəki nişanları izləyən <code>tab-in-indent</code>; və Git-ə sətirlərin sonunda carriage qayıtmalarının yaxşı olduğunu bildirən <code>cr-at-eol</code>.</p>
</div>
<div class="paragraph">
<p>Bunlardan hansının işə salınmasını istədiyinizi vergüllə ayrılmış və ya söndürmək istədiyiniz dəyərlərə <code>core.whitespace</code> ayarlayaraq söyləyə bilərsiniz.
Bir seçimi adının önünə <code>-</code> yazaraq söndürə və ya tamamilə ayar sətrindən kənarda qoyaraq standart dəyəri istifadə edə bilərsiniz.</p>
</div>
<div class="paragraph">
<p>Məsələn, <code>space-before-tab</code> başqa hamısının qurulmasını istəyirsinizsə, bunu edə bilərsiniz (<code>trailing-space</code> həm <code>blank-at-eol</code> həm də <code>blank-at-eof</code> əhatə edəcək short-hand-dir):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global core.whitespace \
    trailing-space,-space-before-tab,indent-with-non-tab,tab-in-indent,cr-at-eol</code></pre>
</div>
</div>
<div class="paragraph">
<p>Və ya yalnız özəlləşdirmə hissəsini təyin edə bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global core.whitespace \
    -space-before-tab,indent-with-non-tab,tab-in-indent,cr-at-eol</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git, <code>git diff</code> əmri işlədərkən bu problemləri aşkarlayacaq və onları rəngləməyə çalışacaq, belə ki, siz onları etmədən əvvəl düzəldə bilərsiniz.
Ayrıca, <code>git apply</code> ilə patch-lar tətbiq etdikdə sizə kömək etmək üçün bu dəyərlərdən istifadə edəcəkdir.</p>
</div>
<div class="paragraph">
<p>Patch-lar tətbiq edərkən, Git-dən göstərilən whitespace məsələləri ilə patch-lar tətbiq edərsə sizi xəbərdar etməsini istəyə bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git apply --whitespace=warn &lt;patch&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ya da Git patch tətbiq etməzdən əvvəl problemi avtomatik olaraq həll etməyə çalışa bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git apply --whitespace=fix &lt;patch&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu seçimlər <code>git rebase</code> əmrinə də aiddir.
Əgər whitespace problemi yaratmısınız, lakin hələ də yuxarıya doğru push etməmisinizsə, Git-in boşluqları yenidən yazdığı üçün whitespace problemini avtomatik olaraq düzəltməsini təmin etmək üçün <code>git rebase --whitespace=fix</code> düyməsini işə sala bilərsiniz.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_server_konfiqurasiyası">Server Konfiqurasiyası</h3>
<div class="paragraph">
<p>Git-in server tərəfi üçün o qədər də konfiqurasiya seçimi mövcud deyil, ancaq qeyd etmək istəyə biləcəyiniz bir neçə maraqlı seçim var.</p>
</div>
<div class="sect4">
<h4 id="_receive_fsckobjects"><code>receive.fsckObjects</code></h4>
<div class="paragraph">
<p>Git, push zamanı alınan hər bir obyektin hələ də SHA-1 hesablama məbləğinə uyğun gəldiyini və etibarlı obyektləri göstərdiyini təmin edə bilər.
Ancaq bunu standart olaraq etmir; bu olduqca bahalı bir əməliyyatdır və xüsusən böyük depolarda və ya push-larda əməliyyatı ləngidə bilər.
Git-in hər push üzərində obyekt uyğunluğunu yoxlamasını istəyirsinizsə, bunu <code>receive.fsckObjects</code>-i true olaraq təyin edərək məcbur edə bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --system receive.fsckObjects true</code></pre>
</div>
</div>
<div class="paragraph">
<p>İndi, Git, hər bir push qəbul edilməzdən əvvəl səhvli (və ya zərərli) müştərilərin pozulmuş məlumatları təqdim etməməsinə əmin olmaq üçün deponuzun bütövlüyünü yoxlayacaqdır.</p>
</div>
</div>
<div class="sect4">
<h4 id="_receive_denynonfastforwards"><code>receive.denyNonFastForwards</code></h4>
<div class="paragraph">
<p>Əgər siz artıq push etdiyiniz commit-nizi geri qaytarsanız və sonra yenidən push etməyə çalışsanız və ya başqa bir şəkildə uzaq branch-ın göstərdiyi commit-i ehtiva etməyən bir remote branch-a push etməyə çalışarsanız, rədd ediləcəksiniz.
Bu ümumiyyətlə yaxşı siyasətdir; lakin geri qaytarma vəziyyətində nə etdiyinizi bildiyinizi və remote branch-ı <code>-f</code> flag-ı ilə push əmrinizə məcburi şəkildə yeniləyə biləcəyinizi müəyyən edə bilərsiniz.</p>
</div>
<div class="paragraph">
<p>Git-ə güc tətbiqetməsindən imtina etməsini söyləmək üçün <code>receive.denyNonFastForwards</code> seçin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --system receive.denyNonFastForwards true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bunu edə biləcəyiniz başqa bir yol, server tərəfdən qəbul hook-larıdır və onları indi bir az əhatə edəcəyik.
Bu yanaşma, müəyyən bir istifadəçi qrupuna sürətli olmayan hücumları inkar etmək kimi daha mürəkkəb şeylər etməyə imkan verir.</p>
</div>
</div>
<div class="sect4">
<h4 id="_receive_denydeletes"><code>receive.denyDeletes</code></h4>
<div class="paragraph">
<p><code>denyNonFastForwards</code> siyasətinin həll yollarından biri də istifadəçinin branch-ı silmək və sonra yeni istinadla geri push etməsidir.
Bunun qarşısını almaq üçün, <code>receive.denyDeletes</code>-i true olaraq seçin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --system receive.denyDeletes true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu, branch və ya etiketlərin silinməsini inkar edir - heç bir istifadəçi bunu edə bilməz.
Remote branch-ları silmək üçün ref fayllarını serverdən manual şəkildə çıxarmalısınız.
Bunu ACL-lər vasitəsilə hər istifadəçi bazasında etmək üçün daha maraqlı yollar var, hansı ki <a href="{{< relurl "book/az/v2/ch00/_an_example_git_enforced_policy" >}}">Git-Enforced Siyasət Nümunəsi</a>-də öyrənəcəksiniz.</p>
</div>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>