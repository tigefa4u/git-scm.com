---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: az
  chapter:
    title: Git Alətləri
    number: 7
  section:
    title: Alt Modullar
    number: 11
    cs_number: '7.11'
    previous: book/az/v2/Git-Alətləri-Git-ilə-Debugging
    next: book/az/v2/Git-Alətləri-Bundling
title: Git - Alt Modullar
url: "/book/az/v2/Git-Alətləri-Alt-Modullar.html"
---
<h2 id="_git_submodules">Alt Modullar</h2>
<div class="paragraph">
<p>Çox vaxt bir layihə üzərində işləyərkən içərisindən başqa bir layihəni istifadə etməli oluruq.
Bu üçüncü tərəfin inkişaf etdirdiyi və ya ayrıca inkişaf etdirdiyiniz və bir çox əsas layihədə istifadə etdiyiniz bir kitabxanada ola bilər.
Bu ssenarilərdə ortaq bir problem ortaya çıxır: iki layihəni ayrı bir hala gətirmək istəyərsən, amma yenə də birini digərindən istifadə edə bilmək istəyirsən.</p>
</div>
<div class="paragraph">
<p>Bir misal.
Deyək ki, bir veb sayt hazırlayırsınız və Atom feed-lər yaradırsınız.
Atom yaradan kodunuzu yazmaq əvəzinə bir kitabxanadan istifadə etməyi qərara alırsınız.
Çox güman ki, bu kodu bir CPAN quraşdırması və ya Ruby gem kimi ortaq bir kitabxanadan daxil etməlisiniz və ya mənbə kodu öz layihə ağacınıza kopyalayırsınız.
Kitabxananın daxil olması ilə əlaqədar problem, kitabxananı hər hansı bir şəkildə düzəltmək və tez-tez onu yerləşdirmək daha çətindir, çünki hər bir müştəridə bu kitabxananın mövcud olduğundan əmin olmalısınız.
Kodun öz layihənizə kopyalanması ilə bağlı problem, yuxarı dəyişikliklər mövcud olduqda etdiyiniz hər hansı bir xüsusi dəyişikliklərin birləşməsi çətinləşməsidir.</p>
</div>
<div class="paragraph">
<p>Git bu məsələni submodullardan istifadə edərək həll edir.
submodullar bir Git deponu başqa bir Git deponun alt kataloqu olaraq saxlamağa imkan verir.
Bu, layihənizdə başqa bir depo klonlaşdırmağa və ayrılıqda vəzifələrinizi yerinə yetirməyə imkan verir.</p>
</div>
<div class="sect3">
<h3 id="_starting_submodules">Submodullarla başlayaq</h3>
<div class="paragraph">
<p>Əsas bir layihəyə və bir neçə alt layihəyə bölünmüş sadə bir layihəni inkişaf etdirmək yolu ilə dəvam edəcəyik.</p>
</div>
<div class="paragraph">
<p>Mövcud Git deponu üzərində işlədiyimiz deponun submodulu olaraq əlavə etməklə başlayaq.
Yeni bir submodul əlavə etmək üçün izləməyə başlamaq istədiyiniz layihənin mütləq və ya nisbi URL-i ilə <code>git submodule add</code> əmrindən istifadə edin.
Bu nümunədə “DbConnector” adlı bir kitabxana əlavə edəcəyik.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git submodule add https://github.com/chaconinc/DbConnector
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Varsayılan olaraq, submodullar alt layihəni “DbConnector” depo ilə eyni adlı bir qovluğa əlavə edəcəkdir.
Əmrin sonunda başqa bir yerə getmək istəsəniz fərqli bir yol əlavə edə bilərsiniz.</p>
</div>
<div class="paragraph">
<p>Bu nöqtədə <code>git status</code> işlədirsinizsə, bir neçə şeyi görəcəksiniz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

	new file:   .gitmodules
	new file:   DbConnector</code></pre>
</div>
</div>
<div class="paragraph">
<p>Əvvəlcə yeni  <code>.gitmodules</code> faylını görməlisiniz.
Bu, layihənin URL-si ilə çəkdiyiniz local subdirectory  arasındakı datanı saxlayan bir konfiqurasiya faylıdır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">[submodule "DbConnector"]
	path = DbConnector
	url = https://github.com/chaconinc/DbConnector</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bir neçə submodulunuz varsa, bu faylda birdən çox giriş olacaqdır.
Bu faylın <code>.gitignore</code> faylı kimi digər fayllarınızla da idarə olunduğunu qeyd etmək vacibdir.
Layihənizin qalan hissəsi ilə push və pull edildi.
Bu layihəni klonlayan digər insanlar submodul layihələrini haradan əldə edəcəyini bilirlər.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<div class="title">gitmodules faylındakı URL digər insanların əvvəlcə  clone/fetch etməyə çalışdıqları bir şey olduqları üçün mümkün olduğundan əldə edə biləcəkləri bir URL istifadə etdiyinizdən əmin olun.</div>
<p>Məsələn, başqalarından çəkmək üçün fərqli bir URL istifadə etsəniz, başqalarının istifadə edə biləcəyi URL-i istifadə edin.
Öz istifadəniz üçün bu dəyəri local olaraq <code>git config submodule.DbConnector.url PRIVATE_URL</code> ilə yaza bilərsiniz.
Tətbiq edildikdə, nisbi bir URL kömək edə bilər.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>git status</code> çıxışındakı digər siyahı, layihə qovluğuna girişdir.
Bunun üzərinə <code>git diff</code> işləsəniz, maraqlı bir şey görəcəksiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --cached DbConnector
diff --git a/DbConnector b/DbConnector
new file mode 160000
index 0000000..c3f01dc
--- /dev/null
+++ b/DbConnector
@@ -0,0 +1 @@
+Subproject commit c3f01dc8862123d317dd46284b05b6892c7b29bc</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DbConnector</code>  işlədiyiniz qovluğunda bir subdirectory olsa da, Git onu submodul kimi görür və bu qovluqda olmadığınız zaman onun konteksini izləmir.
Bunun əvəzinə, Git bunu o depodan xüsusi bir commit kimi görür.</p>
</div>
<div class="paragraph">
<p>Biraz daha yaxşı fərqli çıxış istəyirsinizsə, <code>--submodule</code> seçimini` <code>git diff</code>-ə əlavə edə bilərsiniz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --cached --submodule
diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 0000000..71fc376
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,3 @@
+[submodule "DbConnector"]
+       path = DbConnector
+       url = https://github.com/chaconinc/DbConnector
Submodule DbConnector 0000000...c3f01dc (new submodule)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nə vaxt commit etsəniz, aşağıdakı kimi görünəcəkdir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git commit -am 'Add DbConnector module'
[master fb9093c] Add DbConnector module
 2 files changed, 4 insertions(+)
 create mode 100644 .gitmodules
 create mode 160000 DbConnector</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DbConnector</code> girişi üçün `160000`rejiminə diqqət yetirin.
Bu Git-də xüsusi bir rejimdir ki, bu, bir commiti bir subdirectory və ya bir fayl kimi deyil, bir qovluq girişi kimi qeyd etdiyiniz deməkdir.</p>
</div>
<div class="paragraph">
<p>Nəhayət, bu dəyişiklikləri push edin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git push origin master</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_cloning_submodules">Bir Layihəni Submodullarla Klonlaşdırmaq</h3>
<div class="paragraph">
<p>Burada bir submodul ilə bir layihə klonlayacağıq.
Belə bir layihəni klonlaşdırdıqda, standart olaraq submodulları ehtiva edən qovluqları alırsınız, ancaq bunların içərisindəki faylların heç birini hələ almırsınız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone https://github.com/chaconinc/MainProject
Cloning into 'MainProject'...
remote: Counting objects: 14, done.
remote: Compressing objects: 100% (13/13), done.
remote: Total 14 (delta 1), reused 13 (delta 0)
Unpacking objects: 100% (14/14), done.
Checking connectivity... done.
$ cd MainProject
$ ls -la
total 16
drwxr-xr-x   9 schacon  staff  306 Sep 17 15:21 .
drwxr-xr-x   7 schacon  staff  238 Sep 17 15:21 ..
drwxr-xr-x  13 schacon  staff  442 Sep 17 15:21 .git
-rw-r--r--   1 schacon  staff   92 Sep 17 15:21 .gitmodules
drwxr-xr-x   2 schacon  staff   68 Sep 17 15:21 DbConnector
-rw-r--r--   1 schacon  staff  756 Sep 17 15:21 Makefile
drwxr-xr-x   3 schacon  staff  102 Sep 17 15:21 includes
drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 scripts
drwxr-xr-x   4 schacon  staff  136 Sep 17 15:21 src
$ cd DbConnector/
$ ls
$</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DbConnector</code> qovluğu var, lakin boşdur.
İki əmri işlətməlisiniz: local konfiqurasiya sənədinizi başlatmaq üçün <code>git submodule init</code> və o layihədən bütün məlumatları almaq və layihənizdə sadalanan müvafiq commit-ləri yoxlamaq üçün <code>git submodule update</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git submodule init
Submodule 'DbConnector' (https://github.com/chaconinc/DbConnector) registered for path 'DbConnector'
$ git submodule update
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
Submodule path 'DbConnector': checked out 'c3f01dc8862123d317dd46284b05b6892c7b29bc'</code></pre>
</div>
</div>
<div class="paragraph">
<p>İndi <code>DbConnector</code> subdirectory-niz əvvəllər commit etdiyiniz zaman olduğu vəziyyətdədir.
Bunu etmək üçün bir az daha sadə başqa bir yol var.
Əgər <code>--recurse-submodules</code> əmrini <code>git clone</code> əmrinə əlavə etsəniz, depodakı submodulların hər hansı birində submodullar varsa, avtomatik olaraq depodakı hər bir submodulu işə salır və yeniləyir.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone --recurse-submodules https://github.com/chaconinc/MainProject
Cloning into 'MainProject'...
remote: Counting objects: 14, done.
remote: Compressing objects: 100% (13/13), done.
remote: Total 14 (delta 1), reused 13 (delta 0)
Unpacking objects: 100% (14/14), done.
Checking connectivity... done.
Submodule 'DbConnector' (https://github.com/chaconinc/DbConnector) registered for path 'DbConnector'
Cloning into 'DbConnector'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.
Submodule path 'DbConnector': checked out 'c3f01dc8862123d317dd46284b05b6892c7b29bc'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Layihəni əvvəlcədən klonlaşdırmısınızsa və <code>--recurse-submodules</code> unutmusunuzsa, <code>git submodule update --init</code> əmrini işlədərək  <code>git submodule init</code> və <code>git submodule update</code> addımlarını birləşdirə bilərsiniz.
Hər hansı bir iç-içə keçmiş submodulu işə salmaq, almaq və yoxlamaq üçün <code>git submodule update --init --recursive</code> istifadə edə bilərsiniz.</p>
</div>
</div>
<div class="sect3">
<h3 id="_submodullar_ilə_bir_layihə_üzərində_i̇şləmək">Submodullar ilə bir Layihə üzərində İşləmək</h3>
<div class="paragraph">
<p>İndi içərisində submodulları olan bir layihənin bir nüsxəsi var və həm əsas layihədə, həm də submodul layihədə komanda yoldaşlarımızla əməkdaşlıq edəcəyik.</p>
</div>
<div class="sect4">
<h4 id="_submodule_remote_dan_upstream_dəyişiklikləri_pulling_etmək">Submodule Remote-dan Upstream Dəyişiklikləri Pulling etmək</h4>
<div class="paragraph">
<p>Uzaqdan Layihədə submodulları istifadə etməyin ən sadə modeli, sadəcə bir layihə istifadə etməyiniz və zaman zaman yeniləmələri almaq istəməyiniz, ancaq həqiqətən yoxlanışda bir şey dəyişdirməməyinizdir.
Oradakı sadə bir nümunəyə baxaq.</p>
</div>
<div class="paragraph">
<p>Bir submodulda yeni işin olub olmadığını yoxlamaq istəyirsinizsə, qovluğa girib local kodu yeniləmək üçün yuxarıdakı branch-ı <code>git fetch</code> və <code>git merge</code> işlədə bilərsiniz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git fetch
From https://github.com/chaconinc/DbConnector
   c3f01dc..d0354fc  master     -&gt; origin/master
$ git merge origin/master
Updating c3f01dc..d0354fc
Fast-forward
 scripts/connect.sh | 1 +
 src/db.c           | 1 +
 2 files changed, 2 insertions(+)</code></pre>
</div>
</div>
<div class="paragraph">
<p>İndi əsas layihəyə qayıdırsınız və <code>git diff --submodule</code>   işlədirsinizsə, submodulun yeniləndiyini və ona əlavə olunanların siyahısını əldə etdiyini görə bilərsən.
Hər dəfə <code>git diff</code> işlədikdə <code>--submodule</code> yazmaq istəmirsinizsə, onu <code>diff.submodule</code> konfiqurasiya dəyərini “log”-a  təyin edərək standart format kimi təyin edə bilərsiniz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global diff.submodule log
$ git diff
Submodule DbConnector c3f01dc..d0354fc:
  &gt; more efficient db routine
  &gt; better connection routine</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu anda commit etsəniz, submodulu digər insanlar yenilədikdə yeni kodun içərisinə bağlayacaqsınız.</p>
</div>
<div class="paragraph">
<p>Submodulda manual olaraq fetch edilib birləşməməyi istəsəniz, bunu etmək üçün daha asan bir yol var.
<code>git submodule update --remote</code> işlədirsinizsə, Git submodullara daxil olacaq və sizin üçün yeniləyəcəkdir.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git submodule update --remote DbConnector
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   3f19983..d0354fc  master     -&gt; origin/master
Submodule path 'DbConnector': checked out 'd0354fc054692d3906c85c3af05ddce39a1c0644'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu əmr standart olaraq, submodul deposunun <code>master</code> branch-na çıxışı yeniləmək istədiyinizi qəbul edəcəkdir.
İstəsəniz, bunu fərqli bir şeyə təyin edə bilərsiniz.
Məsələn, DbConnector submodulunun o deponun “stable” branch-nı izləməyini istəyirsinizsə, onu ya <code>.gitmodules</code> sənədinizdə (beləcə hər kəs onu izləyər) və ya local <code>.git/config</code> faylında quraşdıra bilərsiniz.
Gəlin onu <code>.gitmodules</code> sənədinə qoyaq:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config -f .gitmodules submodule.DbConnector.branch stable

$ git submodule update --remote
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   27cf5d3..c87d55d  stable -&gt; origin/stable
Submodule path 'DbConnector': checked out 'c87d55d4c6d4b05ee34fbc8cb6f7bf4585ae6687'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Əgər  <code>-f .gitmodules</code> deaktiv etsəniz, bu yalnız sizin üçün dəyişikliyə səbəb olacaq, ancaq hər kəsin də olduğu kimi bu məlumatı depo ilə izləməyi daha mənalı olar.</p>
</div>
<div class="paragraph">
<p>Bu nöqtədə <code>git status</code> işlədikdə, Git submodulda “new commits” olduğunu göstərəcəkdir.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

  modified:   .gitmodules
  modified:   DbConnector (new commits)

no changes added to commit (use "git add" and/or "git commit -a")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Konfiqurasiya parametrini  <code>status.submodulesummary</code> təyin etsəniz, Git sizə submodullarındakı dəyişikliklərin qısa xülasəsini də göstərəcəkdir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config status.submodulesummary 1

$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

	modified:   .gitmodules
	modified:   DbConnector (new commits)

Submodules changed but not updated:

* DbConnector c3f01dc...c87d55d (4):
  &gt; catch non-null terminated lines</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu nöqtədə <code>git diff</code> işlədirsinizsə, həm də  <code>.gitmodules</code>  faylımızı dəyişdirdiyimizi, həmçinin endirdiyimiz və submodul layihəmizin yerinə yetirməyə hazır olduğumuz bir sıra işlərin olduğunu görə bilərik.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --git a/.gitmodules b/.gitmodules
index 6fc0b3d..fd1cc29 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,4 @@
 [submodule "DbConnector"]
        path = DbConnector
        url = https://github.com/chaconinc/DbConnector
+       branch = stable
 Submodule DbConnector c3f01dc..c87d55d:
  &gt; catch non-null terminated lines
  &gt; more robust error handling
  &gt; more efficient db routine
  &gt; better connection routine</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu, olduqca əlverişlidir, çünki həqiqətən submodulumuzda verəcəyimiz commit-lərin qeydini görə bilərik.
Commit etdikdən sonra bu məlumatı  <code>git log -p</code> işlədərkən də görə bilərsiniz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -p --submodule
commit 0a24cfc121a8a3c118e0105ae4ae4c00281cf7ae
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Wed Sep 17 16:37:02 2014 +0200

    updating DbConnector for bug fixes

diff --git a/.gitmodules b/.gitmodules
index 6fc0b3d..fd1cc29 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,3 +1,4 @@
 [submodule "DbConnector"]
        path = DbConnector
        url = https://github.com/chaconinc/DbConnector
+       branch = stable
Submodule DbConnector c3f01dc..c87d55d:
  &gt; catch non-null terminated lines
  &gt; more robust error handling
  &gt; more efficient db routine
  &gt; better connection routine</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git standart olaraq <code>git submodule update --remote</code>-u işlətdiyiniz zaman submodullarınızın <strong>hamısını</strong> yeniləməyə çalışacaqdır.
Əgər bunların çoxu varsa, yeniləməyə çalışmaq istədiyiniz yalnız submodulun adını ötürmək istəyə bilərsiniz.</p>
</div>
</div>
<div class="sect4">
<h4 id="_upstream_dəyişikliklərini_layihə_uzaqdan_pull_edir">Upstream Dəyişikliklərini Layihə Uzaqdan Pull edir</h4>
<div class="paragraph">
<p>İndi MainProject depolarının öz local klonuna sahib olan işçinizin yerinə keçək.
Yeni düzəlişlərinizi əldə etmək üçün sadəcə <code>git pull</code> yerinə yetirmək kifayət etmir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git pull
From https://github.com/chaconinc/MainProject
   fb9093c..0a24cfc  master     -&gt; origin/master
Fetching submodule DbConnector
From https://github.com/chaconinc/DbConnector
   c3f01dc..c87d55d  stable     -&gt; origin/stable
Updating fb9093c..0a24cfc
Fast-forward
 .gitmodules         | 2 +-
 DbConnector         | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

$ git status
 On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

	modified:   DbConnector (new commits)

Submodules changed but not updated:

* DbConnector c87d55d...c3f01dc (4):
  &lt; catch non-null terminated lines
  &lt; more robust error handling
  &lt; more efficient db routine
  &lt; better connection routine

no changes added to commit (use "git add" and/or "git commit -a")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Varsayılan olaraq, <code>git pull</code> əmri yuxarıda göstərilən ilk əmrin nəticələrində gördüyümüz kimi, submodulları rekursiv şəkildə dəyişir.
Ancaq submodulları <strong>yeniləməz</strong>.
Bu, submodulun “modified” olduğunu və “new commits” verdiyini göstərən <code>git status</code> əmrinin çıxışı ilə göstərilir.
Üstəlik, yeni commit nöqtəsini göstərən mötərizələr (&lt;), bu tapşırıqların MainProject-də qeydə alındığını, lakin local DbConnector yoxlanışında olmadığını göstərir.
Yeniləməni yekunlaşdırmaq üçün <code>git submodule update</code> işləməlisiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git submodule update --init --recursive
Submodule path 'vendor/plugins/demo': checked out '48679c6302815f6c76f1fe30625d795d9e55fc56'

$ git status
 On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working tree clean</code></pre>
</div>
</div>
<div class="paragraph">
<p>Etibarlı tərəfdə olmaq üçün MainProject yeni submodulları əlavə etməyi commit etdiyi submodullar varsa, <code>--init</code> və <code>--recursive</code> flag-larından istifadə edərək <code>git submodule update</code>-ni işə salmalısınız.</p>
</div>
<div class="paragraph">
<p>Bu prosesi avtomatlaşdırmaq istəyirsinizsə,  <code>--recurse-submodules</code> flag-nı <code>git pull</code> əmrinə əlavə edə bilərsiniz (Git 2.14-dən bəri).
Bu, Git pull etməkdən dərhal sonra <code>git submodule update</code>-ni işə salacaq və submodulları düzgün vəziyyətə gətirəcəkdir.
Üstəlik, Git’i həmişə <code>--recurse-submodules</code> ilə pull etmək istəsəniz,  <code>submodule.recurse</code> konfiqurasiya seçimini "true" olaraq təyin edə bilərsiniz (Git 2.15-dən bəri <code>git pull</code> üçün işləyir).
Bu seçim Git-in onu dəstəkləyən bütün əmrlər üçün <code>--recurse-submodules</code> flag-ından istifadə etməsini təmin edəcəkdir (<code>clone</code> xaricində).</p>
</div>
<div class="paragraph">
<p>Super layihə yeniləmələrini pulling edərkən baş verə biləcək xüsusi bir vəziyyət var: ola bilər ki, yuxarıdakı depo, pull etdiyiniz commit-lərin birində <code>.gitmodules</code> faylındakı submodulun URL-sini dəyiştirmiş ola bilər.
Bu, məsələn submodul layihəsi hosting platformasını dəyişdirərsə, baş verə bilər.
Bu vəziyyətdə, super layihə deposunda local olaraq tənzimlənmiş submodulun uzaq yerində tapılmayan bir submodul əməlinə istinad edərsə,  <code>git pull --recurse-submodules</code> və ya <code>git submodule update</code> üçün uğursuz ola bilər.
Bu vəziyyəti düzəltmək üçün <code>git submodule sync</code> əmri tələb olunur:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console"># copy the new URL to your local config
$ git submodule sync --recursive
# update the submodule from the new URL
$ git submodule update --init --recursive</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_submodul_üzərində_i̇şləmək">Submodul üzərində İşləmək</h4>
<div class="paragraph">
<p>Çox güman ki, submodullardan istifadə edirsinizsə, bunu əsas layihədə (və ya bir neçə submodulda) kod üzərində işləyərkən eyni zamanda submoduldakı kod üzərində işləmək istədiyiniz üçün edirsiniz.
Əks təqdirdə bunun əvəzinə daha sadə bir asılılıq idarəetmə sistemindən istifadə edərdiniz (məsələn Maven və ya Rubygems).</p>
</div>
<div class="paragraph">
<p>Beləliklə, indi əsas layihə ilə eyni vaxtda submodulda dəyişiklik etmək və eyni zamanda bu dəyişiklikləri commit etmək və yayımlamaq nümunəsinə baxaq.</p>
</div>
<div class="paragraph">
<p>İndiyə qədər, submodul depolarından dəyişiklik almaq üçün <code>git submodule update</code> əmrini işlətdikdə Git dəyişiklikləri əldə edib subdirectory-da faylları yeniləyəcək, lakin sub-repository-i “detached HEAD” vəziyyəti adlanacaq.
Bu o deməkdir ki, dəyişiklikləri izləyən local (məsələn, <code>master</code> kimi) branch yoxdur.
Heç bir işləyən branch izləmə dəyişiklikləri olmadan o deməkdir ki, submodula dəyişiklik etsəniz də, növbəti dəfə <code>git submodule update</code> işlədikdə bu dəyişikliklər tamamilə itiriləcəkdir.
Bir submoduldakı dəyişikliklərin izlənməsini istəyirsinizsə, əlavə addımlar atmalısınız.</p>
</div>
<div class="paragraph">
<p>Giriş və hack etmək daha asan olması üçün alt modulunuzu qurmaq üçün iki şey etməlisiniz.
Hər bir submodula daxil olmalı və işləmək üçün bir branch-ı yoxlamalısınız.
Sonra dəyişikliklər etdikdən sonra Git’ə nə etməli olduğunu izah etməlisiniz və sonra <code>git submodule update --remote</code> yuxarıdan yeni işə pull ediləcəkdir.
Seçimlər bunlardır ki, onları local işinizə birləşdirə bilərsiniz və ya local işinizi yeni dəyişikliklərin başına qaytarmağa cəhd edə bilərsiniz.</p>
</div>
<div class="paragraph">
<p>Əvvəlcə submodul qovluğumuza daxil olub, bir branch-ı yoxlayaq.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cd DbConnector/
$ git checkout stable
Switched to branch 'stable'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Submodulumuzu “merge” seçimi ilə yeniləməyə çalışaq.
Manual müəyyənləşdirmək üçün <code>update</code> çağırışımıza <code>--merge</code> seçimini əlavə edə bilərik.
Burada bu submodul üçün serverdə bir dəyişiklik olduğunu və birləşdirildiyini görərik.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cd ..
$ git submodule update --remote --merge
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 4 (delta 2), reused 4 (delta 2)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   c87d55d..92c7337  stable     -&gt; origin/stable
Updating c87d55d..92c7337
Fast-forward
 src/main.c | 1 +
 1 file changed, 1 insertion(+)
Submodule path 'DbConnector': merged in '92c7337b30ef9e0893e758dac2459d07362ab5ea'</code></pre>
</div>
</div>
<div class="paragraph">
<p>DbConnector qovluğuna daxil olsaq, dəyişikliklər local <code>stable</code> branch-da göstərilmişdir.
İndi gəlin görək kitabxanaya öz local dəyişikliklərimizi edərik və başqası eyni zamanda başqa bir dəyişikliyi yuxarıya push edəndə nə olacağına baxaq.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cd DbConnector/
$ vim src/db.c
$ git commit -am 'Unicode support'
[stable f906e16] Unicode support
 1 file changed, 1 insertion(+)</code></pre>
</div>
</div>
<div class="paragraph">
<p>İndi submodulumuzu yeniləsək, local bir dəyişiklik etdikdə və yuxarıda əlavə etməli olduğumuz bir dəyişikliyə sahib olduğumuzu görə bilərik.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cd ..
$ git submodule update --remote --rebase
First, rewinding head to replay your work on top of it...
Applying: Unicode support
Submodule path 'DbConnector': rebased into '5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>--rebase</code> və ya <code>--merge</code> unudarsanız, Git yalnız submodulu serverdəki hər hansı bir şeyə yeniləyəcək və layihənizi ayrı bir HEAD vəziyyətinə qaytaracaqdır.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git submodule update --remote
Submodule path 'DbConnector': checked out '5d60ef9bbebf5a0c1c1050f242ceeb54ad58da94'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Əgər bu baş verərsə, narahat olmayın, sadəcə qovluğuna qayıda bilər və yenidən branch-nızı yoxlaya bilərsiniz (bu hələ də işinizi özündə saxlayacaq) <code>origin/stable</code> (və ya istədiyiniz hər hansı bir branch-ı) manual olaraq birləşdirə və ya dəyişdirə bilərsiniz.</p>
</div>
<div class="paragraph">
<p>Submoduldakı dəyişikliklərinizi etməmisinizsə və problem yarada biləcək bir submodul yeniləməsini işlədirsinizsə, Git dəyişiklikləri alır, ancaq submodul qovluğunuzda qeyd olunmamış işləri yazmır.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git submodule update --remote
remote: Counting objects: 4, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 4 (delta 0), reused 4 (delta 0)
Unpacking objects: 100% (4/4), done.
From https://github.com/chaconinc/DbConnector
   5d60ef9..c75e92a  stable     -&gt; origin/stable
error: Your local changes to the following files would be overwritten by checkout:
	scripts/setup.sh
Please, commit your changes or stash them before you can switch branches.
Aborting
Unable to checkout 'c75e92a2b3855c9e5b66f915308390d9db204aca' in submodule path 'DbConnector'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Yuxarıda dəyişdirilmiş bir şey ilə ziddiyyətli dəyişikliklər etmisinizsə, Git yeniləməni işlədiyiniz zaman sizə xəbər verəcəkdir.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git submodule update --remote --merge
Auto-merging scripts/setup.sh
CONFLICT (content): Merge conflict in scripts/setup.sh
Recorded preimage for 'scripts/setup.sh'
Automatic merge failed; fix conflicts and then commit the result.
Unable to merge 'c75e92a2b3855c9e5b66f915308390d9db204aca' in submodule path 'DbConnector'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Submodul qovluğuna girib konflikti normal qaydada istədiyiniz kimi düzəldə bilərsiniz.</p>
</div>
</div>
<div class="sect4">
<h4 id="_publishing_submodules">Submodul Dəyişikliklərini Yayımlamaq</h4>
<div class="paragraph">
<p>İndi submodul qovluğunda bəzi dəyişikliklər var.
Bunlardan bəziləri yeniləmələrimiz tərəfindən yuxarıdan gətirilib, digərləri local olaraq hazırlanıb və hələ də onları açmamışıq.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
Submodule DbConnector c87d55d..82d2ad3:
  &gt; Merge from origin/stable
  &gt; Update setup script
  &gt; Unicode support
  &gt; Remove unnecessary method
  &gt; Add new option for conn pooling</code></pre>
</div>
</div>
<div class="paragraph">
<p>Əsas layihədə iştirak etsək və submodula dəyişikliklərini də pushing etmədən push etsək, dəyişikliklərimizi yoxlamağa çalışan digər insanlara problemə yarnacaq, çünki asılı olan submodul dəyişikliklərini əldə etmək üçün bir yol qalmayacaqlar.
Bu dəyişikliklər yalnız local nüsxəmizdə olacaq.</p>
</div>
<div class="paragraph">
<p>Bunun baş verməməsinə əmin olmaq üçün Git-dən əsas layihəni push etmədən əvvəl bütün submodullarınızın düzgün şəkildə push edildiyini yoxlamağı xahiş edə bilərsiniz.
<code>git push</code> əmri,  “check” və ya “on-demand” olaraq təyin edilə bilən <code>--recurse-submodules</code> argumentini alır.
“check” seçimi, submodul dəyişikliklərindən hər hansı birinə push edilmədiyi təqdirdə, <code>push</code> etməyi asanlaşdıracaq.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git push --recurse-submodules=check
The following submodule paths contain changes that can
not be found on any remote:
  DbConnector

Please try

	git push --recurse-submodules=on-demand

or cd to the path and use

	git push

to push them to a remote.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Gördüyünüz kimi, bundan sonra da nə etmək istədiyimiz barədə bəzi faydalı məsləhətlər verir.
Sadə seçim odur ki, hər bir submodula daxil olub uzaqdan mövcud olduqlarına əmin olmaq üçün manual olaraq uzaqdan idarə etməkdir və sonra bu push etməyi yenidən sınamaqdır.
Bütün push etməklər üçün yoxlama davranışının olmasını istəyirsinizsə,<code>git config push.recurseSubmodules check</code> əməliyyatı edərək bu davranışı standart hala gətirə bilərsiniz.</p>
</div>
<div class="paragraph">
<p>Digər seçim, “on-demand” dəyərini istifadə etməkdir, bu sizin üçün bunu etməyə çalışacaqdır.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git push --recurse-submodules=on-demand
Pushing submodule 'DbConnector'
Counting objects: 9, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (8/8), done.
Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.
Total 9 (delta 3), reused 0 (delta 0)
To https://github.com/chaconinc/DbConnector
   c75e92a..82d2ad3  stable -&gt; stable
Counting objects: 2, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (2/2), done.
Writing objects: 100% (2/2), 266 bytes | 0 bytes/s, done.
Total 2 (delta 1), reused 0 (delta 0)
To https://github.com/chaconinc/MainProject
   3d6d338..9a377d1  master -&gt; master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Gördüyünüz kimi, Git DbConnector moduluna girdi və əsas layihəyə keçməmişdən əvvəl push etdi.
Bu submodul push etmək nədənsə uğursuz olarsa, əsas layihə push etmə də uğursuz olacaq.
Bu davranışı standart olaraq <code>git config push.recurseSubmodules on-demand</code> edərək edə bilərsiniz.</p>
</div>
</div>
<div class="sect4">
<h4 id="_submodul_dəyişikliklərini_birləşdirmək">Submodul Dəyişikliklərini Birləşdirmək</h4>
<div class="paragraph">
<p>Bir submodul arayışını başqası ilə eyni vaxtda dəyişdirsəniz, bəzi problemlərlə qarşılaşa bilərsiniz.
Yəni, submodul tarixləri bir-birindən ayrılıbsa və bir super layihədə branch-ları ayırmaq öhdəliyindədirsə, düzəltmək üçün bir az iş tələb oluna bilər.</p>
</div>
<div class="paragraph">
<p>Təqdim olunanlardan biri digərinin birbaşa əcdadıdırsa (sürətli birləşmə), onda Git birləşmə üçün sadəcə sonuncunu seçəcəkdir ki, beləcə yaxşı işləyəcək.</p>
</div>
<div class="paragraph">
<p>Git sizin üçün mənasız birləşməyə belə cəhd etməyəcək.
Submodul bir-birindən fərqli commit edirsə və birləşdirilməlidirsə, buna bənzər bir şey alacaqsınız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git pull
remote: Counting objects: 2, done.
remote: Compressing objects: 100% (1/1), done.
remote: Total 2 (delta 1), reused 2 (delta 1)
Unpacking objects: 100% (2/2), done.
From https://github.com/chaconinc/MainProject
   9a377d1..eb974f8  master     -&gt; origin/master
Fetching submodule DbConnector
warning: Failed to merge submodule DbConnector (merge following commits not found)
Auto-merging DbConnector
CONFLICT (submodule): Merge conflict in DbConnector
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Beləliklə, əsasən burada nə baş verən budur ki, Git iki branch-ın submodulun tarixində bir-birindən fərqli olan və birləşdirilməli olduğunu  nöqtələri qeyd etdi.
Bunu çaşdırıcı olan “merge following commits not found” kimi izah edir, amma bunun niyə olduğunu birazdan izah edəcəyik.</p>
</div>
<div class="paragraph">
<p>Problemi həll etmək üçün submodulun hansı vəziyyətdə olduğunu müəyyənləşdirməlisiniz.
Qəribədir ki, Git buraya kömək etmək üçün çox məlumat vermir, hətta tarixin hər iki tərəfinin verdiyi SHA-1-lərdən də məlumat vermir.
Xoşbəxtlikdən, bunu anlamaq çox sadədir.
<code>git diff</code> işlədirsinizsə, birləşdirməyə çalışdığınız hər iki branch-da qeyd olunan əmsalların SHA-1-lərini əldə edə bilərsiniz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --cc DbConnector
index eb41d76,c771610..0000000
--- a/DbConnector
+++ b/DbConnector</code></pre>
</div>
</div>
<div class="paragraph">
<p>Beləliklə, bu vəziyyətdə,  <code>eb41d76</code> submodulumuzda <strong>biz</strong> sahip olduğumuz commit və <code>c771610</code> upstream-in sahib olduğu commitdir.
Submodule qovluğumuza daxil olsaq, birləşmə ona toxunmayacağı üçün artıq <code>eb41d76</code> üzərində olmalıdır.
Hansı səbəbdən olursa olsun, sadəcə ona işarə edən bir branch yarada və nəzarət edə bilərsiniz.</p>
</div>
<div class="paragraph">
<p>Önəmli olan qarşı tərəfin commit-nin SHA-1 olmasıdır.
Bu birləşdirib və həll etmək məcburiyyətində olduğunuz bir şeydir.
Sadəcə birbaşa SHA-1 ilə birləşməyə cəhd edə bilərsiniz və ya bunun üçün bir branch yarada və sonra birləşməyə cəhd edə bilərsiniz.
Sonuncunu, daha yaxşı birləşmə commiti verəcəyi üçün tövsiyə edirik.</p>
</div>
<div class="paragraph">
<p>Beləliklə, submodul qovluğumuza daxil olacağıq, <code>git diff</code>-dən ikinci SHA-1 əsasında “try-merge” adlı bir branch yaradacağıq və manual olaraq birləşdirəcəyik.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cd DbConnector

$ git rev-parse HEAD
eb41d764bccf88be77aced643c13a7fa86714135

$ git branch try-merge c771610

$ git merge try-merge
Auto-merging src/main.c
CONFLICT (content): Merge conflict in src/main.c
Recorded preimage for 'src/main.c'
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Burada faktiki olaraq birləşmə konflikti var, buna görə də bu problemi həll etsək və öhdəsinə götürsək, əsas layihəni nəticə ilə yeniləyə bilərik.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ vim src/main.c <b class="conum">(1)</b>
$ git add src/main.c
$ git commit -am 'merged our changes'
Recorded resolution for 'src/main.c'.
[master 9fd905e] merged our changes

$ cd .. <b class="conum">(2)</b>
$ git diff <b class="conum">(3)</b>
diff --cc DbConnector
index eb41d76,c771610..0000000
--- a/DbConnector
+++ b/DbConnector
@@@ -1,1 -1,1 +1,1 @@@
- Subproject commit eb41d764bccf88be77aced643c13a7fa86714135
 -Subproject commit c77161012afbbe1f58b5053316ead08f4b7e6d1d
++Subproject commit 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a
$ git add DbConnector <b class="conum">(4)</b>

$ git commit -m "Merge Tom's Changes" <b class="conum">(5)</b>
[master 10d2c60] Merge Tom's Changes</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Əvvəlcə konflikti həll edirik.</p>
</li>
<li>
<p>Sonra əsas layihə qovluğuna qayıdırıq.</p>
</li>
<li>
<p>SHA-1-ləri yenidən yoxlaya bilərik.</p>
</li>
<li>
<p>Konflikt submodul girişini həll edin.</p>
</li>
<li>
<p>Birləşməyimizi commit edin.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Bir az qarışıq ola bilər, amma həqiqətən çox çətin deyil.</p>
</div>
<div class="paragraph">
<p>Maraqlıdır ki, Git-in ələ keçirdiyi başqa bir hadisə də var.
Birləşdirmə əməliyyatı tarixində <strong>hər ikisini</strong> ehtiva edən submodule qovluğunda varsa, Git bunu sizə mümkün bir həll yolu kimi təklif edəcəkdir.
Submodule layihəsinin bir nöqtəsində kimsə bu iki əmrdən ibarət branch-ları birləşdirdiyini görür, bəlkə buna görə bunlardan  birini istəyərsən.</p>
</div>
<div class="paragraph">
<p>Buna görə əvvəllər edilən xəta mesajı “merge following commits not found” idi, çünki <strong>bunu</strong> edə bilmədi.
Çaşdırıcıdır, çünki bunu etmək üçün kimin <strong>cəhd etməsini</strong> gözləyəcək ki?</p>
</div>
<div class="paragraph">
<p>Bir məqbul birləşmə commiti taparsa, bu kimi bir şey görəcəksiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge origin/master
warning: Failed to merge submodule DbConnector (not fast-forward)
Found a possible merge resolution for the submodule:
 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a: &gt; merged our changes
If this is correct simply add it to the index for example
by using:

  git update-index --cacheinfo 160000 9fd905e5d7f45a0d4cbc43d1ee550f16a30e825a "DbConnector"

which will accept this suggestion.
Auto-merging DbConnector
CONFLICT (submodule): Merge conflict in DbConnector
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git-in təklif etdiyi əmr indeksin yenilənməsini təmin edir, sanki  <code>git add</code> (münaqişəni təmizləyən) kimi işlədin, sonra commit edin.
Yəqin ki, bunu etməməlisiniz.
Asanlıqla submodul qovluğuna girib fərqin nə olduğunu görə bilərsiniz, bu tapşırığa sürətlə irəliləyin, düzgün sınaqdan keçirin və sonra commit edin.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cd DbConnector/
$ git merge 9fd905e
Updating eb41d76..9fd905e
Fast-forward

$ cd ..
$ git add DbConnector
$ git commit -am 'Fast forward to a common submodule child'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu eyni şeyi yerinə yetirir, amma heç olmasa bu şəkildə bunun işlədiyini və tamamlandığınızda submodul qovluğunda kodunuz olduğunu yoxlaya bilərsiniz.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_submodul_göstərişləri">Submodul Göstərişləri</h3>
<div class="paragraph">
<p>Submodullarla işləməyi bir az asanlaşdırmaq üçün edə biləcəyiniz bir neçə iş var.</p>
</div>
<div class="sect4">
<h4 id="_submodule_foreach">Submodule Foreach</h4>
<div class="paragraph">
<p>Hər submodulda bəzi ixtiyari əmrləri işlətmək üçün <code>foreach</code> submodul əmr var.
Eyni layihədə bir neçə submodul varsa, bu həqiqətən faydalı ola bilər.</p>
</div>
<div class="paragraph">
<p>Məsələn, deyək ki, yeni bir xüsusiyyətə başlamaq və ya səhv düzəltmək istəyirik və bir neçə submodulda işimiz var.
Bütün işləri bütün submodullarımızda asanlıqla yığa bilərik.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git submodule foreach 'git stash'
Entering 'CryptoLibrary'
No local changes to save
Entering 'DbConnector'
Saved working directory and index state WIP on stable: 82d2ad3 Merge from origin/stable
HEAD is now at 82d2ad3 Merge from origin/stable</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sonra yeni bir branch yarada və bütün alt modullarımızda ona keçə bilərik.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git submodule foreach 'git checkout -b featureA'
Entering 'CryptoLibrary'
Switched to a new branch 'featureA'
Entering 'DbConnector'
Switched to a new branch 'featureA'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Fikir aldın.
Həqiqətən edə biləcəyiniz bir şey, əsas layihənizdə və bütün alt layihələrinizdə dəyişdirilənlərdən gözəl birləşmiş fərq yaratmaqdır.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff; git submodule foreach 'git diff'
Submodule DbConnector contains modified content
diff --git a/src/main.c b/src/main.c
index 210f1ae..1f0acdc 100644
--- a/src/main.c
+++ b/src/main.c
@@ -245,6 +245,8 @@ static int handle_alias(int *argcp, const char ***argv)

      commit_pager_choice();

+     url = url_decode(url_orig);
+
      /* build alias_argv */
      alias_argv = xmalloc(sizeof(*alias_argv) * (argc + 1));
      alias_argv[0] = alias_string + 1;
Entering 'DbConnector'
diff --git a/src/db.c b/src/db.c
index 1aaefb6..5297645 100644
--- a/src/db.c
+++ b/src/db.c
@@ -93,6 +93,11 @@ char *url_decode_mem(const char *url, int len)
        return url_decode_internal(&amp;url, len, NULL, &amp;out, 0);
 }

+char *url_decode(const char *url)
+{
+       return url_decode_mem(url, strlen(url));
+}
+
 char *url_decode_parameter_name(const char **query)
 {
        struct strbuf out = STRBUF_INIT;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Burada submodulda bir funksiya təyin etdiyimizi və əsas layihədə adlandırdığımızı görə bilərik.
Bu açıqca sadələşdirilmiş bir nümunədir, amma ümid edirik bunun necə faydalı ola biləcəyi barədə sizə bir fikir verəcək.</p>
</div>
</div>
<div class="sect4">
<h4 id="_faydalı_alias_lar">Faydalı Alias-lar</h4>
<div class="paragraph">
<p>Bu əmrlərdən bəziləri üçün bəzi alias-lar qurmaq istəyə bilərsiniz, çünki onlar kifayət qədər uzun ola bilər və əksəriyyətini defolt halına gətirmək üçün konfiqurasiya seçimlərini təyin edə bilməzsiniz.
Git ləqəblərinin qurulmasını <a href="{{< relurl "book/az/v2/ch00/_git_aliases" >}}">Git Alias’lar</a> -də qbaa bilərsiniz, ancaq Git-də submodullarla çox işləməyi planlaşdırırsınızsa, qurmaq istədiyiniz bir nümunəni burada tapa bilərsiniz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config alias.sdiff '!'"git diff &amp;&amp; git submodule foreach 'git diff'"
$ git config alias.spush 'push --recurse-submodules=on-demand'
$ git config alias.supdate 'submodule update --remote --merge'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu yolla submodullarıınızı yeniləmək istədikdə <code>git supdate</code> və ya submodula asılılığını yoxlamaqla basmaq üçün <code>git spush</code> işlədə bilərsiniz.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_submodullarla_bağlı_məsələlər">Submodullarla Bağlı Məsələlər</h3>
<div class="paragraph">
<p>Submodullardan istifadə hiccups olmadan da mümkün deyil.</p>
</div>
<div class="sect4">
<h4 id="_branch_ları_dəyişdirmək">Branch-ları Dəyişdirmək</h4>
<div class="paragraph">
<p>Məsələn, branch-larında submodulları olan branch-ları dəyişdirmək Git 2.13-dən daha köhnə Git versiyaları ilə də çətin ola bilər.
Yeni bir branch yaradırsınızsa, orada bir submodul əlavə edin və sonra bu submodul olmadan yenidən bir branch-a keçin, submodul qovluğu hələ də yığılmamış bir qovluq olaraq qalır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git --version
git version 2.12.2

$ git checkout -b add-crypto
Switched to a new branch 'add-crypto'

$ git submodule add https://github.com/chaconinc/CryptoLibrary
Cloning into 'CryptoLibrary'...
...

$ git commit -am 'Add crypto library'
[add-crypto 4445836] Add crypto library
 2 files changed, 4 insertions(+)
 create mode 160000 CryptoLibrary

$ git checkout master
warning: unable to rmdir CryptoLibrary: Directory not empty
Switched to branch 'master'
Your branch is up-to-date with 'origin/master'.

$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)

	CryptoLibrary/

nothing added to commit but untracked files present (use "git add" to track)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Qovluqda silmək çətin deyil, amma orada olması bir az çaşdırıcı ola bilər.
Əgər onu çıxarıb sonra yenidən həmin submodulu olan branch-a qayıtsanız, onu təkrarlamaq üçün <code>submodule update --init</code>  işlətməlisiniz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clean -ffdx
Removing CryptoLibrary/

$ git checkout add-crypto
Switched to branch 'add-crypto'

$ ls CryptoLibrary/

$ git submodule update --init
Submodule path 'CryptoLibrary': checked out 'b8dda6aa182ea4464f3f3264b11e0268545172af'

$ ls CryptoLibrary/
Makefile	includes	scripts		src</code></pre>
</div>
</div>
<div class="paragraph">
<p>Yenə də həqiqətən çox çətin deyil, ancaq bir az qarışıq ola bilər.</p>
</div>
<div class="paragraph">
<p>Yeni Git versiyaları (Git &gt;= 2.13), keçid etdiyimiz branch üçün submodulları düzgün vəziyyətdə yerləşdirməyin qayğısına qalan <code>git checkout</code> əmrinə <code>--recurse-submodules</code> flagı əlavə etməklə bütün bunları asanlaşdırır.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git --version
git version 2.13.3

$ git checkout -b add-crypto
Switched to a new branch 'add-crypto'

$ git submodule add https://github.com/chaconinc/CryptoLibrary
Cloning into 'CryptoLibrary'...
...

$ git commit -am 'Add crypto library'
[add-crypto 4445836] Add crypto library
 2 files changed, 4 insertions(+)
 create mode 160000 CryptoLibrary

$ git checkout --recurse-submodules master
Switched to branch 'master'
Your branch is up-to-date with 'origin/master'.

$ git status
On branch master
Your branch is up-to-date with 'origin/master'.

nothing to commit, working tree clean</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>git checkout</code>-nın  <code>--recurse-submodules</code> flag-dan istifadə, super layihədə bir neçə branch-da işləyərkən faydalı ola bilər.
Həqiqətən, submodulunu fərqli commit-lərdə qeyd edən branch-lar arasında keçsəniz, <code>git status</code> yerinə yetirildikdə, alt modul ‘modified’' olaraq görünəcək və “new commits” göstəriləcədir.
Bu, submodule vəziyyətinin branch-ları dəyişdirərkən bir qayda olaraq aparılmamasıdır.</p>
</div>
<div class="paragraph">
<p>Bu, həqiqətən çaşdırıcı ola bilər, buna görə də layihənizdə submodullar olduqda həmişə <code>git checkout --recurse-submodules</code> etmək yaxşı bir fikirdir.
<code>--recurse-submodules</code> flag-ı olmayan köhnə Git versiyaları üçün, yoxlanışdan sonra submodulları düzgün vəziyyətə gətirmək üçün <code>git submodule update --init --recursive</code> istifadə edə bilərsiniz.</p>
</div>
<div class="paragraph">
<p>Xoşbəxtlikdən, Git (&gt;= 2.14) konfiqurasiya seçimini <code>submodule.recurse</code> qoyaraq həmişə <code>--recurse-submodules</code> flag-ından istifadə etməyi söyləyə bilərsiniz: <code>git config submodule.recurse true</code>.
Yuxarıda qeyd edildiyi kimi, bu da Git-in  <code>--recurse-submodules</code> seçimi olan hər bir əmr üçün submodullara təkrarlanmasını təmin edəcəkdir (<code>git clone</code> xaricində).</p>
</div>
</div>
<div class="sect4">
<h4 id="_subdirectory_lərdən_submodul_lara_keçid">Subdirectory-lərdən submodul-lara keçid</h4>
<div class="paragraph">
<p>Bir çox insanın işlətdiyi digər əsas xəbərdarlıq subdirectory-dən submodullara keçməkdir.
Layihənizdəki faylları izləmisinizsə və onları submodula köçürmək istəyirsinizsə, diqqətli olmalısınız və ya Git sizə qəzəblənəcəkdir.
Layihənizin alt alt bölməsində fayllarınız olduğunu düşünün və onu bir subdirectory-ə keçirmək istəyirsiniz.
Əgər subdirectory-ni silib sonra <code>submodule add</code> işlədirsinizsə, Git sizə qışqırır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ rm -Rf CryptoLibrary/
$ git submodule add https://github.com/chaconinc/CryptoLibrary
'CryptoLibrary' already exists in the index</code></pre>
</div>
</div>
<div class="paragraph">
<p>Əvvəlcə <code>CryptoLibrary</code> qovluğunu çıxartmalısınız.
Sonra submodulu əlavə edə bilərsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rm -r CryptoLibrary
$ git submodule add https://github.com/chaconinc/CryptoLibrary
Cloning into 'CryptoLibrary'...
remote: Counting objects: 11, done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 11 (delta 0), reused 11 (delta 0)
Unpacking objects: 100% (11/11), done.
Checking connectivity... done.</code></pre>
</div>
</div>
<div class="paragraph">
<p>İndi bir branch-da etdiyinizi düşünün.
Bu sənədlərin submodula deyil, həqiqi ağacda olduğu bir branch-a geri dönməyə çalışarsanız, bu səhvinizi alırsınız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
error: The following untracked working tree files would be overwritten by checkout:
  CryptoLibrary/Makefile
  CryptoLibrary/includes/crypto.h
  ...
Please move or remove them before you can switch branches.
Aborting</code></pre>
</div>
</div>
<div class="paragraph">
<p>Onu <code>checkout -f</code> ilə dəyişdirməyə məcbur edə bilərsiniz, ancaq bu əmrlə yenidən yazıla biləcəyiniz üçün orada saxlanmamış dəyişikliklərin olmadığından ehtiyatlı olun.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -f master
warning: unable to rmdir CryptoLibrary: Directory not empty
Switched to branch 'master'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sonra geri dönəndə nədənsə boş bir <code>CryptoLibrary</code> qovluğu alırsınız və <code>git submodule update</code> onu da düzəldə bilməz.
Bütün sənədlərinizi geri qaytarmaq üçün submodul qovluğuna daxil olmalı və <code>git checkout .</code> başlatmalısınız.
Bunu bir neçə submodul üçün işlətmək üçün <code>submodule foreach</code> skriptində işlədə bilərsiniz.</p>
</div>
<div class="paragraph">
<p>Qeyd etmək vacibdir ki, submodullar bu gün bütün Git məlumatlarını ən yaxşı layihənin <code>.git</code> qovluğunda saxlayırlar, buna görə Git-in çox köhnə versiyasından fərqli olaraq, submodule qovluğunu məhv etmək heç bir commiti və ya branch-nı itirməyəcəkdir.</p>
</div>
<div class="paragraph">
<p>Bu vasitələrlə submodullar eyni vaxtda bir neçə əlaqəli, lakin ayrıca layihələr üzərində inkişaf etdirmək üçün olduqca sadə və təsirli bir metod ola bilər.</p>
</div>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>