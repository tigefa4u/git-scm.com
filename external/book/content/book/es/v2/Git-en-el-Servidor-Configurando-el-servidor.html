---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: es
  chapter:
    title: Git en el Servidor
    number: 4
  section:
    title: Configurando el servidor
    number: 4
    cs_number: '4.4'
    previous: book/es/v2/Git-en-el-Servidor-Generando-tu-clave-pública-SSH
    next: book/es/v2/Git-en-el-Servidor-El-demonio-Git
title: Git - Configurando el servidor
---
<h2 id="r_setting_up_server">Configurando el servidor</h2>
<div class="paragraph">
<p>Vamos a avanzar en los ajustes de los accesos SSH en el lado del servidor.
En este ejemplo, usarás el método de las <code>authorized_keys</code> (claves
autorizadas) para autentificara tus usuarios. Se asume que tienes un servidor en marcha, con una distribución estándar de Linux, tal como Ubuntu. Comienzas creando un usuario <em>git</em> y una
carpeta <code>.ssh</code> para él.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ sudo adduser git
$ su git
$ cd
$ mkdir .ssh &amp;&amp; chmod 700 .ssh
$ touch .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keys</code></pre>
</div>
</div>
<div class="paragraph">
<p>Y a continuación añades las claves públicas de los desarrolladores
al archivo <code>authorized_keys</code> del usuario <code>git</code> que has creado. Suponiendo que
hayas recibido las claves por correo electrónico y que las has guardado en
archivos temporales. Y recordando que las claves públicas son algo así como:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat /tmp/id_rsa.john.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n/ww+ouN4gSLKssMxXnBOvf9LGt4L
ojG6rs6hPB09j9R/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK+4k
Yjh6541NYsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9Ez
Sdfd8AcCIicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC/nLF6JLtPofwFBlgc+myiv
O7TCUSBdLQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPq
dAv8JggJICUvax2T9va5 gsg-keypair</code></pre>
</div>
</div>
<div class="paragraph">
<p>No tienes más que añadirlas al archivo <code>authorized_keys</code> dentro del
directorio <code>.ssh</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat /tmp/id_rsa.john.pub &gt;&gt; ~/.ssh/authorized_keys
$ cat /tmp/id_rsa.josie.pub &gt;&gt; ~/.ssh/authorized_keys
$ cat /tmp/id_rsa.jessica.pub &gt;&gt; ~/.ssh/authorized_keys</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tras esto, puedes preparar un repositorio básico vacío para ellos,
usando el comando <code>git init</code> con la opción <code>--bare</code> para inicializar
el repositorio sin carpeta de trabajo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cd /opt/git
$ mkdir project.git
$ cd project.git
$ git init --bare
Initialized empty Git repository in /opt/git/project.git/</code></pre>
</div>
</div>
<div class="paragraph">
<p>Y John, Josie o Jessica podrán enviar (push) la primera versión de su
proyecto a dicho repositorio, añadiéndolo como remoto y enviando (push)
una rama (branch). Cabe indicar que alguien tendrá que iniciar sesión
en la máquina y crear un repositorio básico, cada vez que se desee añadir
un nuevo proyecto. Suponiendo, por ejemplo, que se llame <code>gitserver</code> el
servidor donde has puesto el usuario <code>git</code> y los repositorios; que dicho
servidor es interno a vuestra red y que está asignado el nombre
<code>gitserver</code> en vuestro DNS.  Podrás utilizar comandos tales como
(suponiendo que <code>myproject</code> es un proyecto ya creado con algunos archivos):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console"># on Johns computer
$ cd myproject
$ git init
$ git add .
$ git commit -m 'initial commit'
$ git remote add origin git@gitserver:/opt/git/project.git
$ git push origin master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tras lo cual, otros podrán clonarlo y enviar cambios de vuelta:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone git@gitserver:/opt/git/project.git
$ cd project
$ vim README
$ git commit -am 'fix for the README file'
$ git push origin master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Con este método, puedes preparar rápidamente un servidor Git con acceso
de lectura/escritura para un grupo de desarrolladores.</p>
</div>
<div class="paragraph">
<p>Observa que todos esos usuarios pueden también entrar en el servidor
obteniendo un intérprete de comandos con el usuario <code>git</code>. Si quieres
restringirlo, tendrás que cambiar el intérprete (shell) en el archivo
<code>passwd</code>.</p>
</div>
<div class="paragraph">
<p>Para una mayor protección, puedes restringir fácilmente el usuario <code>git</code>
a realizar solamente actividades relacionadas con Git, utilizando un
shell limitado llamado <code>git-shell</code> que viene incluido en Git. Si lo
configuras como el shell de inicio de sesión de tu usuario <code>git</code>,
dicho usuario no tendrá acceso al shell normal del servidor. Para
especificar el <code>git-shell</code> en lugar de bash o de csh como el
shell de inicio de sesión de un usuario, has de editar el
archivo <em>/etc/passwd</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat /etc/shells   # mirar si `git-shell` ya está aquí.  Si no...
$ which git-shell   # buscar `git-shell` en nuestro sistema
$ sudo vim /etc/shells  # y añadirlo al final de este archivo con el camino (path) completo</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ahora ya puedes cambiar la shell del usuario utilizando <code>chsh &lt;username&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ sudo chsh git  # poner aquí la nueva shell, normalmente será: /usr/bin/git-shell</code></pre>
</div>
</div>
<div class="paragraph">
<p>De esta forma dejamos al usuario <em>git</em> limitado a utilizar la conexión
SSH solamente para enviar (push) y recibir (pull) repositorios, sin posibilidad
de iniciar una sesión normal en el servidor. Si pruebas a hacerlo, recibirás
un rechazo de inicio de sesión:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ssh git@gitserver
fatal: Interactive git shell is not enabled.
hint: ~/git-shell-commands should exist and have read and execute access.
Connection to gitserver closed.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Los comandos remotos de Git funcionarán con normalidad, pero los usuarios
no podrán obtener un intérprete de comandos del sistema. Tal como nos avisa,
también se puede establecer un directorio llamado <code>git-shell-commands</code> en la cuenta
del usuario <code>git</code> para personalizar un poco el git-shell. Por ejemplo, se puede restringir
qué comandos de Git se aceptarán o se puede personalizar el mensaje que
los usuarios verán si intentan abrir un intérprete de comandos con SSH.</p>
</div>
<div class="paragraph">
<p>Ejecutando <code>git help shell</code> veremos más información sobre cómo personalizar
el shell.</p>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>