---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: es
  chapter:
    title: Fundamentos de Git
    number: 2
  section:
    title: Guardando cambios en el Repositorio
    number: 2
    cs_number: '2.2'
    previous: book/es/v2/Fundamentos-de-Git-Obteniendo-un-repositorio-Git
    next: book/es/v2/Fundamentos-de-Git-Ver-el-Historial-de-Confirmaciones
title: Git - Guardando cambios en el Repositorio
---
<h2 id="_guardando_cambios_en_el_repositorio">Guardando cambios en el Repositorio</h2>
<div class="paragraph">
<p>Ya tienes un repositorio Git y un <em>checkout</em> o copia de trabajo de los archivos de dicho proyecto.
El siguiente paso es realizar algunos cambios y confirmar instantáneas de esos cambios en el repositorio cada vez que el proyecto alcance un estado que quieras conservar.</p>
</div>
<div class="paragraph">
<p>Recuerda que cada archivo de tu repositorio puede tener dos estados: rastreados y sin rastrear.
Los archivos rastreados (<em>tracked files</em> en inglés) son todos aquellos archivos que estaban en la última instantánea del proyecto; pueden ser archivos sin modificar, modificados o preparados.
Los archivos sin rastrear son todos los demás - cualquier otro archivo en tu directorio de trabajo que no estaba en tu última instantánea y que no está en el área de preparación (<em>staging area</em>).
Cuando clonas por primera vez un repositorio, todos tus archivos estarán rastreados y sin modificar pues acabas de sacarlos y aun no han sido editados.</p>
</div>
<div class="paragraph">
<p>Mientras editas archivos, Git los ve como modificados, pues han sido cambiados desde su último <em>commit</em>.
Luego preparas estos archivos modificados y finalmente confirmas todos los cambios preparados, y repites el ciclo.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/es/v2/images/lifecycle.png" >}}" alt="El ciclo de vida del estado de tus archivos.">
</div>
<div class="title">Figura 8. El ciclo de vida del estado de tus archivos.</div>
</div>
<div class="sect3">
<h3 id="r_checking_status">Revisando el Estado de tus Archivos</h3>
<div class="paragraph">
<p>La herramienta principal para determinar qué archivos están en qué estado es el comando <code>git status</code>.
Si ejecutas este comando inmediatamente después de clonar un repositorio, deberías ver algo como esto:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
On branch master
nothing to commit, working directory clean</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto significa que tienes un directorio de trabajo limpio - en otras palabras, que no hay archivos rastreados y modificados.
Además, Git no encuentra archivos sin rastrear, de lo contrario aparecerían listados aquí.
Finalmente, el comando te indica en cuál rama estás y te informa que no ha variado con respecto a la misma rama en el servidor.
Por ahora, la rama siempre será “master”, que es la rama por defecto; no le prestaremos atención de momento.
<a href="{{< relurl "book/es/v2/ch00/ch03-git-branching" >}}">[ch03-git-branching]</a> tratará en detalle las ramas y las referencias.</p>
</div>
<div class="paragraph">
<p>Supongamos que añades un nuevo archivo a tu proyecto, un simple README.
Si el archivo no existía antes y ejecutas <code>git status</code>, verás el archivo sin rastrear de la siguiente manera:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 'My Project' &gt; README
$ git status
On branch master
Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)

    README

nothing added to commit but untracked files present (use "git add" to track)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Puedes ver que el archivo README está sin rastrear porque aparece debajo del encabezado “Untracked files” (“Archivos no rastreados” en inglés) en la salida.
Sin rastrear significa que Git ve archivos que no tenías en el <em>commit</em> anterior. Git no los incluirá en tu próximo <em>commit</em> a menos que se lo indiques explícitamente.
Se comporta así para evitar incluir accidentalmente archivos binarios o cualquier otro archivo que no quieras incluir.
Como tú sí quieres incluir README, debes comenzar a rastrearlo.</p>
</div>
</div>
<div class="sect3">
<h3 id="r_tracking_files">Rastrear Archivos Nuevos</h3>
<div class="paragraph">
<p>Para comenzar a rastrear un archivo debes usar el comando <code>git add</code>.
Para comenzar a rastrear el archivo README, puedes ejecutar lo siguiente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add README</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ahora si vuelves a ver el estado del proyecto, verás que el archivo README está siendo rastreado y está preparado para ser confirmado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    new file:   README</code></pre>
</div>
</div>
<div class="paragraph">
<p>Puedes ver que está siendo rastreado porque aparece luego del encabezado “Cambios a ser confirmados” (“Changes to be committed” en inglés).
Si confirmas en este punto, se guardará en el historial la versión del archivo correspondiente al instante en que ejecutaste <code>git add</code>.
Anteriormente cuando ejecutaste <code>git init</code>, ejecutaste luego <code>git add (files)</code> - lo cual inició el rastreo de archivos en tu directorio.
El comando <code>git add</code> puede recibir tanto una ruta de archivo como de un directorio; si es de un directorio, el comando añade recursivamente los archivos que están dentro de él.</p>
</div>
</div>
<div class="sect3">
<h3 id="_preparar_archivos_modificados">Preparar Archivos Modificados</h3>
<div class="paragraph">
<p>Vamos a cambiar un archivo que esté rastreado.
Si cambias el archivo rastreado llamado “CONTRIBUTING.md” y luego ejecutas el comando <code>git status</code>, verás algo parecido a esto:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    new file:   README

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>El archivo “CONTRIBUTING.md” aparece en una sección llamada “Changes not staged for commit” (“Cambios no preparado para confirmar” en inglés) - lo que significa que existe un archivo rastreado que ha sido modificado en el directorio de trabajo pero que aún no está preparado.
Para prepararlo, ejecutas el comando <code>git add</code>. <code>git add</code> es un comando que cumple varios propósitos - lo usas para empezar a rastrear archivos nuevos, preparar archivos, y hacer otras cosas como marcar archivos en conflicto por combinación como resueltos. Es más útil que lo veas como un comando para “añadir este contenido a la próxima confirmación” más que para “añadir este archivo al proyecto”.
Ejecutemos <code>git add</code> para preparar el archivo “CONTRIBUTING.md” y luego ejecutemos <code>git status</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ambos archivos están preparados y formarán parte de tu próxima confirmación.
En este momento, supongamos que recuerdas que debes hacer un pequeño cambio en <code>CONTRIBUTING.md</code> antes de confirmarlo.
Abres de nuevo el archivo, lo cambias y ahora estás listos para confirmar.
Sin embargo, ejecutemos <code>git status</code> una vez más:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ vim CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>¡¿Pero qué…​?!
Ahora <code>CONTRIBUTING.md</code> aparece como preparado y como no preparado.
¿Cómo es posible?
Resulta que Git prepara un archivo de acuerdo al estado que tenía cuando ejecutas el comando <code>git add</code>.
Si confirmas ahora, se confirmará la versión de <code>CONTRIBUTING.md</code> que tenías la última vez que ejecutaste <code>git add</code> y no la versión que ves ahora en tu directorio de trabajo al ejecutar <code>git status</code>.
Si modificas un archivo luego de ejecutar <code>git add</code>, deberás ejecutar <code>git add</code> de nuevo para preparar la última versión del archivo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_estado_abreviado">Estado Abreviado</h3>
<div class="paragraph">
<p>Si bien es cierto que la salida de <code>git status</code> es bastante explícita, también es verdad que es muy extensa. Git ofrece una opción para obtener un estado abreviado, de manera que puedas ver tus cambios de una forma más compacta. Si ejecutas <code>git status -s</code> o <code>git status --short</code>, obtendrás una salida mucho más simplificada.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>Los archivos nuevos que no están rastreados tienen un <code>??</code> a su lado, los archivos que están preparados tienen una <code>A</code> y los modificados una <code>M</code>. El estado aparece en dos columnas - la columna de la izquierda indica el estado preparado y la columna de la derecha indica el estado sin preparar. Por ejemplo, en esa salida, el archivo <code>README</code> está modificado en el directorio de trabajo pero no está preparado, mientras que <code>lib/simplegit.rb</code> está modificado y preparado. El archivo <code>Rakefile</code> fue modificado, preparado y modificado otra vez por lo que existen cambios preparados y sin preparar.</p>
</div>
</div>
<div class="sect3">
<h3 id="r_ignoring">Ignorar Archivos</h3>
<div class="paragraph">
<p>A veces, tendrás algún tipo de archivo que no quieres que Git añada automáticamente o más aun, que ni siquiera quieras que aparezca como no rastreado.
Este suele ser el caso de archivos generados automáticamente como trazas o archivos creados por tu sistema de compilación. En estos casos, puedes crear un archivo llamado <code>.gitignore</code> que liste patrones a considerar.
Este es un ejemplo de un archivo <code>.gitignore</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .gitignore
*.[oa]
*~</code></pre>
</div>
</div>
<div class="paragraph">
<p>La primera línea le indica a Git que ignore cualquier archivo que termine en “.o” o “.a” - archivos de objeto o librerías que pueden ser producto de compilar tu código.
La segunda línea le indica a Git que ignore todos los archivos que terminen con una tilde (<code>~</code>), la cual es usada por varios editores de texto como Emacs para marcar archivos temporales.
También puedes incluir cosas como trazas, temporales, o pid directamente; documentación generada automáticamente; etc.
Crear un archivo <code>.gitignore</code> antes de comenzar a trabajar es generalmente una buena idea, pues así evitas confirmar accidentalmente archivos que en realidad no quieres incluir en tu repositorio Git.</p>
</div>
<div class="paragraph">
<p>Las reglas sobre los patrones que puedes incluir en el archivo <code>.gitignore</code> son las siguientes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ignorar las líneas en blanco y aquellas que comiencen con <code>#</code>.</p>
</li>
<li>
<p>Emplear patrones glob estándar que se aplicarán recursivamente a todo el directorio del repositorio local.</p>
</li>
<li>
<p>Los patrones pueden comenzar en barra (<code>/</code>) para evitar recursividad.</p>
</li>
<li>
<p>Los patrones pueden terminar en barra (<code>/</code>) para especificar un directorio.</p>
</li>
<li>
<p>Los patrones pueden negarse si se añade al principio el signo de exclamación (<code>!</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Los patrones glob son una especie de expresión regular simplificada usada por los terminales.
Un asterisco (<code>*</code>) corresponde a cero o más caracteres; <code>[abc]</code> corresponde a cualquier caracter dentro de los corchetes (en este caso a, b o c); el signo de interrogación (<code>?</code>) corresponde a un caracter cualquiera; y los corchetes sobre caracteres separados por un guión (<code>[0-9]</code>) corresponde a cualquier caracter entre ellos (en este caso del 0 al 9).
También puedes usar dos asteriscos para indicar directorios anidados; <code>a/**/z</code> coincide con <code>a/z</code>, <code>a/b/z</code>, <code>a/b/c/z</code>, etc.</p>
</div>
<div class="paragraph">
<p>Aquí puedes ver otro ejemplo de un archivo <code>.gitignore</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code># ignora los archivos terminados en .a
*.a

# pero no lib.a, aun cuando había ignorado los archivos terminados en .a en la línea anterior
!lib.a

# ignora unicamente el archivo TODO de la raiz, no subdir/TODO
/TODO

# ignora todos los archivos del directorio build/
build/

# ignora doc/notes.txt, pero no este: doc/server/arch.txt
doc/*.txt

# ignora todos los archivos .txt del directorio doc/
doc/**/*.txt</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Sugerencia</div>
</td>
<td class="content">
<div class="paragraph">
<p>GitHub mantiene una extensa lista de archivos <code>.gitignore</code> adecuados a docenas de proyectos y lenguajes en <a href="https://github.com/github/gitignore" class="bare">https://github.com/github/gitignore</a>, en caso de que quieras tener un punto de partida para tu proyecto.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h3 id="r_git_diff_staged">Ver los Cambios Preparados y No Preparados</h3>
<div class="paragraph">
<p>Si el comando <code>git status</code> es muy impreciso para ti - quieres ver exactamente que ha cambiado, no solo cuáles archivos lo han hecho - puedes usar el comando <code>git diff</code>.
Hablaremos sobre <code>git diff</code> más adelante, pero lo usarás probablemente para responder estas dos preguntas: ¿Qué has cambiado pero aun no has preparado? y ¿Qué has preparado y está listo para confirmar?
A pesar de que <code>git status</code> responde a estas preguntas de forma muy general listando el nombre de los archivos, <code>git diff</code> te muestra las líneas exactas que fueron añadidas y eliminadas, es decir, el parche.</p>
</div>
<div class="paragraph">
<p>Supongamos que editas y preparas el archivo <code>README</code> de nuevo y luego editas <code>CONTRIBUTING.md</code> pero no lo preparas.
Si ejecutas el comando <code>git status</code>, verás algo como esto:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    new file:   README

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para ver qué has cambiado pero aun no has preparado, escribe <code>git diff</code> sin más parámetros:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if you patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este comando compara lo que tienes en tu directorio de trabajo con lo que está en el área de preparación.
El resultado te indica los cambios que has hecho pero que aun no has preparado.</p>
</div>
<div class="paragraph">
<p>Si quieres ver lo que has preparado y será incluido en la próxima confirmación, puedes usar <code>git diff --staged</code>.
Este comando compara tus cambios preparados con la última instantánea confirmada.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+My Project</code></pre>
</div>
</div>
<div class="paragraph">
<p>Es importante resaltar que al llamar a <code>git diff</code> sin parámetros no verás los cambios desde tu última confirmación - solo verás los cambios que aun no están preparados.
Esto puede ser confuso porque si preparas todos tus cambios, <code>git diff</code> no te devolverá ninguna salida.</p>
</div>
<div class="paragraph">
<p>Pasemos a otro ejemplo, si preparas el archivo <code>CONTRIBUTING.md</code> y luego lo editas, puedes usar <code>git diff</code> para ver los cambios en el archivo que ya están preparados y los cambios que no lo están. Si nuestro ambiente es como este:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add CONTRIBUTING.md
$ echo 'test line' &gt;&gt; CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>Puedes usar <code>git diff</code> para ver qué está sin preparar</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 643e24f..87f08c8 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -119,3 +119,4 @@ at the
 ## Starter Projects

 See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).
+# test line</code></pre>
</div>
</div>
<div class="paragraph">
<p>y <code>git diff --cached</code> para ver que has preparado hasta ahora (--staged y --cached son sinónimos):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --cached
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if you patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Nota</div>
</td>
<td class="content">
<div class="title">Git Diff como Herramienta Externa</div>
<div class="paragraph">
<p>A lo largo del libro, continuaremos usando el comando <code>git diff</code> de distintas maneras. Existe otra forma de ver estas diferencias si prefieres utilizar una interfaz gráfica u otro programa externo. Si ejecutas <code>git difftool</code> en vez de <code>git diff</code>, podrás ver los cambios con programas de este tipo como Araxis, emerge, vimdiff y más. Ejecuta <code>git difftool --tool-help</code> para ver qué tienes disponible en tu sistema.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h3 id="r_committing_changes">Confirmar tus Cambios</h3>
<div class="paragraph">
<p>Ahora que tu área de preparación está como quieres, puedes confirmar tus cambios.
Recuerda que cualquier cosa que no esté preparada - cualquier archivo que hayas creado o modificado y que no hayas agregado con <code>git add</code> desde su edición - no será confirmado.
Se mantendrán como archivos modificados en tu disco.
En este caso, digamos que la última vez que ejecutaste <code>git status</code> verificaste que todo estaba preparado y que estás listo para confirmar tus cambios.
La forma más sencilla de confirmar es escribiendo <code>git commit</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Al hacerlo, arrancará el editor de tu preferencia.
(El editor se establece a través de la variable de ambiente <code>$EDITOR</code> de tu terminal - usualmente es vim o emacs, aunque puedes configurarlo con el editor que quieras usando el comando <code>git config --global core.editor</code> tal como viste en <a href="{{< relurl "book/es/v2/ch00/ch01-introduction" >}}">[ch01-introduction]</a>).</p>
</div>
<div class="paragraph">
<p>El editor mostrará el siguiente texto (este ejemplo corresponde a una pantalla de Vim):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code># Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#	new file:   README
#	modified:   CONTRIBUTING.md
#
~
~
~
".git/COMMIT_EDITMSG" 9L, 283C</code></pre>
</div>
</div>
<div class="paragraph">
<p>Puedes ver que el mensaje de confirmación por defecto contiene la última salida del comando <code>git status</code> comentada y una línea vacía encima de ella.
Puedes eliminar estos comentarios y escribir tu mensaje de confirmación, o puedes dejarlos allí para ayudarte a recordar qué estás confirmando.
(Para obtener una forma más explícita de recordar qué has modificado, puedes pasar la opción <code>-v</code> a <code>git commit</code>. Al hacerlo se incluirá en el editor el diff de tus cambios para que veas exactamente qué cambios estás confirmando).
Cuando sales del editor, Git crea tu confirmación con tu mensaje (eliminando el texto comentado y el diff).</p>
</div>
<div class="paragraph">
<p>Otra alternativa es escribir el mensaje de confirmación directamente en el comando <code>commit</code> utilizando la opción -m:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git commit -m "Story 182: Fix benchmarks for speed"
[master 463dc4f] Story 182: Fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README</code></pre>
</div>
</div>
<div class="paragraph">
<p>¡Has creado tu primera confirmación (o <em>commit</em>)!
Puedes ver que la confirmación te devuelve una salida descriptiva: indica cuál rama has confirmado (<code>master</code>), que <em>checksum</em> SHA-1 tiene el <em>commit</em> (<code>463dc4f</code>), cuántos archivos han cambiado y estadísticas sobre las líneas añadidas y eliminadas en el <em>commit</em>.</p>
</div>
<div class="paragraph">
<p>Recuerda que la confirmación guarda una instantánea de tu área de preparación.
Todo lo que no hayas preparado sigue allí modificado; puedes hacer una nueva confirmación para añadirlo a tu historial.
Cada vez que realizas un <em>commit</em>, guardas una instantánea de tu proyecto la cual puedes usar para comparar o volver a ella luego.</p>
</div>
</div>
<div class="sect3">
<h3 id="_saltar_el_área_de_preparación">Saltar el Área de Preparación</h3>
<div class="paragraph">
<p>
A pesar de que puede resultar muy útil para ajustar los <em>commits</em> tal como quieres, el área de preparación es a veces un paso más complejo de lo que necesitas para tu flujo de trabajo.
Si quieres saltarte el área de preparación, Git te ofrece un atajo sencillo.
Añadiendo la opción <code>-a</code> al comando <code>git commit</code> harás que Git prepare automáticamente todos los archivos rastreados antes de confirmarlos, ahorrándote el paso de <code>git add</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
On branch master
Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

no changes added to commit (use "git add" and/or "git commit -a")
$ git commit -a -m 'added new benchmarks'
[master 83e38c7] added new benchmarks
 1 file changed, 5 insertions(+), 0 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Fíjate que en este caso no fue necesario ejecutar <code>git add</code> sobre el archivo <code>CONTRIBUTING.md</code> antes de confirmar.</p>
</div>
</div>
<div class="sect3">
<h3 id="r_removing_files">Eliminar Archivos</h3>
<div class="paragraph">
<p>
Para eliminar archivos de Git, debes eliminarlos de tus archivos rastreados (o mejor dicho, eliminarlos del área de preparación) y luego confirmar.
Para ello existe el comando <code>git rm</code>, que además elimina el archivo de tu directorio de trabajo de manera que no aparezca la próxima vez como un archivo no rastreado.</p>
</div>
<div class="paragraph">
<p>Si simplemente eliminas el archivo de tu directorio de trabajo, aparecerá en la sección “Changes not staged for commit” (esto es, <em>sin preparar</em>) en la salida de <code>git status</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add/rm &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

        deleted:    PROJECTS.md

no changes added to commit (use "git add" and/or "git commit -a")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ahora, si ejecutas <code>git rm</code>, entonces se prepara la eliminación del archivo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rm PROJECTS.md
rm 'PROJECTS.md'
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    deleted:    PROJECTS.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>Con la próxima confirmación, el archivo habrá desaparecido y no volverá a ser rastreado.
Si modificaste el archivo y ya lo habías añadido al índice, tendrás que forzar su eliminación con la opción <code>-f</code>.
Esta propiedad existe por seguridad, para prevenir que elimines accidentalmente datos que aun no han sido guardados como una instantánea y que por lo tanto no podrás recuperar luego con Git.</p>
</div>
<div class="paragraph">
<p>Otra cosa que puedas querer hacer es mantener el archivo en tu directorio de trabajo pero eliminarlo del área de preparación.
En otras palabras, quisieras mantener el archivo en tu disco duro pero sin que Git lo siga rastreando.
Esto puede ser particularmente útil si olvidaste añadir algo en tu archivo <code>.gitignore</code> y lo preparaste accidentalmente, algo como un gran archivo de trazas a un montón de archivos compilados <code>.a</code>.
Para hacerlo, utiliza la opción <code>--cached</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rm --cached README</code></pre>
</div>
</div>
<div class="paragraph">
<p>Al comando <code>git rm</code> puedes pasarle archivos, directorios y patrones glob.
Lo que significa que puedes hacer cosas como</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rm log/\*.log</code></pre>
</div>
</div>
<div class="paragraph">
<p>Fíjate en la barra invertida (<code>\</code>) antes del asterisco <code>*</code>.
Esto es necesario porque Git hace su propia expansión de nombres de archivo, aparte de la expansión hecha por tu terminal.
Este comando elimina todos los archivo que tengan la extensión <code>.log</code> dentro del directorio <code>log/</code>.
O también puedes hacer algo como:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rm \*~</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este comando elimina todos los archivos que acaben con <code>~</code>.</p>
</div>
</div>
<div class="sect3">
<h3 id="r_git_mv">Cambiar el Nombre de los Archivos</h3>
<div class="paragraph">
<p>
Al contrario que muchos sistemas VCS, Git no rastrea explícitamente los cambios de nombre en archivos.
Si renombras un archivo en Git, no se guardará ningún metadato que indique que renombraste el archivo.
Sin embargo, Git es bastante listo como para detectar estos cambios luego que los has hecho - más adelante, veremos cómo se detecta el cambio de nombre.</p>
</div>
<div class="paragraph">
<p>Por esto, resulta confuso que Git tenga un comando <code>mv</code>.
Si quieres renombrar un archivo en Git, puedes ejecutar algo como</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git mv file_from file_to</code></pre>
</div>
</div>
<div class="paragraph">
<p>y funcionará bien.
De hecho, si ejecutas algo como eso y ves el estado, verás que Git lo considera como un renombramiento de archivo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git mv README.md README
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    renamed:    README.md -&gt; README</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sin embargo, eso es equivalente a ejecutar algo como esto:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ mv README.md README
$ git rm README.md
$ git add README</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git se da cuenta que es un renombramiento implícito, así que no importa si renombras el archivo de esa manera o a través del comando <code>mv</code>.
La única diferencia real es que <code>mv</code> es un solo comando en vez de tres - existe por conveniencia.
De hecho, puedes usar la herramienta que quieras para renombrar un archivo y luego realizar el proceso rm/add antes de confirmar.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>