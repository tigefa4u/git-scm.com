---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: es
  chapter:
    title: Herramientas de Git
    number: 7
  section:
    title: Fusión Avanzada
    number: 8
    cs_number: '7.8'
    previous: book/es/v2/Herramientas-de-Git-Reiniciar-Desmitificado
    next: book/es/v2/Herramientas-de-Git-Rerere
title: Git - Fusión Avanzada
url: "/book/es/v2/Herramientas-de-Git-Fusión-Avanzada.html"
---
<h2 id="r_advanced_merging">Fusión Avanzada</h2>
<div class="paragraph">
<p>La fusión en Git suele ser bastante fácil. Dado que Git facilita la fusión de otra rama varias veces, significa que puede tener una rama de larga duración, pero puede mantenerla actualizada sobre la marcha, resolviendo pequeños conflictos a menudo, en lugar de sorprenderse por un conflicto enorme en el final de la serie.</p>
</div>
<div class="paragraph">
<p>Sin embargo, a veces ocurren conflictos engañosos. A diferencia de otros sistemas de control de versiones, Git no intenta ser demasiado listo para fusionar la resolución de conflictos. La filosofía de Git es ser inteligente para determinar cuándo una resolución de fusión no es ambigua, pero si hay un conflicto, no intenta ser inteligente para resolverlo automáticamente. Por lo tanto, si espera demasiado para fusionar dos ramas que divergen rápidamente, puede encontrarse con algunos problemas.</p>
</div>
<div class="paragraph">
<p>En esta sección, veremos cuáles podrían ser algunos de esos problemas y qué herramientas le dará Git para ayudarlo a manejar estas situaciones más engañosas. También cubriremos algunos de los diferentes tipos de fusión no estándar que puede hacer, y también veremos cómo deshacerse de las fusiones que ha realizado.</p>
</div>
<div class="sect3">
<h3 id="_conflictos_de_fusión">Conflictos de Fusión</h3>
<div class="paragraph">
<p>Si bien cubrimos algunos conceptos básicos para resolver conflictos de fusión en <a href="{{< relurl "book/es/v2/ch00/r_basic_merge_conflicts" >}}">Principales Conflictos que Pueden Surgir en las Fusiones</a>, para conflictos más complejos, Git proporciona algunas herramientas para ayudarlo a descubrir qué está sucediendo y cómo lidiar mejor con el conflicto.</p>
</div>
<div class="paragraph">
<p>En primer lugar, si es posible, intente asegurarse de que su directorio de trabajo esté limpio antes de realizar una fusión que pueda tener conflictos. Si tiene un trabajo en progreso, hágale commit a una rama temporal o stash. Esto hace que pueda deshacer <strong>cualquier cosa</strong> que intente aquí. Si tiene cambios no guardados en su directorio de trabajo cuando intenta fusionarlos, algunos de estos consejos pueden ayudarlo a perder ese trabajo.</p>
</div>
<div class="paragraph">
<p>Veamos un ejemplo muy simple. Tenemos un archivo Ruby super simple que imprime <em>hello world</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
  puts 'hello world'
end

hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>En nuestro repositorio, creamos una nueva rama llamada <code>whitespace</code> y procedemos a cambiar todas las terminaciones de línea de Unix a terminaciones de línea de DOS, esencialmente cambiando cada línea del archivo, pero solo con espacios en blanco. Luego cambiamos la línea "hello world" a "hello mundo".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b whitespace
Switched to a new branch 'whitespace'

$ unix2dos hello.rb
unix2dos: converting file hello.rb to DOS format ...
$ git commit -am 'converted hello.rb to DOS'
[whitespace 3270f76] converted hello.rb to DOS
 1 file changed, 7 insertions(+), 7 deletions(-)

$ vim hello.rb
$ git diff -w
diff --git a/hello.rb b/hello.rb
index ac51efd..e85207e 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,7 @@
 #! /usr/bin/env ruby

 def hello
-  puts 'hello world'
+  puts 'hello mundo'^M
 end

 hello()

$ git commit -am 'hello mundo change'
[whitespace 6d338d2] hello mundo change
 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ahora volvemos a nuestra rama <code>master</code> y agregamos cierta documentación para la función.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
Switched to branch 'master'

$ vim hello.rb
$ git diff
diff --git a/hello.rb b/hello.rb
index ac51efd..36c06c8 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello world'
 end

$ git commit -am 'document the function'
[master bec6336] document the function
 1 file changed, 1 insertion(+)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ahora tratamos de fusionarnos en nuestra rama <code>whitespace</code> y tendremos conflictos debido a los cambios en el espacio en blanco.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge whitespace
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="sect4">
<h4 id="r_abort_merge">Abortar una Fusión</h4>
<div class="paragraph">
<p>Ahora tenemos algunas opciones. Primero, cubramos cómo salir de esta situación. Si tal vez no esperabas conflictos y aún no quieres lidiar con la situación, simplemente puedes salir de la fusión con <code>git merge --abort</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status -sb
## master
UU hello.rb

$ git merge --abort

$ git status -sb
## master</code></pre>
</div>
</div>
<div class="paragraph">
<p>La opción <code>git merge --abort</code> intenta volver a su estado antes de ejecutar la fusión. Los únicos casos en los que podría no ser capaz de hacer esto a la perfección serían si hubiera realizado cambios sin stash, no confirmados en su directorio de trabajo cuando lo ejecutó, de lo contrario, debería funcionar bien.</p>
</div>
<div class="paragraph">
<p>Si por alguna razón se encuentra en un estado horrible y solo quiere comenzar de nuevo, también puede ejecutar <code>git reset --hard HEAD</code> o donde quiera volver. Recuerde, una vez más, que esto hará volar su directorio de trabajo, así que asegúrese de no querer ningún cambio allí.</p>
</div>
</div>
<div class="sect4">
<h4 id="_ignorando_el_espacio_en_blanco">Ignorando el Espacio en Blanco</h4>
<div class="paragraph">
<p>En este caso específico, los conflictos están relacionados con el espacio en blanco. Sabemos esto porque el caso es simple, pero también es muy fácil saberlo en casos reales, al analizar el conflicto, porque cada línea se elimina por un lado y se agrega nuevamente por el otro. De manera predeterminada, Git ve que todas estas líneas están siendo modificadas, por lo que no puede fusionar los archivos.</p>
</div>
<div class="paragraph">
<p>Sin embargo, la estrategia de combinación predeterminada puede tomar argumentos, y algunos de ellos son acerca de ignorar adecuadamente los cambios del espacio en blanco. Si ve que tiene muchos problemas con espacios en blanco en una combinación, simplemente puede cancelarla y volverla a hacer, esta vez con <code>-Xignore-all-space</code> o` -Xignore-space-change`. La primera opción ignora los cambios en cualquier <strong>cantidad</strong> de espacios en blanco existentes, la segunda ignora por completo todos los cambios de espacios en blanco.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge -Xignore-all-space whitespace
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dado que en este caso, los cambios reales del archivo no eran conflictivos, una vez que ignoramos los cambios en los espacios en blanco, todo se fusiona perfectamente.</p>
</div>
<div class="paragraph">
<p>Esto es un salvavidas si tiene a alguien en su equipo a quien le gusta ocasionalmente reformatear todo, desde espacios hasta pestañas o viceversa.</p>
</div>
</div>
<div class="sect4">
<h4 id="r_manual_remerge">Re-fusión Manual de Archivos</h4>
<div class="paragraph">
<p>Aunque Git maneja muy bien el preprocesamiento de espacios en blanco, hay otros tipos de cambios que quizás Git no pueda manejar de manera automática, pero que son correcciones de secuencias de comandos. Como ejemplo, imaginemos que Git no pudo manejar el cambio en el espacio en blanco y que teníamos que hacerlo a mano.</p>
</div>
<div class="paragraph">
<p>Lo que realmente tenemos que hacer es ejecutar el archivo que intentamos fusionar a través de un programa <code>dos2unix</code> antes de intentar fusionar el archivo. Entonces, ¿cómo haríamos eso?</p>
</div>
<div class="paragraph">
<p>Primero, entramos en el estado de conflicto de la fusión. Luego queremos obtener copias de mi versión del archivo, su versión (de la rama en la que nos estamos fusionando) y la versión común (desde donde ambos lados se bifurcaron). Entonces, queremos arreglar su lado o nuestro lado y volver a intentar la fusión sólo para este único archivo.</p>
</div>
<div class="paragraph">
<p>Obtener las tres versiones del archivo es bastante fácil. Git almacena todas estas versiones en el índice bajo “etapas”, cada una de las cuales tiene números asociados. La etapa 1 es el ancestro común, la etapa 2 es su versión y la etapa 3 es de la <code>MERGE_HEAD</code>, la versión en la que se está fusionando (“suya”).</p>
</div>
<div class="paragraph">
<p>Puede extraer una copia de cada una de estas versiones del archivo en conflicto con el comando <code>git show</code> y una sintaxis especial.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show :1:hello.rb &gt; hello.common.rb
$ git show :2:hello.rb &gt; hello.ours.rb
$ git show :3:hello.rb &gt; hello.theirs.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si quiere ponerse un poco más intenso, también puede usar el comando de plomería <code>ls-files -u</code> para obtener el verdadero SHA-1s de las manchas de Git para cada uno de los archivos.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git ls-files -u
100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1	hello.rb
100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2	hello.rb
100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3	hello.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>El <code>:1:hello.rb</code> es solo una clave para buscar esa mancha SHA-1.</p>
</div>
<div class="paragraph">
<p>Ahora que tenemos el contexto de estas tres etapas en nuestro directorio de trabajo, manualmente podemos arreglarlos para solucionar los problemas de espacios en blanco y volver a fusionar el archivo con el poco conocido comando <code>git merge-file</code> que hace exactamente eso.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ dos2unix hello.theirs.rb
dos2unix: converting file hello.theirs.rb to Unix format ...

$ git merge-file -p \
    hello.ours.rb hello.common.rb hello.theirs.rb &gt; hello.rb

$ git diff -w
diff --cc hello.rb
index 36c06c8,e85207e..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,8 -1,7 +1,8 @@@
  #! /usr/bin/env ruby

 +# prints out a greeting
  def hello
-   puts 'hello world'
+   puts 'hello mundo'
  end

  hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este punto hemos, agradablemente, fusionado el archivo. De hecho, esto en realidad funciona mejor que la opción de <code>ignore-all-space</code>, porque realmente soluciona los cambios de los espacios en blanco antes de la fusión, en lugar de simplemente ignorarlo. En la fusión `ignore-all-space, en realidad, terminamos con unas pocas líneas con finales de línea DOS, haciendo que las cosas se mezclen.</p>
</div>
<div class="paragraph">
<p>Si quiere tener una idea antes de finalizar este compromiso sobre qué había cambiado en realidad entre un lado y el otro, puede pedirle a <code>git diff</code> que compare qué hay en su directorio de trabajo que está a punto de comprometer como resultado de la fusión a cualquiera de estas etapas. Vamos a través de todas ellas.</p>
</div>
<div class="paragraph">
<p>Para comparar el resultado con lo que tenías en su rama antes de la fusión, en otras palabras, para ver lo que su fusión insertó, puede correr <code>git diff --ours</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --ours
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index 36c06c8..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -2,7 +2,7 @@

 # prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Así, podemos observar fácilmente lo que sucedió en nuestra rama, y si lo que en realidad estamos insertando a este archivo con esta fusión está cambiando solamente esa línea.</p>
</div>
<div class="paragraph">
<p>Si queremos ver cómo el resultado de la fusión difiere de lo que estaba del otro lado, podemos correr <code>git diff --theirs</code>. En este y el siguiente ejemplo, tenemos que usar <code>-w</code> para despojarlo de los espacios en blanco porque lo estamos comparando con lo que está en Git, no con nuestro archivo limpio <code>hello.theirs.rb</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --theirs -w
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index e85207e..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello mundo'
 end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finalmente, puede observar cómo el archivo ha cambiado desde ambos lados con <code>git diff --base</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --base -w
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index ac51efd..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,8 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este punto podemos usar el comando <code>git clean</code> para limpiar los archivos sobrantes que creamos para hacer la fusión manual, pero que ya no necesitamos.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clean -f
Removing hello.common.rb
Removing hello.ours.rb
Removing hello.theirs.rb</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="r_checking_out_conflicts">Revisando Los Conflictos</h4>
<div class="paragraph">
<p>Tal vez en este punto no estemos felices con la resolución por alguna razón, o quizás manualmente editando uno o ambos lados todavía no funciona como es debido y necesitamos más contexto.</p>
</div>
<div class="paragraph">
<p>Cambiemos el ejemplo un poco. En este caso, tenemos dos ramas de larga vida las cuales cada una tiene unos pocos “commit” en ella, aparte de crear un contenido de conflicto legítimo cuando es fusionado.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --graph --oneline --decorate --all
* f1270f7 (HEAD, master) update README
* 9af9d3b add a README
* 694971d update phrase to hola world
| * e3eb223 (mundo) add more tests
| * 7cff591 add testing script
| * c3ffff1 changed text to hello mundo
|/
* b7dcc89 initial hello world code</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ahora tenemos tres “commit” únicos que viven solo en la rama <code>principal</code> y otros tres que viven en la rama <code>mundo</code>. Si intentamos fusionar la rama <code>mundo</code>, generaremos un conflicto.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nos gustaría ver cuál es el conflicto de fusión. Si abrimos el archivo, veremos algo así:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
  puts 'hola world'
=======
  puts 'hello mundo'
&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo
end

hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ambos lados de la fusión han añadido contenido a este archivo, pero algunos de los “commit” han modificado el archivo en el mismo lugar que causó el conflicto.</p>
</div>
<div class="paragraph">
<p>Exploremos un par de herramientas que ahora tiene a su disposición para determinar cómo el conflicto resultó ser. Tal vez, no es tan obvio cómo exactamente debería solucionar este problema. Necesita más contexto.</p>
</div>
<div class="paragraph">
<p>Una herramienta útil es <code>git checkout</code> con la opción  “--conflict”. Esto revisará el archivo de nuevo y reemplazará los marcadores de conflicto de la fusión. Esto puede ser útil si quiere reiniciar los marcadores y tratar de resolverlos de nuevo.</p>
</div>
<div class="paragraph">
<p>Puedes pasar <code>--conflict</code> en lugar de <code>diff3</code> o <code>merge</code> (lo que es por defecto). Si pasa <code>diff3</code>, Git usará una versión un poco diferente de marcadores de conflicto, no solo dándole “ours” versión y la versión de “theirs”, sino también la versión “base” en línea para darle más contexto.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout --conflict=diff3 hello.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Una vez que corremos eso, en su lugar el archivo se verá así:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; ours
  puts 'hola world'
||||||| base
  puts 'hello world'
=======
  puts 'hello mundo'
&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs
end

hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si este formato es de su agrado, puede configurarlo como “default” para futuros conflictos de fusión al colocar el <code>merge.conflictstyle</code> configurándolo a <code>diff3</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global merge.conflictstyle diff3</code></pre>
</div>
</div>
<div class="paragraph">
<p>El comando <code>git checkout</code> puede también  tomar la opción de <code>--theirs`o la `--ours</code>, lo cual puede ser una manera mucho más rápida de escoger un lado o el otro sin tener que fusionar las cosas en lo absoluto.</p>
</div>
<div class="paragraph">
<p>Esto puede ser particularmente útil para conflictos de archivos binarios donde simplemente puede escoger un lado, o donde solo quiere fusionar ciertos archivos desde otra rama – puede hacer la fusión y luego revisar ciertos archivos de un lado o del otro antes de comprometerlos</p>
</div>
</div>
<div class="sect4">
<h4 id="r_merge_log">Registro de Fusión</h4>
<div class="paragraph">
<p>Otra herramienta útil al resolver conflictos de fusión es <code>git log</code>. Esto puede ayudarle a tener contexto de lo que pudo haber contribuido a los conflictos. Revisar un poco el historial para recordar por qué dos líneas de desarrollo estaban tocando el mismo código de área, puede ser muy útil algunas veces.</p>
</div>
<div class="paragraph">
<p>Para obtener una lista completa de “commit” únicos que fueron incluidos en cualquiera de las ramas involucradas en esta fusión, podemos usar la sintaxis “triple dot” (triple punto) que aprendimos en <a href="{{< relurl "book/es/v2/ch00/r_triple_dot" >}}">Tres puntos</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --left-right HEAD...MERGE_HEAD
&lt; f1270f7 update README
&lt; 9af9d3b add a README
&lt; 694971d update phrase to hola world
&gt; e3eb223 add more tests
&gt; 7cff591 add testing script
&gt; c3ffff1 changed text to hello mundo</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esa es una buena lista de los seis compromisos involucrados, así como en qué línea de desarrollo estuvo cada compromiso.</p>
</div>
<div class="paragraph">
<p>Sin embargo, podemos simplificar aún más esto para darnos un contexto mucho más específico. Si añadimos  la opción <code>--merge</code> a <code>git log</code>, solo mostrará los compromisos en cualquier lado de la fusión que toque un archivo que esté actualmente en conflicto.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --left-right --merge
&lt; 694971d update phrase to hola world
&gt; c3ffff1 changed text to hello mundo</code></pre>
</div>
</div>
<div class="paragraph">
<p>En su lugar, si corremos eso con la opción <code>-p</code> obtendremos sólo los diffs del archivo que terminó en conflicto. Esto puede ser <strong>bastante</strong> útil, al darle rápidamente el contexto que necesita para ayudarle a entender por qué algo crea problemas y cómo resolverlo de una forma más inteligente.</p>
</div>
</div>
<div class="sect4">
<h4 id="_formato_diff_combinado">Formato Diff Combinado</h4>
<div class="paragraph">
<p>Dado que las etapas de Git clasifican los resultados que tienen éxito, cuando corre <code>git diff</code> mientras está en un estado de conflicto de fusión, sólo puede obtener lo que está actualmente en conflicto. Esto puede ser útil para ver lo que todavía debe resolver.</p>
</div>
<div class="paragraph">
<p>Cuando corre directamente <code>git diff</code> después de un conflicto de fusión, le dará la información en un formato de salida diff bastante único.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,11 @@@
  #! /usr/bin/env ruby

  def hello
++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
 +  puts 'hola world'
++=======
+   puts 'hello mundo'
++&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo
  end

  hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>El formato es llamado “Diff combinado” y proporciona dos columnas de datos al lado de cada línea. La primera columna muestra si esa línea es diferente (añadida o removida) entre la rama “ours” y el archivo en su directorio de trabajo, y la segunda columna hace lo mismo entre la rama “theirs” y la copia de su directorio de trabajo.</p>
</div>
<div class="paragraph">
<p>Así que en ese ejemplo se puede observar que las líneas &lt;&lt;&lt;&lt;&lt;&lt;&lt; y &gt;&gt;&gt;&gt;&gt;&gt;&gt; están en la copia de trabajo, pero no en ningún lado de la fusión. Esto tiene sentido porque la herramienta de fusión las mantiene ahí para nuestro contexto, pero se espera que las removamos.</p>
</div>
<div class="paragraph">
<p>Si resolvemos el conflicto y corremos <code>git diff</code> de nuevo, veremos la misma cosa, pero es un poco más útil.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ vim hello.rb
$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto muestra que “hola mundo” estaba de nuestro lado, pero no en la copia de trabajo, que “hello mundo” estaba en el lado de ellos, pero no en la copia de trabajo y finalmente que “hola mundo” no estaba en ningún lado, sin embargo está ahora en la copia de trabajo. Esto puede ser útil para revisar antes de comprometer la resolución.</p>
</div>
<div class="paragraph">
<p>También se puede obtener desde el <code>git log</code> para cualquier fusión después de realizada, para ver cómo algo se resolvió luego de dicha fusión. Git dará salida a este formato si se puede correr <code>git show</code> en un compromiso de fusión, o si se añade la opción <code>--cc</code> a un <code>git log -p</code> (el cual por defecto solo muestras parches para compromisos no fusionados).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --cc -p -1
commit 14f41939956d80b9e17bb8721354c33f8d5b5a79
Merge: f1270f7 e3eb223
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Sep 19 18:14:49 2014 +0200

    Merge branch 'mundo'

    Conflicts:
        hello.rb

diff --cc hello.rb
index 0399cd5,59727f0..e1d0799
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h3 id="r_undoing_merges">Deshaciendo Fusiones</h3>
<div class="paragraph">
<p>Ahora que ya conoce como crear un “merge commit” (compromiso de fusión), probablemente haya creado algunos por error.
Una de las ventajas de trabajar con Git es que está bien cometer errores, porque es posible y, en muchos casos, es fácil solucionarlos.</p>
</div>
<div class="paragraph">
<p>Los compromisos de fusión no son diferentes.
Digamos que comenzó a trabajar en una rama temática accidentalmente fusionada en una rama <code>master</code>, y ahora el historial de compromiso se ve así:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/es/v2/images/undomerge-start.png" >}}" alt="Accidental merge commit.">
</div>
<div class="title">Figura 138. Accidental merge commit</div>
</div>
<div class="paragraph">
<p>Existen dos formas de abordar este problema, dependiendo de cuál es el resultado que desea.</p>
</div>
<div class="sect4">
<h4 id="_solucionar_las_referencias">Solucionar las referencias</h4>
<div class="paragraph">
<p>Si el compromiso de fusión no deseado solo existe en su repositorio local, la mejor y más fácil solución es mover las ramas para que así apunten a dónde quiere que lo hagan.
En la mayoría de los casos si sigue al errante <code>git merge</code> con <code>git reset --hard HEAD~</code>, esto restablecerá los punteros de la rama, haciendo que se vea así:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/es/v2/images/undomerge-reset.png" >}}" alt="History after `git reset --hard HEAD~`.">
</div>
<div class="title">Figura 139. History after <code>git reset --hard HEAD~</code>
</div>
</div>
<div class="paragraph">
<p>Ya vimos <code>reset</code> de nuevo en <a href="{{< relurl "book/es/v2/ch00/r_git_reset" >}}">Reiniciar Desmitificado</a>, así que no debería ser muy difícil averiguar lo que está sucediendo.
Aquí un repaso rápido: <code>reset --hard</code> usualmente va a través de tres pasos:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Mover los puntos de la rama HEAD.
En este caso, se quiere mover la <code>principal`a donde se encontraba antes el compromiso de fusión (`C6</code>).</p>
</li>
<li>
<p>Hacer que el índice parezca HEAD.</p>
</li>
<li>
<p>Hacer que el directorio de trabajo parezca el índice.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>La desventaja de este enfoque es que se reescribirá el historial, lo cual puede ser problemático con un depósito compartido.
Revise <a href="{{< relurl "book/es/v2/ch00/r_rebase_peril" >}}">Los Peligros de Reorganizar</a> para saber más de lo que puede suceder; la versión corta es que, si otras personas tienen los compromisos que está reescribiendo, probablemente debería evitar <code>resetear</code>.
Este enfoque tampoco funcionará si cualquiera de los otros compromisos han sido creados desde la fusión; mover los refs efectivamente perdería esos cambios.</p>
</div>
</div>
<div class="sect4">
<h4 id="r_reverse_commit">Revertir el compromiso</h4>
<div class="paragraph">
<p>Si mover los punteros de la rama alrededor no funciona para su caso, Git le proporciona la opción  de hacer un compromiso (“commit”) nuevo que deshace todos los cambios de uno ya existente.
Git llama a esta operación un “revert”, y en este escenario en particular, ha invocado algo así:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git revert -m 1 HEAD
[master b1d8379] Revert "Merge branch 'topic'"</code></pre>
</div>
</div>
<div class="paragraph">
<p>La bandera <code>-m 1</code> indica cuál padre es el “mainline” y debería ser mantenido.
Cuando se invoque la fusión en el <code>HEAD</code> (<code>git merge topic</code>), el nuevo compromiso tiene dos padres: el primero es <code>HEAD</code> (<code>C6</code>), y el segundo es la punta de la rama siendo fusionada en (<code>C4</code>).
En este caso, se quiere deshacer todos los cambios introducidos por el fusionamiento en el padre #2 (<code>C4</code>), pero manteniendo todo el contenido del padre #1 (<code>C6</code>).</p>
</div>
<div class="paragraph">
<p>El historial con el compromiso revertido se ve así:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/es/v2/images/undomerge-revert.png" >}}" alt="History after `git revert -m 1`.">
</div>
<div class="title">Figura 140. History after <code>git revert -m 1</code>
</div>
</div>
<div class="paragraph">
<p>El nuevo compromiso <code>^M</code> tiene exactamente los mismos contenidos que <code>C6</code>, así que comenzando desde aquí es como si la fusión nunca hubiese sucedido, excepto que ahora los no fusionados compromisos están todavía en <code>HEAD</code>'s history.
Git se confundirá si intenta fusionar la rama <code>temática</code> en la rama <code>master</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge topic
Already up-to-date.</code></pre>
</div>
</div>
<div class="paragraph">
<p>No hay nada en <code>topic</code> que no sea ya alcanzable para la <code>master</code>.
Que es peor, si añade trabajo a <code>topic</code> y fusiona otra vez, Git solo traerá los cambios desde la fusión revertida:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/es/v2/images/undomerge-revert2.png" >}}" alt="History with a bad merge.">
</div>
<div class="title">Figura 141. History with a bad merge</div>
</div>
<div class="paragraph">
<p>La mejor forma de evitar esto es deshacer la fusión original, dado que ahora se quiere traer los cambios que fueron revertidos, <strong>luego</strong> crear un nuevo compromiso de fusión:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git revert ^M
[master 09f0126] Revert "Revert "Merge branch 'topic'""
$ git merge topic</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/es/v2/images/undomerge-revert3.png" >}}" alt="History after re-merging a reverted merge.">
</div>
<div class="title">Figura 142. History after re-merging a reverted merge</div>
</div>
<div class="paragraph">
<p>En este ejemplo, <code>M</code> y <code>^M</code> se cancelan.
Efectivamente <code>^^M</code> se fusiona en los cambios desde <code>C3</code> y <code>C4</code>, y <code>C8</code> se fusiona en los cambios desde <code>C7</code>, así que ahora <code>topic</code> está completamente fusionado.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_otros_tipos_de_fusiones">Otros Tipos de Fusiones</h3>
<div class="paragraph">
<p>Hasta hora ya cubrimos la fusión normal de dos ramas, normalmente manejado con lo que es llamado la estrategia de fusión “recursive”. Sin embargo, hay otras formas de fusionar a las ramas. Cubriremos algunas de ellas rápidamente.</p>
</div>
<div class="sect4">
<h4 id="_nuestra_o_su_preferencia">Nuestra o Su preferencia</h4>
<div class="paragraph">
<p>Primero que nada, hay otra cosa útil que podemos hacer con el modo de fusión “recursive”. Ya vimos las opciones <code>ignore-all-space</code> e <code>ignore-space-change</code> las cuales son pasadas con un <code>-X</code>, pero también le podemos decir a Git que favorezca un lado u otro cuando observe un conflicto.</p>
</div>
<div class="paragraph">
<p>Por defecto, cuando Git ve un conflicto entre dos ramas siendo fusionadas, añadirá marcadores de conflicto de fusión a los códigos, marcará el archivo como conflictivo y le dejará resolverlo. Si prefiere que Git simplemente escoja un lado específico e ignore el otro, en lugar de dejarle manualmente fusionar el conflicto, puede pasar el comando de fusión, ya sea on un <code>-Xours</code> o <code>-Xtheirs</code>.</p>
</div>
<div class="paragraph">
<p>Si Git ve esto, no añadirá marcadores de conflicto. Cualquier diferencia que pueda ser fusionable, se fusionará. Cualquier diferencia que entre en conflicto, él simplemente escogerá el lado que especifique en su totalidad, incluyendo los archivos binarios.</p>
</div>
<div class="paragraph">
<p>Si volvemos al ejemplo de “hello world” que estábamos utilizando antes, podemos ver que el fusionamiento en nuestra rama causa conflicto.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved 'hello.rb' using previous resolution.
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sin embargo, si lo corremos con <code>-Xours</code> o <code>-Xtheirs</code> no lo causa.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge -Xours mundo
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 test.sh  | 2 ++
 2 files changed, 3 insertions(+), 1 deletion(-)
 create mode 100644 test.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este caso, en lugar de obtener marcadores de conflicto en el archivo con “hello mundo” en un lado y “hola world” en el otro, simplemente escogerá “hola world”. Sin embargo, todos los cambios no conflictivos en esa rama se fusionaron exitosamente.</p>
</div>
<div class="paragraph">
<p>Esta opción también puede ser trasmitida al comando  <code>git merge-file</code> que vimos antes al correr algo como esto <code>git merge-file --ours</code> para archivos de fusión individuales.</p>
</div>
<div class="paragraph">
<p>Si quiere realizar algo así, pero Git no ha intentado siquiera fusionar cambios desde el otro lado, hay una opción más draconiana, la cual es la estrategia de fusión “ours” merge <em>strategy. Esto es diferente de la opción de fusión recursiva “ours” recursive merge _option</em>.</p>
</div>
<div class="paragraph">
<p>Esto básicamente hace una fusión falsa. Registrará un nuevo compromiso de fusión con ambas ramas como padres, pero ni siquiera mirará a la rama que está fusionando. Simplemente registrará como el resultado de la fusión el código exacto en su rama actual.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge -s ours mundo
Merge made by the 'ours' strategy.
$ git diff HEAD HEAD~
$</code></pre>
</div>
</div>
<div class="paragraph">
<p>Puede observar que no hay diferencia entre la rama en la que estábamos y el resultado de la fusión.</p>
</div>
<div class="paragraph">
<p>Esto a menudo puede ser útil para, básicamente, engañar a Git y que piense que una rama ya ha sido fusionada cuando se hace una fusión más adelante. Por ejemplo, decir que ha ramificado una rama de “release” y ha hecho un poco de trabajo que querrá fusionar de vuelta en su rama “master” en algún punto.
Mientras tanto, algunos arreglos de fallos en la “master” necesitan ser adaptados en la rama de <code>release</code>. Se puede fusionar la rama “bugfix” en la  de <code>release</code> y también <code>merge -s ours</code>, la misma rama en la principal (a pesar de que el arreglo ya se encuentre ahí). Así que, más tarde cuando fusione la de lanzamiento otra vez, no hay conflictos del “bugfix”.</p>
</div>
</div>
<div class="sect4">
<h4 id="r_subtree_merge">Convergencia de Subárbol</h4>
<div class="paragraph">
<p>La idea de la convergencia de subárboles es que usted tiene dos proyectos, de los cuales uno lleva un subdirectorio del otro y viceversa
Cuando especifica una convergencia de subárbol, Git suele ser lo suficientemente inteligente para comprender que uno es un subárbol del otro y convergerá apropiadamente.</p>
</div>
<div class="paragraph">
<p>Veremos un ejemplo donde se añade un proyecto separado a un proyecto existente y luego se converge el código del segundo dentro de un subdirectorio del primero.</p>
</div>
<div class="paragraph">
<p>Primero, añadiremos la aplicación Rack a nuestro proyecto.
Añadiremos el proyecto Rack como referencia remota en nuestro propio proyecto y luego lo colocaremos en su propia branch:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add rack_remote https://github.com/rack/rack
$ git fetch rack_remote
warning: no common commits
remote: Counting objects: 3184, done.
remote: Compressing objects: 100% (1465/1465), done.
remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.
Resolving deltas: 100% (1952/1952), done.
From https://github.com/rack/rack
 * [new branch]      build      -&gt; rack_remote/build
 * [new branch]      master     -&gt; rack_remote/master
 * [new branch]      rack-0.4   -&gt; rack_remote/rack-0.4
 * [new branch]      rack-0.9   -&gt; rack_remote/rack-0.9
$ git checkout -b rack_branch rack_remote/master
Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.
Switched to a new branch "rack_branch"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ahora tenemos la raíz del proyecto Rack en nuestro branch <code>rack_branch</code> y nuestro proyecto en el branch <code>master</code>.
Si verifica uno y luego el otro, puede observar que tienen diferentes raíces de proyecto:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ls
AUTHORS         KNOWN-ISSUES   Rakefile      contrib         lib
COPYING         README         bin           example         test
$ git checkout master
Switched to branch "master"
$ ls
README</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este concepto es algo extraño. No todas las <em>branchs</em> en su repositorio tendrán que ser <em>branchs</em> del mismo proyecto como tal. No es común, porque rara vez es de ayuda, pero es fácil que los <em>branchs</em> contengan historias completamente diferentes.</p>
</div>
<div class="paragraph">
<p>En este caso, queremos integrar el proyecto Rack a nuestro proyecto <code>master</code> como un subdirectorio.
Podemos hacer eso en Git con <code>git read-tree</code>.
Aprenderá más sobre <code>read-tree</code> y sus amigos en <a href="{{< relurl "book/es/v2/ch00/ch10-git-internals" >}}">[ch10-git-internals]</a>, pero por ahora sepa que éste interpreta el árbol raíz de una <em>branch</em> en su <em>'área de staging</em> y <em>directorio de trabajo</em>.
Sólo cambiamos de vuelta a su <em>branch</em> <code>master</code>, e integramos la <em>branch</em> <code>rack_branch</code> al subdirectorio <code>rack</code> de nuestra <em>branch</em> <code>master</code> de nuestro proyecto principal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git read-tree --prefix=rack/ -u rack_branch</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cuando hacemos “commit”, parece que tenemos todos los archivos Rack bajo ese subdirectorio - como si los hubiéramos copiado de un tarball.
Lo interesante es que podemos facilmente converger cambios de una de las <em>branchs</em> a la otra.
Entonces, si el proyecto Rack se actualiza, podemos atraer cambios río arriba alternando a esa <em>branch</em> e incorporando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout rack_branch
$ git pull</code></pre>
</div>
</div>
<div class="paragraph">
<p>Luego, podemos converger de vuelta esos cambios a nuestr <em>branch</em> <code>master</code>.
Para incorporar los cambios y rellenar previamente el mensaje de “commit”, utilice las opciones <code>--squash</code> y <code>--no-commit</code>, así como la estrategia de convergencia recursiva de la opción <code>-Xsubtree</code>. (La estrategia recursiva está aquí por defecto, pero la incluímos para aclarar.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
$ git merge --squash -s recursive -Xsubtree=rack --no-commit rack_branch
Squash commit -- not updating HEAD
Automatic merge went well; stopped before committing as requested</code></pre>
</div>
</div>
<div class="paragraph">
<p>Todos los cambios del proyeto Rack se convergieron y están listos para ser encomendados localmente.
También puede hacer lo opuesto - hacer cambios en el subdirectorio <code>rack</code> de su <code>master branch</code> y luego convergerlos a su <em>branch</em> <code>rack_branch</code> más adelante para entregarlos a los mantenedores o empujarlos río arriba.</p>
</div>
<div class="paragraph">
<p>Esto nos deja una manera de tener un flujo de trabajo algo similar al flujo de trabajo de submódulo sin utilizar submódulos (de los cuales hablamos en <a href="{{< relurl "book/es/v2/ch00/r_git_submodules" >}}">Submódulos</a>). Podemos mantener <em>branchs</em> con otros proyectos relacionados en nuestro repositorio y convergerlos tipo subárbol a nuestro proyecto ocasionalmente. Esto es bueno por ciertas razones, por ejemplo, todo el códido se encomienda a un único lugar. Sin embargo, tiene el defecto de ser un poco más complejo y facilita el cometer errores al reintegrar cambios o empujar accidentalmente una <em>branch</em> a un repositorio con el que no guarda relación.</p>
</div>
<div class="paragraph">
<p>Otra particularidad es que para diferenciar entre lo que tiene en su subdirectorio <code>rack</code> y el código en su <em>branch</em> <code>rack_branch</code> - para ver si necesita convergerlos - no puede usar el comando <code>diff</code> normal.
En lugar de esto, debe ejecutar <code>git diff-tree</code> con la <em>branch</em> que desea comparar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff-tree -p rack_branch</code></pre>
</div>
</div>
<div class="paragraph">
<p>O, para comparar lo que hay en su subdirectorio <code>rack</code> con lo que era la <em>branch</em> <code>master</code> en el servidor la última vez que usted hizo fetch, ejecute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff-tree -p rack_remote/master</code></pre>
</div>
</div>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>