---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: zh
  chapter:
    title: Git 与其他系统
    number: 9
  section:
    title: 作为客户端的 Git
    number: 1
    cs_number: '9.1'
    previous: book/zh/v2/自定义-Git-总结
    next: book/zh/v2/Git-与其他系统-迁移到-Git
title: Git - 作为客户端的 Git
url: "/book/zh/v2/Git-与其他系统-作为客户端的-Git.html"
---
<p>现实并不总是尽如人意。
通常，你不能立刻就把接触到的每一个项目都切换到 Git。
有时候你被困在使用其他 VCS 的项目中，却希望使用 Git。
在本章的第一部分我们将会了解到，怎样在你的那些托管在不同系统的项目上使用 Git 客户端。</p><p>在某些时候，你可能想要将已有项目转换到 Git。
本章的第二部分涵盖了从几个特定系统将你的项目迁移至 Git 的方法，即使没有预先构建好的导入工具，我们也有办法手动导入。</p>
<h2 id="_作为客户端的_git">作为客户端的 Git</h2>
<div class="paragraph">
<p>
Git 为开发者提供了如此优秀的体验，许多人已经找到了在他们的工作站上使用 Git 的方法，即使他们团队其余的人使用的是完全不同的 VCS。
有许多这种可用的适配器，它们被叫做“桥接”。
下面我们将要介绍几个很可能会在实际中用到的桥接。</p>
</div>
<div class="sect3">
<h3 id="_git_svn">Git 与 Subversion</h3>
<div class="paragraph">
<p>
很大一部分开源项目与相当多的企业项目使用 Subversion 来管理它们的源代码。
而且在大多数时间里，它已经是开源项目 VCS 选择的 <em>事实标准</em>。
它在很多方面都与曾经是源代码管理世界的大人物的 CVS 相似。</p>
</div>
<div class="paragraph">
<p>
Git 中最棒的特性就是有一个与 Subversion 的双向桥接，它被称作 <code>git svn</code>。
这个工具允许你使用 Git 作为连接到 Subversion 有效的客户端，这样你可以使用 Git 所有本地的功能然后如同正在本地使用 Subversion 一样推送到 Subversion 服务器。
这意味着你可以在本地做新建分支与合并分支、使用暂存区、使用变基与拣选等等的事情，同时协作者还在继续使用他们黑暗又古老的方式。
当你试图游说公司将基础设施修改为完全支持 Git 的过程中，一个好方法是将 Git 偷偷带入到公司环境，并帮助周围的开发者提升效率。
Subversion 桥接就是进入 DVCS 世界的诱饵。</p>
</div>
<div class="sect4">
<h4 id="_git_svn_2"><code>git svn</code></h4>
<div class="paragraph">
<p>在 Git 中所有 Subversion 桥接命令的基础命令是 <code>git svn</code>。
它可以跟很多命令，所以我们会通过几个简单的工作流程来为你演示最常用的命令。</p>
</div>
<div class="paragraph">
<p>需要特别注意的是当你使用 <code>git svn</code> 时，就是在与 Subversion 打交道，一个与 Git 完全不同的系统。
尽管 <strong>可以</strong> 在本地新建分支与合并分支，但是你最好还是通过变基你的工作来保证你的历史尽可能是直线，并且避免做类似同时与 Git 远程服务器交互的事情。</p>
</div>
<div class="paragraph">
<p>不要重写你的历史然后尝试再次推送，同时也不要推送到一个平行的 Git 仓库来与其他使用 Git 的开发者协作。
Subversion 只能有一个线性的历史，弄乱它很容易。
如果你在一个团队中工作，其中有一些人使用 SVN 而另一些人使用 Git，你需要确保每个人都使用 SVN 服务器来协作——这样做会省去很多麻烦。</p>
</div>
</div>
<div class="sect4">
<h4 id="_设置">设置</h4>
<div class="paragraph">
<p>为了演示这个功能，需要一个有写入权限的典型 SVN 仓库。
如果想要拷贝这些例子，你必须获取一份可写入的 SVN 测试仓库的副本。
为了轻松地拷贝，可以使用 Subversion 自带的一个名为 <code>svnsync</code> 的工具。
为了这些测试，我们在 Google Code 上创建了一个 <code>protobuf</code> 项目部分拷贝的新
Subversion 仓库。<code>protobuf</code> 是一个将结构性数据编码用于网络传输的工具。</p>
</div>
<div class="paragraph">
<p>接下来，你需要先创建一个新的本地 Subversion 仓库：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ mkdir /tmp/test-svn
$ svnadmin create /tmp/test-svn</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，允许所有用户改变版本属性——最容易的方式是添加一个返回值为 0 的 <code>pre-revprop-change</code> 脚本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat /tmp/test-svn/hooks/pre-revprop-change
#!/bin/sh
exit 0;
$ chmod +x /tmp/test-svn/hooks/pre-revprop-change</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在可以调用加入目标与来源仓库参数的 <code>svnsync init</code> 命令同步这个项目到本地的机器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ svnsync init file:///tmp/test-svn \
  http://your-svn-server.example.org/svn/</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样就设置好了同步所使用的属性。
可以通过运行下面的命令来克隆代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ svnsync sync file:///tmp/test-svn
Committed revision 1.
Copied properties for revision 1.
Transmitting file data .............................[...]
Committed revision 2.
Copied properties for revision 2.
[…]</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然这个操作可能只会花费几分钟，但如果你尝试拷贝原始的仓库到另一个非本地的远程仓库时，即使只有不到 100 个的提交，这个过程也可能会花费将近一个小时。
Subversion 必须一次复制一个版本然后推送回另一个仓库——这低效得可笑，但却是做这件事唯一简单的方式。</p>
</div>
</div>
<div class="sect4">
<h4 id="_开始">开始</h4>
<div class="paragraph">
<p>既然已经有了一个有写入权限的 Subversion 仓库，那么你可以开始一个典型的工作流程。
可以从 <code>git svn clone</code> 命令开始，它会将整个 Subversion 仓库导入到一个本地 Git 仓库。
需要牢记的一点是如果是从一个真正托管的 Subversion 仓库中导入，需要将 <code>file:///tmp/test-svn</code> 替换为你的 Subversion 仓库的 URL：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn clone file:///tmp/test-svn -T trunk -b branches -t tags
Initialized empty Git repository in /private/tmp/progit/test-svn/.git/
r1 = dcbfb5891860124cc2e8cc616cded42624897125 (refs/remotes/origin/trunk)
    A	m4/acx_pthread.m4
    A	m4/stl_hash.m4
    A	java/src/test/java/com/google/protobuf/UnknownFieldSetTest.java
    A	java/src/test/java/com/google/protobuf/WireFormatTest.java
…
r75 = 556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae (refs/remotes/origin/trunk)
Found possible branch point: file:///tmp/test-svn/trunk =&gt; file:///tmp/test-svn/branches/my-calc-branch, 75
Found branch parent: (refs/remotes/origin/my-calc-branch) 556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae
Following parent with do_switch
Successfully followed parent
r76 = 0fb585761df569eaecd8146c71e58d70147460a2 (refs/remotes/origin/my-calc-branch)
Checked out HEAD:
  file:///tmp/test-svn/trunk r75</code></pre>
</div>
</div>
<div class="paragraph">
<p>这相当于运行了两个命令—— <code>git svn init</code> 以及紧接着的 <code>git svn fetch</code> ——你提供的 URL。
这会花费一些时间。例如，如果测试项目只有 75 个左右的提交并且代码库并不是很大，
但是 Git 必须一次一个地检出一个版本同时单独地提交它。
对于有成百上千个提交的项目，这真的可能会花费几小时甚至几天来完成。</p>
</div>
<div class="paragraph">
<p><code>-T trunk -b branches -t tags</code> 部分告诉 Git Subversion 仓库遵循基本的分支与标签惯例。
如果你命名了不同的主干、分支或标签，可以修改这些参数。
因为这是如此地常见，所以能用 <code>-s</code> 来替代整个这部分，这表示标准布局并且指代所有那些选项。
下面的命令是相同的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn clone file:///tmp/test-svn -s</code></pre>
</div>
</div>
<div class="paragraph">
<p>至此，应该得到了一个已经导入了分支与标签的有效的 Git 仓库：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch -a
* master
  remotes/origin/my-calc-branch
  remotes/origin/tags/2.0.2
  remotes/origin/tags/release-2.0.1
  remotes/origin/tags/release-2.0.2
  remotes/origin/tags/release-2.0.2rc1
  remotes/origin/trunk</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意这个工具是如何将 Subversion 标签作为远程引用来管理的。

让我们近距离看一下 Git 的底层命令 <code>show-ref</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show-ref
556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae refs/heads/master
0fb585761df569eaecd8146c71e58d70147460a2 refs/remotes/origin/my-calc-branch
bfd2d79303166789fc73af4046651a4b35c12f0b refs/remotes/origin/tags/2.0.2
285c2b2e36e467dd4d91c8e3c0c0e1750b3fe8ca refs/remotes/origin/tags/release-2.0.1
cbda99cb45d9abcb9793db1d4f70ae562a969f1e refs/remotes/origin/tags/release-2.0.2
a9f074aa89e826d6f9d30808ce5ae3ffe711feda refs/remotes/origin/tags/release-2.0.2rc1
556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae refs/remotes/origin/trunk</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git 在从 Git 服务器克隆时并不这样做；下面是在刚刚克隆完成的有标签的仓库的样子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show-ref
c3dcbe8488c6240392e8a5d7553bbffcb0f94ef0 refs/remotes/origin/master
32ef1d1c7cc8c603ab78416262cc421b80a8c2df refs/remotes/origin/branch-1
75f703a3580a9b81ead89fe1138e6da858c5ba18 refs/remotes/origin/branch-2
23f8588dde934e8f33c263c6d8359b2ae095f863 refs/tags/v0.1.0
7064938bd5e7ef47bfd79a685a62c1e2649e2ce7 refs/tags/v0.2.0
6dcb09b5b57875f334f61aebed695e2e4193db5e refs/tags/v1.0.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git 直接将标签抓取至 <code>refs/tags</code>，而不是将它们看作分支。</p>
</div>
</div>
<div class="sect4">
<h4 id="_提交回_subversion">提交回 Subversion</h4>
<div class="paragraph">
<p>现在你有了一个工作目录，你可以在项目上做一些改动，然后高效地使用 Git 作为 SVN 客户端将你的提交推送到上游。
一旦编辑了一个文件并提交它，你就有了一个存在于本地 Git 仓库的提交，这提交在 Subversion 服务器上并不存在：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git commit -am 'Adding git-svn instructions to the README'
[master 4af61fd] Adding git-svn instructions to the README
 1 file changed, 5 insertions(+)</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来，你需要将改动推送到上游。
注意这会怎样改变你使用 Subversion 的方式——你可以离线做几次提交然后一次性将它们推送到 Subversion 服务器。
要推送到一个 Subversion 服务器，运行 <code>git svn dcommit</code> 命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	README.txt
Committed r77
    M	README.txt
r77 = 95e0222ba6399739834380eb10afcd73e0670bc5 (refs/remotes/origin/trunk)
No changes between 4af61fd05045e07598c553167e0f31c84fd6ffe1 and refs/remotes/origin/trunk
Resetting to the latest refs/remotes/origin/trunk</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会拿走你在 Subversion 服务器代码之上所做的所有提交，针对每一个做一个 Subversion 提交，然后重写你本地的 Git 提交来包含一个唯一的标识符。
这很重要因为这意味着所有你的提交的 SHA-1 校验和都改变了。
部分由于这个原因，同时使用一个基于 Git 的项目远程版本和一个 Subversion 服务器并不是一个好主意。
如果你查看最后一次提交，有新的 <code>git-svn-id</code> 被添加：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -1
commit 95e0222ba6399739834380eb10afcd73e0670bc5
Author: ben &lt;ben@0b684db3-b064-4277-89d1-21af03df0a68&gt;
Date:   Thu Jul 24 03:08:36 2014 +0000

    Adding git-svn instructions to the README

    git-svn-id: file:///tmp/test-svn/trunk@77 0b684db3-b064-4277-89d1-21af03df0a68</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意你原来提交的 SHA-1 校验和原来是以 <code>4af61fd</code> 开头，而现在是以 <code>95e0222</code> 开头。
如果想要既推送到一个 Git 服务器又推送到一个 Subversion 服务器，必须先推送（<code>dcommit</code>）到 Subversion 服务器，因为这个操作会改变你的提交数据。</p>
</div>
</div>
<div class="sect4">
<h4 id="_拉取新改动">拉取新改动</h4>
<div class="paragraph">
<p>如果你和其他开发者一起工作，当在某一时刻你们其中之一推送时，另一人尝试推送修改会导致冲突。
那次修改会被拒绝直到你合并他们的工作。
在 <code>git svn</code> 中，它看起来是这样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...

ERROR from SVN:
Transaction is out of date: File '/trunk/README.txt' is out of date
W: d5837c4b461b7c0e018b49d12398769d2bfc240a and refs/remotes/origin/trunk differ, using rebase:
:100644 100644 f414c433af0fd6734428cf9d2a9fd8ba00ada145 c80b6127dd04f5fcda218730ddf3a2da4eb39138 M	README.txt
Current branch master is up to date.
ERROR: Not all changes have been committed into SVN, however the committed
ones (if any) seem to be successfully integrated into the working tree.
Please see the above messages for details.</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了解决这种情况，可以运行 <code>git svn rebase</code>，它会从服务器拉取任何你本地还没有的改动，并将你所有的工作变基到服务器的内容之上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn rebase
Committing to file:///tmp/test-svn/trunk ...

ERROR from SVN:
Transaction is out of date: File '/trunk/README.txt' is out of date
W: eaa029d99f87c5c822c5c29039d19111ff32ef46 and refs/remotes/origin/trunk differ, using rebase:
:100644 100644 65536c6e30d263495c17d781962cfff12422693a b34372b25ccf4945fe5658fa381b075045e7702a M	README.txt
First, rewinding head to replay your work on top of it...
Applying: update foo
Using index info to reconstruct a base tree...
M	README.txt
Falling back to patching base and 3-way merge...
Auto-merging README.txt
ERROR: Not all changes have been committed into SVN, however the committed
ones (if any) seem to be successfully integrated into the working tree.
Please see the above messages for details.</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，所有你的工作都已经在 Subversion 服务器的内容之上了，你就可以顺利地 <code>dcommit</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	README.txt
Committed r85
    M	README.txt
r85 = 9c29704cc0bbbed7bd58160cfb66cb9191835cd8 (refs/remotes/origin/trunk)
No changes between 5762f56732a958d6cfda681b661d2a239cc53ef5 and refs/remotes/origin/trunk
Resetting to the latest refs/remotes/origin/trunk</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，和 Git 需要你在推送前合并本地还没有的上游工作不同的是，<code>git svn</code> 只会在修改发生冲突时要求你那样做（更像是 Subversion 工作的行为）。
如果其他人推送一个文件的修改然后你推送了另一个文件的修改，你的 <code>dcommit</code> 命令会正常工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	configure.ac
Committed r87
    M	autogen.sh
r86 = d8450bab8a77228a644b7dc0e95977ffc61adff7 (refs/remotes/origin/trunk)
    M	configure.ac
r87 = f3653ea40cb4e26b6281cec102e35dcba1fe17c4 (refs/remotes/origin/trunk)
W: a0253d06732169107aa020390d9fefd2b1d92806 and refs/remotes/origin/trunk differ, using rebase:
:100755 100755 efa5a59965fbbb5b2b0a12890f1b351bb5493c18 e757b59a9439312d80d5d43bb65d4a7d0389ed6d M	autogen.sh
First, rewinding head to replay your work on top of it...</code></pre>
</div>
</div>
<div class="paragraph">
<p>记住这一点很重要，因为结果是当你推送后项目的状态并不存在于你的电脑中。
如果修改并未冲突但却是不兼容的，可能会引起一些难以诊断的问题。
这与使用 Git 服务器并不同——在 Git 中，可以在发布前完全测试客户端系统的状态，然而在 SVN 中，你甚至不能立即确定在提交前与提交后的状态是相同的。</p>
</div>
<div class="paragraph">
<p>你也应该运行这个命令从 Subversion 服务器上拉取修改，即使你自己并不准备提交。
可以运行 <code>git svn fetch</code> 来抓取新数据，但是 <code>git svn rebase</code> 会抓取并更新你本地的提交。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn rebase
    M	autogen.sh
r88 = c9c5f83c64bd755368784b444bc7a0216cc1e17b (refs/remotes/origin/trunk)
First, rewinding head to replay your work on top of it...
Fast-forwarded master to refs/remotes/origin/trunk.</code></pre>
</div>
</div>
<div class="paragraph">
<p>每隔一会儿运行 <code>git svn rebase</code> 确保你的代码始终是最新的。
虽然需要保证当运行这个命令时工作目录是干净的。
如果有本地的修改，在运行 <code>git svn rebase</code> 之前要么储藏你的工作要么做一次临时的提交，不然，当变基会导致合并冲突时，命令会终止。</p>
</div>
</div>
<div class="sect4">
<h4 id="_git_分支问题">Git 分支问题</h4>
<div class="paragraph">
<p>当适应了 Git 的工作流程，你大概会想要创建主题分支，在上面做一些工作，然后将它们合并入主分支。
如果你正通过 <code>git svn</code> 推送到一个 Subversion 服务器，你可能想要把你的工作变基到一个单独的分支上，而不是将分支合并到一起。
比较喜欢变基的原因是因为 Subversion 有一个线性的历史并且无法像 Git 一样处理合并，所以 <code>git svn</code> 在将快照转换成 Subversion 提交时，只会保留第一父提交。</p>
</div>
<div class="paragraph">
<p>假设你的历史像下面这样：创建了一个 <code>experiment</code> 分支，做了两次提交，然后将它们合并回 <code>master</code>。
当 <code>dcommit</code> 时，你看到输出是这样的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	CHANGES.txt
Committed r89
    M	CHANGES.txt
r89 = 89d492c884ea7c834353563d5d913c6adf933981 (refs/remotes/origin/trunk)
    M	COPYING.txt
    M	INSTALL.txt
Committed r90
    M	INSTALL.txt
    M	COPYING.txt
r90 = cb522197870e61467473391799148f6721bcf9a0 (refs/remotes/origin/trunk)
No changes between 71af502c214ba13123992338569f4669877f55fd and refs/remotes/origin/trunk
Resetting to the latest refs/remotes/origin/trunk</code></pre>
</div>
</div>
<div class="paragraph">
<p>在一个合并过历史提交的分支上 <code>dcommit</code> 命令工作得很好，除了当你查看你的 Git 项目历史时，它并没有重写所有你在 <code>experiment</code> 分支上所做的任意提交——相反，所有这些修改显示一个单独合并提交的 SVN 版本中。</p>
</div>
<div class="paragraph">
<p>当其他人克隆那些工作时，他们只会看到一个被塞入了所有改动的合并提交，就像运行了 <code>git merge --squash</code>；他们无法看到修改从哪来或何时提交的信息。</p>
</div>
</div>
<div class="sect4">
<h4 id="_subversion_分支">Subversion 分支</h4>
<div class="paragraph">
<p>在 Subversion 中新建分支与在 Git 中新建分支并不相同；如果你能不用它，那最好就不要用。
然而，你可以使用 <code>git svn</code> 在 Subversion 中创建分支并在分支上做提交。</p>
</div>
</div>
<div class="sect4">
<h4 id="_创建一个新的_svn_分支">创建一个新的 SVN 分支</h4>
<div class="paragraph">
<p>要在 Subversion 中创建一个新分支，运行 <code>git svn branch &lt;new-branch&gt;</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn branch opera
Copying file:///tmp/test-svn/trunk at r90 to file:///tmp/test-svn/branches/opera...
Found possible branch point: file:///tmp/test-svn/trunk =&gt; file:///tmp/test-svn/branches/opera, 90
Found branch parent: (refs/remotes/origin/opera) cb522197870e61467473391799148f6721bcf9a0
Following parent with do_switch
Successfully followed parent
r91 = f1b64a3855d3c8dd84ee0ef10fa89d27f1584302 (refs/remotes/origin/opera)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这与 Subversion 中的 <code>svn copy trunk branches/opera</code> 命令作用相同并且是在 Subversion 服务器中操作。
需要重点注意的是它并不会检出到那个分支；如果你在这时提交，提交会进入服务器的 <code>trunk</code> 分支，而不是 <code>opera</code> 分支。</p>
</div>
</div>
<div class="sect4">
<h4 id="_切换活动分支">切换活动分支</h4>
<div class="paragraph">
<p>Git 通过查找在历史中 Subversion 分支的头部来指出你的提交将会到哪一个分支——应该只有一个，并且它应该是在当前分支历史中最后一个有 <code>git-svn-id</code> 的。</p>
</div>
<div class="paragraph">
<p>如果想要同时在不止一个分支上工作，可以通过在导入的那个分支的 Subversion 提交开始来设置本地分支 <code>dcommit</code> 到特定的 Subversion 分支。
如果想要一个可以单独在上面工作的 <code>opera</code> 分支，可以运行</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch opera remotes/origin/opera</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，如果想要将你的 <code>opera</code> 分支合并入 <code>trunk</code>（你的 <code>master</code> 分支），可以用一个正常的 <code>git merge</code> 来这样做。
但是你需要通过 <code>-m</code> 来提供一个描述性的提交信息，否则合并信息会是没有用的 “Merge branch opera”。</p>
</div>
<div class="paragraph">
<p>记住尽管使用的是 <code>git merge</code> 来做这个操作，而且合并可能会比在 Subversion 中更容易一些
（因为 Git 会为你自动地检测合适的合并基础），但这并不是一个普通的 Git 合并提交。
你不得不将这个数据推送回一个 Subversion 服务器，Subversion 服务器不支持那些跟踪多个父结点的提交；
所以，当推送完成后，它看起来会是一个将其他分支的所有提交压缩在一起的单独提交。
在合并一个分支到另一个分支后，你并不能像 Git 中那样轻松地回到原来的分支继续工作。
你运行的 <code>dcommit</code> 命令会将哪个分支被合并进来的信息抹掉，所以后续的合并基础计算会是错的——
<code>dcommit</code> 会使你的 <code>git merge</code> 结果看起来像是运行了 <code>git merge --squash</code>。
不幸的是，没有一个好的方式来避免这种情形—— Subversion 无法存储这个信息，
所以当使用它做为服务器时你总是会被它的限制打垮。
为了避免这些问题，应该在合并到主干后删除本地分支（本例中是 <code>opera</code>）。</p>
</div>
</div>
<div class="sect4">
<h4 id="_subversion_命令">Subversion 命令</h4>
<div class="paragraph">
<p><code>git svn</code> 工具集通过提供很多功能与 Subversion 中那些相似的命令来帮助简化转移到 Git 的过程。
下面是一些提供了 Subversion 中常用功能的命令。</p>
</div>
<div class="sect5">
<h6 id="_svn_风格历史">SVN 风格历史</h6>
<div class="paragraph">
<p>如果你习惯于使用 Subversion 并且想要看 SVN 输出风格的提交历史，可以运行 <code>git svn log</code> 来查看 SVN 格式的提交历史：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn log
------------------------------------------------------------------------
r87 | schacon | 2014-05-02 16:07:37 -0700 (Sat, 02 May 2014) | 2 lines

autogen change

------------------------------------------------------------------------
r86 | schacon | 2014-05-02 16:00:21 -0700 (Sat, 02 May 2014) | 2 lines

Merge branch 'experiment'

------------------------------------------------------------------------
r85 | schacon | 2014-05-02 16:00:09 -0700 (Sat, 02 May 2014) | 2 lines

updated the changelog</code></pre>
</div>
</div>
<div class="paragraph">
<p>关于 <code>git svn log</code>，有两件重要的事你应该知道。
首先，它是离线工作的，并不像真正的 <code>svn log</code> 命令，会向 Subversion 服务器询问数据。
其次，它只会显示已经提交到 Subversion 服务器上的提交。
还未 dcommit 的本地 Git 提交并不会显示；同样也不会显示这段时间中其他人推送到 Subversion 服务器上的提交。
它更像是最后获取到的 Subversion 服务器上的提交状态。</p>
</div>
</div>
<div class="sect5">
<h6 id="_svn_注解">SVN 注解</h6>
<div class="paragraph">
<p>类似 <code>git svn log</code> 命令离线模拟了 <code>svn log</code> 命令，你可以认为 <code>git svn blame [FILE]</code> 离线模拟了 <code>svn annotate</code>。
输出看起来像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn blame README.txt
 2   temporal Protocol Buffers - Google's data interchange format
 2   temporal Copyright 2008 Google Inc.
 2   temporal http://code.google.com/apis/protocolbuffers/
 2   temporal
22   temporal C++ Installation - Unix
22   temporal =======================
 2   temporal
79    schacon Committing in git-svn.
78    schacon
 2   temporal To build and install the C++ Protocol Buffer runtime and the Protocol
 2   temporal Buffer compiler (protoc) execute the following:
 2   temporal</code></pre>
</div>
</div>
<div class="paragraph">
<p>重复一次，它并不显示你在 Git 中的本地提交，也不显示同一时间被推送到 Subversion 的其他提交。</p>
</div>
</div>
<div class="sect5">
<h6 id="_svn_服务器信息">SVN 服务器信息</h6>
<div class="paragraph">
<p>可以通过运行 <code>git svn info</code> 得到与 <code>svn info</code> 相同种类的信息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn info
Path: .
URL: https://schacon-test.googlecode.com/svn/trunk
Repository Root: https://schacon-test.googlecode.com/svn
Repository UUID: 4c93b258-373f-11de-be05-5f7a86268029
Revision: 87
Node Kind: directory
Schedule: normal
Last Changed Author: schacon
Last Changed Rev: 87
Last Changed Date: 2009-05-02 16:07:37 -0700 (Sat, 02 May 2009)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就像是在你上一次和 Subversion 服务器通讯时同步了之后，离线运行的 <code>blame</code> 与 <code>log</code> 命令。</p>
</div>
</div>
<div class="sect5">
<h6 id="_忽略_subversion_所忽略的">忽略 Subversion 所忽略的</h6>
<div class="paragraph">
<p>如果克隆一个在任意一处设置 <code>svn:ignore</code> 属性的 Subversion 仓库时，你也许会想要设置对应的 <code>.gitignore</code> 文件，这样就不会意外的提交那些不该提交的文件。
<code>git svn</code> 有两个命令来帮助解决这个问题。
第一个是 <code>git svn create-ignore</code>，它会为你自动地创建对应的 <code>.gitignore</code> 文件，这样你的下次提交就能包含它们。</p>
</div>
<div class="paragraph">
<p>第二个命令是 <code>git svn show-ignore</code>，它会将你需要放在 <code>.gitignore</code> 文件中的每行内容打印到标准输出，这样就可以将输出内容重定向到项目的例外文件中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn show-ignore &gt; .git/info/exclude</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样，你就不会由于 <code>.gitignore</code> 文件而把项目弄乱。
当你是 Subversion 团队中唯一的 Git 用户时这是一个好的选项，并且你的队友并不想要项目内存在 <code>.gitignore</code> 文件。</p>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_git_svn_总结">Git-Svn 总结</h4>
<div class="paragraph">
<p>当你不得不使用 Subversion 服务器或者其他必须运行一个 Subversion 服务器的开发环境时，<code>git svn</code> 工具很有用。
你应该把它当做一个不完全的 Git，然而，你要是不用它的话，就会在做转换的过程中遇到很多麻烦的问题。
为了不惹麻烦，尽量遵守这些准则：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>保持一个线性的 Git 历史，其中不能有 <code>git merge</code> 生成的合并提交。
把你在主线分支外开发的全部工作变基到主线分支；而不要合并入主线分支。</p>
</li>
<li>
<p>不要建立一个单独的 Git 服务器，也不要在 Git 服务器上协作。
可以用一台 Git 服务器来帮助新来的开发者加速克隆，但是不要推送任何不包含 <code>git-svn-id</code> 条目的东西。
你可能会需要增加一个 <code>pre-receive</code> 钩子来检查每一个提交信息是否包含 <code>git-svn-id</code> 并且拒绝任何未包含的提交。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果你遵守了那些准则，忍受用一个 Subversion 服务器来工作可以更容易些。
然而，如果有可能迁移到一个真正的 Git 服务器，那么迁移过去能使你的团队获得更多好处。</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_git_与_mercurial">Git 与 Mercurial</h3>
<div class="paragraph">
<p>

DVCS 的宇宙里不只有 Git。
实际上，在这个空间里有许多其他的系统。对于如何正确地进行分布式版本管理，每一个系统都有自己的视角。
除了 Git，最流行的就是 Mercurial，并且它们两个在很多方面都很相似。</p>
</div>
<div class="paragraph">
<p>好消息是，如果你更喜欢 Git 的客户端行为但是工作在源代码由 Mercurial 控制的项目中，有一种使用 Git 作为 Mercurial 托管仓库的客户端的方法。
由于 Git 与服务器仓库是使用远程交互的，那么由远程助手实现的桥接方法就不会让人很惊讶。
这个项目的名字是 git-remote-hg，可以在 <a href="https://github.com/felipec/git-remote-hg" class="bare">https://github.com/felipec/git-remote-hg</a> 找到。</p>
</div>
<div class="sect4">
<h4 id="_git_remote_hg">git-remote-hg</h4>
<div class="paragraph">
<p>首先，需要安装 git-remote-hg。
实际上需要将它的文件放在 PATH 变量的某个目录中，像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ curl -o ~/bin/git-remote-hg \
  https://raw.githubusercontent.com/felipec/git-remote-hg/master/git-remote-hg
$ chmod +x ~/bin/git-remote-hg</code></pre>
</div>
</div>
<div class="paragraph">
<p>假定 <code>~/bin</code> 在 <code>$PATH</code> 变量中。
Git-remote-hg 有一个其他的依赖：<code>mercurial</code> Python 库。
如果已经安装了 Python，安装它就像这样简单：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ pip install mercurial</code></pre>
</div>
</div>
<div class="paragraph">
<p>（如果未安装 Python，访问 <a href="https://www.python.org/" class="bare">https://www.python.org/</a> 来获取它。）</p>
</div>
<div class="paragraph">
<p>需要做的最后一件事是安装 Mercurial 客户端。
如果还没有安装的话请访问 <a href="https://www.mercurial-scm.org/" class="bare">https://www.mercurial-scm.org/</a> 来安装。</p>
</div>
<div class="paragraph">
<p>现在已经准备好摇滚了。
你所需要的一切就是一个你可以推送的 Mercurial 仓库。
很幸运，每一个 Mercurial 仓库都可以这样做，所以我们只需要使用大家用来学习 Mercurial 的“hello world”仓库就可以了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ hg clone http://selenic.com/repo/hello /tmp/hello</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_开始_2">开始</h4>
<div class="paragraph">
<p>既然有一个可用的 “server-side” 仓库，我们可以通过一个典型的工作流来了解。
你将会看到，这两种系统非常相似，没有太多的出入。</p>
</div>
<div class="paragraph">
<p>和 Git 一样，首先我们克隆：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone hg::/tmp/hello /tmp/hello-git
$ cd /tmp/hello-git
$ git log --oneline --graph --decorate
* ac7955c (HEAD, origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master, master) Create a makefile
* 65bb417 Create a standard "hello, world" program</code></pre>
</div>
</div>
<div class="paragraph">
<p>你会注意到与 Mercurial 仓库工作时使用了标准的 <code>git clone</code> 命令。
那是因为 git-remote-hg 工作在相当低的底层，使用类似于 Git HTTP/S 协议的机制实现的（远程助手）。
由于 Git 与 Mercurial 都设计为每一个客户端有一个仓库的完整历史，所以这个命令做了一次完整的克隆，包括所有的项目历史，并且相当快地完成。</p>
</div>
<div class="paragraph">
<p>log 命令显示了两次提交，最后一次提交指向了一大堆引用。
那说明这其中的一部分实际上并没有在那儿。
让我们看看 <code>.git</code> 目录中实际上有什么：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ tree .git/refs
.git/refs
├── heads
│   └── master
├── hg
│   └── origin
│       ├── bookmarks
│       │   └── master
│       └── branches
│           └── default
├── notes
│   └── hg
├── remotes
│   └── origin
│       └── HEAD
└── tags

9 directories, 5 files</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git-remote-hg 尝试让结构更有 Git 风格，但是在隐藏在下面的是它管理两个轻微不同系统之间概念的映射。
<code>refs/hg</code> 目录中存储了实际的远程引用。
例如，<code>refs/hg/origin/branches/default</code> 是一个包含以 “ac7955c” 开始的 SHA-1 值的 Git 引用文件，是 <code>master</code> 所指向的提交。
所以 <code>refs/hg</code> 目录是一种类似 <code>refs/remotes/origin</code> 的替代品，但是它引入了书签与分支的区别。</p>
</div>
<div class="paragraph">
<p><code>notes/hg</code> 文件是 git-remote-hg 如何在 Git 的提交散列与 Mercurial 变更集 ID 之间建立映射的起点。
让我们来探索一下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat notes/hg
d4c10386...

$ git cat-file -p d4c10386...
tree 1781c96...
author remote-hg &lt;&gt; 1408066400 -0800
committer remote-hg &lt;&gt; 1408066400 -0800

Notes for master

$ git ls-tree 1781c96...
100644 blob ac9117f...	65bb417...
100644 blob 485e178...	ac7955c...

$ git cat-file -p ac9117f
0a04b987be5ae354b710cefeba0e2d9de7ad41a9</code></pre>
</div>
</div>
<div class="paragraph">
<p>所以 <code>refs/notes/hg</code> 指向了一个树，即在 Git 对象数据库中的一个有其他对象名字的列表。
<code>git ls-tree</code> 输出 tree 对象中所有项目的模式、类型、对象哈希与文件名。
如果深入挖掘 tree 对象中的一个项目，我们会发现在其中是一个名字为 “ac9117f” 的 blob 对象（<code>master</code> 所指向提交的 SHA-1 散列值），包含内容 “0a04b98” （是 <code>default</code> 分支指向的 Mercurial 变更集的 ID）。</p>
</div>
<div class="paragraph">
<p>好消息是大多数情况下我们不需要关心以上这些。
典型的工作流程与使用 Git 远程仓库并没有什么不同。</p>
</div>
<div class="paragraph">
<p>在我们继续之前，这里还有一件需要注意的事情：忽略。
Mercurial 与 Git 使用非常类似的机制实现这个功能，但是一般来说你不会想要把一个 <code>.gitignore</code> 文件提交到 Mercurial 仓库中。
幸运的是，Git 有一种方式可以忽略本地磁盘仓库的文件，而且 Mercurial 格式是与 Git 兼容的，所以你只需将这个文件拷贝过去：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cp .hgignore .git/info/exclude</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.git/info/exclude</code> 文件的作用像是一个 <code>.gitignore</code>，但是它不包含在提交中。</p>
</div>
</div>
<div class="sect4">
<h4 id="_工作流程_2">工作流程</h4>
<div class="paragraph">
<p>假设我们已经做了一些工作并且在 <code>master</code> 分支做了几次提交，而且已经准备将它们推送到远程仓库。
这是我们仓库现在的样子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --graph --decorate
* ba04a2a (HEAD, master) Update makefile
* d25d16f Goodbye
* ac7955c (origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master) Create a makefile
* 65bb417 Create a standard "hello, world" program</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们的 <code>master</code> 分支领先 <code>origin/master</code> 分支两个提交，但是那两个提交只存在于我们的本地机器中。
让我们看看在同一时间有没有其他人做过什么重要的工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git fetch
From hg::/tmp/hello
   ac7955c..df85e87  master     -&gt; origin/master
   ac7955c..df85e87  branches/default -&gt; origin/branches/default
$ git log --oneline --graph --decorate --all
* 7b07969 (refs/notes/hg) Notes for default
* d4c1038 Notes for master
* df85e87 (origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master) Add some documentation
| * ba04a2a (HEAD, master) Update makefile
| * d25d16f Goodbye
|/
* ac7955c Create a makefile
* 65bb417 Create a standard "hello, world" program</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为使用了 <code>--all</code> 标记，我们看到被 git-remote-hg 内部使用的 “notes” 引用，但是可以忽略它们。
剩下的部分是我们期望的；<code>origin/master</code> 已经前进了一次提交，同时我们的历史现在分叉了。
Mercurial 和我们本章中讨论的其他系统不一样，它能够处理合并，所以我们不需要做任何其他事情。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge origin/master
Auto-merging hello.c
Merge made by the 'recursive' strategy.
 hello.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
$ git log --oneline --graph --decorate
*   0c64627 (HEAD, master) Merge remote-tracking branch 'origin/master'
|\
| * df85e87 (origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master) Add some documentation
* | ba04a2a Update makefile
* | d25d16f Goodbye
|/
* ac7955c Create a makefile
* 65bb417 Create a standard "hello, world" program</code></pre>
</div>
</div>
<div class="paragraph">
<p>完美。
运行测试然后所有测试都通过了，所以我们准备将工作共享给团队的其他成员。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git push
To hg::/tmp/hello
   df85e87..0c64627  master -&gt; master</code></pre>
</div>
</div>
<div class="paragraph">
<p>就是这样！
如果你现在查看一下 Mercurial 仓库，你会发现这样实现了我们所期望的：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ hg log -G --style compact
o    5[tip]:4,2   dc8fa4f932b8   2014-08-14 19:33 -0700   ben
|\     Merge remote-tracking branch 'origin/master'
| |
| o  4   64f27bcefc35   2014-08-14 19:27 -0700   ben
| |    Update makefile
| |
| o  3:1   4256fc29598f   2014-08-14 19:27 -0700   ben
| |    Goodbye
| |
@ |  2   7db0b4848b3c   2014-08-14 19:30 -0700   ben
|/     Add some documentation
|
o  1   82e55d328c8c   2005-08-26 01:21 -0700   mpm
|    Create a makefile
|
o  0   0a04b987be5a   2005-08-26 01:20 -0700   mpm
     Create a standard "hello, world" program</code></pre>
</div>
</div>
<div class="paragraph">
<p>序号 <em>2</em> 的变更集是由 Mercurial 生成的，序号 <em>3</em> 与序号 <em>4</em> 的变更集是由 git-remote-hg 生成的，通过 Git 推送上来的提交。</p>
</div>
</div>
<div class="sect4">
<h4 id="_分支与书签">分支与书签</h4>
<div class="paragraph">
<p>Git 只有一种类型的分支：当提交生成时移动的一个引用。
在 Mercurial 中，这种类型的引用叫作 “bookmark”，它的行为非常类似于 Git 分支。</p>
</div>
<div class="paragraph">
<p>Mercurial 的 “branch” 概念则更重量级一些。
变更集生成时的分支会记录 <em>在变更集中</em>，意味着它会永远地存在于仓库历史中。
这个例子描述了一个在 <code>develop</code> 分支上的提交：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ hg log -l 1
changeset:   6:8f65e5e02793
branch:      develop
tag:         tip
user:        Ben Straub &lt;ben@straub.cc&gt;
date:        Thu Aug 14 20:06:38 2014 -0700
summary:     More documentation</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意开头为 “branch” 的那行。
Git 无法真正地模拟这种行为（并且也不需要这样做；两种类型的分支都可以表达为 Git 的一个引用），但是 git-remote-hg 需要了解其中的区别，因为 Mercurial 关心。</p>
</div>
<div class="paragraph">
<p>创建 Mercurial 书签与创建 Git 分支一样容易。
在 Git 这边：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b featureA
Switched to a new branch 'featureA'
$ git push origin featureA
To hg::/tmp/hello
 * [new branch]      featureA -&gt; featureA</code></pre>
</div>
</div>
<div class="paragraph">
<p>这就是所要做的全部。
在 Mercurial 这边，它看起来像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ hg bookmarks
   featureA                  5:bd5ac26f11f9
$ hg log --style compact -G
@  6[tip]   8f65e5e02793   2014-08-14 20:06 -0700   ben
|    More documentation
|
o    5[featureA]:4,2   bd5ac26f11f9   2014-08-14 20:02 -0700   ben
|\     Merge remote-tracking branch 'origin/master'
| |
| o  4   0434aaa6b91f   2014-08-14 20:01 -0700   ben
| |    update makefile
| |
| o  3:1   318914536c86   2014-08-14 20:00 -0700   ben
| |    goodbye
| |
o |  2   f098c7f45c4f   2014-08-14 20:01 -0700   ben
|/     Add some documentation
|
o  1   82e55d328c8c   2005-08-26 01:21 -0700   mpm
|    Create a makefile
|
o  0   0a04b987be5a   2005-08-26 01:20 -0700   mpm
     Create a standard "hello, world" program</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意在修订版本 5 上的新 <code>[featureA]</code> 标签。
在 Git 这边这些看起来像是 Git 分支，除了一点：不能从 Git 这边删除书签（这是远程助手的一个限制）。</p>
</div>
<div class="paragraph">
<p>你也可以工作在一个 “重量级” 的 Mercurial branch：只需要在 <code>branches</code> 命名空间内创建一个分支：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b branches/permanent
Switched to a new branch 'branches/permanent'
$ vi Makefile
$ git commit -am 'A permanent change'
$ git push origin branches/permanent
To hg::/tmp/hello
 * [new branch]      branches/permanent -&gt; branches/permanent</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面是 Mercurial 这边的样子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ hg branches
permanent                      7:a4529d07aad4
develop                        6:8f65e5e02793
default                        5:bd5ac26f11f9 (inactive)
$ hg log -G
o  changeset:   7:a4529d07aad4
|  branch:      permanent
|  tag:         tip
|  parent:      5:bd5ac26f11f9
|  user:        Ben Straub &lt;ben@straub.cc&gt;
|  date:        Thu Aug 14 20:21:09 2014 -0700
|  summary:     A permanent change
|
| @  changeset:   6:8f65e5e02793
|/   branch:      develop
|    user:        Ben Straub &lt;ben@straub.cc&gt;
|    date:        Thu Aug 14 20:06:38 2014 -0700
|    summary:     More documentation
|
o    changeset:   5:bd5ac26f11f9
|\   bookmark:    featureA
| |  parent:      4:0434aaa6b91f
| |  parent:      2:f098c7f45c4f
| |  user:        Ben Straub &lt;ben@straub.cc&gt;
| |  date:        Thu Aug 14 20:02:21 2014 -0700
| |  summary:     Merge remote-tracking branch 'origin/master'
[...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>分支名字 “permanent” 记录在序号 <em>7</em> 的变更集中。</p>
</div>
<div class="paragraph">
<p>在 Git 这边，对于其中任何一种风格的分支的工作都是相同的：仅仅是正常做的检出、提交、抓取、合并、拉取与推送。
还有需要知道的一件事情是 Mercurial 不支持重写历史，只允许添加历史。
下面是我们的 Mercurial 仓库在交互式的变基与强制推送后的样子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ hg log --style compact -G
o  10[tip]   99611176cbc9   2014-08-14 20:21 -0700   ben
|    A permanent change
|
o  9   f23e12f939c3   2014-08-14 20:01 -0700   ben
|    Add some documentation
|
o  8:1   c16971d33922   2014-08-14 20:00 -0700   ben
|    goodbye
|
| o  7:5   a4529d07aad4   2014-08-14 20:21 -0700   ben
| |    A permanent change
| |
| | @  6   8f65e5e02793   2014-08-14 20:06 -0700   ben
| |/     More documentation
| |
| o    5[featureA]:4,2   bd5ac26f11f9   2014-08-14 20:02 -0700   ben
| |\     Merge remote-tracking branch 'origin/master'
| | |
| | o  4   0434aaa6b91f   2014-08-14 20:01 -0700   ben
| | |    update makefile
| | |
+---o  3:1   318914536c86   2014-08-14 20:00 -0700   ben
| |      goodbye
| |
| o  2   f098c7f45c4f   2014-08-14 20:01 -0700   ben
|/     Add some documentation
|
o  1   82e55d328c8c   2005-08-26 01:21 -0700   mpm
|    Create a makefile
|
o  0   0a04b987be5a   2005-08-26 01:20 -0700   mpm
     Create a standard "hello, world" program</code></pre>
</div>
</div>
<div class="paragraph">
<p>变更集 <em>8</em>、<em>9</em> 与 <em>10</em> 已经被创建出来并且属于 <code>permanent</code> 分支，但是旧的变更集依然在那里。
这会让使用 Mercurial 的团队成员非常困惑，所以要避免这种行为。</p>
</div>
</div>
<div class="sect4">
<h4 id="_mercurial_总结">Mercurial 总结</h4>
<div class="paragraph">
<p>Git 与 Mercurial 如此相似，以至于跨这两个系统进行工作十分流畅。
如果能注意避免改变在你机器上的历史（就像通常建议的那样），你甚至并不会察觉到另一端是 Mercurial。</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_git_与_perforce">Git 与 Perforce</h3>
<div class="paragraph">
<p>

在企业环境中 Perforce 是非常流行的版本管理系统。
它大概起始于 1995 年，这使它成为了本章中介绍的最古老的系统。
就其本身而言，它设计时带有当时时代的局限性；它假定你始终连接到一个单独的中央服务器，本地磁盘只保存一个版本。
诚然，它的功能与限制适合几个特定的问题，但实际上，在很多情况下，将使用 Perforce 的项目换做使用 Git 会更好。</p>
</div>
<div class="paragraph">
<p>如果你决定混合使用 Perforce 与 Git 这里有两种选择。
第一个我们要介绍的是 Perforce 官方制作的 “Git Fusion” 桥接，它可以将 Perforce 仓库中的子树表示为一个可读写的 Git 仓库。
第二个是 git-p4，一个客户端桥接允许你将 Git 作为 Perforce 的客户端使用，而不用在 Perforce 服务器上做任何重新的配置。</p>
</div>
<div class="sect4">
<h4 id="_p4_git_fusion">Git Fusion</h4>
<div class="paragraph">
<p>
Perforce 提供了一个叫作 Git Fusion 的产品（可在 <a href="http://www.perforce.com/git-fusion" class="bare">http://www.perforce.com/git-fusion</a> 获得），它将会在服务器这边同步 Perforce 服务器与 Git 仓库。</p>
</div>
<div class="sect5">
<h6 id="_设置_2">设置</h6>
<div class="paragraph">
<p>针对我们的例子，我们将会使用最简单的方式安装 Git Fusion：下载一个虚拟机来运行 Perforce 守护进程与 Git Fusion。
可以从 <a href="http://www.perforce.com/downloads/Perforce/20-User" class="bare">http://www.perforce.com/downloads/Perforce/20-User</a> 获得虚拟机镜像，下载完成后将它导入到你最爱的虚拟机软件中（我们将会使用 VirtualBox）。</p>
</div>
<div class="paragraph">
<p>在第一次启动机器后，它会询问你自定义三个 Linux 用户（<code>root</code>、<code>perforce</code> 与 <code>git</code>）的密码，
并且提供一个实例名字来区分在同一网络下不同的安装。当那些都完成后，将会看到这样：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/zh/v2/images/git-fusion-boot.png" >}}" alt="Git Fusion 虚拟机启动屏幕。">
</div>
<div class="title">Figure 146. Git Fusion 虚拟机启动屏幕。</div>
</div>
<div class="paragraph">
<p>应当注意显示在这儿的 IP 地址，我们将会在后面用到。
接下来，我们将会创建一个 Perforce 用户。
选择底部的 “Login” 选项并按下回车（或者用 SSH 连接到这台机器），然后登录为 <code>root</code>。
然后使用这些命令创建一个用户：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ p4 -p localhost:1666 -u super user -f john
$ p4 -p localhost:1666 -u john passwd
$ exit</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个命令将会打开一个 VI 编辑器来自定义用户，但是可以通过输入 <code>:wq</code> 并回车来接受默认选项。
第二个命令将会提示输入密码两次。
这就是所有我们要通过终端提示符做的事情，所以现在可以退出当前会话了。</p>
</div>
<div class="paragraph">
<p>接下来要做的事就是告诉 Git 不要验证 SSL 证书。
Git Fusion 镜像内置一个证书，但是域名并不匹配你的虚拟主机的 IP 地址，所以 Git 会拒绝 HTTPS 连接。
如果要进行永久安装，查阅 Perforce Git Fusion 手册来安装一个不同的证书；然而，对于我们这个例子来说，这已经足够了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ export GIT_SSL_NO_VERIFY=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们可以测试所有东西是不是正常工作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone https://10.0.1.254/Talkhouse
Cloning into 'Talkhouse'...
Username for 'https://10.0.1.254': john
Password for 'https://john@10.0.1.254':
remote: Counting objects: 630, done.
remote: Compressing objects: 100% (581/581), done.
remote: Total 630 (delta 172), reused 0 (delta 0)
Receiving objects: 100% (630/630), 1.22 MiB | 0 bytes/s, done.
Resolving deltas: 100% (172/172), done.
Checking connectivity... done.</code></pre>
</div>
</div>
<div class="paragraph">
<p>虚拟机镜像自带一个可以克隆的样例项目。
这里我们会使用之前创建的 <code>john</code> 用户，通过 HTTPS 进行克隆；Git 询问此次连接的凭证，但是凭证缓存会允许我们跳过这步之后的任意后续请求。</p>
</div>
</div>
<div class="sect5">
<h6 id="_fusion_配置">Fusion 配置</h6>
<div class="paragraph">
<p>一旦安装了 Git Fusion，你会想要调整配置。
使用你最爱的 Perforce 客户端做这件事实际上相当容易；只需要映射 Perforce 服务器上的 <code>//.git-fusion</code> 目录到你的工作空间。
文件结构看起来像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ tree
.
├── objects
│   ├── repos
│   │   └── [...]
│   └── trees
│       └── [...]
│
├── p4gf_config
├── repos
│   └── Talkhouse
│       └── p4gf_config
└── users
    └── p4gf_usermap

498 directories, 287 files</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>objects</code> 目录被 Git Fusion 内部用来双向映射 Perforce 对象与 Git 对象，你不必弄乱那儿的任何东西。
在这个目录中有一个全局的 <code>p4gf_config</code> 文件，每个仓库中也会有一份——这些配置文件决定了 Git Fusion 的行为。
让我们看一下根目录下的文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">[repo-creation]
charset = utf8

[git-to-perforce]
change-owner = author
enable-git-branch-creation = yes
enable-swarm-reviews = yes
enable-git-merge-commits = yes
enable-git-submodules = yes
preflight-commit = none
ignore-author-permissions = no
read-permission-check = none
git-merge-avoidance-after-change-num = 12107

[perforce-to-git]
http-url = none
ssh-url = none

[@features]
imports = False
chunked-push = False
matrix2 = False
parallel-push = False

[authentication]
email-case-sensitivity = no</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里我们并不会深入介绍这些选项的含义，但是要注意这是一个 INI 格式的文本文件，就像 Git 的配置。
这个文件指定了全局选项，但它可以被仓库特定的配置文件覆盖，像是 <code>repos/Talkhouse/p4gf_config</code>。
如果打开这个文件，你会看到有一些与全局默认不同设置的 <code>[@repo]</code> 区块。
你也会看到像下面这样的区块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">[Talkhouse-master]
git-branch-name = master
view = //depot/Talkhouse/main-dev/... ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是一个 Perforce 分支与一个 Git 分支的映射。
这个区块可以被命名成你喜欢的名字，只要保证名字是唯一的即可。
<code>git-branch-name</code> 允许你将在 Git 下显得笨重的仓库路径转换为更友好的名字。
<code>view</code> 选项使用标准视图映射语法控制 Perforce 文件如何映射到 Git 仓库。
可以指定一个以上的映射，就像下面的例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">[multi-project-mapping]
git-branch-name = master
view = //depot/project1/main/... project1/...
       //depot/project2/mainline/... project2/...</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过这种方式，如果正常工作空间映射包含对目录结构的修改，可以将其复制为一个 Git 仓库。</p>
</div>
<div class="paragraph">
<p>最后一个我们讨论的文件是 <code>users/p4gf_usermap</code>，它将 Perforce 用户映射到 Git 用户，但你可能不会需要它。
当从一个 Perforce 变更集转换为一个 Git 提交时，Git Fusion 的默认行为是去查找 Perforce 用户，然后把邮箱地址与全名存储在 Git 的 author/commiter 字段中。
当反过来转换时，默认的行为是根据存储在 Git 提交中 author 字段中的邮箱地址来查找 Perforce 用户，然后以该用户提交变更集（以及权限的应用）。
大多数情况下，这个行为工作得很好，但是考虑下面的映射文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>john john@example.com "John Doe"
john johnny@appleseed.net "John Doe"
bob employeeX@example.com "Anon X. Mouse"
joe employeeY@example.com "Anon Y. Mouse"</code></pre>
</div>
</div>
<div class="paragraph">
<p>每一行的格式都是 <code>&lt;user&gt; &lt;email&gt; "&lt;full name&gt;"</code>，创建了一个单独的用户映射。
前两行映射不同的邮箱地址到同一个 Perforce 用户账户。
当使用几个不同的邮箱地址（或改变邮箱地址）生成 Git 提交并且想要让他们映射到同一个 Perforce 用户时这会很有用。
当从一个 Perforce 变更集创建一个 Git 提交时，第一个匹配 Perforce 用户的行会被用作 Git 作者信息。</p>
</div>
<div class="paragraph">
<p>最后两行从创建的 Git 提交中掩盖了 Bob 与 Joe 的真实名字与邮箱地址。
当你想要将一个内部项目开源，但不想将你的雇员目录公布到全世界时这很不错。
注意邮箱地址与全名需要是唯一的，除非想要所有的 Git 提交都属于一个虚构的作者。</p>
</div>
</div>
<div class="sect5">
<h6 id="_工作流程_3">工作流程</h6>
<div class="paragraph">
<p>Perforce Git Fusion 是在 Perforce 与 Git 版本控制间双向的桥接。
让我们看一下在 Git 这边工作是什么样的感觉。
假定我们在 “Jam” 项目中使用上述的配置文件映射了，可以这样克隆：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone https://10.0.1.254/Jam
Cloning into 'Jam'...
Username for 'https://10.0.1.254': john
Password for 'https://john@10.0.1.254':
remote: Counting objects: 2070, done.
remote: Compressing objects: 100% (1704/1704), done.
Receiving objects: 100% (2070/2070), 1.21 MiB | 0 bytes/s, done.
remote: Total 2070 (delta 1242), reused 0 (delta 0)
Resolving deltas: 100% (1242/1242), done.
Checking connectivity... done.
$ git branch -a
* master
  remotes/origin/HEAD -&gt; origin/master
  remotes/origin/master
  remotes/origin/rel2.1
$ git log --oneline --decorate --graph --all
* 0a38c33 (origin/rel2.1) Create Jam 2.1 release branch.
| * d254865 (HEAD, origin/master, origin/HEAD, master) Upgrade to latest metrowerks on Beos -- the Intel one.
| * bd2f54a Put in fix for jam's NT handle leak.
| * c0f29e7 Fix URL in a jam doc
| * cc644ac Radstone's lynx port.
[...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>当首次这样做时，会花费一些时间。
这里发生的是 Git Fusion 会将在 Perforce 历史中所有合适的变更集转换为 Git 提交。
这发生在服务器端本地，所以会相当快，但是如果有很多历史，那么它还是会花费一些时间。
后来的抓取会做增量转换，所以会感觉更像 Git 的本地速度。</p>
</div>
<div class="paragraph">
<p>如你所见，我们的仓库看起来像之前使用过的任何一个 Git 仓库了。
这里有三个分支，Git 已经帮助创建了一个跟踪 <code>origin/master</code> 的本地 <code>master</code> 分支。
让我们做一些工作，创建几个新提交：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console"># ...
$ git log --oneline --decorate --graph --all
* cfd46ab (HEAD, master) Add documentation for new feature
* a730d77 Whitespace
* d254865 (origin/master, origin/HEAD) Upgrade to latest metrowerks on Beos -- the Intel one.
* bd2f54a Put in fix for jam's NT handle leak.
[...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们有两个新提交。
现在我们检查下是否有其他人在工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git fetch
remote: Counting objects: 5, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 2), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://10.0.1.254/Jam
   d254865..6afeb15  master     -&gt; origin/master
$ git log --oneline --decorate --graph --all
* 6afeb15 (origin/master, origin/HEAD) Update copyright
| * cfd46ab (HEAD, master) Add documentation for new feature
| * a730d77 Whitespace
|/
* d254865 Upgrade to latest metrowerks on Beos -- the Intel one.
* bd2f54a Put in fix for jam's NT handle leak.
[...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>看起来有人在工作！
从这个视图来看你并不知道这点，但是 <code>6afeb15</code> 提交确实是使用 Perforce 客户端创建的。
从 Git 的视角看它仅仅只是另一个提交，准确地说是一个点。
让我们看看 Perforce 服务器如何处理一个合并提交：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge origin/master
Auto-merging README
Merge made by the 'recursive' strategy.
 README | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
$ git push
Counting objects: 9, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (9/9), done.
Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.
Total 9 (delta 6), reused 0 (delta 0)
remote: Perforce: 100% (3/3) Loading commit tree into memory...
remote: Perforce: 100% (5/5) Finding child commits...
remote: Perforce: Running git fast-export...
remote: Perforce: 100% (3/3) Checking commits...
remote: Processing will continue even if connection is closed.
remote: Perforce: 100% (3/3) Copying changelists...
remote: Perforce: Submitting new Git commit objects to Perforce: 4
To https://10.0.1.254/Jam
   6afeb15..89cba2b  master -&gt; master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git 认为它成功了。
让我们从 Perforce 的视角看一下 <code>README</code> 文件的历史，使用 <code>p4v</code> 的版本图功能。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/zh/v2/images/git-fusion-perforce-graph.png" >}}" alt="Git 推送后的 Perforce 版本图。">
</div>
<div class="title">Figure 147. Git 推送后的 Perforce 版本图</div>
</div>
<div class="paragraph">
<p>如果你在之前从未看过这个视图，它似乎让人困惑，但是它显示出了作为 Git 历史图形化查看器相同的概念。
我们正在查看 <code>README</code> 文件的历史，所以左上角的目录树只显示那个文件在不同分支的样子。
右上方，我们有不同版本文件关系的可视图，这个可视图的全局视图在右下方。
视图中剩余的部分显示出选择版本的详细信息（在这个例子中是 <code>2</code>）</p>
</div>
<div class="paragraph">
<p>还要注意的一件事是这个图看起来很像 Git 历史中的图。
Perforce 没有存储 <code>1</code> 和 <code>2</code> 提交的命名分支，所以它在 <code>.git-fusion</code> 目录中生成了一个 “anonymous” 分支来保存它。
这也会在 Git 命名分支不对应 Perforce 命名分支时发生（稍后你可以使用配置文件来映射它们到 Perforce 分支）。</p>
</div>
<div class="paragraph">
<p>这些大多数发生在后台，但是最终结果是团队中的一个人可以使用 Git，另一个可以使用 Perforce，而所有人都不知道其他人的选择。</p>
</div>
</div>
<div class="sect5">
<h6 id="_git_fusion_总结">Git-Fusion 总结</h6>
<div class="paragraph">
<p>如果你有（或者能获得）接触你的 Perforce 服务器的权限，那么 Git Fusion 是使 Git 与 Perforce 互相交流的很好的方法。
这里包含了一点配置，但是学习曲线并不是很陡峭。
这是本章中其中一个不会出现无法使用 Git 全部能力的警告的章节。
这并不是说扔给 Perforce 任何东西都会高兴——如果你尝试重写已经推送的历史，Git Fusion 会拒绝它——虽然 Git Fusion 尽力让你感觉是原生的。
你甚至可以使用 Git 子模块（尽管它们对 Perforce 用户看起来很奇怪），合并分支（在 Perforce 这边会被记录了一次整合）。</p>
</div>
<div class="paragraph">
<p>如果不能说服你的服务器管理员设置 Git Fusion，依然有一种方式来一起使用这两个工具。</p>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_git_p4_client">Git-p4</h4>
<div class="paragraph">
<p>
Git-p4 是 Git 与 Perforce 之间的双向桥接。
它完全运行在你的 Git 仓库内，所以你不需要任何访问 Perforce 服务器的权限（当然除了用户验证）。
Git-p4 并不像 Git Fusion 一样灵活或完整，但是它允许你在无需修改服务器环境的情况下，做大部分想做的事情。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>为了与 git-p4 一起工作需要在你的 <code>PATH</code> 环境变量中的某个目录中有 <code>p4</code> 工具。
在写这篇文章的时候，它可以在 <a href="http://www.perforce.com/downloads/Perforce/20-User" class="bare">http://www.perforce.com/downloads/Perforce/20-User</a> 免费获得。</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="_设置_3">设置</h6>
<div class="paragraph">
<p>出于演示的目的，我们将会从上面演示的 Git Fusion OVA 运行 Perforce 服务器，但是我们会绕过 Git Fusion 服务器然后直接进行 Perforce 版本管理。</p>
</div>
<div class="paragraph">
<p>为了使用 <code>p4</code> 命令行客户端（git-p4 依赖项），你需要设置两个环境变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ export P4PORT=10.0.1.254:1666
$ export P4USER=john</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_开始_3">开始</h6>
<div class="paragraph">
<p>像在 Git 中的任何事情一样，第一个命令就是克隆：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git p4 clone //depot/www/live www-shallow
Importing from //depot/www/live into www-shallow
Initialized empty Git repository in /private/tmp/www-shallow/.git/
Doing initial import of //depot/www/live/ from revision #head into refs/remotes/p4/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样会创建出一种在 Git 中名为 “shallow” 的克隆；只有最新版本的 Perforce 被导入至 Git；记住，Perforce 并未被设计成给每一个用户一个版本。
使用 Git 作为 Perforce 客户端这样就足够了，但是为了其他目的的话这样可能不够。</p>
</div>
<div class="paragraph">
<p>完成之后，我们就有一个全功能的 Git 仓库：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cd myproject
$ git log --oneline --all --graph --decorate
* 70eaf78 (HEAD, p4/master, p4/HEAD, master) Initial import of //depot/www/live/ from the state at revision #head</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意有一个 “p4” 远程代表 Perforce 服务器，但是其他东西看起来就像是标准的克隆。
实际上，这有一点误导：其实远程仓库并不存在。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote -v</code></pre>
</div>
</div>
<div class="paragraph">
<p>在当前仓库中并不存在任何远程仓库。
Git-p4 创建了一些引用来代表服务器的状态，它们看起来类似 <code>git log</code> 显示的远程引用，但是它们并不被 Git 本身管理，并且你无法推送它们。</p>
</div>
</div>
<div class="sect5">
<h6 id="_工作流程_4">工作流程</h6>
<div class="paragraph">
<p>好了，让我们开始一些工作。
假设你已经在一个非常重要的功能上做了一些工作，然后准备好将它展示给团队中的其他人。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --all --graph --decorate
* 018467c (HEAD, master) Change page title
* c0fb617 Update link
* 70eaf78 (p4/master, p4/HEAD) Initial import of //depot/www/live/ from the state at revision #head</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们已经生成了两次新提交并已准备好推送它们到 Perforce 服务器。
让我们检查一下今天其他人是否做了一些工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git p4 sync
git p4 sync
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
Import destination: refs/remotes/p4/master
Importing revision 12142 (100%)
$ git log --oneline --all --graph --decorate
* 75cd059 (p4/master, p4/HEAD) Update copyright
| * 018467c (HEAD, master) Change page title
| * c0fb617 Update link
|/
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</code></pre>
</div>
</div>
<div class="paragraph">
<p>看起来他们做了，<code>master</code> 与 <code>p4/master</code> 已经分叉了。
Perforce 的分支系统一点也 <em>不</em> 像 Git 的，所以提交合并提交没有任何意义。
Git-p4 建议变基你的提交，它甚至提供了一个快捷方式来这样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git p4 rebase
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
No changes to import!
Rebasing the current branch onto remotes/p4/master
First, rewinding head to replay your work on top of it...
Applying: Update link
Applying: Change page title
 index.html | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>从输出中可能大概得知，<code>git p4 rebase</code> 是 <code>git p4 sync</code> 接着 <code>git rebase p4/master</code> 的快捷方式。
它比那更聪明一些，特别是工作在多个分支时，但这是一个进步。</p>
</div>
<div class="paragraph">
<p>现在我们的历史再次是线性的，我们准备好我们的改动贡献回 Perforce。
<code>git p4 submit</code> 命令会尝试在 <code>p4/master</code> 与 <code>master</code> 之间的每一个 Git 提交创建一个新的 Perforce 修订版本。
运行它会带我们到最爱的编辑器，文件内容看起来像是这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console"># A Perforce Change Specification.
#
#  Change:      The change number. 'new' on a new changelist.
#  Date:        The date this specification was last modified.
#  Client:      The client on which the changelist was created.  Read-only.
#  User:        The user who created the changelist.
#  Status:      Either 'pending' or 'submitted'. Read-only.
#  Type:        Either 'public' or 'restricted'. Default is 'public'.
#  Description: Comments about the changelist.  Required.
#  Jobs:        What opened jobs are to be closed by this changelist.
#               You may delete jobs from this list.  (New changelists only.)
#  Files:       What opened files from the default changelist are to be added
#               to this changelist.  You may delete files from this list.
#               (New changelists only.)

Change:  new

Client:  john_bens-mbp_8487

User: john

Status:  new

Description:
   Update link

Files:
   //depot/www/live/index.html   # edit


######## git author ben@straub.cc does not match your p4 account.
######## Use option --preserve-user to modify authorship.
######## Variable git-p4.skipUserNameCheck hides this message.
######## everything below this line is just the diff #######
--- //depot/www/live/index.html  2014-08-31 18:26:05.000000000 0000
+++ /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/index.html   2014-08-31 18:26:05.000000000 0000
@@ -60,7 +60,7 @@
 &lt;/td&gt;
 &lt;td valign=top&gt;
 Source and documentation for
-&lt;a href="http://www.perforce.com/jam/jam.html"&gt;
+&lt;a href="jam.html"&gt;
 Jam/MR&lt;/a&gt;,
 a software build tool.
 &lt;/td&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>除了结尾 git-p4 给我们的帮助性的提示，其它的与你运行 <code>p4 submit</code> 后看到的内容大多相同。
当提交或变更集需要一个名字时 git-p4 会分别尝试使用你的 Git 与 Perforce 设置，但是有些情况下你会想要覆盖默认行为。
例如，如果你正导入的提交是由没有 Perforce 用户账户的贡献者编写的，你还是会想要最终的变更集看起来像是他们写的（而不是你）。</p>
</div>
<div class="paragraph">
<p>Git-p4 帮助性地将 Git 的提交注释导入到 Perforce 变更集的内容，这样所有我们必须做的就是保存并退出，两次（每次一个提交）。
这会使 shell 输出看起来像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git p4 submit
Perforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Synchronizing p4 checkout...
... - file(s) up-to-date.
Applying dbac45b Update link
//depot/www/live/index.html#4 - opened for edit
Change 12143 created with 1 open file(s).
Submitting change 12143.
Locking 1 files ...
edit //depot/www/live/index.html#5
Change 12143 submitted.
Applying 905ec6a Change page title
//depot/www/live/index.html#5 - opened for edit
Change 12144 created with 1 open file(s).
Submitting change 12144.
Locking 1 files ...
edit //depot/www/live/index.html#6
Change 12144 submitted.
All commits applied!
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
Import destination: refs/remotes/p4/master
Importing revision 12144 (100%)
Rebasing the current branch onto remotes/p4/master
First, rewinding head to replay your work on top of it...
$ git log --oneline --all --graph --decorate
* 775a46f (HEAD, p4/master, p4/HEAD, master) Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</code></pre>
</div>
</div>
<div class="paragraph">
<p>结果恰如我们只是做了一次 <code>git push</code>，就像是应当实际发生的最接近的类比。</p>
</div>
<div class="paragraph">
<p>注意在这个过程中每一个 Git 提交都会被转化为一个 Perforce 变更集。
如果想要将它们压缩成为一个单独的提交，可以在运行 <code>git p4 submit</code> 前进行一次交互式变基。
同样注意的是所有被转化为变更集的提交的 SHA-1 校验和都改变了，
这是因为 git-p4 在每一个转化的提交增加一行到提交注释结尾：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -1
commit 775a46f630d8b46535fc9983cf3ebe6b9aa53145
Author: John Doe &lt;john@example.com&gt;
Date:   Sun Aug 31 10:31:44 2014 -0800

    Change page title

    [git-p4: depot-paths = "//depot/www/live/": change = 12144]</code></pre>
</div>
</div>
<div class="paragraph">
<p>当尝试提交一次合并提交时会发生什么？
让我们尝试一下。
这是我们可能会遇到的一种情形：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --all --graph --decorate
* 3be6fd8 (HEAD, master) Correct email address
*   1dcbf21 Merge remote-tracking branch 'p4/master'
|\
| * c4689fc (p4/master, p4/HEAD) Grammar fix
* | cbacd0a Table borders: yes please
* | b4959b6 Trademark
|/
* 775a46f Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git 与 Perforce 历史在 775a46f 后分叉了。
Git 这边有两次提交，然后一次与 Perforce 头部的合并提交，还有另一个提交。
我们将会尝试提交这些到 Perforce 那边单独的变更集之上。
让我们看看如果尝试这样提交会发生什么：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git p4 submit -n
Perforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Would synchronize p4 checkout in /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Would apply
  b4959b6 Trademark
  cbacd0a Table borders: yes please
  3be6fd8 Correct email address</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>-n</code> 标记是 <code>--dry-run</code> 的缩写，将会报告如果提交命令真的运行会发生什么。
这本例中，它看起来像是我们会创建三个 Perforce 变更集，对应着不在 Perforce 服务器端的三次非合并提交。
那听起来像是我们想要的，让我们看看它会如何做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git p4 submit
[…]
$ git log --oneline --all --graph --decorate
* dadbd89 (HEAD, p4/master, p4/HEAD, master) Correct email address
* 1b79a80 Table borders: yes please
* 0097235 Trademark
* c4689fc Grammar fix
* 775a46f Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们的历史变成线性了，就像在提交前刚刚变基过（实际上也是这样）。
这意味着你可以在 Git 这边自由地创建、工作、扔掉与合并分支而不用害怕你的历史会变得与 Perforce 不兼容。
如果你可以变基它，你就可以将它贡献到 Perforce 服务器。</p>
</div>
</div>
<div class="sect5">
<h6 id="_git_p4_branches">分支</h6>
<div class="paragraph">
<p>如果你的 Perforce 项目有多个分支，你并不会不走运；git-p4 可以以一种类似 Git 的方式来处理那种情况。
假定你的 Perforce 仓库平铺的时候像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>//depot
  └── project
      ├── main
      └── dev</code></pre>
</div>
</div>
<div class="paragraph">
<p>并且假定你有一个 <code>dev</code> 分支，有一个视图规格像下面这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>//depot/project/main/... //depot/project/dev/...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git-p4 可以自动地检测到这种情形并做正确的事情：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git p4 clone --detect-branches //depot/project@all
Importing from //depot/project@all into project
Initialized empty Git repository in /private/tmp/project/.git/
Importing revision 20 (50%)
    Importing new branch project/dev

    Resuming with change 20
Importing revision 22 (100%)
Updated branches: main dev
$ cd project; git log --oneline --all --graph --decorate
* eae77ae (HEAD, p4/master, p4/HEAD, master) main
| * 10d55fb (p4/project/dev) dev
| * a43cfae Populate //depot/project/main/... //depot/project/dev/....
|/
* 2b83451 Project init</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意在仓库路径中的 “@all” 说明符；那会告诉 git-p4 不仅仅只是克隆那个子树最新的变更集，更包括那些路径未接触的所有变更集。
这有点类似于 Git 的克隆概念，但是如果你工作在一个具有很长历史的项目，那么它会花费一段时间。</p>
</div>
<div class="paragraph">
<p><code>--detect-branches</code> 标记告诉 git-p4 使用 Perforce 的分支规范来映射到 Git 的引用中。
如果这些映射不在 Perforce 服务器中（使用 Perforce 的一种完美有效的方式），你可以告诉 git-p4 分支映射是什么，然后你会得到同样的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git init project
Initialized empty Git repository in /tmp/project/.git/
$ cd project
$ git config git-p4.branchList main:dev
$ git clone --detect-branches //depot/project@all .</code></pre>
</div>
</div>
<div class="paragraph">
<p>设置 <code>git-p4.branchList</code> 配置选项为 <code>main:dev</code> 告诉 git-p4 那个 “main” 与 “dev” 都是分支，第二个是第一个的子分支。</p>
</div>
<div class="paragraph">
<p>如果我们现在运行 <code>git checkout -b dev p4/project/dev</code> 并且做一些提交，在运行 <code>git p4 submit</code> 时 git-p4 会聪明地选择正确的分支。
不幸的是，git-p4 不能混用 shallow 克隆与多个分支；如果你有一个巨型项目并且想要同时工作在不止一个分支上，可能不得不针对每一个你想要提交的分支运行一次 <code>git p4 clone</code>。</p>
</div>
<div class="paragraph">
<p>为了创建与整合分支，你不得不使用一个 Perforce 客户端。
Git-p4 只能同步或提交已有分支，并且它一次只能做一个线性的变更集。
如果你在 Git 中合并两个分支并尝试提交新的变更集，所有这些会被记录为一串文件修改；关于哪个分支参与的元数据在整合中会丢失。</p>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_git_与_perforce_总结">Git 与 Perforce 总结</h4>
<div class="paragraph">
<p>Git-p4 将与 Perforce 服务器工作时使用 Git 工作流成为可能，并且它非常擅长这点。
然而，需要记住的重要一点是 Perforce 负责源头，而你只是在本地使用 Git。
在共享 Git 提交时要相当小心：如果你有一个其他人使用的远程仓库，不要在提交到 Perforce 服务器前推送任何提交。</p>
</div>
<div class="paragraph">
<p>如果想要为源码管理自由地混合使用 Perforce 与 Git 作为客户端，可以说服服务器管理员安装 Git Fusion，Git Fusion 使 Git 作为 Perforce 服务器的首级版本管理客户端。</p>
</div>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>