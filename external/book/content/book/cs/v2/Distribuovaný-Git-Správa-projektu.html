---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: cs
  chapter:
    title: Distribuovaný Git
    number: 5
  section:
    title: Správa projektu
    number: 3
    cs_number: '5.3'
    previous: book/cs/v2/Distribuovaný-Git-Přispívání-do-projektu
    next: book/cs/v2/Distribuovaný-Git-Shrnutí
title: Git - Správa projektu
url: "/book/cs/v2/Distribuovaný-Git-Správa-projektu.html"
---
<h2 id="_správa_projektu">Správa projektu</h2>
<div class="paragraph">
<p>
K znalosti toho, jak lze do projektu efektivně přispívat, budete pravděpodobně muset vědět, jak ho spravovat.
Spadá sem přijímání a aplikování záplat generovaných příkazem <code>format-patch</code> a zaslaných elektronickou poštou, nebo integrování změn ve vzdálených větvích pro repozitáře, které jste do svého projektu přidali jako vzdálené repozitáře.
Ať už spravujete obecně uznávaný repozitář, nebo chcete pomáhat při ověřování či schvalování záplat, budete muset vědět, jak přijímat práci ostatních přispěvatelů způsobem, který je pro ostatní přispěvatele co nejčistší a pro vás dlouhodobě udržitelný.</p>
</div>
<div class="sect3">
<h3 id="_práce_v_tématických_větvích">Práce v tématických větvích</h3>
<div class="paragraph">
<p>Pokud uvažujete o integraci nové práce do projektu, je většinou dobré vyzkoušet si to v tématické větvi, tj. v dočasné větvi, kterou vytvoříte konkrétně pro vyzkoušení této práce.
Tímto způsobem můžete záplatu odděleně doladit, a pokud není funkční, můžete ji nechat být až do doby, kdy najdete čas se k ní vrátit.
Pokud pro větev vytvoříte jednoduchý název spojený s tématem testované práce (například <code>ruby_client</code> nebo něco obdobně popisného), snadno si zase vzpomenete, pokud ji na nějakou dobu opustíte a vrátíte se k až tomu později.
Správce projektu v Gitu má sklony přidělovat těmto větvím také jmenný prostor — například <code>sc/ruby_client</code>, kde <code>sc</code> je zkratka pro osobu, která práci vytvořila.
Jak si vzpomínáte, můžete větev založenou na své větvi <code>master</code> vytvořit takto:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch sc/ruby_client master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nebo, pokud na ni chcete rovnou přepnout, můžete použít volbu <code>checkout -b</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b sc/ruby_client master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Teď jste připraveni svůj příspěvek do této tématické větve přidat a rozhodnout se, zda ji začleníte do své větve s delší životností.</p>
</div>
</div>
<div class="sect3">
<h3 id="_patches_from_email">Aplikace záplat zaslaných elektronickou poštou</h3>
<div class="paragraph">
<p>
Pokud elektronickou poštou obdržíte záplatu, kterou potřebujete integrovat do svého projektu, budete ji chtít aplikovat do tématické větve, kde ji posoudíte.
Záplatu zaslanou elektronickou poštou lze aplikovat dvěma způsoby: příkazem <code>git apply</code> nebo příkazem <code>git am</code>.</p>
</div>
<div class="sect4">
<h4 id="_aplikace_záplaty_příkazem_apply">Aplikace záplaty příkazem <code>apply</code>
</h4>
<div class="paragraph">
<p>
Pokud dostanete záplatu od někoho, kdo ji vygeneroval příkazem <code>git diff</code> nebo unixovým příkazem <code>diff</code> (což se nedoporučuje — viz následující část), můžete ji aplikovat příkazem <code>git apply</code>.
Za předpokladu, že jste záplatu uložili jako <code>/tmp/patch-ruby-client.patch</code>, můžete záplatu aplikovat následovně:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git apply /tmp/patch-ruby-client.patch</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tím se soubory ve svém pracovním adresáři změní.
Je to téměř stejné, jako byste k aplikaci záplaty použili příkaz <code>patch -p1</code>. Příkaz <code>apply</code> je ale víc paranoidní a přijímá méně přibližných shod než příkaz <code>patch</code>.
Poradí si také s přidanými, odstraněnými a přejmenovanými soubory, jsou-li popsány ve formátu <code>git diff</code>, což by příkaz <code>patch</code> neudělal.
A konečně příkaz <code>git apply</code> pracuje na principu „aplikuj vše, nebo zruš vše“. Buď jsou tedy aplikovány všechny soubory, nebo žádný. Naproti tomu příkaz <code>patch</code> může aplikovat soubory záplat jen částečně a tím zanechat váš pracovní adresář v podivném stavu.
Příkaz <code>git apply</code> je celkově konzervativnější než příkaz <code>patch</code>.
Tímto příkazem se nezapíše revize. Po jeho provedení budete muset připravit a zapsat provedené změny ručně.</p>
</div>
<div class="paragraph">
<p>Příkaz <code>git apply</code> můžete použít také ke kontrole, zda bude záplata aplikována čistě ještě před tím, než skutečnou aplikaci provedete. V takovém případě pro záplatu použijte příkaz <code>git apply --check</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git apply --check 0001-seeing-if-this-helps-the-gem.patch
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pokud se nezobrazí žádný výstup, bude záplata aplikována čistě.
Jestliže kontrola selže, vrací příkaz nenulový návratový kód, a proto ho můžete snadno používat ve skriptech.</p>
</div>
</div>
<div class="sect4">
<h4 id="_git_am">Aplikace záplaty příkazem <code>am</code>
</h4>
<div class="paragraph">
<p>
Pokud je přispěvatel uživatelem Gitu a byl natolik dobrý, že k vygenerování záplaty použil příkaz <code>format-patch</code>, budete mít usnadněnou práci, protože záplata obsahuje informace o autorovi a zprávu k revizi.
Můžete-li, doporučte svým přispěvatelům, aby místo příkazu <code>diff</code> používali příkaz <code>format-patch</code>.
K použití příkazu <code>git apply</code> byste měli být nuceni jen v případě použití starého typu záplat.</p>
</div>
<div class="paragraph">
<p>K aplikaci záplaty vygenerované příkazem <code>format-patch</code> používejte příkaz <code>git am</code>.
Z technického hlediska je <code>git am</code> navržen tak, aby četl soubor ve formátu elektronické pošty (mbox), což je jednoduchý textový formát pro uložení jedné nebo více e-mailových zpráv do jednoho textového souboru.
Vypadá například takto:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith &lt;jessica@example.com&gt;
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20</code></pre>
</div>
</div>
<div class="paragraph">
<p>Toto je začátek výstupu příkazu format-patch, který jste viděli v předchozí části.
Zároveň je to také platný e-mailový formát mbox.
Pokud vám někdo poslal záplatu příkazem <code>git send-email</code> a vy záplatu stáhnete do formátu mbox, můžete tento soubor mbox předat příkazu <code>git am</code> a ten začne aplikovat všechny záplaty, které najde.
Jestliže spustíte poštovního klienta, který dokáže uložit několik e-mailů ve formátu mbox, můžete do jednoho souboru uložit celou sérii záplat a příkazem <code>git am</code> je pak aplikovat všechny najednou.</p>
</div>
<div class="paragraph">
<p>Pokud však někdo nahrál soubor záplaty vygenerovaný příkazem <code>format-patch</code> do tiketového nebo podobného systému, můžete soubor uložit lokálně a poté jej aplikovat předáním uloženého souboru příkazu <code>git am</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git am 0001-limit-log-function.patch
Applying: add limit to log function</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jak vidíte, záplata byla aplikována čistě a automaticky byla vytvořena nová revize.
Informace o autorovi jsou převzaty z hlavičkových polí e-mailu <code>From</code> a <code>Date</code>, zpráva k revizi je převzata z pole <code>Subject</code> a těla e-mailu (před samotnou záplatou).
Pokud byla záplata aplikována například ze souboru mbox z předchozího příkladu, bude vygenerovaná revize vypadat zhruba takto:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --pretty=fuller -1
commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
Author:     Jessica Smith &lt;jessica@example.com&gt;
AuthorDate: Sun Apr 6 10:17:23 2008 -0700
Commit:     Scott Chacon &lt;schacon@gmail.com&gt;
CommitDate: Thu Apr 9 09:19:06 2009 -0700

   add limit to log function

   Limit log functionality to the first 20</code></pre>
</div>
</div>
<div class="paragraph">
<p>Informace <code>Commit</code> uvádí osobu, která záplatu aplikovala, a čas, kdy se tak stalo.
Informace <code>Author</code> uvádí jedince, který záplatu původně vytvořil, a kdy tak učinil.</p>
</div>
<div class="paragraph">
<p>Může se ale stát, že záplata nebude aplikována čistě.
Vaše hlavní větev se mohla příliš odchýlit od větve, z níž byla záplata vytvořena, nebo je záplata závislá na jiné záplatě, kterou jste ještě neaplikovali.
V takovém případě proces <code>git am</code> selže a zeptá se vás, co chcete udělat dál:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git am 0001-seeing-if-this-helps-the-gem.patch
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Patch failed at 0001.
When you have resolved this problem run "git am --resolved".
If you would prefer to skip this patch, instead run "git am --skip".
To restore the original branch and stop patching run "git am --abort".</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tento příkaz vloží značky konfliktu do všech problematických souborů — podobně jako při konfliktu u operací sloučení (merge) nebo přeskládání (rebase).
Problém se řešíte v podstatě stejným způsobem. Úpravou souboru konflikt odstraňte, připravte nový soubor k zapsání a spusťte příkaz <code>git am --resolved</code>, čímž se přesunete k následující záplatě:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ (fix the file)
$ git add ticgit.gemspec
$ git am --resolved
Applying: seeing if this helps the gem</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pokud chcete, aby se Git pokusil vyřešit konflikt inteligentněji, můžete zadat volbu <code>-3</code>. Git se pokusí o třícestné sloučení.
Tato možnost není nastavena jako výchozí, protože ji nelze použít v situaci, kdy revize, o níž záplata říká, že je na ní založena, není obsažena ve vašem repozitáři.
Pokud ale tuto revizi k dispozici máte — záplata byla založena na veřejné revizi — vede volba <code>-3</code> k mnohem inteligentnější  aplikaci kolidující záplaty:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git am -3 0001-seeing-if-this-helps-the-gem.patch
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
No changes -- Patch already applied.</code></pre>
</div>
</div>
<div class="paragraph">
<p>V tomto případě už byla záplata aplikována.
Bez volby <code>-3</code> by to vypadalo jako konflikt.</p>
</div>
<div class="paragraph">
<p>Pokud aplikujete několik záplat z jednoho souboru mbox, můžete příkaz <code>am</code> spustit také v interaktivním režimu, který zastaví před každou nalezenou záplatou a zeptá se vás, zda ji chcete aplikovat:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git am -3 -i mbox
Commit Body is:
--------------------------
seeing if this helps the gem
--------------------------
Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all</code></pre>
</div>
</div>
<div class="paragraph">
<p>To oceníte v situaci, kdy už máte uložených více záplat, protože pokud si nepamatujete, o co v záplatě jde, můžete si ji před aplikací prohlédnout a neaplikovat ji, pokud už jste tak učinili dříve.</p>
</div>
<div class="paragraph">
<p>Až budete mít všechny záplaty aplikovány a zapsány do tématické větve, můžete se rozhodnout, zda a jak je chcete integrovat do některé z trvalejších větví.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_checking_out_remotes">Získání vzdálených větví (checkout)</h3>
<div class="paragraph">
<p>
Pokud váš příspěvek pochází od uživatele Gitu, který založil vlastní repozitář, odeslal do něj sérii změn a následně vám poslal adresu repozitáře (URL) a název vzdálené větve, v níž změny najdete, můžete je přidat jako vzdálené a lokálně je začlenit.</p>
</div>
<div class="paragraph">
<p>Pokud vám například Jessica poslala dopis, že ve svém repozitáři ve větvi <code>ruby-client</code> vytvořila skvělou novou funkci, můžete si ji po přidání vzdáleného repozitáře a po získání obsahu zmíněné větve otestovat lokálně:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add jessica git://github.com/jessica/myproject.git
$ git fetch jessica
$ git checkout -b rubyclient jessica/ruby-client</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pokud vám později znovu napíše, že jiná větev obsahuje další skvělou funkci, můžete tuto větev vyzvednout a získat její obsah, protože už repozitář máte nastaven jako vzdálený.</p>
</div>
<div class="paragraph">
<p>Užitečné je to zejména tehdy, když s někým spolupracujete dlouhodobě.
Pokud někdo přispěje jen sem tam jednou záplatou, pak bude časově výhodnější, když vám ji pošle e-mailem, než abyste všechny přispěvatele kvůli pár záplatám nutili zprovoznit si vlastní server a abyste si stále přidávali a odstraňovali vzdálené repozitáře.
Asi byste taky nechtěli spravovat stovky vzdálených repozitářů — jeden pro každého, kdo přispěje jednou či dvěma záplatami.
Ale skripty a hostované služby tento přístup mohou velmi usnadnit. Do velké míry tu záleží na tom, jak vy a vaši vývojáři k vývoji přistupujete.</p>
</div>
<div class="paragraph">
<p>Další výhodou tohoto postupu je, že získáte rovněž historii revizí.
I když můžete při slučování narazit na opodstatněné problémy, víte, z jakých historických základů jejich práce vychází. Řádné třícestné sloučení je vždy lepším řešením, než nutnost zadat volbu <code>-3</code> a doufat, že byla záplata vygenerována z veřejné revize, kterou máte k dispozici.</p>
</div>
<div class="paragraph">
<p>Pokud s někým nespolupracujete dlouhodobě, ale přesto od něj chcete stáhnout data tímto způsobem, můžete zadat URL vzdáleného repozitáře k příkazu <code>git pull</code>.
Provede se jednorázové stažení a URL se neuloží jako odkaz na vzdálený repozitář:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git pull https://github.com/onetimeguy/project
From https://github.com/onetimeguy/project
 * branch            HEAD       -&gt; FETCH_HEAD
Merge made by recursive.</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_what_is_introduced">Jak zjistit provedené změny</h3>
<div class="paragraph">
<p>
Máte tématickou větev, která obsahuje příspěvek od jiného vývojáře.
V tomto okamžiku můžete určit, co byste s ním rádi udělali.
V této části si zopakujeme několik příkazů, abyste viděli, jak se dají použít k přesnému zjištění toho, co se v případě sloučení (merge) dostane do vaší hlavní větve.</p>
</div>
<div class="paragraph">
<p>Často může být užitečné získat přehled o všech revizích, které jsou obsaženy v určité větvi, ale nejsou ve vaší větvi <code>master</code>.
Revize ve větvi <code>master</code> lze vyloučit přidáním volby <code>--not</code> před název větve.
Činnost je stejná jako při uvedení tvaru <code>master..contrib</code>, který jsme použili dříve.
Pokud vám například přispěvatel pošle dvě záplaty a vy vytvoříte větev s názvem <code>contrib</code>, do níž tyto záplaty aplikujete, můžete spustit následující příkaz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log contrib --not master
commit 5b6235bd297351589efc4d73316f0a68d484f118
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Oct 24 09:53:59 2008 -0700

    seeing if this helps the gem

commit 7482e0d16d04bea79d0dba8988cc78df655f16a0
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Mon Oct 22 19:38:36 2008 -0700

    updated the gemspec to hopefully work better</code></pre>
</div>
</div>
<div class="paragraph">
<p>Chcete-li zjistit, jaké změny byly provedeny v jednotlivých revizích, můžete k příkazu <code>git log</code> přidat volbu <code>-p</code>, která ke každé revizi připojí rozdíly ve formátu diff.</p>
</div>
<div class="paragraph">
<p>Chcete-li vidět úplný výpis rozdílů, které by vznikly sloučením této tématické větve s jinou větví, budete muset pro obdržení správných výsledků použít zvláštní trik.
Možná vás napadne, že byste spustili příkaz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Výstupem příkazu bude výpis rozdílů, ale může být zavádějící.
Pokud se vaše větev <code>master</code> posunula vpřed od chvíle, kdy jste z ní vytvořili tématickou větev, dostanete zdánlivě nesmyslné výsledky.
Je to tím, že Git přímo porovnává snímek poslední revize v tématické větvi, na které se nacházíte, se snímkem poslední revize ve větvi <code>master</code>.
Pokud jste například do souboru ve větvi <code>master</code> přidali jeden řádek, přímé srovnání snímků bude vypadat, jako kdyby měla tématická větev tento řádek odstranit.</p>
</div>
<div class="paragraph">
<p>Pokud je větev <code>master</code> přímým předkem vaší tématické větve, nebude s příkazem žádný problém. Pokud se však obě historie v nějakém bodě rozdělily, bude výpis rozdílů vypadat, jako kdybyste chtěli přidat všechny nové věci v tématické větvi a odstranit vše, co je pouze ve větvi <code>master</code>.</p>
</div>
<div class="paragraph">
<p>To, co opravdu chcete vidět, jsou změny přidané do tématické větve — tj. práci, která se objeví v případě, že provedete začlenění této větve do větve <code>master</code>.
Dosáhnete toho tak, že necháte Git porovnat poslední revizi z tématické větve s nejbližším společným předchůdcem sdíleným s větví <code>master</code>.</p>
</div>
<div class="paragraph">
<p>Šlo by to udělat tak, že explicitně najdete společného předka obou větví a spustíte pro něj příkaz <code>diff</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge-base contrib master
36c7dba2c95e6bbb78dfa822519ecfec6e1ca649
$ git diff 36c7db</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ale není to moc praktické, a proto Git nabízí pro provedení stejné činnosti jinou zkratku: trojtečkovou syntaxi.
V souvislosti s příkazem <code>diff</code> můžete za jméno druhé větve připsat tři tečky a pak jméno aktuální větve. Zjistí se tím změny mezi poslední revizí v aktuální větvi a společným předkem s druhou větví:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff master...contrib</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tento příkaz zobrazí pouze práci, která byla ve vaší aktuální tématické větvi provedena od chvíle, kdy se oddělila od hlavní větve.
Tento velmi užitečný zápis stojí za zapamatování.</p>
</div>
</div>
<div class="sect3">
<h3 id="_integrace_příspěvků">Integrace příspěvků</h3>
<div class="paragraph">
<p>
Když už je práce v tématické větvi připravena k integraci do některé z významnějších větví, vyvstává otázka, jak to provést.
Kromě toho, jaký celkový pracovní postup chcete při správě projektu používat?
Můžete si vybrat z řady možností, takže se na pár z nich podíváme.</p>
</div>
<div class="sect4">
<h4 id="_pracovní_postupy_založené_na_slučování">Pracovní postupy založené na slučování</h4>
<div class="paragraph">
<p>
Jeden z jednoduchých pracovních postupů používá začleňování vaší práce do vaší větve <code>master</code>.
V tomto scénáři máte svou větev <code>master</code>, která obsahuje v podstatě stabilní kód.
Pokud mátě v tématické větvi nějakou práci, kterou jste vytvořili sami, nebo kterou přispěl někdo jiný a vy jste ji ověřovali, začleníte ji do své větve <code>master</code> (merge), odstraníte tématickou větev a pokračujete dál.
Máme-li repozitář s prací ve dvou větvích pojmenovaných <code>ruby_client</code> a <code>php_client</code>, který vypadá jako na obrázku <a href="{{< relurl "book/cs/v2/ch00/merwf_a" >}}">Historie s několika tématickými větvemi.</a>, a začleníme nejprve větev <code>ruby_client</code> a poté <code>php_client</code>, bude naše historie vypadat jako na obrázku <a href="{{< relurl "book/cs/v2/ch00/merwf_b" >}}">Po začlenění tématické větve.</a>.</p>
</div>
<div id="merwf_a" class="imageblock">
<div class="content">
<img src="{{< relurl "book/cs/v2/images/merging-workflows-1.png" >}}" alt="Historie s několika tématickými větvemi.">
</div>
<div class="title">Figure 73. Historie s několika tématickými větvemi.</div>
</div>
<div id="merwf_b" class="imageblock">
<div class="content">
<img src="{{< relurl "book/cs/v2/images/merging-workflows-2.png" >}}" alt="Po začlenění tématické větve.">
</div>
<div class="title">Figure 74. Po začlenění tématické větve.</div>
</div>
<div class="paragraph">
<p>Jde nejspíš o nejjednodušší pracovní postup, ale může vést k problémům v případě, že se použije pro větší nebo stabilnější projekty, u kterých chcete být při vkládání nových věcí opravdu opatrní.</p>
</div>
<div class="paragraph">
<p>U důležitějších projektů asi budete chtít použít dvoufázový cyklus slučování<sup class="footnote">[<a id="_footnoteref_18" class="footnote" href="#_footnotedef_18" title="View footnote.">18</a>]</sup>.
V tomto scénáři máte dvě větve s dlouhou životností: hlavní větev <code>master</code> a větev <code>develop</code>. Určíte, že větev <code>master</code> bude aktualizována, pouze když je k dispozici velmi stabilní verze. Veškerý nový kód je integrován do větve <code>develop</code>.
Obě tyto větve pravidelně odesíláte do veřejného repozitáře.
Pokaždé, když máte novou tématickou větev nachystanou k začlenění (obrázek <a href="{{< relurl "book/cs/v2/ch00/merwf_c" >}}">Před začleněním tématické větve.</a>), začleníte ji do větve <code>develop</code> (obrázek <a href="{{< relurl "book/cs/v2/ch00/merwf_d" >}}">Po začlenění tématické větve.</a>), označíte vydání (tag) a poté posunete větev <code>master</code> rychle vpřed do místa, kde je nyní větev <code>develop</code> stabilní (obrázek <a href="{{< relurl "book/cs/v2/ch00/merwf_e" >}}">Po vydání nové verze projektu.</a>).</p>
</div>
<div id="merwf_c" class="imageblock">
<div class="content">
<img src="{{< relurl "book/cs/v2/images/merging-workflows-3.png" >}}" alt="Před začleněním tématické větve.">
</div>
<div class="title">Figure 75. Před začleněním tématické větve.</div>
</div>
<div id="merwf_d" class="imageblock">
<div class="content">
<img src="{{< relurl "book/cs/v2/images/merging-workflows-4.png" >}}" alt="Po začlenění tématické větve.">
</div>
<div class="title">Figure 76. Po začlenění tématické větve.</div>
</div>
<div id="merwf_e" class="imageblock">
<div class="content">
<img src="{{< relurl "book/cs/v2/images/merging-workflows-5.png" >}}" alt="Po vydání nové verze projektu.">
</div>
<div class="title">Figure 77. Po vydání nové verze projektu.</div>
</div>
<div class="paragraph">
<p>Pokud někdo při takovém přístupu naklonuje repozitář vašeho projektu, může se buď přepnout na větev <code>master</code> s cílem přeložit si poslední stabilní verzi a snadno ji udržovat aktuální, nebo se může přepnout na větev <code>develop</code>, která obsahuje nejpokročilejší funkčnost.
Tento koncept můžete dále rozšířit o integrační větev, v níž budete veškerou práci slučovat.
Teprve pokud je kód v této větvi stabilní a projde testováním, začleníte ho do větve <code>develop</code>. A až se větev develop ukáže v některém okamžiku jako stabilní, posunete rychle vpřed i svou větev <code>master</code>.</p>
</div>
</div>
<div class="sect4">
<h4 id="_pracovní_postupy_se_začleňováním_velkého_objemu_dat">Pracovní postupy se začleňováním velkého objemu dat</h4>
<div class="paragraph">
<p>
Váš gitový projekt má čtyři větve s dlouhou životností: <code>master</code>, <code>next</code> a <code>pu</code> (proposed updates, čili navrhované úpravy) pro novou práci a <code>maint</code> pro přenos oprav z novějších verzí do starších (maintenance backports).
Pokud přispěvatelé vytvoří novou práci, je shromažďována v tématických větvích v repozitáři správce podobným způsobem, jaký jsme popsali dříve (viz obrázek <a href="{{< relurl "book/cs/v2/ch00/merwf_f" >}}">Správa komplexní série paralelně zpracovávaných příspěvků v tématických větvích.</a>).
V této fázi jsou náměty vyhodnoceny a určí se, zda jsou bezpečné a zralé k použití, nebo zda potřebují dopracovat.
Pokud jsou bezpečné, jsou začleněny do  větve <code>next</code> a ta je odeslána do sdíleného repozitáře, aby si všichni mohli vyzkoušet výsledek jejich integrace.</p>
</div>
<div id="merwf_f" class="imageblock">
<div class="content">
<img src="{{< relurl "book/cs/v2/images/large-merges-1.png" >}}" alt="Správa komplexní série paralelně zpracovávaných příspěvků v tématických větvích.">
</div>
<div class="title">Figure 78. Správa komplexní série paralelně zpracovávaných příspěvků v tématických větvích.</div>
</div>
<div class="paragraph">
<p>Pokud nějaké téma ještě vyžaduje dopracování, je místo toho začleněno do větve <code>pu</code>.
Pokud se ukáže, že jsou tyto tématické větve naprosto stabilní, budou začleněny do větve <code>master</code> a poté budou znovu sestaveny z tématických větví, které byly ve větvi <code>next</code>, ale ještě se nedostaly do větve <code>master</code>.
To znamená, že se větev <code>master</code> téměř vždy posouvá vpřed, větev <code>next</code> je čas od času přeskládána a větev <code>pu</code> je přeskládávána o něco častěji:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/cs/v2/images/large-merges-2.png" >}}" alt="Začlenění tématických větví s příspěvky do integračních větví s dlouhou životností.">
</div>
<div class="title">Figure 79. Začlenění tématických větví s příspěvky do integračních větví s dlouhou životností.</div>
</div>
<div class="paragraph">
<p>Pokud se tématická větev nakonec začlení do větve <code>master</code>, z repozitáře se odstraní.
Projekt Git má kromě toho větev <code>maint</code>, která byla odštěpena z posledního vydání a obsahuje záplaty přenesené z vyšších verzí (backport) pro případ, že by bylo třeba vydat opravnou verzi.
Pokud tedy klonujete repozitář Git, můžete se přepnout do čtyř větví a podívat se na projekt v různých fázích vývoje — v závislosti na tom, jak čerstvou verzi chcete nebo jak chcete přispívat. A správce projektu má k dispozici strukturovaný pracovní postup k posouzení nových příspěvků.</p>
</div>
</div>
<div class="sect4">
<h4 id="_rebase_cherry_pick">Pracovní postupy s přeskládáním a s částečným převzetím revizí</h4>
<div class="paragraph">
<p>
Někteří správci dávají místo začlenění práce z příspěvků (merge) přednost přeskládání (rebase) nebo částečnému převzetí (cherry pick) do větve <code>master</code>, čímž udržují historii téměř lineární.
Máte-li hotovou práci v tématické větvi a rozhodli jste se, že ji chcete integrovat, přejdete na tuto větev a spustíte příkaz <code>rebase</code>, jímž znovu sestavíte příslušné změny na vrcholu své aktuální větve <code>master</code> (nebo větve <code>develop</code> a podobně).
Pokud vše funguje, můžete větev <code>master</code> posunout rychle vpřed a výsledkem procesu bude lineární historie projektu.</p>
</div>
<div class="paragraph">
<p>
Druhým způsobem, jak přesunout práci z jedné větve do druhé, je tzv. částečné převzetí (angl. cherry picking<sup class="footnote">[<a id="_footnoteref_19" class="footnote" href="#_footnotedef_19" title="View footnote.">19</a>]</sup>).
Částečné převzetí lze v systému Git přirovnat k přeskládání jediného objektu revize.
Vezme se záplata, která byla provedena v dané revizi, a zkusí se znovu aplikovat na větev, na níž se právě nacházíte.
Využijete to v situaci, kdy tématická větev obsahuje několik revizí a chcete integrovat pouze jednu z nich, nebo když máte v tématické větvi jediný objekt revize a dáváte přednost použití <code>cherry-pick</code> před provedením <code>rebase</code>.
Dejme tomu, že máte projekt, který vypadá nějak takto:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/cs/v2/images/rebasing-1.png" >}}" alt="Příklad historie před provedením cherry-pick.">
</div>
<div class="title">Figure 80. Příklad historie před provedením cherry-pick.</div>
</div>
<div class="paragraph">
<p>Chcete-li do hlavní větve stáhnout revizi <code>e43a6</code>, můžete zadat následující příkaz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cherry-pick e43a6
Finished one cherry-pick.
[master]: created a0a41a9: "More friendly message when locking the index fails."
 3 files changed, 17 insertions(+), 3 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tím se stáhne stejná změna, která byla uvedena v revizi <code>e43a6</code>, ale hodnota SHA-1 obou revizí se bude lišit, protože se bude lišit datum.
Vaše historie teď vypadá nějak takto:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/cs/v2/images/rebasing-2.png" >}}" alt="Historie po částečném převzetí revize z tématické větve.">
</div>
<div class="title">Figure 81. Historie po částečném převzetí revize z tématické větve.</div>
</div>
<div class="paragraph">
<p>Teď můžete tématickou větev odstranit a zahodit revize, které nehodláte vtáhnout do jiné větve.</p>
</div>
</div>
<div class="sect4">
<h4 id="_rerere">Rerere</h4>
<div class="paragraph">
<p>
Pokud provádíte velké množství operací slučování a přeskládání, nebo pokud spravujete tématické větve s dlouhou životností, může vám pomoci vlastnost Gitu zvaná „rerere“.</p>
</div>
<div class="paragraph">
<p>Rerere znamená „reuse recorded resolution“, čili „znovupoužití zaznamenaného řešení“. Jde o způsob jak si zjednodušit ruční řešení konfliktu.
Pokud je mechanismus rerere povolen, uchovává Git sadu obrazů před a po úspěšných sloučeních. Pokud si Git všimne, že konflikt vypadá přesně jako ten, který jste už vyřešili, použije vaše řešení z minula a nebude vás tím zatěžovat.</p>
</div>
<div class="paragraph">
<p>Uvedený rys má dvě části: konfigurační nastavení a příkaz.
Konfigurační nastavení se jmenuje <code>rerere.enabled</code> a je dost šikovné na to, abyste je umístili do globální konfigurace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global rerere.enabled true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Kdykoliv teď provedete sloučení, které řeší konflikt, zaznamená se řešení do mezipaměti pro případ, že bychom ho v budoucnu potřebovali.</p>
</div>
<div class="paragraph">
<p>V případě potřeby můžete s mezipamětí pro rerere pracovat pomocí příkazu <code>git rerere</code>.
Pokud je vyvolán bez parametru, prochází Git svou databázi řešení a pokouší se najít shodu s konflikty při aktuální operaci slučování a vyřešit je (i když při nastavení <code>rerere.enabled</code> na hodnotu <code>true</code> se to dělá automaticky).
Existují i varianty příkazu pro případy, kdy chceme zobrazit, co se bude zaznamenávat, když chceme odstranit určité řešení z mezipaměti a když chceme celou mezipaměť vymazat.
Příkazem <code>rerere</code> se budeme podrobněji zabývat v podkapitole <a href="{{< relurl "book/cs/v2/ch00/_rerere" >}}">Rerere</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_tagging_releases">Označení vydání značkou</h3>
<div class="paragraph">
<p>
Když jste se rozhodli vydat určitou verzi, pravděpodobně ji budete chtít označit, abyste mohli toto vydání v kterémkoli okamžiku v budoucnosti obnovit.
Novou značku můžete vytvořit způsobem, který jsme probrali v kapitole <a href="{{< relurl "book/cs/v2/ch00/_git_basics_chapter" >}}">Základy práce se systémem Git</a>.
Pokud se rozhodnete značku podepsat jako správce, bude označení probíhat takto:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git tag -s v1.5 -m 'my signed 1.5 tag'
You need a passphrase to unlock the secret key for
user: "Scott Chacon &lt;schacon@gmail.com&gt;"
1024-bit DSA key, ID F721C45A, created 2009-02-09</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pokud své značky podepisujete, můžete mít problémy s distribucí veřejného klíče PGP použitého k podepsání značky.
Správce projektu Git vyřešil tento problém tak, že přidal svůj veřejný klíč jako blob do repozitáře a poté vložil značku, která ukazuje přímo na tento obsah.
Pomocí příkazu <code>gpg --list-keys</code> můžete určit, jaký klíč chcete:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ gpg --list-keys
/Users/schacon/.gnupg/pubring.gpg
---------------------------------
pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]
uid                  Scott Chacon &lt;schacon@gmail.com&gt;
sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Poté můžete klíč přímo importovat do gitové databáze: vyexportujte ho a výsledek předáte příkazu <code>git hash-object</code>, který zapíše nový blob s tímto obsahem do systému Git a vrátí vám otisk SHA-1 tohoto blobu:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ gpg -a --export F721C45A | git hash-object -w --stdin
659ef797d181633c87ec71ac3f9ba29fe5775b92</code></pre>
</div>
</div>
<div class="paragraph">
<p>Teď máte v Gitu obsah svého klíče a můžete vytvořit značku, která bude ukazovat přímo na něj s tím, že zadáte novou hodnotu SHA-1, kterou vám vrátil příkaz <code>hash-object</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pokud provedete příkaz <code>git push --tags</code>, začnete značku <code>maintainer-pgp-pub</code> sdílet s ostatními.
Když bude chtít kdokoliv nějakou značku ověřit, může přímo importovat váš klíč PGP tak, že stáhne blob přímo z databáze a naimportuje ho do programu GPG:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show maintainer-pgp-pub | gpg --import</code></pre>
</div>
</div>
<div class="paragraph">
<p>Klíč pak může použít k ověření všech vašich podepsaných značek.
Pokud navíc zadáte do zprávy značky další instrukce k jejímu ověření, může si je koncový uživatel zobrazit příkazem <code>git show &lt;značka&gt;</code>.</p>
</div>
</div>
<div class="sect3">
<h3 id="_build_number">Vygenerování čísla sestavení</h3>
<div class="paragraph">
<p>
Git nepoužívá pro jednotlivé revize monotónně rostoucí čísla jako „v123“ nebo něco podobného. Pokud chcete získat čitelnou podobu jména revize, můžete pro daný objekt revize spustit příkaz <code>git describe</code><sup class="footnote">[<a id="_footnoteref_20" class="footnote" href="#_footnotedef_20" title="View footnote.">20</a>]</sup>.
Git vám vrátí název nejbližší značky, který doplní počtem revizí za touto značkou a částečnou hodnotou SHA-1 popisovaného objektu revize:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git describe master
v1.6.2-rc1-20-g8c5b85c</code></pre>
</div>
</div>
<div class="paragraph">
<p>Díky tomu lze pro snímek nebo sestavení (build) při exportu použít jméno, které je pro člověka trochu srozumitelné.
Pokud překládáte Git ze zdrojového kódu naklonovaného z repozitáře projektu Git, získáte ve skutečnosti po spuštění příkazu <code>git --version</code> něco, co vypadá podobně.
Pokud získáváte popis objektu revize, který jste právě opatřili značkou, vrátí příkaz název této značky.</p>
</div>
<div class="paragraph">
<p>Příkaz <code>git describe</code> upřednostňuje anotované značky (značky vytvořené s příznakem <code>-a</code> nebo <code>-s</code>). Pokud tedy používáte příkaz <code>git describe</code>, měli byste značky vytvářet právě tímto způsobem, čímž si při získávání popisu objektu revize zajistíte vhodné pojmenování.
Tento řetězec můžete také použít jako cíl příkazů <code>checkout</code> nebo <code>show</code>, ačkoli ty spoléhají na část se zkrácenou hodnotou SHA-1, a proto nemusí platit navždy.
Například jádro Linuxu nyní přešlo z 8 na 10 znaků SHA-1, aby byla zajištěna jedinečnost identifikace objektů. Starší výstupy příkazu <code>git describe</code> tím byly zneplatněny.</p>
</div>
</div>
<div class="sect3">
<h3 id="_preparing_release">Příprava vydání</h3>
<div class="paragraph">
<p>
Nyní budete chtít sestavení vydat.
Jednou z věcí, kterou budete chtít udělat, je vytvoření archivu nejnovějšího snímku vašeho kódu pro všechny nebohé duše, které Git nepoužívají.
Příkaz pro vytvoření archivu zní <code>git archive</code><sup class="footnote">[<a id="_footnoteref_21" class="footnote" href="#_footnotedef_21" title="View footnote.">21</a>]</sup>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git archive master --prefix='project/' | gzip &gt; `git describe master`.tar.gz
$ ls *.tar.gz
v1.6.2-rc1-20-g8c5b85c.tar.gz</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pokud někdo tento tarball otevře, získá nejnovější snímek vašeho projektu uvnitř adresáře projektu.
V podstatě stejným způsobem můžete vytvořit také archiv zip tím, že k příkazu <code>git archive</code> přidáte volbu <code>--format=zip</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git archive master --prefix='project/' --format=zip &gt; `git describe master`.zip</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nyní máte vytvořen tarball a archiv zip s novou verzí projektu. Můžete je nahrát na příslušnou webovou stránku nebo rozeslat elektronickou poštou.</p>
</div>
</div>
<div class="sect3">
<h3 id="_the_shortlog">Příkaz „shortlog“</h3>
<div class="paragraph">
<p>
Nyní je na čase obeslat přes poštovní konferenci lidi, kteří chtějí vědět, co je ve vašem projektu nového.
Seznam změn (changelog), které byly do projektu přidány od posledního vydání nebo e-mailu, lze rychle a elegantně získat příkazem <code>git shortlog</code>.
Příkaz shrne popis všech revizí v zadaném rozmezí. Pokud bylo vaše poslední vydání pojmenováno v1.0.1, zobrazí následující příkaz shrnutí změn ve všech novějších revizích:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git shortlog --no-merges master --not v1.0.1
Chris Wanstrath (8):
      Add support for annotated tags to Grit::Tag
      Add packed-refs annotated tag support.
      Add Grit::Commit#to_patch
      Update version and History.txt
      Remove stray `puts`
      Make ls_tree ignore nils

Tom Preston-Werner (4):
      fix dates in history
      dynamic version method
      Version bump to 1.0.2
      Regenerated gemspec for version 1.0.2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Výstupem příkazu je shrnutí všech revizí od v1.0.1 (seskupené podle autora), které můžete přes poštovní konferenci rozeslat.</p>
</div>
</div>
<div id='footnotes'>
<hr>
<div class="footnote" id="_footnotedef_18">
<a href="#_footnoteref_18">18</a>. two-phase merge cycle
</div>
<div class="footnote" id="_footnotedef_19">
<a href="#_footnoteref_19">19</a>. Pozn. překl.: „Cherry picking“ je doslova něco jako „vyzobání třešniček“.
</div>
<div class="footnote" id="_footnotedef_20">
<a href="#_footnoteref_20">20</a>. Pozn. překl.: Slovo <em>describe</em> znamená doslova <em>popiš</em> (rozkazovací způsob). Příkaz tedy vrací doslovně <em>popis objektu revize</em>.
</div>
<div class="footnote" id="_footnotedef_21">
<a href="#_footnoteref_21">21</a>. Pozn. překl.: Při použití příkazu v systému Windows nelze pro vytvoření jména archivu použít obrat `git describe master`.tar.gz, protože zde nefunguje uzavření do opačných apostrofů. V unixových systémech fungují opačné apostrofy tak, že se nahradí výsledkem příkazu, který je v nich uzavřen. V tomto případě by se tedy vrátilo jméno objektu revize odvozené od nejbližší značky, ke kterému se přidá dvojice přípon <code>.tar.gz</code>. Ve Windows budeme muset uvést konkrétní jméno souboru.
</div>
</div><div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>