---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: sr
  chapter:
    title: Гит алати
    number: 7
  section:
    title: Напредно спајање
    number: 8
    cs_number: '7.8'
    previous: book/sr/v2/Гит-алати-Демистификовани-ресет
    next: book/sr/v2/Гит-алати-Rerere
title: Git - Напредно спајање
url: "/book/sr/v2/Гит-алати-Напредно-спајање.html"
---
<h2 id="_advanced_merging">Напредно спајање</h2>
<div class="paragraph">
<p>Спајање у програму Гит је у општем случају прилично једноставно.
Пошто програм Гит вишеструко спајање неке друге гране чини једноставним, то значи да можете имати веома дуготрајне гране које у ходу можете одржавати ажурним, често решавајући мале конфликте уместо да будете изненађени огромним конфликтом на крају низова.</p>
</div>
<div class="paragraph">
<p>Међутим, понекад долази до компликованих конфликата.
За разлику од неких других система за контролу верзије, програм Гит не покушава да буде превише паметан када дође до решавања конфликта при спајању.
Филозофија програма Гит је да буде паметан када одређује да ли је решење спајања недвосмислено, али ако постоји конфликт, да се не прави паметан у вези аутоматског решавања.
Дакле, ако сувише дуго чекате да спојите две гране које се брзо разилазе, можете наићи на одређене проблеме.</p>
</div>
<div class="paragraph">
<p>У овом одељку ћемо представити шта могу бити неки од тих проблема и које алате вам програм Гит нуди као помоћ у обради тих компликованијих ситуација.
Такође ћемо представити неке другачије, нестандардне врсте спајања које можете урадити, као и како да се избавите из спајања која сте већ обавили.</p>
</div>
<div class="sect3">
<h3 id="_конфликти_при_спајању">Конфликти при спајању</h3>
<div class="paragraph">
<p>Мада смо прешли неке основе решавања конфликта при спајању у <a href="{{< relurl "book/sr/v2/ch00/_basic_merge_conflicts" >}}">Основни конфликти при спајању</a>, за сложеније конфликте програм Git нуди неколико алата који вам помажу да откријете шта се дешава и како да се успешније носите са конфликтом.</p>
</div>
<div class="paragraph">
<p>Најпре, ако је то уопште и могуће, покушајте обезбедити да вам је радни директоријум чист пре него што покренете спајања која би могла имати конфликте.
Ако имате посао у току, или га комитујте у привремену грану или га сакријте.
На тај начин можете вратити на старо <strong>све</strong> што овде покушате.
Ако у радном директоријуму имате несачуване промене када покушате спајање, неки од ових трикова вам могу помоћи да очувате тај рад.</p>
</div>
<div class="paragraph">
<p>Хајде да прођемо кроз веома једноставан пример.
Имамо супер једноставан Руби фајл који исписује ’hello world’.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
  puts 'hello world'
end

hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>У нашем репозиторијуму креирамо нову грану под именом <code>whitespace</code> и крећемо да променимо све Јуникс завршетке редова у ДОС завршетке редова, у суштини мењајући сваку линију фајла, али само са празним простором <em>(whitespace)</em>.
Затим променимо линију „hello world” у „hello mundo”.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b whitespace
Switched to a new branch 'whitespace'

$ unix2dos hello.rb
unix2dos: converting file hello.rb to DOS format ...
$ git commit -am 'Convert hello.rb to DOS'
[whitespace 3270f76] Convert hello.rb to DOS
 1 file changed, 7 insertions(+), 7 deletions(-)

$ vim hello.rb
$ git diff -b
diff --git a/hello.rb b/hello.rb
index ac51efd..e85207e 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,7 @@
 #! /usr/bin/env ruby

 def hello
-  puts 'hello world'
+  puts 'hello mundo'^M
 end

 hello()

$ git commit -am 'Use Spanish instead of English'
[whitespace 6d338d2] Use Spanish instead of English
 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Сада се вратимо назад на нашу <code>master</code> грану и додамо документацију функције.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
Switched to branch 'master'

$ vim hello.rb
$ git diff
diff --git a/hello.rb b/hello.rb
index ac51efd..36c06c8 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello world'
 end

$ git commit -am 'Add comment documenting the function'
[master bec6336] Add comment documenting the function
 1 file changed, 1 insertion(+)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Сада покушамо да спојимо нашу <code>whitespace</code> грану и добијамо конфликте због промена празног простора.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge whitespace
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="sect4">
<h4 id="_abort_merge">Прекид спајања</h4>
<div class="paragraph">
<p>Сада имамо неколико опција.
Најпре, хајде да покажемо како да се избавимо из ове ситуације.
Ако можда нисте очекивали конфликте и још увек не желите да се заиста бавите ситуацијом, можете једноставно да се повучете назад из спајања са <code>git merge --abort</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status -sb
## master
UU hello.rb

$ git merge --abort

$ git status -sb
## master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Опција <code>git merge --abort</code> покушава да вас врати на старо стање пре покретања спајања.
Једини случајеви када ово не би перфектно могла да уради је ако бисте имали несакривене, некомитоване измене у радном директоријум када сте је покренули. У супротном би требало да ради како треба.</p>
</div>
<div class="paragraph">
<p>Ако из неког разлога једноставно желите да почнете из почетка, можете да покренете и <code>git reset --hard HEAD</code>, и ваш репозиторијум ће се вратити назад на последње комитовано стање.
Упамтите да ће се изгубити сав рад који није комитован, па будите сигурни да вам не требају никакве промене.</p>
</div>
</div>
<div class="sect4">
<h4 id="_игнорисање_празног_простора">Игнорисање празног простора</h4>
<div class="paragraph">
<p>У овом посебном случају, конфликти су везани за празан простор.
То знамо само зато што је случај једноставан, али је углавном прилично лако да се и у реалним случајевима препозна, јер када се погледа у конфликт, свака линија се уклања на једној страни, па се поново додаје на другој.
Програм Гит подразумевано све ове линије види као измењене, тако да не може да их споји.</p>
</div>
<div class="paragraph">
<p>Међутим, подразумевана стратегија спајања може да узме аргументе, а њих неколико су у вези исправног игнорисања измена празног простора.
Ако приметите да у спајању имате доста проблема везаних за празан простор, можете једноставно да прекинете спајање па да га покренете поново, али овај пут са <code>-Xignore-all-space</code> или <code>-Xignore-space-change</code>.
Прва опција <strong>потпуно</strong> игнорише празан простор када пореди линије, а друга третира низове од једног или више празних карактера као еквивалентне.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge -Xignore-space-change whitespace
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Пошто у овом случају стварне измене фајла нису у конфликту, чим занемаримо измене празног простора, све се спаја без проблема.</p>
</div>
<div class="paragraph">
<p>Ово је сламка спаса ако у свом тиму имате некога ко повремено воли да реформатира све из размака у табулаторе или обрнуто.</p>
</div>
</div>
<div class="sect4">
<h4 id="_manual_remerge">Ручно поновно спајање фајла</h4>
<div class="paragraph">
<p>Мада програм Гит прилично добро одрађује препроцесирање празног простора, постоји неколико осталих врста измена које програм Гит можда не може аутоматски да обради, али могу да се реше скриптом.
Као пример, хајде да се претварамо да програм Гит није могао да обради измену празног простора и да то морамо да обавимо ручно.</p>
</div>
<div class="paragraph">
<p>Уствари, оно што морамо да урадимо је да филтрирамо фајл који покушавамо да спојимо кроз <code>dos2unix</code> програм пре него што заиста извршимо спајање фајла.
Па како то можемо да урадимо?</p>
</div>
<div class="paragraph">
<p>Најпре, треба да дођемо у стање конфликта при спајању.
Затим желимо да имамо копије моје верзије фајла, њихове верзије (из гране коју спајамо) и заједничку верзију (одакле су обе гране потекле).
Онда желимо да исправимо било њихову страну или нашу страну и покушамо поново да урадимо спајање, само за овај један фајл.</p>
</div>
<div class="paragraph">
<p>Добијање три верзије фајла је у суштини прилично лако.
Програм Гит чува све ове верзије у индексу под „stages” (етапе) и свака од њих има придружен број.
Етапа 1 је заједнички предак, етапа 2 је ваша верзија и етапа 3 је из <code>MERGE_HEAD</code>, тј. верзија коју спајате („њихова”).</p>
</div>
<div class="paragraph">
<p>Командом <code>git show</code>, користећи специјалну синтаксу можете да издвојите копију сваког од ових верзија конфликтног фајла.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show :1:hello.rb &gt; hello.common.rb
$ git show :2:hello.rb &gt; hello.ours.rb
$ git show :3:hello.rb &gt; hello.theirs.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ако желите још мало хард кора, можете такође да употребите и <code>ls-files -u</code> цевоводну команду којом добијате актуелне SHA-1 суме Git блобова за сваки од ових фајлова.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git ls-files -u
100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1	hello.rb
100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2	hello.rb
100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3	hello.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>:1:hello.rb</code> је једноставно скраћеница за проналажење SHA-1 тог блоба.</p>
</div>
<div class="paragraph">
<p>Сада када у радном директоријуму имамо садржај сваког од ова три фајла, можемо ручно да исправимо њихов тако да средимо проблем са празним простором, задамо поновно спајање фајла са не баш познатом <code>git merge-file</code> командом која ради управо то.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ dos2unix hello.theirs.rb
dos2unix: converting file hello.theirs.rb to Unix format ...

$ git merge-file -p \
    hello.ours.rb hello.common.rb hello.theirs.rb &gt; hello.rb

$ git diff -b
diff --cc hello.rb
index 36c06c8,e85207e..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,8 -1,7 +1,8 @@@
  #! /usr/bin/env ruby

 +# prints out a greeting
  def hello
-   puts 'hello world'
+   puts 'hello mundo'
  end

  hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>У овом тренутку имамо фино спојени фајл.
Уствари, ово практично функционише и боље од опције <code>ignore-space-change</code> јер заиста исправља измене празног простора пре спајања, уместо да их једноставно игнорише.
У <code>ignore-space-change</code> спајању, на крају имамо и неколико линија са ДОС завршетком, чиме је ствар измешана.</p>
</div>
<div class="paragraph">
<p>Ако желите да стекнете идеју шта је заиста промењено између једне или друге стране пре довршавања овог комита, можете питати <code>git diff</code> да упореди оно што је радном директоријуму и што ћете комитовати као резултат спајања са било којом од ових етапа.
Хајде да прођемо кроз све.</p>
</div>
<div class="paragraph">
<p>Да бисте упоредили ваш резултат са оним што сте имали у својој грани пре спајања, другим речима, да видите шта је унело спајање, извршите <code>git diff --ours</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --ours
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index 36c06c8..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -2,7 +2,7 @@

 # prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Тако да овде лако можемо видети шта се догодило у нашој грани, да је измена те једне линије уствари оно што спајањем заиста уводимо у овај фајл.</p>
</div>
<div class="paragraph">
<p>Ако желимо да видимо како се резултат спајања разликује од онога што је на њиховој страни, можете извршити <code>git diff --theirs</code>.
У овом и наредном примеру, морамо да употребимо <code>-b</code> да уклонимо празан простор јер поређење вршимо са оним што се налази у програму Гит, а не у нашем очишћеном <code>hello.theirs.rb</code> фајлу.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --theirs -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index e85207e..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello mundo'
 end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Коначно, можете видети како се фајл променио са обе стране командом <code>git diff --base</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --base -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index ac51efd..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,8 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>У овом тренутку можемо употребити команду <code>git clean</code> да уклонимо додатне фајлове које смо направили у циљу ручног спајања, јер више нису потребни.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clean -f
Removing hello.common.rb
Removing hello.ours.rb
Removing hello.theirs.rb</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_checking_out_conflicts">Одјављивање конфликата</h4>
<div class="paragraph">
<p>Можда у овом тренутку из неког разлога нисмо задовољни решењем, или можда ручно уређивање једне или обе стране није дало резултат и потребно нам је још контекста.</p>
</div>
<div class="paragraph">
<p>Хајде да мало изменимо пример.
У овом примеру, имамо две дуготрајније гране које обе имају по неколико комита, али стварају прави конфликт садржаја када се споје.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --graph --oneline --decorate --all
* f1270f7 (HEAD, master) Update README
* 9af9d3b Create README
* 694971d Update phrase to 'hola world'
| * e3eb223 (mundo) Add more tests
| * 7cff591 Create initial testing script
| * c3ffff1 Change text to 'hello mundo'
|/
* b7dcc89 Initial hello world code</code></pre>
</div>
</div>
<div class="paragraph">
<p>Сада имамо три јединствена комита који живе само на <code>master</code> грани и три друга која живе на <code>mundo</code> грани.
Ако покушамо да спојимо <code>mundo</code> грану, добијамо конфликт.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Волели бисмо да видимо шта је конфликт при спајању.
Ако отворимо фајл, видећемо нешто слично овоме:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
  puts 'hola world'
=======
  puts 'hello mundo'
&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo
end

hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Обе стране спајања су додале садржај у овај фајл, али су неки од комита изменили фајл на истом месту, што је и изазвало овај конфликт.</p>
</div>
<div class="paragraph">
<p>Хајде да истражимо неколико алата које имате на располагању за одређивање начина на који је дошло до овог конфликта.
Можда није очигледно како би тачно требало да решите овај конфликт.
Потребно вам је још контекста.</p>
</div>
<div class="paragraph">
<p>Један користан алат је <code>git checkout</code> са опцијом `--conflict'.
Ово ће поново одјавити фајл и заменити маркере за конфликт спајања.
Биће од користи ако желите да ресетујете маркере и покушате поново да их разрешите.</p>
</div>
<div class="paragraph">
<p>Опцији <code>--conflict</code> можете проследити или <code>diff3</code> или <code>merge</code> (што је подразумевана вредност).
Ако јој проследите <code>diff3</code>, програм Гит ће користити мало измењену верзију маркера конфликта, који не приказују само „ours” и „theirs” верзије, већ и „base” верзију у линији, тако да вам пружа више контекста.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout --conflict=diff3 hello.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Када ово извршимо, фајл ће изгледати овако:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; ours
  puts 'hola world'
||||||| base
  puts 'hello world'
=======
  puts 'hello mundo'
&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs
end

hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ако вам се допада овај формат, можете поставити да буде подразумевани за све будуће конфликте при спајању тако што поставите подешавање <code>merge.conflictstyle</code> на <code>diff3</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global merge.conflictstyle diff3</code></pre>
</div>
</div>
<div class="paragraph">
<p>И <code>git checkout</code> команда такође може примити <code>--ours</code> и <code>--theirs</code> опције, што може бити заиста брз начин да се изабере једна или друга страна без икаквог спајања ствари.</p>
</div>
<div class="paragraph">
<p>Ово може бити посебно корисно за конфликте бинарних фајлова где једноставно можете изабрати једну страну, или где само желите да спојите одређене фајлове из неке друге гране - можете да обавите спајање па да онда одјавите одређене фајлове са једне или друге стране пре комитовања.</p>
</div>
</div>
<div class="sect4">
<h4 id="_merge_log">Лог спајања</h4>
<div class="paragraph">
<p>Још један користан алат за решавање конфликта при спајању је <code>git log</code>.
Ово може да вам помогне тако што пружа контекст онога што је можда допринело стварању конфликта.
Понекада преглед мало историје може да буде од изузетне помоћи да запамтите зашто су две линије развоја утицале на исти део кода.</p>
</div>
<div class="paragraph">
<p>Да бисте добили потпуну листу свих јединствених комитова који су били део било које гране укључене у ово спајање, можемо да употребимо синтаксу „три тачке” коју смо научили у <a href="{{< relurl "book/sr/v2/ch00/_triple_dot" >}}">Трострука тачка</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --left-right HEAD...MERGE_HEAD
&lt; f1270f7 Update README
&lt; 9af9d3b Create README
&lt; 694971d Update phrase to 'hola world'
&gt; e3eb223 Add more tests
&gt; 7cff591 Create initial testing script
&gt; c3ffff1 Change text to 'hello mundo'</code></pre>
</div>
</div>
<div class="paragraph">
<p>То је фина листа од укупно шест комитова који су умешани, као и на којој грани развоја је био сваки од њих.</p>
</div>
<div class="paragraph">
<p>Мада ово можемо даље да упростимо тако да добијемо још одређенији контекст.
Ако команди <code>git log</code> додамо опцију <code>--merge</code>, она ће приказати само комитове у било којој страни који утичу на фајл који је тренутно у конфликту.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --left-right --merge
&lt; 694971d Update phrase to 'hola world'
&gt; c3ffff1 Change text to 'hello mundo'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ако уместо овога то извршите са опцијом <code>-p</code>, добићете само разлике са фајлом који је завршио у конфликту.
Ово <strong>заиста</strong> може бити од помоћи тако што вам брзо даје контекст који вам је потребан да разумете зашто је нешто у конфликту и како да интелигентније разрешите тај конфликт.</p>
</div>
</div>
<div class="sect4">
<h4 id="_формат_комбиноване_разлике">Формат комбиноване разлике</h4>
<div class="paragraph">
<p>Пошто програм Гит стејџује све успешне резултате спајања, када извршите <code>git diff</code> док се налазите у стању спајања са конфликтом, добијате само оно што је тренутно још увек у конфликту.
То може бити од помоћи да видите шта још увек морате да разрешите.</p>
</div>
<div class="paragraph">
<p>Када <code>git diff</code> извршите директно након конфликта при спајању, она вам даје информације у прилично јединственом излазном формату разлике.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,11 @@@
  #! /usr/bin/env ruby

  def hello
++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
 +  puts 'hola world'
++=======
+   puts 'hello mundo'
++&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo
  end

  hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Формат се зове „комбинована разлика” <em>(„Combined Diff”)</em> и уз сваку од линија вам приказује две колоне података.
Прва колона вам приказује да ли се та линија разликује (додата је или уклоњена) између „ours” гране и фајла у радном директоријуму, а друга колона показује исто то само између „theirs” гране и копије у радном директоријуму.</p>
</div>
<div class="paragraph">
<p>Тако да у том примеру можете видети да су <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> и <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> линије у радној копији, али нису ни на једној страни спајања.
Ово има смисла јер их је ту сместио алат за спајање како би нам приказао наш контекст, али се од нас очекује да их уклонимо.</p>
</div>
<div class="paragraph">
<p>Ако разрешимо конфликт па поново извршимо <code>git diff</code>, видећемо исту ствар, али ипак мало корисније.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ vim hello.rb
$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ово нам показује да је „hola world” било на нашој страни али не и у радној копији, да је „hello mundo” било на њиховој страни алине и у радној копији и на крају да „hola mundo” није било ни на једној страни али се сада налази у радној копији.
Ово може бити корисно за преглед пре комитовања разрешења.</p>
</div>
<div class="paragraph">
<p>Можете да га добијете за било које спајање и од <code>git log</code> да видите како је нешто било разрешено након што се то уради.
Програм Гит ће исписати овај формат ако извршите <code>git show</code> на комиту спајања, или ако команди <code>git log -p</code> додате опцију <code>--cc</code> (која подразумевано приказује само закрпе за комите који нису комити спајања).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --cc -p -1
commit 14f41939956d80b9e17bb8721354c33f8d5b5a79
Merge: f1270f7 e3eb223
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Sep 19 18:14:49 2014 +0200

    Merge branch 'mundo'

    Conflicts:
        hello.rb

diff --cc hello.rb
index 0399cd5,59727f0..e1d0799
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_undoing_merges">Опозив спајања</h3>
<div class="paragraph">
<p>Сада када знате како да направите комит спајања, вероватно ћете да направите и понеку грешку.
Једна од сјајних ствари рада у програму Гит је да уопште није проблем правити грешке, јер могу (а у многим случајевима и једноставно) да се исправе.</p>
</div>
<div class="paragraph">
<p>Исти је случај и са комитовима спајања.
Рецимо да се започели рад на тематској грани, грешком је спојили у <code>master</code>, па сада историја комитова изгледа овако:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/sr/v2/images/undomerge-start.png" >}}" alt="Случајни комит спајања">
</div>
<div class="title">Слика 137. Случајни комит спајања</div>
</div>
<div class="paragraph">
<p>Постоје два начина да се приступи овом проблему, зависно од тога шта вам је жељени исход.</p>
</div>
<div class="sect4">
<h4 id="_исправљање_референци">Исправљање референци</h4>
<div class="paragraph">
<p>Ако нежељени комит спајања постоји само у вашем локалном репозиторијуму, најлакше и најбоље решење је да померите гране тако показују на жељено место.
У већини случајева, ако након погрешног <code>git merge</code> извршите <code>git reset --hard HEAD~</code>, ресетоваћете показиваче грана тако да изгледају овако:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/sr/v2/images/undomerge-reset.png" >}}" alt="Историја након `git reset --hard HEAD~`">
</div>
<div class="title">Слика 138. Историја након <code>git reset --hard HEAD~</code>
</div>
</div>
<div class="paragraph">
<p><code>reset</code> смо објаснили раније у <a href="{{< relurl "book/sr/v2/ch00/_git_reset" >}}">Демистификовани ресет</a>, тако да не би требало да вам буде сувише тешко да схватите шта се овде догађа.
Ево брзог подсетника: <code>reset --hard</code> обично пролази кроз три корака:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Померање гране на коју показује HEAD.
У овом случају желимо да се <code>master</code> помери на место пре комита спајања (<code>C6</code>).</p>
</li>
<li>
<p>Сређивање да индекс изгледа као HEAD.</p>
</li>
<li>
<p>Сређивање да радни директоријум изгледа као индекс.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Мана овог приступа је да поново исписује историју, што може бити проблем за дељени репозиторијум.
Погледајте <a href="{{< relurl "book/sr/v2/ch00/_rebase_peril" >}}">Опасности ребазирања</a> за више о томе шта може да се догоди; укратко, ако други људи имају комитове које преписујете, врло вероватно би требало да избегнете <code>reset</code>.
Овај приступ такође неће радити ако су након спајања креирани било који други комитови; померањем референци би се те промене ефективно изгубиле.</p>
</div>
</div>
<div class="sect4">
<h4 id="_reverse_commit">Враћање комита</h4>
<div class="paragraph">
<p>Ако померање показивача грана неће радити у вашем случају, програм Git вам нуди опцију прављења новог комита који поништава све измене које је увео постојећи.
Програм Git ову операцију назива „враћање” <em>(„revert”)</em> и у овом сценарију бисте је позвали на следећи начин:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git revert -m 1 HEAD
[master b1d8379] Revert "Merge branch 'topic'"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Заставица <code>-m 1</code> наводи који родитељ „главне линије” би требало да се задржи.
Када позовете спајање у <code>HEAD</code> (<code>git merge topic</code>), нови комит има два родитеља: први је <code>HEAD</code> (<code>C6</code>), а други је врх гране која се спаја (<code>C4</code>).
У овом случају, желимо да опозовемо све измене уведене спајањем родитеља #2 (<code>C4</code>), а да истовремено задржимо сав садржај из родитеља #1 (<code>C6</code>).</p>
</div>
<div class="paragraph">
<p>Након враћања комита историја изгледа овако:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/sr/v2/images/undomerge-revert.png" >}}" alt="Историја након `git revert -m 1`">
</div>
<div class="title">Слика 139. Историја након <code>git revert -m 1</code>
</div>
</div>
<div class="paragraph">
<p>Нови комит <code>^M</code> има потпуно исти садржај као <code>C6</code>, тако да ако се почне одавде, исто је као да се спајање никада није ни догодило, осим што се комитови који нису спајање још увек налазе у историји <code>HEAD</code>.</p>
</div>
<div class="paragraph">
<p>Програм Гит ће се збунити ако поново покушате да спојите <code>topic</code> у <code>master</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge topic
Already up-to-date.</code></pre>
</div>
</div>
<div class="paragraph">
<p>У <code>topic</code> грани не постоји ништа што већ није достижно из <code>master</code> гране.
Још горе, ако додате рад у <code>topic</code> и поново урадите спајање, програм Git ће унети само измене настале  <em>након</em> враћеног спајања:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/sr/v2/images/undomerge-revert2.png" >}}" alt="Историја са лошим спајањем">
</div>
<div class="title">Слика 140. Историја са лошим спајањем</div>
</div>
<div class="paragraph">
<p>Најбољи начин да се ово реши је да се поништи враћање оригиналног спајања, јер сада желите да уведете измене које су враћене, па <strong>затим</strong> креирате нови комит спајања:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git revert ^M
[master 09f0126] Revert "Revert "Merge branch 'topic'""
$ git merge topic</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/sr/v2/images/undomerge-revert3.png" >}}" alt="Историја након поновног спајања враћеног спајања">
</div>
<div class="title">Слика 141. Историја након поновног спајања враћеног спајања</div>
</div>
<div class="paragraph">
<p>У овом примеру се <code>M</code> и <code>^M</code> поништавају.
<code>^^M</code> ефективно спаја измене из <code>C3</code> и <code>C4</code>, а <code>C8</code> спаја измене из <code>C7</code>, тако да је <code>topic</code> сада у потпуности спојена.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_остале_врсте_спајања">Остале врсте спајања</h3>
<div class="paragraph">
<p>До сада смо представили обично спајање две гране, које се углавном обрађује оним што се назива „рекурзивна” стратегија спајања.
Међутим, постоје и други начини да се споје две гране.
Хајде да брзо представимо неколико њих.</p>
</div>
<div class="sect4">
<h4 id="_предност_нашег_или_њиховог">Предност нашег или њиховог</h4>
<div class="paragraph">
<p>Пре свега, постоји још једна корисна ствар коју можемо урадити са обичним „рекурзивним” режимом спајања.
Већ смо видели опције <code>ignore-all-space</code> и <code>ignore-space-change</code> које се прослеђују са <code>-X</code>, али програму Гит можемо такође навести да даје предност једној или другој страни када наиђе на конфликт.</p>
</div>
<div class="paragraph">
<p>Када програм Гит наиђе на конфликт између две гране које се спајају, он ће подразумевано да дода маркере конфликта у ваш кôд и маркираће фајл као конфликтни, па ће вама оставити да разрешите конфликт.
Ако бисте желели да програм Гит просто изабере одређену страну и игнорише другу, уместо да од вас очекује да ручно решите конфликт, проследите команди <code>merge</code> било <code>-Xours</code> или <code>-Xtheirs</code>.</p>
</div>
<div class="paragraph">
<p>Ако програм Гит наиђе на ово, он неће да дода маркере конфликта.
У случају било којих разлика које могу да се споје, спојиће.
У случају било којих разлика које изазивају конфликт, просто ће изабрати страну коју сте навели у целини, укључујући и бинарне фајлове.</p>
</div>
<div class="paragraph">
<p>Ако се вратимо на „hello world” пример који смо раније користили, можемо видети да је спајање наше гране изазвало конфликте.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved 'hello.rb' using previous resolution.
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Међутим, ако га покренемо са <code>-Xours</code> или <code>-Xtheirs</code> конфликта нема.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge -Xours mundo
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 test.sh  | 2 ++
 2 files changed, 3 insertions(+), 1 deletion(-)
 create mode 100644 test.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>У том случају, уместо да постави маркере конфликта у фајлу са „hello mundo” не једној страни и „hola world” на другој, просто ће изабрати „hola world”.
Међутим, успешно се спајају све остале измене на тој грани које не праве конфликте.</p>
</div>
<div class="paragraph">
<p>Ова опција може да се проследи и команди <code>git merge-file</code> коју смо раније видели извршавајући нешто као што је <code>git merge-file --ours</code> за спајање појединачних фајлова.</p>
</div>
<div class="paragraph">
<p>Ако желите да урадите овако нешто, али тако да програм Гит уопште ни не покуша да споји измене са друге стране, постоји драконска опција, под именом „ours” <em>стратегија</em> спајања.
Ово се разликује од „ours” <em>опције</em> рекурзивног спајања.</p>
</div>
<div class="paragraph">
<p>Ово ће практично да уради лажно спајање.
Забележиће нови комит спајања којем су обе гране родитељи, али чак неће ни да погледа грану коју спајате.
Само ће забележити да је резултат спајања потпуно исти кôд који је у вашој грани.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge -s ours mundo
Merge made by the 'ours' strategy.
$ git diff HEAD HEAD~
$</code></pre>
</div>
</div>
<div class="paragraph">
<p>Видите да нема никаквих разлика између гране на којој смо се налазили и резултата спајања.</p>
</div>
<div class="paragraph">
<p>Ово често може бити корисно да се програм Гит у суштини завара тако да мисли да је грана већ спојена када касније буде радио спајање.
На пример, рецимо да сте разгранали <code>release</code> грану и да сте на њој урадили неки посао који ћете у неком тренутку хтети да спојите назад у своју <code>master</code> грану.
У међувремену, нека исправка бага у <code>master</code> грани треба да се портује назад у вашу <code>release</code> грану.
Грану са исправљеним багом можете да спојите у <code>release</code> грану и да такође урадите <code>merge -s ours</code> исте гране у своју <code>master</code> грану (мада се исправка тамо већ налази), тако да када касније поново спојите <code>release</code> грану, неће бити конфликта услед исправке бага.</p>
</div>
</div>
<div class="sect4">
<h4 id="_subtree_merge">Спајање подстабла</h4>
<div class="paragraph">
<p>Идеја код спајања подстабла је да имате два пројекта и један од пројеката се мапира у поддиректоријум другог и обрнуто.
Када задате спајање подстабла, програм Гит је често довољно паметан да одреди ако је један подстабло оног другог, па да споји на погодан начин.</p>
</div>
<div class="paragraph">
<p>Проћи ћемо кроз пример додавања одвојеног пројекта у постојећи пројекат, па затим спајање кода другог у поддиректоријум првог.</p>
</div>
<div class="paragraph">
<p>На почетку, додајмо <em>Rack</em> апликацију нашем пројекту.
<em>Rack</em> пројекат додајемо као удаљену референцу у пројекат, па је затим одјављујемо у њену сопствену грану:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add rack_remote https://github.com/rack/rack
$ git fetch rack_remote --no-tags
warning: no common commits
remote: Counting objects: 3184, done.
remote: Compressing objects: 100% (1465/1465), done.
remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.
Resolving deltas: 100% (1952/1952), done.
From https://github.com/rack/rack
 * [new branch]      build      -&gt; rack_remote/build
 * [new branch]      master     -&gt; rack_remote/master
 * [new branch]      rack-0.4   -&gt; rack_remote/rack-0.4
 * [new branch]      rack-0.9   -&gt; rack_remote/rack-0.9
$ git checkout -b rack_branch rack_remote/master
Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.
Switched to a new branch "rack_branch"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Сада у <code>rack_branch</code> имамо корен <em>Rack</em> пројекта и наш пројекат у <code>master</code> грани.
Ако одјавите један па онда други, видећете да им се корени пројекта разликују:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ls
AUTHORS         KNOWN-ISSUES   Rakefile      contrib         lib
COPYING         README         bin           example         test
$ git checkout master
Switched to branch "master"
$ ls
README</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ово је прилично чудан концепт.
Не морају све гране у вашем репозиторијуму да буду гране истог пројекта.
Није уобичајено, јер је ретко од помоћи, али је прилично једноставно да имате гране које садрже потпуно различите историје.</p>
</div>
<div class="paragraph">
<p>У овом случају желимо да повучемо <em>Rack</em> пројекат у наш <code>master</code> пројекат као поддиректоријум.
У програму Гит то можемо да урадимо помоћу <code>git read-tree</code>.
Научићете више о <code>read-tree</code> и његовим другарима у <a href="{{< relurl "book/sr/v2/ch00/ch10-git-internals" >}}">Гит изнутра</a>, али за сада је довољно да знате да она учитава корено стабло једне од грана у ваш текући стејџ и радни директоријум.
Управо смо се вратили у вашу <code>master</code> грану и повлачимо <code>rack_branch</code> грану у <code>rack</code> поддиректоријум наше <code>master</code> гране главног пројекта:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git read-tree --prefix=rack/ -u rack_branch</code></pre>
</div>
</div>
<div class="paragraph">
<p>Када комитујемо, изгледа као да у том поддиректоријуму имамо све <em>Rack</em> фајлове – као да смо их прекопирали из <em>tarball</em> архиве.
Оно што је интересантно је да прилично једноставно можемо да спојимо измене из једне гране у другу.
Дакле, ако се <em>Rack</em> пројекат ажурира, узводне промене можемо да повучемо тако што се пребацимо на ту грану и повучемо:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout rack_branch
$ git pull</code></pre>
</div>
</div>
<div class="paragraph">
<p>Те измене затим можемо да спојимо назад у нашу <code>master</code> грану.
Да бисте повукли измене и унапред попунили комит подруку, употребите <code>--squash</code> опцију, као и <code>-Xsubtree</code> опцију рекурзивне стратегије спајања.
Рекурзивна стратегија је овде и иначе подразумевана, али је због јаснијег приказа овде наводимо.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
$ git merge --squash -s recursive -Xsubtree=rack rack_branch
Squash commit -- not updating HEAD
Automatic merge went well; stopped before committing as requested</code></pre>
</div>
</div>
<div class="paragraph">
<p>Све измене из <em>Rack</em> пројекта су спојене и спремне за локално комитовање.
Такође можете да урадите и супротно – направите измене у <code>rack</code> поддиректоријуму ваше <code>master</code> гране па их спојите у <code>rack_branch</code> да их касније предате одржаваоцима или да их гурнете узводно.</p>
</div>
<div class="paragraph">
<p>Ово нам омогућава начин да имамо сличан процес рада као у случају подмодула само без потребе да се користе подмодули (које ћемо обрадити у <a href="{{< relurl "book/sr/v2/ch00/_git_submodules" >}}">Подмодули</a>).
У нашем репозиторијуму можемо да држимо гране са осталим повезаним пројектима и да их повремено спајамо као подстабло у наш пројекат.
То је на неки начин фино, на пример сав кôд се комитује на једно место.
Међутим, постоје и лоше стране јер је донекле комплексно и лакше је да се направе грешке приликом реинтеграције измена или нехотичног гурања гране у неповезани репозиторијум.</p>
</div>
<div class="paragraph">
<p>Још једна помало чудна ствар је начин на који добијате разлику између онога што се налази у <code>rack</code> поддиректоријуму и кода у <code>rack_branch</code> грани – како бисте видели да ли је потребно да их спојите – не можете употребити обичну <code>diff</code> команду.
Уместо ње морате извршити <code>git diff-tree</code> са граном коју желите да упоредите:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff-tree -p rack_branch</code></pre>
</div>
</div>
<div class="paragraph">
<p>Или, да бисте упоредили оно што се налази у <code>rack</code> поддиректоријуму са оним из <code>master</code> гране на серверу последњи пут кад сте преузели са њега, можете да извршите:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff-tree -p rack_remote/master</code></pre>
</div>
</div>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>