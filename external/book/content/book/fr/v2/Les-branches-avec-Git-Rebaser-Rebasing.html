---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: fr
  chapter:
    title: Les branches avec Git
    number: 3
  section:
    title: Rebaser (Rebasing)
    number: 6
    cs_number: '3.6'
    previous: book/fr/v2/Les-branches-avec-Git-Branches-de-suivi-à-distance
    next: book/fr/v2/Les-branches-avec-Git-Résumé
title: Git - Rebaser (Rebasing)
---
<h2 id="s_rebasing">Rebaser (<em>Rebasing</em>)</h2>
<div class="paragraph">
<p>
Dans Git, il y a deux façons d’intégrer les modifications d’une branche dans une autre : en fusionnant (<code>merge</code>) et en rebasant (<code>rebase</code>).
Dans ce chapitre, vous apprendrez la signification de rebaser, comment le faire, pourquoi c’est un outil incroyable et dans quels cas il est déconseillé de l’utiliser.</p>
</div>
<div class="sect3">
<h3 id="_les_bases">Les bases</h3>
<div class="paragraph">
<p>Si vous revenez à un exemple précédent du chapitre <a href="{{< relurl "book/fr/v2/ch00/s_basic_merging" >}}">Fusions (<em>Merges</em>)</a>, vous remarquerez que votre travail a divergé et que vous avez ajouté des <em>commits</em> sur deux branches différentes.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/basic-rebase-1.png" >}}" alt="Historique divergeant simple">
</div>
<div class="title">Figure 35. Historique divergeant simple</div>
</div>
<div class="paragraph">
<p>Comme nous l’avons déjà expliqué, le moyen le plus simple pour intégrer ces branches est la fusion via la commande <code>merge</code>.
Cette commande réalise une <em>fusion à trois branches</em> entre les deux derniers instantanés (<em>snapshots</em>) de chaque branche (C3 et C4) et l’ancêtre commun le plus récent (C2), créant un nouvel instantané (et un <em>commit</em>).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/basic-rebase-2.png" >}}" alt="Fusion pour intégrer des travaux aux historiques divergeants">
</div>
<div class="title">Figure 36. Fusion pour intégrer des travaux aux historiques divergeants</div>
</div>
<div class="paragraph">
<p>Cependant, il existe un autre moyen : vous pouvez prendre le <em>patch</em> de la modification introduite en <code>C4</code> et le réappliquer sur <code>C3</code>.
Dans Git, cette action est appelée "rebaser" (<em>rebasing</em>).
Avec la commande <code>rebase</code>, vous pouvez prendre toutes les modifications qui ont été validées sur une branche et les rejouer sur une autre.</p>
</div>
<div class="paragraph">
<p>Dans cet exemple, vous lanceriez les commandes suivantes :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cela fonctionne en cherchant l’ancêtre commun le plus récent des deux branches (celle sur laquelle vous vous trouvez et celle sur laquelle vous rebasez), en récupérant toutes les différences introduites par chaque <em>commit</em> de la branche courante, en les sauvant dans des fichiers temporaires, en réinitialisant la branche courante sur le même <em>commit</em> que la branche de destination et en appliquant finalement chaque modification dans le même ordre.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/basic-rebase-3.png" >}}" alt="Rebasage des modifications introduites par `C4` sur `C3`">
</div>
<div class="title">Figure 37. Rebasage des modifications introduites par <code>C4</code> sur <code>C3</code>
</div>
</div>
<div class="paragraph">
<p>À ce moment, vous pouvez retourner sur la branche <code>master</code> et réaliser une fusion en avance rapide (<em>fast-forward merge</em>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
$ git merge experiment</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/basic-rebase-4.png" >}}" alt="Avance rapide de la branche `master`">
</div>
<div class="title">Figure 38. Avance rapide de la branche <code>master</code>
</div>
</div>
<div class="paragraph">
<p>À présent, l’instantané pointé par <code>C4'</code> est exactement le même que celui pointé par <code>C5</code> dans l’exemple de fusion.
Il n’y a pas de différence entre les résultats des deux types d’intégration, mais rebaser rend l’historique plus clair.
Si vous examinez le journal de la branche rebasée, elle est devenue linéaire : toutes les modifications apparaissent en série même si elles ont eu lieu en parallèle.</p>
</div>
<div class="paragraph">
<p>Vous aurez souvent à faire cela pour vous assurer que vos <em>commits</em> s’appliquent proprement sur une branche distante — par exemple, sur un projet où vous souhaitez contribuer mais que vous ne maintenez pas.
Dans ce cas, vous réaliseriez votre travail dans une branche puis vous rebaseriez votre travail sur <code>origin/master</code> quand vous êtes prêt à soumettre vos patchs au projet principal.
De cette manière, le mainteneur n’a pas à réaliser de travail d’intégration — juste une avance rapide ou simplement une application propre.</p>
</div>
<div class="paragraph">
<p>Il faut noter que l’instantané pointé par le <em>commit</em> final, qu’il soit le dernier des <em>commits</em> d’une opération de rebasage ou le <em>commit</em> final issu d’une fusion, sont en fait le même instantané — c’est juste que l’historique est différent.
Rebaser rejoue les modifications d’une ligne de <em>commits</em> sur une autre dans l’ordre d’apparition, alors que la fusion joint et fusionne les deux têtes.</p>
</div>
</div>
<div class="sect3">
<h3 id="_rebases_plus_intéressants">Rebases plus intéressants</h3>
<div class="paragraph">
<p>Vous pouvez aussi faire rejouer votre rebasage sur autre chose qu’une branche.
Prenez un historique tel que <a href="{{< relurl "book/fr/v2/ch00/rbdiag_e" >}}">Un historique avec deux branches thématiques qui sortent l’une de l’autre</a> par exemple.
Vous avez créé une branche thématique (<code>server</code>) pour ajouter des fonctionnalités côté serveur à votre projet et avez réalisé un <em>commit</em>.
Ensuite, vous avez créé une branche pour ajouter des modifications côté client (<code>client</code>) et avez validé plusieurs fois.
Finalement, vous avez rebasculé sur la branche <code>server</code> et avez réalisé quelques <em>commits</em> supplémentaires.</p>
</div>
<div id="rbdiag_e" class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/interesting-rebase-1.png" >}}" alt="Un historique avec deux branches thématiques qui sortent l’une de l’autre">
</div>
<div class="title">Figure 39. Un historique avec deux branches thématiques qui sortent l’une de l’autre</div>
</div>
<div class="paragraph">
<p>Supposons que vous décidez que vous souhaitez fusionner vos modifications du côté client dans votre ligne principale pour une publication (<em>release</em>) mais vous souhaitez retenir les modifications de la partie serveur jusqu’à ce qu’elles soient un peu mieux testées.
Vous pouvez récupérer les modifications du côté client qui ne sont pas sur le serveur (<code>C8</code> et <code>C9</code>) et les rejouer sur la branche <code>master</code> en utilisant l’option <code>--onto</code> de <code>git rebase</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rebase --onto master server client</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cela signifie en substance "Extraire la branche client, déterminer les patchs depuis l’ancêtre commun des branches <code>client</code> et <code>server</code> puis les rejouer sur <code>master</code> ".
C’est assez complexe, mais le résultat est assez impressionnant.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/interesting-rebase-2.png" >}}" alt="Rebaser deux branches thématiques l’une sur l’autre">
</div>
<div class="title">Figure 40. Rebaser deux branches thématiques l’une sur l’autre</div>
</div>
<div class="paragraph">
<p>Maintenant, vous pouvez faire une avance rapide sur votre branche <code>master</code> (cf. <a href="{{< relurl "book/fr/v2/ch00/rbdiag_g" >}}">Avance rapide sur votre branche <code>master</code> pour inclure les modifications de la branche client</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
$ git merge client</code></pre>
</div>
</div>
<div id="rbdiag_g" class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/interesting-rebase-3.png" >}}" alt="Avance rapide sur votre branche `master` pour inclure les modifications de la branche client">
</div>
<div class="title">Figure 41. Avance rapide sur votre branche <code>master</code> pour inclure les modifications de la branche client</div>
</div>
<div class="paragraph">
<p>Supposons que vous décidiez de tirer (<em>pull</em>) votre branche <code>server</code> aussi.
Vous pouvez rebaser la branche <code>server</code> sur la branche <code>master</code> sans avoir à l’extraire avant en utilisant <code>git rebase [branchedebase] [branchethematique]</code> — qui extrait la branche thématique (dans notre cas, <code>server</code>) pour vous et la rejoue sur la branche de base (<code>master</code>) :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rebase master server</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cette commande rejoue les modifications de <code>server</code> sur le sommet de la branche <code>master</code>, comme indiqué dans <a href="{{< relurl "book/fr/v2/ch00/rbdiag_h" >}}">Rebasage de la branche server sur le sommet de la branche <code>master</code></a>.</p>
</div>
<div id="rbdiag_h" class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/interesting-rebase-4.png" >}}" alt="Rebasage de la branche server sur le sommet de la branche `master`">
</div>
<div class="title">Figure 42. Rebasage de la branche server sur le sommet de la branche <code>master</code>
</div>
</div>
<div class="paragraph">
<p>Vous pouvez ensuite faire une avance rapide sur la branche de base (<code>master</code>) :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
$ git merge server</code></pre>
</div>
</div>
<div class="paragraph">
<p>Vous pouvez effacer les branches <code>client</code> et <code>server</code> une fois que tout le travail est intégré et que vous n’en avez plus besoin, éliminant tout l’historique de ce processus, comme visible sur <a href="{{< relurl "book/fr/v2/ch00/rbdiag_i" >}}">Historique final des <em>commits</em></a> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch -d client
$ git branch -d server</code></pre>
</div>
</div>
<div id="rbdiag_i" class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/interesting-rebase-5.png" >}}" alt="Historique final des _commits_">
</div>
<div class="title">Figure 43. Historique final des <em>commits</em>
</div>
</div>
</div>
<div class="sect3">
<h3 id="s_rebase_peril">Les dangers du rebasage</h3>
<div class="paragraph">
<p>
Ah… mais les joies de rebaser ne viennent pas sans leurs contreparties, qui peuvent être résumées en une ligne :</p>
</div>
<div class="paragraph">
<p><strong>Ne rebasez jamais des <em>commits</em> qui ont déjà été poussés sur un dépôt public.</strong></p>
</div>
<div class="paragraph">
<p>Si vous suivez ce conseil, tout ira bien.
Sinon, de nombreuses personnes vont vous haïr et vous serez méprisé par vos amis et votre famille.</p>
</div>
<div class="paragraph">
<p>Quand vous rebasez des données, vous abandonnez les <em>commits</em> existants et vous en créez de nouveaux qui sont similaires mais différents.
Si vous poussez des <em>commits</em> quelque part, que d’autres les tirent et se basent dessus pour travailler, et qu’après coup, vous réécrivez ces <em>commits</em> à l’aide de <code>git rebase</code> et les poussez à nouveau, vos collaborateurs devront re-fusionner leur travail et les choses peuvent rapidement devenir très désordonnées quand vous essaierez de tirer leur travail dans votre dépôt.</p>
</div>
<div class="paragraph">
<p>Examinons un exemple expliquant comment rebaser un travail déjà publié sur un dépôt public peut générer des gros problèmes.
Supposons que vous clonez un dépôt depuis un serveur central et réalisez quelques travaux dessus.
Votre historique de <em>commits</em> ressemble à ceci :</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/perils-of-rebasing-1.png" >}}" alt="Cloner un dépôt et baser du travail dessus.">
</div>
<div class="title">Figure 44. Cloner un dépôt et baser du travail dessus</div>
</div>
<div class="paragraph">
<p>À présent, une autre personne travaille et inclut une fusion, puis elle pousse ce travail sur le serveur central.
Vous le récupérez et vous fusionnez la nouvelle branche distante dans votre copie, ce qui donne l’historique suivant :</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/perils-of-rebasing-2.png" >}}" alt="Récupération de _commits_ et fusion dans votre copie.">
</div>
<div class="title">Figure 45. Récupération de <em>commits</em> et fusion dans votre copie</div>
</div>
<div class="paragraph">
<p>Ensuite, la personne qui a poussé le travail que vous venez de fusionner décide de faire marche arrière et de rebaser son travail.
Elle lance un <code>git push --force</code> pour forcer l’écrasement de l’historique sur le serveur.
Vous récupérez alors les données du serveur, qui vous amènent les nouveaux <em>commits</em>.</p>
</div>
<div id="s_pre_merge_rebase_work" class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/perils-of-rebasing-3.png" >}}" alt="Quelqu’un pousse des _commits_ rebasés, en abandonnant les _commits_ sur lesquels vous avez fondé votre travail.">
</div>
<div class="title">Figure 46. Quelqu’un pousse des <em>commits</em> rebasés, en abandonnant les <em>commits</em> sur lesquels vous avez fondé votre travail</div>
</div>
<div class="paragraph">
<p>Vous êtes désormais tous les deux dans le pétrin.
Si vous faites un <code>git pull</code>, vous allez créer un <em>commit</em> de fusion incluant les deux historiques et votre dépôt ressemblera à ça :</p>
</div>
<div id="s_merge_rebase_work" class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/perils-of-rebasing-4.png" >}}" alt="Vous fusionnez le même travail une nouvelle fois dans un nouveau _commit_ de fusion">
</div>
<div class="title">Figure 47. Vous fusionnez le même travail une nouvelle fois dans un nouveau <em>commit</em> de fusion</div>
</div>
<div class="paragraph">
<p>Si vous lancez <code>git log</code> lorsque votre historique ressemble à ceci, vous verrez deux <em>commits</em> qui ont la même date d’auteur et les mêmes messages, ce qui est déroutant.
De plus, si vous poussez cet historique sur le serveur, vous réintroduirez tous ces <em>commits</em> rebasés sur le serveur central, ce qui va encore plus dérouter les autres développeurs.
C’est plutôt logique de présumer que l’autre développeur ne souhaite pas voir apparaître <code>C4</code> et <code>C6</code> dans l’historique.
C’est la raison pour laquelle il avait effectué un rebasage initialement.</p>
</div>
</div>
<div class="sect3">
<h3 id="s_rebase_rebase">Rebaser quand vous rebasez</h3>
<div class="paragraph">
<p>Si vous vous retrouvez effectivement dans une situation telle que celle-ci, Git dispose d’autres fonctions magiques qui peuvent vous aider.
Si quelqu’un de votre équipe pousse de force des changements qui écrasent des travaux sur lesquels vous vous êtes basés, votre défi est de déterminer ce qui est à vous et ce qui a été réécrit.</p>
</div>
<div class="paragraph">
<p>Il se trouve qu’en plus de l’empreinte SHA du <em>commit</em>, Git calcule aussi une empreinte qui est uniquement basée sur le patch introduit avec le commit.
Ceci est appelé un "identifiant de patch" (<em>patch-id</em>).</p>
</div>
<div class="paragraph">
<p>Si vous tirez des travaux qui ont été réécrits et les rebasez au-dessus des nouveaux <em>commits</em> de votre collègue, Git peut souvent déterminer ceux qui sont uniquement les vôtres et les réappliquer au sommet de votre nouvelle branche.</p>
</div>
<div class="paragraph">
<p>Par exemple, dans le scénario précédent, si au lieu de fusionner quand nous étions à l’étape <a href="{{< relurl "book/fr/v2/ch00/s_pre_merge_rebase_work" >}}">Quelqu’un pousse des <em>commits</em> rebasés, en abandonnant les <em>commits</em> sur lesquels vous avez fondé votre travail</a> nous exécutons la commande  <code>git rebase teamone/master</code>, Git va :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Déterminer quels travaux sont uniques à notre branche (C2, C3, C4, C6, C7)</p>
</li>
<li>
<p>Déterminer ceux qui ne sont pas des <em>commits</em> de fusion (C2, C3, C4)</p>
</li>
<li>
<p>Déterminer ceux qui n’ont pas été réécrits dans la branche de destination (uniquement C2 et C3 puisque C4 est le même <em>patch</em> que C4')</p>
</li>
<li>
<p>Appliquer ces <em>commits</em> au sommet de <code>teamone/master</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ainsi, au lieu du résultat que nous avons observé au chapitre <a href="{{< relurl "book/fr/v2/ch00/s_merge_rebase_work" >}}">Vous fusionnez le même travail une nouvelle fois dans un nouveau <em>commit</em> de fusion</a>, nous aurions pu finir avec quelque chose qui ressemblerait davantage à <a href="{{< relurl "book/fr/v2/ch00/s_rebase_rebase_work" >}}">Rebaser au-dessus de travaux rebasés puis que l’on a poussé en forçant</a>.</p>
</div>
<div id="s_rebase_rebase_work" class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/perils-of-rebasing-5.png" >}}" alt="Rebaser au-dessus de travaux rebasés puis que l’on a poussé en forçant">
</div>
<div class="title">Figure 48. Rebaser au-dessus de travaux rebasés puis que l’on a poussé en forçant</div>
</div>
<div class="paragraph">
<p>Cela fonctionne seulement si les <em>commits</em> C4 et C4' de votre collègue correspondent presque exactement aux mêmes modifications.
Autrement, le rebasage ne sera pas capable de déterminer qu’il s’agit d’un doublon et va ajouter un autre <em>patch</em> similaire à C4 (ce qui échouera probablement puisque les changements sont au moins partiellement déjà présents).</p>
</div>
<div class="paragraph">
<p>Vous pouvez également simplifier tout cela en lançant un <code>git pull --rebase</code> au lieu d’un <code>git pull</code> normal.
Vous pouvez encore le faire manuellement à l’aide d’un <code>git fetch</code> suivi d’un <code>git rebase team1/master</code> dans le cas présent.</p>
</div>
<div class="paragraph">
<p>Si vous utilisez <code>git pull</code> et voulez faire de <code>--rebase</code> le traitement par défaut, vous pouvez changer la valeur du paramètre de configuration <code>pull.rebase</code> par <code>git config --global pull.rebase true</code>.</p>
</div>
<div class="paragraph">
<p>Si vous considérez le fait de rebaser comme un moyen de nettoyer et réarranger des <em>commits</em> avant de les pousser et si vous vous en tenez à ne rebaser que des <em>commits</em> qui n’ont jamais été publiés, tout ira bien.
Si vous tentez de rebaser des <em>commits</em> déjà publiés sur lesquels les gens ont déjà basé leur travail, vous allez au devant de gros problèmes et votre équipe vous en tiendra rigueur.</p>
</div>
<div class="paragraph">
<p>Si vous ou l’un de vos collègues y trouve cependant une quelconque nécessité, assurez-vous que tout le monde sache lancer un <code>git pull --rebase</code> pour essayer de rendre les choses un peu plus faciles.</p>
</div>
</div>
<div class="sect3">
<h3 id="_rebaser_ou_fusionner">Rebaser ou Fusionner</h3>
<div class="paragraph">
<p>
Maintenant que vous avez vu concrètement ce que signifient rebaser et fusionner, vous devez vous demander ce qu’il est préférable d’utiliser.
Avant de pouvoir répondre à cela, revenons quelque peu en arrière et parlons un peu de ce que signifie un historique.</p>
</div>
<div class="paragraph">
<p>On peut voir l’historique des <em>commits</em> de votre dépôt comme un <strong>enregistrement de ce qu’il s’est réellement passé</strong>.
Il s’agit d’un document historique qui a une valeur en tant que tel et ne doit pas être altéré.
Sous cet angle, modifier l’historique des <em>commits</em> est presque blasphématoire puisque vous <em>mentez</em> sur ce qu’il s’est réellement passé.
Dans ce cas, que faire dans le cas d’une série de <em>commits</em> de fusions désordonnés ?
Cela reflète ce qu’il s’est passé et le dépôt devrait le conserver pour la postérité.</p>
</div>
<div class="paragraph">
<p>Le point de vue inverse consiste à considérer que l’historique des <em>commits</em> est <strong>le reflet de la façon dont votre projet a été construit</strong>.
Vous ne publieriez jamais le premier brouillon d’un livre et le manuel de maintenance de votre projet mérite une révision attentive.
Ceci constitue le camp de ceux qui utilisent des outils tels que le rebasage et les branches filtrées pour raconter une histoire de la meilleure des manières pour les futurs lecteurs.</p>
</div>
<div class="paragraph">
<p>Désormais, nous espérons que vous comprenez qu’il n’est pas si simple de répondre à la question portant sur le meilleur outil entre fusion et rebasage.
Git est un outil puissant et vous permet beaucoup de manipulations sur et avec votre historique mais chaque équipe et chaque projet sont différents.
Maintenant que vous savez comment fonctionnent ces deux outils, c’est à vous de décider lequel correspond le mieux à votre situation en particulier.</p>
</div>
<div class="paragraph">
<p>De manière générale, la manière de profiter au mieux des deux mondes consiste à rebaser des modifications locales que vous avez effectuées mais qui n’ont pas encore été partagées avant de les pousser de manière à obtenir un historique propre mais sans jamais rebaser quoi que ce soit que vous ayez déjà poussé quelque part.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>