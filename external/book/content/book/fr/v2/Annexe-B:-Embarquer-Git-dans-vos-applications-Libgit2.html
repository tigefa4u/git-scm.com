---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: fr
  chapter:
    title: 'Annexe B: Embarquer Git dans vos applications'
    number: 2
  section:
    title: Libgit2
    number: 2
    cs_number: A2.2
    previous: book/fr/v2/Annexe-B:-Embarquer-Git-dans-vos-applications-Git-en-ligne-de-commande
    next: book/fr/v2/Annexe-B:-Embarquer-Git-dans-vos-applications-JGit
title: Git - Libgit2
url: "/book/fr/v2/Annexe-B:-Embarquer-Git-dans-vos-applications-Libgit2.html"
---
<h2 id="_libgit2">Libgit2</h2>
<div class="paragraph">
<p>
Une autre option à votre disposition consiste à utiliser Libgit2.
Libgit2 est une mise en œuvre de Git sans dépendance externe, qui se focalise sur une interface de programmation agréable à utiliser depuis d’autres programmes.
Vous pouvez la trouver sur <a href="https://libgit2.github.com" class="bare">https://libgit2.github.com</a>.</p>
</div>
<div class="paragraph">
<p>Voyons d’abord à quoi ressemble l’API C.
En voici un tour rapide :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">// Ouvrir un depot
git_repository *repo;
int error = git_repository_open(&amp;repo, "/path/to/repository");

// Dereferencer HEAD vers un commit
git_object *head_commit;
error = git_revparse_single(&amp;head_commit, repo, "HEAD^{commit}");
git_commit *commit = (git_commit*)head_commit;

// afficher quelques proprietes du commit
printf("%s", git_commit_message(commit));
const git_signature *author = git_commit_author(commit);
printf("%s &lt;%s&gt;\n", author-&gt;name, author-&gt;email);
const git_oid *tree_id = git_commit_tree_id(commit);

// Nettoyer
git_commit_free(commit);
git_repository_free(repo);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Les deux premières lignes ouvrent un dépôt Git.
Le type <code>git_repository</code> représente un identificateur de dépôt avec un cache en mémoire.
C’est la méthode la plus simple, quand vous connaissez le chemin exact vers le répertoire de travail ou le répertoire <code>.git</code> d’un dépôt.
Il y a aussi <code>git_repository_open_ext</code> qui inclut des options pour chercher, <code>git_clone</code> et ses déclinaisons pour créer un clone local d’un dépôt distant et <code>git_repository_init</code> pour créer un dépôt entièrement nouveau.</p>
</div>
<div class="paragraph">
<p>Le second bloc de code utilise la syntaxe « rev-parse » (voir <a href="{{< relurl "book/fr/v2/ch00/s_branch_references" >}}">Références de branches</a> pour plus de détails) pour obtenir le <em>commit</em> sur lequel HEAD peut pointer.
Le type retourné est un pointeur sur <code>git_object</code> qui représente quelque chose qui existe dans la base de données des objets de Git pour un dépôt.
<code>git_object</code> est en fait une type « parent » pour différentes sortes d’objets ; l’agencement en mémoire de chacun de ces types « enfants » est identique à celui de <code>git_object</code>, donc on peut forcer la conversion vers le type désiré en toute sécurité.
Dans notre cas, <code>git_object_type(commit)</code> retournerait <code>GIT_OBJ_COMMIT</code>, il est donc permis de le convertir en un pointeur de <code>git_commit</code>.</p>
</div>
<div class="paragraph">
<p>Le bloc suivant montre comment accéder aux propriétés d’un <em>commit</em>.
La dernière ligne utilise un type <code>git_oid</code> ; c’est la représentation d’une empreinte SHA-1 dans Libgit2.</p>
</div>
<div class="paragraph">
<p>De cet exemple, une structure générale commence à émerger :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Si vous déclarez un pointeur et que vous en passez une référence dans un appel à Libgit2, cet appel renverra vraisemblablement un code de retour entier.
Une valeur <code>0</code> indique un succès ; toute valeur négative est une erreur.</p>
</li>
<li>
<p>Si Libgit2 peuple un pointeur pour vous, vous êtes responsable de sa libération.</p>
</li>
<li>
<p>Si Libgit2 retourne un pointeur <code>const</code> après un appel, vous n’avez pas besoin de le libérer mais il deviendra invalide quand l’objet qui le possède sera lui-même libéré.</p>
</li>
<li>
<p>Écrire en C est un exercice plutôt douloureux.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>
Cette dernière remarque signifie qu’il est fort peu probable que vous écrirez du C pour utiliser Libgit2.
Heureusement, il existe un certain nombre de liaisons vers d’autres langages qui rendent plus facile l’interaction avec des dépôts Git depuis votre environnement et votre langage spécifiques.
Voyons l’exemple ci-dessus réécrit en utilisant le portage Ruby de Libgit2, appelé Rugged et qui peut être trouvé sur <a href="https://github.com/libgit2/rugged" class="bare">https://github.com/libgit2/rugged</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">repo = Rugged::Repository.new('path/to/repository')
commit = repo.head.target
puts commit.message
puts "#{commit.author[:name]} &lt;#{commit.author[:email]}&gt;"
tree = commit.tree</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tout de suite, le code est moins verbeux.
Déjà, Rugged utilise des exceptions ; il peut lever <code>ConfigError</code> ou <code>ObjectE</code> pour signaler des conditions d’erreur.
Ensuite, il n’y a pas de libération explicite des ressources, puisque Ruby utilise un ramasse-miettes.
Voyons un exemple légèrement plus compliqué : créer un <em>commit</em> à partir de rien.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">blob_id = repo.write("Blob contents", :blob) # <b class="conum">(1)</b>

index = repo.index
index.read_tree(repo.head.target.tree)
index.add(:path =&gt; 'newfile.txt', :oid =&gt; blob_id) # <b class="conum">(2)</b>

sig = {
    :email =&gt; "bob@example.com",
    :name =&gt; "Bob User",
    :time =&gt; Time.now,
}

commit_id = Rugged::Commit.create(repo,
    :tree =&gt; index.write_tree(repo), # <b class="conum">(3)</b>
    :author =&gt; sig,
    :committer =&gt; sig, # <b class="conum">(4)</b>
    :message =&gt; "Add newfile.txt", # <b class="conum">(5)</b>
    :parents =&gt; repo.empty? ? [] : [ repo.head.target ].compact, # <b class="conum">(6)</b>
    :update_ref =&gt; 'HEAD', # <b class="conum">(7)</b>
)
commit = repo.lookup(commit_id) # <b class="conum">(8)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Créer un nouveau blob qui contient le contenu d’un nouveau fichier.</p>
</li>
<li>
<p>Peupler l’index avec l’arbre du <em>commit</em> HEAD et ajouter le nouveau fichier sous le chemin <code>newfile.txt</code>.</p>
</li>
<li>
<p>Ceci crée un nouvel arbre dans la base de données des objets et l’utilise pour le nouveau <em>commit</em>.</p>
</li>
<li>
<p>Nous utilisons la même signature pour l’auteur et le validateur.</p>
</li>
<li>
<p>Le message de validation.</p>
</li>
<li>
<p>À la création d’un <em>commit</em>, il faut spécifier les parents du nouveau <em>commit</em>.
on utilise le sommet de HEAD comme parent unique.</p>
</li>
<li>
<p>Rugged (et Libgit2) peuvent en option mettre à jour la référence lors de la création du <em>commit</em>.</p>
</li>
<li>
<p>La valeur retournée est une empreinte SHA-1 du nouvel objet <em>commit</em> que vous pouvez alors utiliser pour obtenir un objet <code>Commit</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Le code Ruby est joli et propre, mais comme Libgit2 réalise le gros du travail, il tourne aussi plutôt rapidement.
Si vous n’êtes pas rubyiste, nous aborderons d’autres portages dans <a href="{{< relurl "book/fr/v2/ch00/s_libgit2_bindings" >}}">Autres liaisons</a>.</p>
</div>
<div class="sect3">
<h3 id="_fonctionnalité_avancée">Fonctionnalité avancée</h3>
<div class="paragraph">
<p>Libgit2 a certaines capacités qui ne sont pas disponibles dans Git natif.
Un exemple est la possibilité de greffons : Libgit2 vous permet de fournir des services « d’arrière-plan » pour différents types d’opérations, pour vous permettre de stocker les choses d’une manière différente de Git.
Libgit2 autorise des services d’arrière-plan pour la configuration, le stockage des références et la base de données d’objets, entre autres.</p>
</div>
<div class="paragraph">
<p>Voyons comment cela fonctionne.
Le code ci-dessous est emprunté à un ensemble d’exemples de services fourni par l’équipe Libgit2 (qui peut être trouvé sur <a href="https://github.com/libgit2/libgit2-backends" class="bare">https://github.com/libgit2/libgit2-backends</a>).
Voici comment un service d’arrière-plan pour une base de données d’objets peut être créée :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">git_odb *odb;
int error = git_odb_new(&amp;odb); // <b class="conum">(1)</b>

git_odb_backend *my_backend;
error = git_odb_backend_mine(&amp;my_backend, /*…*/); // <b class="conum">(2)</b>

error = git_odb_add_backend(odb, my_backend, 1); // <b class="conum">(3)</b>

git_repository *repo;
error = git_repository_open(&amp;repo, "some-path");
error = git_repository_set_odb(odb); // <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>(Notez que les erreurs sont capturées, mais ne sont pas gérées. Nous espérons que votre code est meilleur que le nôtre).</em></p>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Initialise une enveloppe d’interface d’une base de données d’objets vide (ODB) qui agit comme un conteneur pour les tâches de fond qui feront le vrai travail.</p>
</li>
<li>
<p>Initialise une tâche de fond ODB.</p>
</li>
<li>
<p>Ajoute la tâche de fond dans l’enveloppe.</p>
</li>
<li>
<p>Ouvre le dépôt et le paramètre pour utiliser notre ODB pour rechercher les objets.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Mais qu’est-ce que ce <code>git_odb_backend_mine</code> ?
Hé bien, c’est le constructeur de notre propre réalisation de l’ODB et nous pouvons la faire comme nous voulons tant que la structure <code>git_odb_backend</code> est correctement renseignée.
Voici à quoi elle <em>pourrait</em> ressembler :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">typedef struct {
    git_odb_backend parent;

    // Some other stuff
    void *custom_context;
} my_backend_struct;

int git_odb_backend_mine(git_odb_backend **backend_out, /*…*/)
{
    my_backend_struct *backend;

    backend = calloc(1, sizeof (my_backend_struct));

    backend-&gt;custom_context = …;

    backend-&gt;parent.read = &amp;my_backend__read;
    backend-&gt;parent.read_prefix = &amp;my_backend__read_prefix;
    backend-&gt;parent.read_header = &amp;my_backend__read_header;
    // …

    *backend_out = (git_odb_backend *) backend;

    return GIT_SUCCESS;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>La contrainte la plus subtile ici est que le premier membre de <code>my_backend_structure</code> doit être une structure <code>git_odb_backend</code> ; cela assure que la disposition en mémoire correspond à ce qu’attend le code de Libgit2.
Le reste est totalement arbitraire ; cette structure peut être aussi grande ou petite que nécessaire.</p>
</div>
<div class="paragraph">
<p>La fonction d’initialisation alloue de la mémoire pour la structure, initialise le contexte spécifique, puis remplit les membres de la structure <code>parent</code> qu’elle supporte.
Référez-vous au fichier <code>include/git2/sys/odb_backend.h</code> dans les sources de Libgit2 pour l’intégralité des signatures d’appels ; votre cas d’utilisation particulier vous permettra de déterminer lesquelles vous souhaitez supporter.</p>
</div>
</div>
<div class="sect3">
<h3 id="s_libgit2_bindings">Autres liaisons</h3>
<div class="paragraph">
<p>Libgit2 dispose de liaisons vers de nombreux langages.
Nous allons montrer ici un petit exemple en utilisant quelques-unes des liaisons les plus abouties au moment de la rédaction de ce livre ; des bibliothèques existent pour de nombreux autres langages qui incluent C++, Go, Node.js, Erlang et la JVM à différents stades de maturité.
La collection officielle de liaisons peut être trouvée en parcourant les dépôts sur <a href="https://github.com/libgit2" class="bare">https://github.com/libgit2</a>.
Le code que nous allons écrire retournera le message de validation du <em>commit</em> finalement pointé par HEAD (<code>git log -1</code> en quelque sorte).</p>
</div>
<div class="sect4">
<h4 id="_libgit2sharp">LibGit2Sharp</h4>
<div class="paragraph">
<p>
Si vous écrivez une application .NET ou Mono, LigGit2Sharp (<a href="https://github.com/libgit2/libgit2sharp" class="bare">https://github.com/libgit2/libgit2sharp</a>) est tout ce que vous cherchez.
Les liaisons sont écrites en C# et une grande attention a été portée à envelopper les appels directs à Libgit2 avec une interface de programmation naturelle en C#.
Voici à quoi notre programme d’exemple ressemble :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">new Repository(@"C:\path\to\repo").Head.Tip.Message;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pour les applications graphiques Windows, il existe même un paquet NuGet qui vous permettra de démarrer vos développements rapidement.</p>
</div>
</div>
<div class="sect4">
<h4 id="_objective_git">objective-git</h4>
<div class="paragraph">
<p>
Si votre application tourne sur une plateforme Apple, vous avez de grandes chances d’utiliser Objective-C comme langage de programmation.
Objective-Git (<a href="https://github.com/libgit2/objective-git" class="bare">https://github.com/libgit2/objective-git</a>) est le nom de la liaison de Libgit2 pour cet environnement.
Le programme d’exemple ressemble à ceci :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-objc" data-lang="objc">GTRepository *repo =
    [[GTRepository alloc] initWithURL:[NSURL fileURLWithPath: @"/path/to/repo"] error:NULL];
NSString *msg = [[[repo headReferenceWithError:NULL] resolvedTarget] message];</code></pre>
</div>
</div>
<div class="paragraph">
<p>Objective-git est totalement interopérable avec Swift, donc n’ayez crainte si vous avez abandonné Objective-C.</p>
</div>
</div>
<div class="sect4">
<h4 id="_pygit2">pygit2</h4>
<div class="paragraph">
<p>
La liaison avec Libgit2 en Python s’appelle Pygit2 et elle peut être trouvée sur <a href="https://www.pygit2.org/" class="bare">https://www.pygit2.org/</a>.
Notre programme d’exemple :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">pygit2.Repository("/chemin/du/depot") # ouvre le depot
    .head                             # recupere la branche en cours
    .peel(pygit2.Commit)              # descend au commit
    .message                          # lit le message</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_pour_aller_plus_loin">Pour aller plus loin</h3>
<div class="paragraph">
<p>Bien sûr, un traitement complet des capacités de Libgit2 est hors du cadre de ce livre.
Si vous souhaitez plus d’information sur Libgit2 elle-même, la documentation de programmation se trouve sur <a href="https://libgit2.github.com/libgit2" class="bare">https://libgit2.github.com/libgit2</a> et un ensemble de guides sur <a href="https://libgit2.github.com/docs" class="bare">https://libgit2.github.com/docs</a>.
Pour les autres liaisons, cherchez dans le README et dans les tests ; il y a souvent des petits didacticiels et des pointeurs sur d’autres documents.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>