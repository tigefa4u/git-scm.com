---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: fr
  chapter:
    title: Les bases de Git
    number: 2
  section:
    title: Enregistrer des modifications dans le dépôt
    number: 2
    cs_number: '2.2'
    previous: book/fr/v2/Les-bases-de-Git-Démarrer-un-dépôt-Git
    next: book/fr/v2/Les-bases-de-Git-Visualiser-l’historique-des-validations
title: Git - Enregistrer des modifications dans le dépôt
url: "/book/fr/v2/Les-bases-de-Git-Enregistrer-des-modifications-dans-le-dépôt.html"
---
<h2 id="_enregistrer_des_modifications_dans_le_dépôt">Enregistrer des modifications dans le dépôt</h2>
<div class="paragraph">
<p>Vous avez à présent un dépôt Git valide et une extraction ou copie de travail du projet.
Vous devez faire quelques modifications et valider des instantanés de ces modifications dans votre dépôt chaque fois que votre projet atteint un état que vous souhaitez enregistrer.</p>
</div>
<div class="paragraph">
<p>Souvenez-vous que chaque fichier de votre copie de travail peut avoir deux états : sous suivi de version ou non suivi.
Les fichiers suivis sont les fichiers qui appartenaient déjà au dernier instantané ; ils peuvent être inchangés, modifiés ou indexés.
En résumé, les fichiers suivis sont ceux que Git connait.</p>
</div>
<div class="paragraph">
<p>Tous les autres fichiers sont non suivis — tout fichier de votre copie de travail qui n’appartenait pas à votre dernier instantané et n’a pas été indexé.
Quand vous clonez un dépôt pour la première fois, tous les fichiers seront sous suivi de version et inchangés car Git vient tout juste de les extraire et vous ne les avez pas encore édités.</p>
</div>
<div class="paragraph">
<p>Au fur et à mesure que vous éditez des fichiers, Git les considère comme modifiés, car vous les avez modifiés depuis le dernier instantané.
Vous <strong>indexez</strong> ces fichiers modifiés et vous enregistrez toutes les modifications indexées, puis ce cycle se répète.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/lifecycle.png" >}}" alt="Le cycle de vie des états des fichiers.">
</div>
<div class="title">Figure 8. Le cycle de vie des états des fichiers.</div>
</div>
<div class="sect3">
<h3 id="s_checking_status">Vérifier l’état des fichiers</h3>
<div class="paragraph">
<p>L’outil principal pour déterminer quels fichiers sont dans quel état est la commande <code>git status</code>.
Si vous lancez cette commande juste après un clonage, vous devriez voir ce qui suit :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
Sur la branche master
Votre branche est à jour avec 'origin/master'.
rien à valider, la copie de travail est propre</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ce message signifie que votre copie de travail est propre, en d’autres termes, aucun fichier suivi n’a été modifié.
Git ne voit pas non plus de fichiers non-suivis, sinon ils seraient listés ici.
Enfin, la commande vous indique sur quelle branche vous êtes.
Pour l’instant, c’est toujours ``master'', qui correspond à la valeur par défaut ; nous ne nous en soucierons pas maintenant.
Dans <a href="{{< relurl "book/fr/v2/ch00/ch03-git-branching" >}}">Les branches avec Git</a>, nous parlerons plus en détail des branches et des références.</p>
</div>
<div class="paragraph">
<p>Supposons que vous souhaitez ajouter un nouveau fichier au projet, un simple fichier LISEZMOI.
Si le fichier n’existait pas auparavant, et si vous lancez <code>git status</code>, vous voyez votre fichier non suivi comme suit :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 'Mon Projet' &gt; LISEZMOI
$ git status
Sur la branche master
Votre branche est à jour avec 'origin/master'.
Fichiers non suivis:
  (utilisez "git add &lt;fichier&gt;..." pour inclure dans ce qui sera validé)

        LISEZMOI

aucune modification ajoutée à la validation mais des fichiers non suivis sont présents (utilisez "git add" pour les suivre)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Vous pouvez constater que votre nouveau fichier <code>LISEZMOI</code> n’est pas en suivi de version, car il apparaît dans la section « Fichiers non suivis » de l’état de la copie de travail.
« non suivi » signifie simplement que Git détecte un fichier qui n’était pas présent dans le dernier instantané ; Git ne le placera sous suivi de version que quand vous lui indiquerez de le faire.
Ce comportement permet de ne pas placer accidentellement sous suivi de version des fichiers binaires générés ou d’autres fichiers que vous ne voulez pas inclure.
Mais vous voulez inclure le fichier <code>LISEZMOI</code> dans l’instantané, alors commençons à suivre ce fichier.</p>
</div>
</div>
<div class="sect3">
<h3 id="s_tracking_files">Placer de nouveaux fichiers sous suivi de version</h3>
<div class="paragraph">
<p>Pour commencer à suivre un nouveau fichier, vous utilisez la commande <code>git add</code>.
Pour commencer à suivre le fichier <code>LISEZMOI</code>, vous pouvez entrer ceci :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add LISEZMOI</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si vous lancez à nouveau la commande <code>git status</code>, vous pouvez constater que votre fichier <code>LISEZMOI</code> est maintenant suivi et indexé :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
Sur la branche master
Votre branche est à jour avec 'origin/master'.
Modifications qui seront validées :
  (utilisez "git restore --staged &lt;fichier&gt;..." pour désindexer)

        nouveau fichier : LISEZMOI</code></pre>
</div>
</div>
<div class="paragraph">
<p>Vous pouvez affirmer qu’il est indexé car il apparaît dans la section « Modifications qui seront validées ».
Si vous validez à ce moment, la version du fichier à l’instant où vous lancez <code>git add</code> est celle qui sera dans l’historique des instantanés.
Vous pouvez vous souvenir que lorsque vous avez précédemment lancé <code>git init</code>, vous avez ensuite lancé <code>git add (fichiers)</code> — c’était bien sûr pour commencer à placer sous suivi de version les fichiers de votre répertoire de travail.
La commande <code>git add</code> accepte en paramètre un chemin qui correspond à un fichier ou un répertoire ; dans le cas d’un répertoire, la commande ajoute récursivement tous les fichiers de ce répertoire.</p>
</div>
</div>
<div class="sect3">
<h3 id="_indexer_des_fichiers_modifiés">Indexer des fichiers modifiés</h3>
<div class="paragraph">
<p>Maintenant, modifions un fichier qui est déjà sous suivi de version.
Si vous modifiez le fichier sous suivi de version appelé <code>CONTRIBUTING.md</code> et que vous lancez à nouveau votre commande <code>git status</code>, vous verrez ceci :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
Sur la branche master
Votre branche est à jour avec 'origin/master'.
Modifications qui seront validées :
  (utilisez "git reset HEAD &lt;fichier&gt;..." pour désindexer)

        nouveau fichier : LISEZMOI

Modifications qui ne seront pas validées :
  (utilisez "git add &lt;fichier&gt;..." pour mettre à jour ce qui sera validé)
  (utilisez "git checkout -- &lt;fichier&gt;..." pour annuler les modifications dans la copie de travail)

        modifié :         CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>Le fichier <code>CONTRIBUTING.md</code> apparaît sous la section nommée « Modifications qui ne seront pas validées » ce qui signifie que le fichier sous suivi de version a été modifié dans la copie de travail mais n’est pas encore indexé.
Pour l’indexer, il faut lancer la commande <code>git add</code>.
<code>git add</code> est une commande multi-usage — elle peut être utilisée pour placer un fichier sous suivi de version, pour indexer un fichier ou pour d’autres actions telles que marquer comme résolus des conflits de fusion de fichiers.
Sa signification s’approche plus de « ajouter ce contenu pour la prochaine validation » que de « ajouter ce contenu au projet ».
Lançons maintenant <code>git add</code> pour indexer le fichier <code>CONTRIBUTING.md</code>, et relançons la commande <code>git status</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
Sur la branche master
Votre branche est à jour avec 'origin/master'.
Modifications qui seront validées :
  (utilisez "git reset HEAD &lt;fichier&gt;..." pour désindexer)

        nouveau fichier : LISEZMOI
        modifié :         CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>À présent, les deux fichiers sont indexés et feront partie de la prochaine validation.
Mais supposons que vous souhaitiez apporter encore une petite modification au fichier <code>CONTRIBUTING.md</code> avant de réellement valider la nouvelle version.
Vous l’ouvrez à nouveau, réalisez la petite modification et vous voilà prêt à valider.
Néanmoins, vous lancez <code>git status</code> une dernière fois :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ vim CONTRIBUTING.md
$ git status
Sur la branche master
Votre branche est à jour avec 'origin/master'.
Modifications qui seront validées :
  (utilisez "git reset HEAD &lt;fichier&gt;..." pour désindexer)

        nouveau fichier : LISEZMOI
        modifié :         CONTRIBUTING.md

Modifications qui ne seront pas validées :
  (utilisez "git add &lt;fichier&gt;..." pour mettre à jour ce qui sera validé)
  (utilisez "git checkout -- &lt;fichier&gt;..." pour annuler les modifications dans la copie de travail)

        modifié :         CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>Que s’est-il donc passé ?
À présent, <code>CONTRIBUTING.md</code> apparaît à la fois comme indexé et non indexé.
En fait, Git indexe un fichier dans son état au moment où la commande <code>git add</code> est lancée.
Si on valide les modifications maintenant, la version de <code>CONTRIBUTING.md</code> qui fera partie de l’instantané est celle correspondant au moment où la commande <code>git add CONTRIBUTING.md</code> a été lancée, et non la version actuellement présente dans la copie de travail au moment où la commande <code>git commit</code> est lancée.
Si le fichier est modifié après un <code>git add</code>, il faut relancer <code>git add</code> pour prendre en compte l’état actuel de la copie de travail :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add CONTRIBUTING.md
$ git status
Sur la branche master
Votre branche est à jour avec 'origin/master'.
Modifications qui seront validées :
  (utilisez "git reset HEAD &lt;fichier&gt;..." pour désindexer)

        nouveau fichier : LISEZMOI
        modifié :         CONTRIBUTING.md</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_statut_court">Statut court</h3>
<div class="paragraph">
<p>Bien que <code>git status</code> soit informatif, il est aussi plutôt verbeux.
Git a aussi une option de status court qui permet de voir les modifications de façon plus compacte.
Si vous lancez <code>git status -s</code> ou <code>git status --short</code>, vous obtenez une information bien plus simple.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt</pre>
</div>
</div>
<div class="paragraph">
<p>Les nouveaux fichiers qui ne sont pas suivis sont précédés de <code>??</code>, les fichiers nouveaux et indexés sont précédés de <code>A</code>, les fichiers modifiés de <code>M</code> et ainsi de suite.
Il y a deux colonnes d’état - celle de gauche indique l’état de l’index et celle de droite l’état du dossier de travail.
Donc l’exemple ci-dessus indique que le fichier <code>README</code> est modifié dans le répertoire de travail mais n’est pas encore indexé, tandis que le fichier <code>lib/simplegit.rb</code> est modifié et indexé.
Le fichier <code>Rakefile</code> a été modifié, indexé puis modifié à nouveau, de sorte qu’il a des modifications à la fois indexées et non-indexées.</p>
</div>
</div>
<div class="sect3">
<h3 id="s_ignoring">Ignorer des fichiers</h3>
<div class="paragraph">
<p>Il apparaît souvent qu’un type de fichiers présent dans la copie de travail ne doit pas être ajouté automatiquement ou même ne doit pas apparaître comme fichier potentiel pour le suivi de version.
Ce sont par exemple des fichiers générés automatiquement tels que les fichiers de journaux ou de sauvegardes produits par l’outil que vous utilisez.
Dans un tel cas, on peut énumérer les patrons de noms de fichiers à ignorer dans un fichier <code>.gitignore</code>.
Voici ci-dessous un exemple de fichier <code>.gitignore</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .gitignore
*.[oa]
*~</code></pre>
</div>
</div>
<div class="paragraph">
<p>La première ligne ordonne à Git d’ignorer tout fichier se terminant en <code>.o</code> ou <code>.a</code> — des fichiers objet ou archive qui sont généralement produits par la compilation d’un programme.
La seconde ligne indique à Git d’ignorer tous les fichiers se terminant par un tilde (<code>~</code>), ce qui est le cas des noms des fichiers temporaires pour de nombreux éditeurs de texte tels qu’Emacs.
On peut aussi inclure un répertoire <code>log</code>, <code>tmp</code> ou <code>pid</code>, ou le répertoire de documentation générée automatiquement, ou tout autre fichier.
Renseigner un fichier <code>.gitignore</code> avant de commencer à travailler est généralement une bonne idée qui évitera de valider par inadvertance des fichiers qui ne doivent pas apparaître dans le dépôt Git.</p>
</div>
<div class="paragraph">
<p>Les règles de construction des patrons à placer dans le fichier <code>.gitignore</code> sont les suivantes :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>les lignes vides ou commençant par <code>#</code> sont ignorées ;</p>
</li>
<li>
<p>les patrons standards de fichiers sont utilisables et seront appliqués recursivement dans tout l’arbre de travail ;</p>
</li>
<li>
<p>si le patron commence par une barre oblique (`/), le patron n’est pas récursif ;</p>
</li>
<li>
<p>si le patron se termine par une barre oblique (<code>/</code>), il indique un répertoire ;</p>
</li>
<li>
<p>un patron commençant par un point d’exclamation (<code>!</code>) indique des fichiers à inclure malgré les autres règles.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Les patrons standards de fichiers sont des expressions régulières simplifiées utilisées par les shells.
Un astérisque (<code>*</code>) correspond à un ou plusieurs caractères ; <code>[abc]</code> correspond à un des trois caractères listés dans les crochets, donc a ou b ou c ; un point d’interrogation (<code>?</code>) correspond à un unique caractère ; des crochets entourant des caractères séparés par un tiret (<code>[0-9]</code>) correspond à un caractère dans l’intervalle des deux caractères indiqués, donc ici de 0 à 9.
Vous pouvez aussi utiliser deux astérisques pour indiquer une série de répertoires inclus ; <code>a/**/z</code> correspond donc à <code>a/z</code>, <code>a/b/z</code>, <code>a/b/c/z</code> et ainsi de suite.</p>
</div>
<div class="paragraph">
<p>Voici un autre exemple de fichier <code>.gitignore</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code># pas de fichier .a
*.a

# mais suivre lib.a malgré la règle précédente
!lib.a

# ignorer uniquement le fichier TODO à la racine du projet
/TODO

# ignorer tous les fichiers dans le répertoire build
build/

# ignorer doc/notes.txt, mais pas doc/server/arch.txt
doc/*.txt

# ignorer tous les fichiers .txt sous le répertoire doc/
doc/**/*.txt</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Astuce</div>
</td>
<td class="content">
<div class="paragraph">
<p>GitHub maintient une liste assez complète d’exemples de fichiers <code>.gitignore</code> correspondant à de nombreux types de projets et langages.
Voir <a href="https://github.com/github/gitignore" class="bare">https://github.com/github/gitignore</a> pour obtenir un point de départ pour votre projet.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Dans un cas simple, un dépôt peut n’avoir qu’un unique fichier <code>.gitignore</code> à la racine de l’arbre de travail, qui s’applique récursivement dans le dépôt.
Cependant, il est aussi possible d’avoir des fichiers <code>.gitignore</code> dans les sous-répertoires.
Les règles dans ces fichiers <code>.gitignore</code> locaux ne s’appliquent qu’à partir du répertoire où ils se trouvent.
Le dépôt des sources du noyau Linux contient 206 fichier <code>.gitignore</code>.</p>
</div>
<div class="paragraph">
<p>Les détails de l’utilisation de multiples fichiers <code>.gitignore</code> dépassent l’objet de ce livre ; référez-vous à <code>man gitignore</code> pour plus d’information.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h3 id="s_git_diff_staged">Inspecter les modifications indexées et non indexées</h3>
<div class="paragraph">
<p>Si le résultat de la commande <code>git status</code> est encore trop vague — lorsqu’on désire savoir non seulement quels fichiers ont changé mais aussi ce qui a changé dans ces fichiers — on peut utiliser la commande <code>git diff</code>.
Cette commande sera traitée en détail plus loin ; mais elle sera vraisemblablement utilisée le plus souvent pour répondre aux questions suivantes : qu’est-ce qui a été modifié mais pas encore indexé ? Quelle modification a été indexée et est prête pour la validation ?
Là où <code>git status</code> répond de manière générale à ces questions, <code>git diff</code> montre les lignes exactes qui ont été ajoutées, modifiées ou effacées — le patch en somme.</p>
</div>
<div class="paragraph">
<p>Supposons que vous éditez et indexez à nouveau le fichier <code>LISEZMOI</code> et que vous éditez <code>CONTRIBUTING.md</code> sans l’indexer.
Si vous lancer la commande <code>git status</code>, vous allez voir une fois encore quelque chose comme :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
Sur la branche master
Votre branche est à jour avec 'origin/master'.
Modifications qui seront validées :
  (utilisez "git reset HEAD &lt;fichier&gt;..." pour désindexer)

        nouveau fichier : LISEZMOI

Modifications qui ne seront pas validées :
  (utilisez "git add &lt;fichier&gt;..." pour mettre à jour ce qui sera validé)
  (utilisez "git checkout -- &lt;fichier&gt;..." pour annuler les modifications dans la copie de travail)

        modifié :         CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pour visualiser ce qui a été modifié mais pas encore indexé, tapez <code>git diff</code> sans autre argument :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if you patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cette commande compare le contenu du répertoire de travail avec la zone d’index.
Le résultat vous indique les modifications réalisées mais non indexées.</p>
</div>
<div class="paragraph">
<p>Si vous souhaitez visualiser les modifications indexées qui feront partie de la prochaine validation, vous pouvez utiliser <code>git diff --cached</code> (avec les versions 1.6.1 et supérieures de Git, vous pouvez aussi utiliser <code>git diff --staged</code>, qui est plus mnémotechnique).
Cette commande compare les fichiers indexés et le dernier instantané :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --staged
diff --git a/LISEZMOI b/LISEZMOI
new file mode 100644
index 0000000..1e17b0c
--- /dev/null
+++ b/LISEZMOI
@@ -0,0 +1 @@
+Mon Projet</code></pre>
</div>
</div>
<div class="paragraph">
<p>Il est important de noter que <code>git diff</code> ne montre pas les modifications réalisées depuis la dernière validation — seulement les modifications qui sont non indexées.
Cela peut introduire une confusion car si tous les fichiers modifiés ont été indexés, <code>git diff</code> n’indiquera aucun changement.</p>
</div>
<div class="paragraph">
<p>Par exemple, si vous indexez le fichier <code>CONTRIBUTING.md</code> et l’éditez ensuite, vous pouvez utiliser <code>git diff</code> pour visualiser les modifications indexées et non indexées de ce fichier.
Si l’état est le suivant :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add CONTRIBUTING.md
$ echo 'ligne de test' &gt;&gt; CONTRIBUTING.md
$ git status
Sur la branche master
Votre branche est à jour avec 'origin/master'.
Modifications qui seront validées :
  (utilisez "git reset HEAD &lt;fichier&gt;..." pour désindexer)

        nouveau fichier : CONTRIBUTING.md

Modifications qui ne seront pas validées :
  (utilisez "git add &lt;fichier&gt;..." pour mettre à jour ce qui sera validé)
  (utilisez "git checkout -- &lt;fichier&gt;..." pour annuler les modifications dans la copie de travail)

        modifié :         CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>À présent, vous pouvez utiliser <code>git diff</code> pour visualiser les modifications non indexées :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 643e24f..87f08c8 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -119,3 +119,4 @@ at the
 ## Starter Projects

 See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).
+ligne de test</code></pre>
</div>
</div>
<div class="paragraph">
<p>et <code>git diff --cached</code> pour visualiser ce qui a été indexé jusqu’à maintenant :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --cached
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if you patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's</code></pre>
</div>
</div>
<div id="s_git_difftool" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Git Diff dans un outil externe</div>
<div class="paragraph">
<p>Nous allons continuer à utiliser la commande <code>git diff</code> de différentes manières par la suite.
Il existe une autre manière de visualiser les différences si vous préférez un outil graphique ou externe.
Si vous lancez <code>git difftool</code> au lieu de <code>git diff</code>, vous pourrez visualiser les différences grâce à une application telle que Araxis, emerge, vimdiff ou autre.
Lancez <code>git difftool --tool-help</code> pour connaître les applications disponibles sur votre système.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h3 id="s_committing_changes">Valider vos modifications</h3>
<div class="paragraph">
<p>Maintenant que votre zone d’index est dans l’état désiré, vous pouvez valider vos modifications.
Souvenez-vous que tout ce qui est encore non indexé — tous les fichiers qui ont été créés ou modifiés mais n’ont pas subi de <code>git add</code> depuis que vous les avez modifiés — ne feront pas partie de la prochaine validation.
Ils resteront en tant que fichiers modifiés sur votre disque.
Dans notre cas, la dernière fois que vous avez lancé <code>git status</code>, vous avez vérifié que tout était indexé, et vous êtes donc prêt à valider vos modifications.
La manière la plus simple de valider est de taper <code>git commit</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cette action lance votre éditeur choisi.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Ceci est paramétré par la variable d’environnement <code>EDITOR</code> de votre shell — habituellement vim ou Emacs, mais vous pouvez le paramétrer spécifiquement pour Git en utilisant la commande <code>git config --global core.editor</code> comme nous l’avons vu au <a href="{{< relurl "book/fr/v2/ch00/ch01-getting-started" >}}">Démarrage rapide</a>).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>L’éditeur affiche le texte suivant (par exemple, ici Vim) :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code># Veuillez saisir le message de validation pour vos modifications. Les lignes
# commençant par '#' seront ignorées, et un message vide abandonne la validation.
# Sur la branche master
# Votre branche est à jour avec 'origin/master'.
#
# Modifications qui seront validées :
#       nouveau fichier : LISEZMOI
#       modifié :         CONTRIBUTING.md
#</code></pre>
</div>
</div>
<div class="paragraph">
<p>Vous constatez que le message de validation par défaut contient une ligne vide suivie en commentaire par le résultat de la commande <code>git status</code>.
Vous pouvez effacer ces lignes de commentaire et saisir votre propre message de validation, ou vous pouvez les laisser en place pour vous aider à vous rappeler ce que vous êtes en train de valider.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Pour un rappel plus explicite de ce que vous avez modifié, vous pouvez aussi passer l’option <code>-v</code> à la commande <code>git commit</code>.
Cette option place le résultat du diff en commentaire dans l’éditeur pour vous permettre de visualiser exactement ce que vous avez modifié.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Quand vous quittez l’éditeur (après avoir sauvegardé le message), Git crée votre <em>commit</em> avec ce message de validation (après avoir retiré les commentaires et le diff).</p>
</div>
<div class="paragraph">
<p>Autrement, vous pouvez spécifier votre message de validation en ligne avec la commande <code>git commit</code> en le saisissant après l’option <code>-m</code>, comme ceci :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git commit -m "Story 182: Fix benchmarks for speed"
[master 463dc4f] Story 182: Fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 LISEZMOI</code></pre>
</div>
</div>
<div class="paragraph">
<p>À présent, vous avez créé votre premier <em>commit</em> !
Vous pouvez constater que le <em>commit</em> vous fournit quelques informations sur lui-même : sur quelle branche vous avez validé (<code>master</code>), quelle est sa somme de contrôle SHA-1 (<code>463dc4f</code>), combien de fichiers ont été modifiés, et quelques statistiques sur les lignes ajoutées et effacées dans ce <em>commit</em>.</p>
</div>
<div class="paragraph">
<p>Souvenez-vous que la validation enregistre l’instantané que vous avez préparé dans la zone d’index.
Tout ce que vous n’avez pas indexé est toujours en état modifié ; vous pouvez réaliser une nouvelle validation pour l’ajouter à l’historique.
À chaque validation, vous enregistrez un instantané du projet en forme de jalon auquel vous pourrez revenir ou avec lequel comparer votre travail ultérieur.</p>
</div>
</div>
<div class="sect3">
<h3 id="_passer_létape_de_mise_en_index">Passer l’étape de mise en index</h3>
<div class="paragraph">
<p>
Bien qu’il soit incroyablement utile de pouvoir organiser les <em>commits</em> exactement comme on l’entend, la gestion de la zone d’index est parfois plus complexe que nécessaire dans le cadre d’une utilisation normale.
Si vous souhaitez éviter la phase de placement des fichiers dans la zone d’index, Git fournit un raccourci très simple.
L’ajout de l’option <code>-a</code> à la commande <code>git commit</code> ordonne à Git de placer automatiquement tout fichier déjà en suivi de version dans la zone d’index avant de réaliser la validation, évitant ainsi d’avoir à taper les commandes <code>git add</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
Sur la branche master
Votre branche est à jour avec 'origin/master'.
Modifications qui ne seront pas validées :
  (utilisez "git add &lt;fichier&gt;..." pour mettre à jour ce qui sera validé)
  (utilisez "git checkout -- &lt;fichier&gt;..." pour annuler les modifications dans la copie de travail)

        modifié :         CONTRIBUTING.md

aucune modification n'a été ajoutée à la validation (utilisez "git add" ou "git commit -a")
$ git commit -a -m 'added new benchmarks'
[master 83e38c7] added new benchmarks
 1 file changed, 5 insertions(+), 0 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notez bien que vous n’avez pas eu à lancer <code>git add</code> sur le fichier <code>CONTRIBUTING.md</code> avant de valider.</p>
</div>
</div>
<div class="sect3">
<h3 id="s_removing_files">Effacer des fichiers</h3>
<div class="paragraph">
<p>
Pour effacer un fichier de Git, vous devez l’éliminer des fichiers en suivi de version (plus précisément, l’effacer dans la zone d’index) puis valider.
La commande <code>git rm</code> réalise cette action mais efface aussi ce fichier de votre copie de travail de telle sorte que vous ne le verrez pas réapparaître comme fichier non suivi en version à la prochaine validation.</p>
</div>
<div class="paragraph">
<p>Si vous effacez simplement le fichier dans votre copie de travail, il apparaît sous la section « Modifications qui ne seront pas validées » (c’est-à-dire, <em>non indexé</em>) dans le résultat de <code>git status</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ rm PROJECTS.md
$ git status
Sur la branche master
Votre branche est à jour avec 'origin/master'.
Modifications qui ne seront pas validées :
  (utilisez "git add/rm &lt;fichier&gt;..." pour mettre à jour ce qui sera validé)
  (utilisez "git checkout -- &lt;fichier&gt;..." pour annuler les modifications dans la copie de travail)

        supprimé :        PROJECTS.md

aucune modification n'a été ajoutée à la validation (utilisez "git add" ou "git commit -a")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ensuite, si vous lancez <code>git rm</code>, l’effacement du fichier est indexé :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rm PROJECTS.md
rm 'PROJECTS.md'
Sur la branche master
Votre branche est à jour avec 'origin/master'.
Modifications qui seront validées :
  (utilisez "git reset HEAD &lt;fichier&gt;..." pour désindexer)

        supprimé :        PROJECTS.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lors de la prochaine validation, le fichier sera absent et non-suivi en version.
Si vous avez auparavant modifié et indexé le fichier, son élimination doit être forcée avec l’option <code>-f</code>.
C’est une mesure de sécurité pour empêcher un effacement accidentel de données qui n’ont pas encore été enregistrées dans un instantané et qui seraient définitivement perdues.</p>
</div>
<div class="paragraph">
<p>Un autre scénario serait de vouloir abandonner le suivi de version d’un fichier tout en le conservant dans la copie de travail.
Ceci est particulièrement utile lorsqu’on a oublié de spécifier un patron dans le fichier <code>.gitignore</code> et on a accidentellement indexé un fichier, tel qu’un gros fichier de journal ou une série d’archives de compilation <code>.a</code>.
Pour réaliser ce scénario, utilisez l’option <code>--cached</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rm --cached LISEZMOI</code></pre>
</div>
</div>
<div class="paragraph">
<p>Vous pouvez spécifier des noms de fichiers ou de répertoires, ou des patrons de fichiers à la commande <code>git rm</code>.
Cela signifie que vous pouvez lancer des commandes telles que :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rm log/\*.log</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notez bien la barre oblique inverse (<code>\</code>) devant <code>*</code>.
Il est nécessaire d’échapper le caractère <code>\*</code> car Git utilise sa propre expansion de nom de fichier en addition de l’expansion du shell.
Ce caractère d’échappement doit être omis sous Windows si vous utilisez le terminal système.
Cette commande efface tous les fichiers avec l’extension <code>.log</code> présents dans le répertoire <code>log/</code>.
Vous pouvez aussi lancer une commande telle que :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rm \*~</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cette commande élimine tous les fichiers se terminant par <code>~</code>.</p>
</div>
</div>
<div class="sect3">
<h3 id="s_git_mv">Déplacer des fichiers</h3>
<div class="paragraph">
<p>
À la différence des autres VCS, Git ne suit pas explicitement les mouvements des fichiers.
Si vous renommez un fichier suivi par Git, aucune méta-donnée indiquant le renommage n’est stockée par Git.
Néanmoins, Git est assez malin pour s’en apercevoir après coup — la détection de mouvement de fichier sera traitée plus loin.</p>
</div>
<div class="paragraph">
<p>De ce fait, que Git ait une commande <code>mv</code> peut paraître trompeur.
Si vous souhaitez renommer un fichier dans Git, vous pouvez lancer quelque chose comme :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git mv nom_origine nom_cible</code></pre>
</div>
</div>
<div class="paragraph">
<p>et cela fonctionne.
En fait, si vous lancez quelque chose comme ceci et inspectez le résultat d’une commande <code>git status</code>, vous constaterez que Git gère le renommage de fichier :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git mv LISEZMOI.txt LISEZMOI
$ git status
Sur la branche master
Votre branche est à jour avec 'origin/master'.
Modifications qui seront validées :
  (utilisez "git reset HEAD &lt;fichier&gt;..." pour désindexer)

        renommé :         LISEZMOI.txt -&gt; LISEZMOI</code></pre>
</div>
</div>
<div class="paragraph">
<p>Néanmoins, cela revient à lancer les commandes suivantes :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ mv LISEZMOI.txt LISEZMOI
$ git rm LISEZMOI.txt
$ git add LISEZMOI</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git trouve implicitement que c’est un renommage, donc cela importe peu si vous renommez un fichier de cette manière ou avec la commande <code>mv</code>.
La seule différence réelle est que <code>git mv</code> ne fait qu’une commande à taper au lieu de trois — c’est une commande de convenance.
Le point principal est que vous pouvez utiliser n’importe quel outil pour renommer un fichier, et traiter les commandes <code>add</code>/<code>rm</code> plus tard, avant de valider la modification.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>