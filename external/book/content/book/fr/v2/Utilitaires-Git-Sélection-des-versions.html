---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: fr
  chapter:
    title: Utilitaires Git
    number: 7
  section:
    title: Sélection des versions
    number: 1
    cs_number: '7.1'
    previous: book/fr/v2/GitHub-Résumé
    next: book/fr/v2/Utilitaires-Git-Indexation-interactive
title: Git - Sélection des versions
url: "/book/fr/v2/Utilitaires-Git-Sélection-des-versions.html"
---
<p>À présent, vous avez appris les commandes et modes de fonctionnement usuels requis pour gérer et maintenir un dépôt Git pour la gestion de votre code source.
Vous avez déroulé les routines de suivi et de validation de fichiers, vous avez exploité la puissance de l’index, de la création et de la fusion de branches locales de travail.</p><p>Maintenant, vous allez explorer un certain nombre de fonctionnalités particulièrement efficaces, fonctionnalités que vous utiliserez moins souvent mais dont vous pourriez avoir l’usage à un moment ou à un autre.</p>
<h2 id="s_revision_selection">Sélection des versions</h2>
<div class="paragraph">
<p>Git vous permet de faire référence à certains <em>commits</em> ou un ensemble de <em>commits</em> de différentes façons.
Si elles ne sont pas toutes évidentes, il est bon de les connaître.</p>
</div>
<div class="sect3">
<h3 id="_révisions_ponctuelles">Révisions ponctuelles</h3>
<div class="paragraph">
<p>Naturellement, vous pouvez référencer un <em>commit</em> par sa signature SHA-1, mais il existe des méthodes plus confortables pour les humains.
Cette section présente les méthodes pour référencer un <em>commit</em> simple.</p>
</div>
</div>
<div class="sect3">
<h3 id="_empreinte_sha_courte">Empreinte SHA courte</h3>
<div class="paragraph">
<p>Git est capable de deviner de quel <em>commit</em> vous parlez si vous ne fournissez que quelques caractères du début de la signature, tant que votre SHA-1 partiel comporte au moins 4 caractères et ne correspond pas à plusieurs <em>commits</em>.
Dans ces conditions, un seul objet correspondra à ce SHA-1 partiel.</p>
</div>
<div class="paragraph">
<p>Par exemple, pour afficher un <em>commit</em> précis, supposons que vous exécutiez <code>git log</code> et que vous identifiiez le <em>commit</em> où vous avez introduit une fonctionnalité précise.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log
commit 734713bc047d87bf7eac9674765ae793478c50d3
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'

commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pour cet exemple, choisissons <code>1c002dd…​</code>.
Si vous affichez le contenu de ce <em>commit</em> via <code>git show</code>, les commandes suivantes sont équivalentes (en partant du principe que les SHA-1 courts ne sont pas ambigus).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b
$ git show 1c002dd4b536e7479f
$ git show 1c002d</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git peut déterminer une référence SHA-1 tout à la fois la plus courte possible et non ambigüe.
Ajoutez l’option <code>--abbrev-commit</code> à la commande <code>git log</code> et le résultat affiché utilisera des valeurs plus courtes mais uniques ; par défaut Git retiendra 7 caractères et augmentera au besoin :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --abbrev-commit --pretty=oneline
ca82a6d changed the version number
085bb3b removed unnecessary test code
a11bef0 first commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>En règle générale, entre 8 et 10 caractères sont largement suffisants pour assurer l’unicité dans un projet.
Par exemple, en février 2019, le noyau Linux (qui est un projet plutôt imposant) avait de plus de 875 000 <em>commits</em> et presque sept millions d’objets dont les empreintes SHA sont uniques à partir des 12 premiers caractères.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Quelques mots sur SHA-1</div>
<div class="paragraph">
<p>Beaucoup de gens s’inquiètent qu’à un moment donné ils auront, par des circonstances hasardeuses, deux objets dans leur référentiel de hachage de même empreinte SHA-1.
Qu’en est-il réellement ?</p>
</div>
<div class="paragraph">
<p>S’il vous arrivait de valider un objet qui se hache à la même empreinte SHA-1 qu’un objet existant dans votre référentiel, Git verrait l’objet existant déjà dans votre base de données et présumerait qu’il était déjà enregistré.
Si vous essayez de récupérer l’objet de nouveau à un moment donné, vous auriez toujours les données du premier objet.</p>
</div>
<div class="paragraph">
<p>Quoi qu’il en soit, vous devriez être conscient à quel point ce scénario est ridiculement improbable.
Une empreinte SHA-1 porte sur 20 octets soit 160 bits.
Le nombre d’objets aléatoires à hacher requis pour assurer une probabilité de collision de 50 % vaut environ 2<sup>80</sup> (la formule pour calculer la probabilité de collision est <code>p = (n(n-1)/2) * (1/2^160)</code>).
2<sup>80</sup> vaut 1,2 × 10<sup>24</sup> soit 1 million de milliards de milliards.
Cela représente 1 200 fois le nombre de grains de sable sur Terre.</p>
</div>
<div class="paragraph">
<p>Voici un exemple pour vous donner une idée de ce qui pourrait provoquer une collision du SHA-1.
Si tous les 6,5 milliards d’humains sur Terre programmaient et que chaque seconde, chacun produisait du code équivalent à l’historique entier du noyau Linux (6,5 millions d’objets Git) et le poussait sur un énorme dépôt Git, cela prendrait 2 ans pour que ce dépôt contienne assez d’objets pour avoir une probabilité de 50 % qu’une seule collision SHA-1 existe.
Ainsi, une collision organique de SHA-1 est moins probable que tous les membres de votre équipe de programmeurs soient attaqués et tués par des loups dans des incidents sans relation la même nuit.</p>
</div>
<div class="paragraph">
<p>Si vous y dédiiez plusieurs milliers de dollars de puissance de calcul, il searit possible de synthétiser deux fichiers avec la même empreinte, comme prouvé par <a href="https://shattered.io/" class="bare">https://shattered.io/</a> en février 2017.
Git évolue vers l’utilisation de SHA256 comme algorithme par défaut d’empreinte, qui est beaucoup plus résilient aux attaques par collision, et a déjà du code en place pour amenuiser cette attaque (bien qu’il ne puisse pas totalement éliminer cette faiblesse)</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h3 id="s_branch_references">Références de branches</h3>
<div class="paragraph">
<p>La méthode la plus commune pour désigner un <em>commit</em> est une branche y pointant.
Dès lors, vous pouvez utiliser le nom de la branche dans toute commande utilisant un objet de type <em>commit</em> ou un SHA-1.
Par exemple, si vous souhaitez afficher le dernier <em>commit</em> d’une branche, les commandes suivantes sont équivalentes, en supposant que la branche <code>sujet1</code> pointe sur <code>ca82a6d</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show ca82a6dff817ec66f44342007202690a93763949
$ git show sujet1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pour connaître l’empreinte SHA sur laquelle pointe une branche ou pour savoir parmi tous les exemples précédents ce que cela donne en terme de SHA, vous pouvez utiliser la commande de plomberie nommée <code>rev-parse</code>.
Référez-vous à <a href="{{< relurl "book/fr/v2/ch00/ch10-git-internals" >}}">Les tripes de Git</a> pour plus d’informations sur les commandes de plomberie ; <code>rev-parse</code> sert aux opérations de bas niveau et n’est pas conçue pour être utilisée quotidiennement.
Quoi qu’il en soit, elle se révèle utile pour comprendre ce qui se passe.
Je vous invite à tester <code>rev-parse</code> sur votre propre branche.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rev-parse topic1
ca82a6dff817ec66f44342007202690a93763949</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="s_git_reflog">Raccourcis RefLog</h3>
<div class="paragraph">
<p>Git maintient en arrière-plan un historique des références où sont passés HEAD et vos branches sur les derniers mois — ceci s’appelle le <em>reflog</em>.</p>
</div>
<div class="paragraph">
<p>Vous pouvez le consulter avec la commande <code>git reflog</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git reflog
734713b... HEAD@{0}: commit: fixed refs handling, added gc auto, updated
d921970... HEAD@{1}: merge phedders/rdocs: Merge made by recursive.
1c002dd... HEAD@{2}: commit: added some blame and merge stuff
1c36188... HEAD@{3}: rebase -i (squash): updating HEAD
95df984... HEAD@{4}: commit: # This is a combination of two commits.
1c36188... HEAD@{5}: rebase -i (squash): updating HEAD
7e05da5... HEAD@{6}: rebase -i (pick): updating HEAD</code></pre>
</div>
</div>
<div class="paragraph">
<p>À chaque fois que l’extrémité de votre branche est modifiée, Git enregistre cette information pour vous dans son historique temporaire.
Vous pouvez référencer d’anciens <em>commits</em> avec cette donnée.
Si vous souhaitez consulter le n-ième antécédent de votre HEAD, vous pouvez utiliser la référence <code>@{n}</code> du reflog, 5 dans cet exemple :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show HEAD@{5}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Vous pouvez également remonter le temps et savoir où en était une branche à une date donnée.
Par exemple, pour savoir où en était la branche <code>master</code> hier (<em>yesterday</em> en anglais), tapez :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show master@{yesterday}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cette technique fonctionne uniquement si l’information est encore présente dans le reflog et vous ne pourrez donc pas le consulter sur des <em>commits</em> plus vieux que quelques mois.</p>
</div>
<div class="paragraph">
<p>Pour consulter le reflog au format <code>git log</code>, exécutez: <code>git log -g</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -g master
commit 734713bc047d87bf7eac9674765ae793478c50d3
Reflog: master@{0} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: commit: fixed refs handling, added gc auto, updated
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Reflog: master@{1} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: merge phedders/rdocs: Merge made by recursive.
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Veuillez noter que le reflog ne stocke que des informations locales, c’est un historique de ce que vous avez fait dans votre dépôt.
Les références sont différentes pour un autre dépôt et juste après le clone d’un dépôt, votre reflog sera vide puisque qu’aucune activité n’aura été produite.
Exécuter <code>git show HEAD@{2.months.ago}</code> ne fonctionnera que si vous avez dupliqué ce projet depuis au moins 2 mois — si vous l’avez dupliqué il y a 5 minutes, vous n’obtiendrez aucun résultat.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Astuce</div>
</td>
<td class="content">
<div class="title">Pensez le reflog comme la version Git d’un historique shell</div>
<div class="paragraph">
<p>Si vous avez une culture UNIX ou Linux, vous pouvez penser le reflog comme la version Git d’un historique shell, ce qui implique que ce qui y est n’est clairement pertinent que pour vous et votre « session », et n’a rien à voir avec n’importe qui d’autre qui pourrait travailler sur la même machine.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Échapper les accolades dans PowerShell</div>
<div class="paragraph">
<p>Avec PowerShell, les accolades telles que <code>{</code> et <code>}</code> sont des caractères spéciaux et doivent être échappés.
Vous pouvez les échapper avec des apostrophes inversées ` ou placer la référence du commit entre guillemets :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show HEAD@{0}     # will NOT work
$ git show HEAD@`{0`}   # OK
$ git show "HEAD@{0}"   # OK</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h3 id="_références_ancêtres">Références ancêtres</h3>
<div class="paragraph">
<p>Une solution fréquente pour référencer un <em>commit</em> est d’utiliser son ascendance.
Si vous suffixez une référence par <code>^</code>, Git la résoudra comme étant le parent de cette référence.
Supposons que vous consultiez votre historique :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --pretty=format:'%h %s' --graph
* 734713b fixed refs handling, added gc auto, updated tests
*   d921970 Merge commit 'phedders/rdocs'
|\
| * 35cfb2b Some rdoc changes
* | 1c002dd added some blame and merge stuff
|/
* 1c36188 ignore *.gem
* 9b29157 add open3_detach to gemspec file list</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alors, vous pouvez consulter le <em>commit</em> précédent en spécifiant <code>HEAD^</code>, ce qui signifie « le parent de HEAD » :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show HEAD^
commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Échapper l''accent circonflexe sous Windows</div>
<div class="paragraph">
<p>Sous Windows dans <code>cmd.exe</code>, <code>^</code> est un caractère spécial qui doit être traité différemment.
Vous pouvez soit le doubler soit placer la référence du commit entre guillemets :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show HEAD^     # will NOT work on Windows
$ git show HEAD^^    # OK
$ git show "HEAD^"   # OK</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Vous pouvez également spécifier un nombre après <code>^</code> — par exemple, <code>d921970^2</code> signifie « le second parent de d921970 ».
Cette syntaxe ne sert que pour les <em>commits</em> de fusion, qui ont plus d’un parent.
Le premier parent est la branche depuis laquelle vous avez fusionné, et le second est le <em>commit</em> de la branche que vous avez fusionnée :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show d921970^
commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff

$ git show d921970^2
commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548
Author: Paul Hedderly &lt;paul+git@mjr.org&gt;
Date:   Wed Dec 10 22:22:03 2008 +0000

    Some rdoc changes</code></pre>
</div>
</div>
<div class="paragraph">
<p>Une autre solution courante pour spécifier une référence ancêtre est le <code>~</code>.
Il fait également référence au premier parent, donc <code>HEAD~</code> et <code>HEAD^</code> sont équivalents.
La différence apparaît si vous spécifiez un nombre.
<code>HEAD~2</code> signifie « le premier parent du premier parent », ou bien « le grand-parent » ; on remonte les premiers parents autant de fois que demandé.
Par exemple, dans l’historique précédemment présenté, <code>HEAD~3</code> serait :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show HEAD~3
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cela peut aussi s’écrire <code>HEAD<sup>^</sup></code>, qui là encore est le premier parent du premier parent du premier parent :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show HEAD^^^
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem</code></pre>
</div>
</div>
<div class="paragraph">
<p>Vous pouvez également combiner ces syntaxes — vous pouvez obtenir le second parent de la référence précédente (en supposant que c’était un <em>commit</em> de fusion) en utilisant <code>HEAD~3^2</code>, et ainsi de suite.</p>
</div>
</div>
<div class="sect3">
<h3 id="s_commit_ranges">Plages de <em>commits</em>
</h3>
<div class="paragraph">
<p>À présent que vous pouvez spécifier des <em>commits</em> individuels, voyons comment spécifier des plages de <em>commits</em>.
Ceci est particulièrement pratique pour la gestion des branches — si vous avez beaucoup de branches, vous pouvez utiliser les plages pour répondre à des questions telles que « Quel travail sur cette branche n’ai-je pas encore fusionné sur ma branche principale ? ».</p>
</div>
<div class="sect4">
<h4 id="_double_point">Double point</h4>
<div class="paragraph">
<p>La spécification de plage de <em>commits</em> la plus fréquente est la syntaxe double-point.
En gros, cela demande à Git de résoudre la plage des <em>commits</em> qui sont accessibles depuis un <em>commit</em> mais ne le sont pas depuis un autre.
Par exemple, disons que votre historique ressemble à <a href="{{< relurl "book/fr/v2/ch00/double_dot" >}}">Exemple d’historique pour la sélection de plage.</a>.</p>
</div>
<div id="double_dot" class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/double-dot.png" >}}" alt="Exemple d’historique pour la sélection de plage.">
</div>
<div class="title">Figure 136. Exemple d’historique pour la sélection de plage.</div>
</div>
<div class="paragraph">
<p>Si vous voulez savoir ce qui n’a pas encore été fusionné sur votre branche <code>master</code> depuis votre branche <code>experiment</code>, vous pouvez demander à Git de vous montrer un journal des <em>commits</em> avec <code>master..experiment</code> — ce qui signifie « tous les <em>commits</em> accessibles par <code>experiment</code> qui ne le sont pas par <code>master</code> ».
Dans un souci de brièveté et de clarté de ces exemples, je vais utiliser les lettres des <em>commits</em> issus du diagramme à la place de la vraie liste dans l’ordre où ils auraient dû être affichés :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log master..experiment
D
C</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si, par contre, vous souhaitez voir l’opposé — tous les <em>commits</em> dans <code>master</code> mais pas encore dans <code>experiment</code> — vous pouvez inverser les noms de branches, <code>experiment..master</code> vous montre tout ce que <code>master</code> accède mais qu'`experiment` ne voit pas :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log experiment..master
F
E</code></pre>
</div>
</div>
<div class="paragraph">
<p>C’est pratique si vous souhaitez maintenir <code>experiment</code> à jour et anticiper les fusions.
Un autre cas d’utilisation fréquent consiste à voir ce que vous vous apprêtez à pousser sur une branche distante :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log origin/master..HEAD</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cette commande vous affiche tous les <em>commits</em> de votre branche courante qui ne sont pas sur la branche <code>master</code> du dépôt distant <code>origin</code>.
Si vous exécutez <code>git push</code> et que votre branche courante suit <code>origin/master</code>, les <em>commits</em> listés par <code>git log origin/master..HEAD</code> sont les <em>commits</em> qui seront transférés sur le serveur.
Vous pouvez également laisser tomber une borne de la syntaxe pour faire comprendre à Git que vous parlez de HEAD.
Par exemple, vous pouvez obtenir les mêmes résultats que précédemment en tapant <code>git log origin/master..</code> — Git utilise HEAD si une des bornes est manquante.</p>
</div>
</div>
<div class="sect4">
<h4 id="_emplacements_multiples">Emplacements multiples</h4>
<div class="paragraph">
<p>La syntaxe double-point est pratique comme raccourci ; mais peut-être souhaitez-vous utiliser plus d’une branche pour spécifier une révision, comme pour voir quels <em>commits</em> sont dans plusieurs branches mais sont absents de la branche courante.
Git vous permet cela avec <code>^</code> ou <code>--not</code> en préfixe de toute référence de laquelle vous ne souhaitez pas voir les <em>commits</em>.
Les 3 commandes ci-après sont équivalentes :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log refA..refB
$ git log ^refA refB
$ git log refB --not refA</code></pre>
</div>
</div>
<div class="paragraph">
<p>C’est utile car cela vous permet de spécifier plus de 2 références dans votre requête, ce que vous ne pouvez accomplir avec la syntaxe double-point.
Par exemple, si vous souhaitez voir les <em>commits</em> qui sont accessibles depuis <code>refA</code> et <code>refB</code> mais pas depuis <code>refC</code>, vous pouvez taper ces 2 commandes :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log refA refB ^refC
$ git log refA refB --not refC</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ceci vous fournit un système de requêtage des révisions très puissant, pour vous aider à saisir ce qui se trouve sur vos branches.</p>
</div>
</div>
<div class="sect4">
<h4 id="s_triple_dot">Triple point</h4>
<div class="paragraph">
<p>La dernière syntaxe majeure de sélection de plage de <em>commits</em> est la syntaxe triple-point qui spécifie tous les <em>commits</em> accessibles par l’une des deux références, exclusivement.
Toujours avec l’exemple d’historique de <a href="{{< relurl "book/fr/v2/ch00/double_dot" >}}">Exemple d’historique pour la sélection de plage.</a>, si vous voulez voir ce qui se trouve sur <code>master</code> ou <code>experiment</code> mais pas sur les deux, exécutez :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log master...experiment
F
E
D
C</code></pre>
</div>
</div>
<div class="paragraph">
<p>Encore une fois, cela vous donne un <code>log</code> normal mais ne vous montre les informations que pour ces quatre <em>commits</em>, dans l’ordre naturel des dates de validation.</p>
</div>
<div class="paragraph">
<p>Une option courante à utiliser avec la commande <code>log</code> dans ce cas est <code>--left-right</code> qui vous montre la borne de la plage à laquelle ce <em>commit</em> appartient.
Cela rend les données plus utiles :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --left-right master...experiment
&lt; F
&lt; E
&gt; D
&gt; C</code></pre>
</div>
</div>
<div class="paragraph">
<p>Avec ces outils, vous pourrez spécifier à Git les <em>commits</em> que vous souhaitez inspecter.</p>
</div>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>