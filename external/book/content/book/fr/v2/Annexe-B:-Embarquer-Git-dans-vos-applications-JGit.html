---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: fr
  chapter:
    title: 'Annexe B: Embarquer Git dans vos applications'
    number: 2
  section:
    title: JGit
    number: 3
    cs_number: A2.3
    previous: book/fr/v2/Annexe-B:-Embarquer-Git-dans-vos-applications-Libgit2
    next: book/fr/v2/Annexe-B:-Embarquer-Git-dans-vos-applications-go-git
title: Git - JGit
url: "/book/fr/v2/Annexe-B:-Embarquer-Git-dans-vos-applications-JGit.html"
---
<h2 id="_jgit">JGit</h2>
<div class="paragraph">
<p>
Si vous voulez utiliser Git depuis un programme Java, il existe une bibliothèque complète appelée JGit.
JGit est une réalisation relativement complète de Git écrite nativement en Java etelle est largement utilisée dans la communauté Java.
Le projet JGit est développé sous l’égide d’Eclipse et son site se trouve sur <a href="https://www.eclipse.org/jgit" class="bare">https://www.eclipse.org/jgit</a>.</p>
</div>
<div class="sect3">
<h3 id="_mise_en_place">Mise en place</h3>
<div class="paragraph">
<p>Il y a différents moyens de connecter votre projet à JGit et de commencer à l’utiliser dans votre code.
La manière probablement la plus facile consiste à utiliser Maven – on réalise l’intégration en ajoutant la section suivante sous la balise <code>&lt;dependencies&gt;</code> de votre fichier pom.xml :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.eclipse.jgit&lt;/groupId&gt;
    &lt;artifactId&gt;org.eclipse.jgit&lt;/artifactId&gt;
    &lt;version&gt;3.5.0.201409260305-r&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>La <code>version</code> aura très certainement évolué lorsque vous lirez ces lignes ; vérifiez <a href="https://www.eclipse.org/jgit/download" class="bare">https://www.eclipse.org/jgit/download</a> pour une information de version mise à jour.
Une fois cette étape accomplie, Maven va automatiquement récupérer et utiliser les bibliothèques JGit dont vous aurez besoin.</p>
</div>
<div class="paragraph">
<p>Si vous préférez gérer les dépendances binaires par vous-même, des binaires JGit pré-construits sont disponibles sur <a href="https://www.eclipse.org/jgit/download" class="bare">https://www.eclipse.org/jgit/download</a>.
Vous pouvez les inclure dans votre projet en lançant une commande telle que :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">javac -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App.java
java -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_plomberie">Plomberie</h3>
<div class="paragraph">
<p>JGit propose deux niveaux généraux d’interfaçage logiciel : plomberie et porcelaine.
La terminologie de ces niveaux est directement calquée sur celle de Git lui-même et JGit est partitionné globalement de la même manière : les APIs de porcelaine sont une interface de haut niveau pour des interactions de niveau utilisateur (le genre de choses qu’un utilisateur normal ferait en utilisant la ligne de commande), tandis que les APIs de plomberie permettent d’interagir directement avec les objets de bas niveau du dépôt.</p>
</div>
<div class="paragraph">
<p>Le point de départ pour la plupart des sessions JGit est la classe <code>Repository</code> et la première action consiste à créer une instance de celle-ci.
Pour un dépôt basé sur un système de fichier (hé oui, JGit permet d’autre modèles de stockage), cela passe par l’utilisation d’un <code>FileRepositoryBuilder</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Creer un nouveau depot
Repository newlyCreatedRepo = FileRepositoryBuilder.create(
    new File("/tmp/new_repo/.git"));
newlyCreatedRepo.create();

// Ouvrir un depot existant
Repository existingRepo = new FileRepositoryBuilder()
    .setGitDir(new File("my_repo/.git"))
    .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Le constructeur contient une API souple qui fournit tout ce dont il a besoin pour trouver un dépôt Git, que votre programme sache ou ne sache pas exactement où il est situé.
Il peut utiliser des variables d’environnement (<code>.readEnvironment()</code>), démarrer depuis le répertoire de travail et chercher (<code>setWorkTree(…).findGitDir()</code>) ou juste ouvrir un répertoire <code>.git</code> connu, comme ci-dessus.</p>
</div>
<div class="paragraph">
<p>Une fois muni d’une instance de <code>Repository</code>, vous pouvez faire toutes sortes de choses avec.
En voici un échantillon rapide :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// acceder a une reference
Ref master = repo.getRef("master");

// acceder a l'objet pointe par une reference
ObjectId masterTip = master.getObjectId();

// Rev-parse
ObjectId obj = repo.resolve("HEAD^{tree}");

// Charger le contenu brut d'un objet
ObjectLoader loader = repo.open(masterTip);
loader.copyTo(System.out);

// Creer une branche
RefUpdate createBranch1 = repo.updateRef("refs/heads/branch1");
createBranch1.setNewObjectId(masterTip);
createBranch1.update();

// Delete a branch
RefUpdate deleteBranch1 = repo.updateRef("refs/heads/branch1");
deleteBranch1.setForceUpdate(true);
deleteBranch1.delete();

// Config
Config cfg = repo.getConfig();
String name = cfg.getString("user", null, "name");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Il y a pas mal de choses mises en œuvre ici, donc nous allons détailler chaque section.</p>
</div>
<div class="paragraph">
<p>La première ligne récupère un pointeur sur la référence <code>master</code>.
JGit récupère automatiquement la référence master <em>réelle</em> qui se situe dans <code>refs/heads/master</code> et retourne un objet qui vous permet de récupérer des informations sur cette référence.
Vous pouvez récupérer le nom (<code>.getName()</code>) ou bien l’objet cible de la référence directe (<code>.getObjectId()</code>), ou encore la référence pointée par une référence symbolique (<code>.getTarget()</code>).
Les objets de référence sont aussi utilisés pour représenter les références d’étiquette ou des objets, donc vous pouvez demander si l’étiquette est « pelée », ce qui signifie qu’elle pointe sur une cible finale d’une série (potentiellement longue) d’objets étiquettes.</p>
</div>
<div class="paragraph">
<p>La seconde ligne donne la cible de la référence <code>master</code> qui est retournée comme une instance d’ObjectId.
ObjectId représente l’empreinte SHA-1 d’un objet qui peut exister ou non dans la base de données des objets de Git.
La troisième ligne est similaire, mais elle montre comment JGit gère la syntaxe « rev-parse » (pour plus d’information, voir <a href="{{< relurl "book/fr/v2/ch00/s_branch_references" >}}">Références de branches</a>).
Vous pouvez passer n’importe quel spécificateur d’objet que Git comprend et JGit retournera un ObjectId valide ou bien <code>null</code>.</p>
</div>
<div class="paragraph">
<p>Les deux lignes suivantes montrent comment charger le contenu brut d’un objet.
Dans cet exemple, nous appelons <code>ObjectLoader.copyTo()</code> pour rediriger le contenu de l’objet directement sur la sortie standard, mais <code>ObjectLoader</code> dispose aussi de méthodes pour lire le type et la taille d’un objet et le retourner dans un tableau d’octets.
Pour les gros objets (pour lesquels <code>.isLarge()</code> renvoie <code>true</code>), vous pouvez appeler <code>.openStream()</code> pour récupérer un objet similaire à InputStream qui peut lire l’objet brut sans le tirer intégralement en mémoire vive.</p>
</div>
<div class="paragraph">
<p>Les quelques lignes suivantes montrent ce qui est nécessaire pour créer une nouvelle branche.
Nous créons une instance de RefUpdate, configurons quelques paramètres et appelons <code>.update()</code> pour déclencher la modification.
Le code pour effacer cette branche suit juste après.
Notez que <code>.setForceUpdate(true)</code> est nécessaire pour que cela fonctionne ; sinon l’appel à <code>.delete()</code> retourne <code>REJECTED</code> et il ne se passera rien.</p>
</div>
<div class="paragraph">
<p>Le dernier exemple montre comment récupérer la valeur <code>user.name</code> depuis les fichiers de configuration de Git.
Cette instance de Config utilise le dépôt que nous avons ouvert plus tôt pour la configuration locale, mais détectera automatiquement les fichiers de configuration globale et système et y lira aussi les valeurs.</p>
</div>
<div class="paragraph">
<p>Ceci n’est qu’un petit échantillon de toute l’API de plomberie ; il existe beaucoup d’autre méthodes et classes.
Ici, nous ne montrons pas non plus comment JGit gère les erreurs, au moyen d’exceptions.
Les APIs JGit lancent quelques fois des exceptions Java standard (telles que <code>IOException</code>), mais il existe aussi une liste de types d’exception spécifiques à JGit (tels que <code>NoRemoteRepositoryException</code>, <code>CorruptObjectException</code> et <code>NoMergeBaseException</code>).</p>
</div>
</div>
<div class="sect3">
<h3 id="_porcelaine">Porcelaine</h3>
<div class="paragraph">
<p>Les APIs de plomberie sont plutôt complètes, mais il peut s’avérer lourd de les enchaîner pour des activités fréquentes, telles que l’ajout de fichier à l’index ou la validation.
JGit fournit un ensemble de plus haut niveau d’APIs pour simplifier celles-ci et le point d’entrée pour ces APIs est la classe <code>Git</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Repository repo;
// construit le depot...
Git git = new Git(repo);</code></pre>
</div>
</div>
<div class="paragraph">
<p>La classe Git propose un joli ensemble de méthodes de haut niveau de style <code>builder</code> qui peuvent être utilisées pour construire des comportements assez complexes.
Voyons un exemple, tel que recréer quelque chose comme <code>git ls-remote</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">CredentialsProvider cp = new UsernamePasswordCredentialsProvider("username", "p4ssw0rd");
Collection&lt;Ref&gt; remoteRefs = git.lsRemote()
    .setCredentialsProvider(cp)
    .setRemote("origin")
    .setTags(true)
    .setHeads(false)
    .call();
for (Ref ref : remoteRefs) {
    System.out.println(ref.getName() + " -&gt; " + ref.getObjectId().name());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>C’est la structure habituelle avec la classe Git ; les méthodes renvoient un objet commande qui permet d’enchaîner les appels de paramétrage qui sont finalement exécutés par l’appel à <code>.call()</code>.
Dans notre cas, nous interrogeons le dépôt distant <code>origin</code> sur ses étiquettes, et non sur ses sommets de branches.
Notez aussi l’utilisation d’un objet <code>CredentialsProvider</code> pour l’authentification.</p>
</div>
<div class="paragraph">
<p>De nombreuses autres commandes sont disponibles au travers de la classe Git, dont entre autres <code>add</code>, <code>blame</code>, <code>commit</code>, <code>clean</code>, <code>push</code>, <code>rebase</code>, <code>revert</code> et <code>reset</code>.</p>
</div>
</div>
<div class="sect3">
<h3 id="_pour_aller_plus_loin_2">Pour aller plus loin</h3>
<div class="paragraph">
<p>Tout ceci n’est qu’un mince échantillon de toutes les capacités de JGit.
Si vous êtes intéressé et souhaitez en savoir plus, voici des liens vers plus d’information et d’inspiration :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>La documentation officielle de l’API JGit est disponible sur <a href="https://www.eclipse.org/jgit/documentation" class="bare">https://www.eclipse.org/jgit/documentation</a>.
Il existe des Javadoc standard, donc votre EDI JVM favori sera aussi capable de les installer localement.</p>
</li>
<li>
<p>Le livre de recettes JGit <a href="https://github.com/centic9/jgit-cookbook" class="bare">https://github.com/centic9/jgit-cookbook</a> contient de nombreux exemples de réalisation de différentes tâches avec JGit.</p>
</li>
</ul>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>