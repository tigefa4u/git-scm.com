---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: fr
  chapter:
    title: Git distribué
    number: 5
  section:
    title: Maintenance d’un projet
    number: 3
    cs_number: '5.3'
    previous: book/fr/v2/Git-distribué-Contribution-à-un-projet
    next: book/fr/v2/Git-distribué-Résumé
title: Git - Maintenance d’un projet
url: "/book/fr/v2/Git-distribué-Maintenance-d’un-projet.html"
---
<h2 id="_maintenance_dun_projet">Maintenance d’un projet</h2>
<div class="paragraph">
<p>
En plus de savoir comment contribuer efficacement à un projet, vous aurez probablement besoin de savoir comment en maintenir un.
Cela peut consister à accepter et appliquer les patchs générés via <code>format-patch</code> et envoyés par courriel, ou à intégrer des modifications dans des branches distantes de dépôts distants.
Que vous mainteniez le dépôt de référence ou que vous souhaitiez aider en vérifiant et approuvant les patchs, vous devez savoir comment accepter les contributions d’une manière limpide pour vos contributeurs et soutenable à long terme pour vous.</p>
</div>
<div class="sect3">
<h3 id="_travail_dans_des_branches_thématiques">Travail dans des branches thématiques</h3>
<div class="paragraph">
<p>
Quand vous vous apprêtez à intégrer des contributions, une bonne idée consiste à les essayer d’abord dans une branche thématique, une branche temporaire spécifiquement créée pour essayer cette nouveauté.
De cette manière, il est plus facile de rectifier un patch à part et de le laisser s’il ne fonctionne pas jusqu’à ce que vous disposiez de temps pour y travailler.
Si vous créez une simple branche nommée d’après le thème de la modification que vous allez essayer, telle que <code>ruby_client</code> ou quelque chose d’aussi descriptif, vous pouvez vous en souvenir simplement plus tard.
Le mainteneur du projet Git a l’habitude d’utiliser des espaces de nommage pour ses branches, tels que <code>sc/ruby_client</code>, où <code>sc</code> représente les initiales de la personne qui a fourni le travail.
Comme vous devez vous en souvenir, on crée une branche à partir de <code>master</code> de la manière suivante :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch sc/ruby_client master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ou bien, si vous voulez aussi basculer immédiatement dessus, vous pouvez utiliser l’option <code>checkout -b</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b sc/ruby_client master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Vous voilà maintenant prêt à ajouter les modifications sur cette branche thématique et à déterminer si c’est prêt à être fusionné dans les branches au long cours.</p>
</div>
</div>
<div class="sect3">
<h3 id="s_patches_from_email">Application des patchs à partir de courriel</h3>
<div class="paragraph">
<p>
Si vous recevez un patch par courriel et que vous devez l’intégrer dans votre projet, vous devez l’appliquer dans une branche thématique pour l’évaluer.
Il existe deux moyens d’appliquer un patch reçu par courriel : <code>git apply</code> et <code>git am</code>.</p>
</div>
<div class="sect4">
<h4 id="_application_dun_patch_avec_apply">Application d’un patch avec <code>apply</code>
</h4>
<div class="paragraph">
<p>
Si vous avez reçu le patch de quelqu’un qui l’a généré avec la commande <code>git diff</code> ou <code>diff</code> Unix, vous pouvez l’appliquer avec la commande <code>git apply</code>.
Si le patch a été sauvé comme fichier <code>/tmp/patch-ruby-client.patch</code>, vous pouvez l’appliquer comme ceci :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git apply /tmp/patch-ruby-client.patch</code></pre>
</div>
</div>
<div class="paragraph">
<p>Les fichiers dans votre copie de travail sont modifiés.
C’est quasiment identique à la commande <code>patch -p1</code> qui applique directement les patchs mais en plus paranoïaque et moins tolérant sur les concordances approximatives.
Les ajouts, effacements et renommages de fichiers sont aussi gérés s’ils sont décrits dans le format <code>git diff</code>, ce que <code>patch</code> ne supporte pas.
Enfin, <code>git apply</code> fonctionne en mode « applique tout ou refuse tout » dans lequel toutes les modifications proposées sont appliquées si elles le peuvent, sinon rien n’est modifié, là où <code>patch</code> peut n’appliquer que partiellement les patchs, laissant le répertoire de travail dans un état intermédiaire.
<code>git apply</code> est par-dessus tout plus paranoïaque que <code>patch</code>.
Il ne créera pas une validation à votre place : après l’avoir lancé, vous devrez indexer et valider les modifications manuellement.</p>
</div>
<div class="paragraph">
<p>Vous pouvez aussi utiliser <code>git apply</code> pour voir si un patch s’applique proprement avant de réellement l’appliquer — vous pouvez lancer <code>git apply --check</code> avec le patch :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git apply --check 0001-seeing-if-this-helps-the-gem.patch
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply</code></pre>
</div>
</div>
<div class="paragraph">
<p>S’il n’y pas de message, le patch devrait s’appliquer proprement.
Cette commande se termine avec un statut non-nul si la vérification échoue et vous pouvez donc l’utiliser dans des scripts.</p>
</div>
</div>
<div class="sect4">
<h4 id="s_git_am">Application d’un patch avec <code>am</code>
</h4>
<div class="paragraph">
<p>
Si le contributeur est un utilisateur de Git qui a été assez gentil d’utiliser la commande <code>format-patch</code> pour générer ses patchs, votre travail sera facilité car le patch contient alors déjà l’information d’auteur et le message de validation.
Si possible, encouragez vos contributeurs à utiliser <code>format-patch</code> au lieu de <code>patch</code> pour générer les patchs qu’ils vous adressent.
Vous ne devriez avoir à n’utiliser <code>git apply</code> que pour les vrais patchs.</p>
</div>
<div class="paragraph">
<p>Pour appliquer un patch généré par <code>format-patch</code>, vous utilisez <code>git am</code>.
Techniquement, <code>git am</code> s’attend à lire un fichier au format mbox, qui est un format texte simple permettant de stocker un ou plusieurs courriels dans un unique fichier texte.
Il ressemble à ceci :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith &lt;jessica@example.com&gt;
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20</code></pre>
</div>
</div>
<div class="paragraph">
<p>C’est le début de ce que la commande <code>format-patch</code> affiche, comme vous avez vu dans la section précédente.
C’est aussi un format courriel mbox parfaitement valide.
Si quelqu’un vous a envoyé par courriel un patch correctement formaté en utilisant <code>git send-mail</code> et que vous le téléchargez en format mbox, vous pouvez pointer <code>git am</code> sur ce fichier mbox et il commencera à appliquer tous les patchs contenus.
Si vous utilisez un client courriel qui sait sauver plusieurs messages au format mbox, vous pouvez sauver la totalité de la série de patchs dans un fichier et utiliser <code>git am</code> pour les appliquer tous en une fois.</p>
</div>
<div class="paragraph">
<p>Néanmoins, si quelqu’un a déposé un fichier de patch généré via <code>format-patch</code> sur un système de suivi de faits techniques ou quelque chose de similaire, vous pouvez toujours sauvegarder le fichier localement et le passer à <code>git am</code> pour l’appliquer :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git am 0001-limit-log-function.patch
Application : add limit to log function</code></pre>
</div>
</div>
<div class="paragraph">
<p>Vous remarquez qu’il s’est appliqué proprement et a créé une nouvelle validation pour vous.
L’information d’auteur est extraite des en-têtes <code>From</code> et <code>Date</code> tandis que le message de validation est repris du champ <code>Subject</code> et du corps (avant le patch) du message.
Par exemple, si le patch est appliqué depuis le fichier mbox ci-dessus, la validation générée ressemblerait à ceci :</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ git log --pretty=fuller -1
commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
Author:     Jessica Smith &lt;jessica@example.com&gt;
AuthorDate: Sun Apr 6 10:17:23 2008 -0700
Commit:     Scott Chacon &lt;schacon@gmail.com&gt;
CommitDate: Thu Apr 9 09:19:06 2009 -0700

   add limit to log function

   Limit log functionality to the first 20</pre>
</div>
</div>
<div class="paragraph">
<p>L’information <code>Commit</code> indique la personne qui a appliqué le patch et la date d’application.
L’information <code>Author</code> indique la personne qui a créé le patch et la date de création.</p>
</div>
<div class="paragraph">
<p>Il reste la possibilité que le patch ne s’applique pas proprement.
Peut-être votre branche principale a-t’elle déjà trop divergé de la branche sur laquelle le patch a été construit, ou peut-être que le patch dépend d’un autre patch qui n’a pas encore été appliqué.
Dans ce cas, le processus de <code>git am</code> échouera et vous demandera ce que vous souhaitez faire :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git am 0001-seeing-if-this-helps-the-gem.patch
Application : seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Le patch a échoué à 0001.
Lorsque vous aurez résolu ce problème, lancez "git am --continue".
Si vous préférez sauter ce patch, lancez "git am --skip" à la place.
Pour restaurer la branche d'origine et stopper le patchage, lancez
"git am --abort".</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cette commande introduit des marqueurs de conflit dans tous les fichiers qui ont généré un problème, de la même manière qu’un conflit de fusion ou de rebasage.
Vous pouvez résoudre les problèmes de manière identique — éditez le fichier pour résoudre les conflits, indexez le nouveau fichier, puis lancez <code>git am --resolved</code> ou <code>git am --continue</code> pour continuer avec le patch suivant :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ (correction du fichier)
$ git add ticgit.gemspec
$ git am --continue
Applying: seeing if this helps the gem</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si vous souhaitez que Git essaie de résoudre les conflits avec plus d’intelligence, vous pouvez passer l’option <code>-3</code> qui demande à Git de tenter une fusion à trois sources.
Cette option n’est pas active par défaut parce qu’elle ne fonctionne pas si le <em>commit</em> sur lequel le patch indique être basé n’existe pas dans votre dépôt.
Si par contre, le patch est basé sur un <em>commit</em> public, l’option <code>-3</code> est généralement beaucoup plus fine pour appliquer des patchs conflictuels :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git am -3 0001-seeing-if-this-helps-the-gem.patch
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
No changes -- Patch already applied.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dans ce cas, je cherchais à appliquer un patch qui avait déjà été intégré.
Sans l’option <code>-3</code>, cela aurait ressemblé à un conflit.</p>
</div>
<div class="paragraph">
<p>Si vous appliquez des patchs à partir d’un fichier mbox, vous pouvez aussi lancer la commande <code>am</code> en mode interactif qui s’arrête à chaque patch trouvé et vous demande si vous souhaitez l’appliquer :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git am -3 -i mbox
Commit Body is:
--------------------------
seeing if this helps the gem
--------------------------
Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all</code></pre>
</div>
</div>
<div class="paragraph">
<p>C’est agréable si vous avez un certain nombre de patchs sauvegardés parce que vous pouvez voir les patchs pour vous rafraîchir la mémoire et ne pas les appliquer s’ils ont déjà été intégrés.</p>
</div>
<div class="paragraph">
<p>Quand tous les patchs pour votre sujet ont été appliqués et validés dans votre branche, vous pouvez choisir si et comment vous souhaitez les intégrer dans une branche au long cours.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="s_checking_out_remotes">Vérification des branches distantes</h3>
<div class="paragraph">
<p>
Si votre contribution a été fournie par un utilisateur de Git qui a mis en place son propre dépôt public sur lequel il a poussé ses modifications et vous a envoyé l’URL du dépôt et le nom de la branche distante, vous pouvez les ajouter en tant que dépôt distant et réaliser les fusions localement.</p>
</div>
<div class="paragraph">
<p>Par exemple, si Jessica vous envoie un courriel indiquant qu’elle a une nouvelle fonctionnalité géniale dans la branche <code>ruby-client</code> de son dépôt, vous pouvez la tester en ajoutant le dépôt distant et en tirant la branche localement :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add jessica git://github.com/jessica/monproject.git
$ git fetch jessica
$ git checkout -b rubyclient jessica/ruby-client</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si elle vous envoie un autre mail indiquant une autre branche contenant une autre fonctionnalité géniale, vous pouvez la récupérer et la tester simplement à partir de votre référence distante.</p>
</div>
<div class="paragraph">
<p>C’est d’autant plus utile si vous travaillez en continu avec une personne.
Si quelqu’un n’a qu’un seul patch à contribuer de temps en temps, l’accepter via courriel peut s’avérer moins consommateur en temps de préparation du serveur public, d’ajout et retrait de branches distantes juste pour tirer quelques patchs.
Vous ne souhaiteriez sûrement pas devoir gérer des centaines de dépôts distants pour intégrer à chaque fois un ou deux patchs.
Néanmoins, des scripts et des services hébergés peuvent rendre cette tâche moins ardue.
Cela dépend largement de votre manière de développer et de celle de vos contributeurs.</p>
</div>
<div class="paragraph">
<p>Cette approche a aussi l’avantage de vous fournir l’historique des validations.
Même si vous pouvez rencontrer des problèmes de fusion légitimes, vous avez l’information dans votre historique de la base ayant servi pour les modifications contribuées.
La fusion à trois sources est choisie par défaut plutôt que d’avoir à spécifier l’option <code>-3</code> en espérant que le patch a été généré à partir d’un instantané public auquel vous auriez accès.</p>
</div>
<div class="paragraph">
<p>Si vous ne travaillez pas en continu avec une personne mais souhaitez tout de même tirer les modifications de cette manière, vous pouvez fournir l’URL du dépôt distant à la commande <code>git pull</code>.
Cela permet de réaliser un tirage unique sans sauver l’URL comme référence distante :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git pull https://github.com/pourunefois/projet
From https://github.com/onetimeguy/project
 * branch            HEAD       -&gt; FETCH_HEAD
Merge made by recursive.</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="s_what_is_introduced">Déterminer les modifications introduites</h3>
<div class="paragraph">
<p>
Vous avez maintenant une branche thématique qui contient les contributions.
À partir de là, vous pouvez déterminer ce que vous souhaitez en faire.
Cette section revisite quelques commandes qui vont vous permettre de faire une revue de ce que vous allez exactement introduire si vous fusionnez dans la branche principale.</p>
</div>
<div class="paragraph">
<p>Faire une revue de tous les <em>commits</em> dans cette branche s’avère souvent d’une grande aide.
Vous pouvez exclure les <em>commits</em> de la branche <code>master</code> en ajoutant l’option <code>--not</code> devant le nom de la branche.
C’est équivalent au format <code>master..contrib</code> utilisé plus haut.
Par exemple, si votre contributeur vous envoie deux patchs et que vous créez une branche appelée <code>contrib</code> et y appliquez ces patchs, vous pouvez lancer ceci :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log contrib --not master
commit 5b6235bd297351589efc4d73316f0a68d484f118
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Oct 24 09:53:59 2008 -0700

    seeing if this helps the gem

commit 7482e0d16d04bea79d0dba8988cc78df655f16a0
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Mon Oct 22 19:38:36 2008 -0700

    updated the gemspec to hopefully work better</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pour visualiser les modifications que chaque <strong>commit</strong> introduit, souvenez-vous que vous pouvez passer l’option <code>-p</code> à <code>git log</code> et elle ajoutera le diff introduit à chaque <em>commit</em>.</p>
</div>
<div class="paragraph">
<p>Pour visualiser un diff complet de ce qui arriverait si vous fusionniez cette branche thématique avec une autre branche, vous pouvez utiliser un truc bizarre pour obtenir les résultats corrects.
Vous pourriez penser à lancer ceci :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cette commande affiche un diff mais elle peut être trompeuse.
Si votre branche <code>master</code> a avancé depuis que vous avez créé la branche thématique, vous obtiendrez des résultats apparemment étranges.
Cela arrive parce que Git compare directement l’instantané de la dernière validation sur la branche thématique et celui de la dernière validation sur la branche <code>master</code>.
Par exemple, si vous avez ajouté une ligne dans un fichier sur la branche <code>master</code>, une comparaison directe donnera l’impression que la branche thématique va retirer cette ligne.</p>
</div>
<div class="paragraph">
<p>Si <code>master</code> est un ancêtre directe de la branche thématique, ce n’est pas un problème.
Si les deux historiques ont divergé, le diff donnera l’impression que vous ajoutez toutes les nouveautés de la branche thématique et retirez tout ce qui a été fait depuis dans la branche <code>master</code>.</p>
</div>
<div class="paragraph">
<p>Ce que vous souhaitez voir en fait, ce sont les modifications ajoutées sur la branche thématique — le travail que vous introduirez si vous fusionnez cette branche dans <code>master</code>.
Vous obtenez ce résultat en demandant à Git de comparer le dernier instantané de la branche thématique avec son ancêtre commun à la branche <code>master</code> le plus récent.</p>
</div>
<div class="paragraph">
<p>Techniquement, c’est réalisable en déterminant exactement l’ancêtre commun et en lançant la commande <code>diff</code> dessus :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge-base contrib master
36c7dba2c95e6bbb78dfa822519ecfec6e1ca649
$ git diff 36c7db</code></pre>
</div>
</div>
<div class="paragraph">
<p>ou de manière plus concise :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff $(git merge-base contrib master)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Néanmoins, comme ce n’est pas très commode, Git fournit un raccourci pour réaliser la même chose : la syntaxe à trois points.
Dans le contexte de la commande <code>diff</code>, vous pouvez placer trois points après une autre branche pour réaliser un <code>diff</code> entre le dernier instantané de la branche sur laquelle vous vous trouvez et son ancêtre commun avec une autre branche :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff master...contrib</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cette commande ne vous montre que les modifications que votre branche thématique a introduites depuis son ancêtre commun avec master.
C’est une syntaxe très simple à retenir.</p>
</div>
</div>
<div class="sect3">
<h3 id="_intégration_des_contributions">Intégration des contributions</h3>
<div class="paragraph">
<p>
Lorsque tout le travail de votre branche thématique est prêt à être intégré dans la branche principale, il reste à savoir comment le faire.
De plus, il faut connaître le mode de gestion que vous souhaitez pour votre projet.
Vous avez de nombreux choix et je vais en traiter quelques-uns.</p>
</div>
<div class="sect4">
<h4 id="_modes_de_fusion">Modes de fusion</h4>
<div class="paragraph">
<p>
Un mode simple fusionne votre travail dans la branche <code>master</code>.
Dans ce scénario, vous avez une branche <code>master</code> qui contient le code stable.
Quand vous avez des modifications prêtes dans une branche thématique, vous la fusionnez dans votre branche <code>master</code> puis effacez la branche thématique, et ainsi de suite.
Si vous avez un dépôt contenant deux branches nommées <code>ruby_client</code> et <code>php_client</code> qui ressemble à <a href="{{< relurl "book/fr/v2/ch00/merwf_a" >}}">Historique avec quelques branches thématiques.</a> et que vous fusionnez <code>ruby_client</code> en premier, suivi de <code>php_client</code>, alors votre historique ressemblera à la fin à <a href="{{< relurl "book/fr/v2/ch00/merwf_b" >}}">Après fusion des branches thématiques.</a>.</p>
</div>
<div id="merwf_a" class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/merging-workflows-1.png" >}}" alt="Historique avec quelques branches thématiques.">
</div>
<div class="title">Figure 72. Historique avec quelques branches thématiques.</div>
</div>
<div id="merwf_b" class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/merging-workflows-2.png" >}}" alt="Après fusion des branches thématiques.">
</div>
<div class="title">Figure 73. Après fusion des branches thématiques.</div>
</div>
<div class="paragraph">
<p>C’est probablement le mode le plus simple mais cela peut s’avérer problématique si vous avez à gérer des dépôts ou des projets plus gros pour lesquels vous devez être circonspect sur ce que vous acceptez.</p>
</div>
<div class="paragraph">
<p>Si vous avez plus de développeurs ou un projet plus important, vous souhaiterez probablement utiliser un cycle de fusion à deux étapes.
Dans ce scénario, vous avez deux branches au long cours, <code>master</code> et <code>develop</code>, dans lequel vous déterminez que <code>master</code> est mis à jour seulement lors d’une version vraiment stable et tout le nouveau code est intégré dans la branche <code>develop</code>.
Vous poussez régulièrement ces deux branches sur le dépôt public.
Chaque fois que vous avez une nouvelle branche thématique à fusionner (<a href="{{< relurl "book/fr/v2/ch00/merwf_c" >}}">Avant la fusion d’une branche thématique.</a>), vous la fusionnez dans <code>develop</code> (<a href="{{< relurl "book/fr/v2/ch00/merwf_d" >}}">Après la fusion d’une branche thématique.</a>).
Puis, lorsque vous étiquetez une version majeure, vous mettez <code>master</code> à niveau avec l’état stable de <code>develop</code> en avance rapide (<a href="{{< relurl "book/fr/v2/ch00/merwf_e" >}}">Après une publication d’une branche thématique.</a>).</p>
</div>
<div id="merwf_c" class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/merging-workflows-3.png" >}}" alt="Avant la fusion d’une branche thématique.">
</div>
<div class="title">Figure 74. Avant la fusion d’une branche thématique.</div>
</div>
<div id="merwf_d" class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/merging-workflows-4.png" >}}" alt="Après la fusion d’une branche thématique.">
</div>
<div class="title">Figure 75. Après la fusion d’une branche thématique.</div>
</div>
<div id="merwf_e" class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/merging-workflows-5.png" >}}" alt="Après une publication d’une branche thématique.">
</div>
<div class="title">Figure 76. Après une publication d’une branche thématique.</div>
</div>
<div class="paragraph">
<p>Ainsi, lorsque l’on clone le dépôt de votre projet, on peut soit extraire la branche <code>master</code> pour construire la dernière version stable et mettre à jour facilement ou on peut extraire la branche <code>develop</code> qui représente le nec plus ultra du développement.</p>
</div>
<div class="paragraph">
<p>Vous pouvez aussi continuer ce concept avec une branche d’intégration où tout le travail est fusionné.
Alors, quand la base de code sur cette branche est stable et que les tests passent, vous la fusionnez dans la branche <code>develop</code>.
Quand cela s’est avéré stable pendant un certain temps, vous mettez à jour la branche <code>master</code> en avance rapide.</p>
</div>
</div>
<div class="sect4">
<h4 id="_gestions_avec_nombreuses_fusions">Gestions avec nombreuses fusions</h4>
<div class="paragraph">
<p>
Le projet Git dispose de quatre branches au long cours : <code>master</code>, <code>next</code>, <code>pu</code> (<em>proposed updates</em> : propositions) pour les nouveaux travaux et <code>maint</code> pour les backports de maintenance.
Quand une nouvelle contribution est proposée, elle est collectée dans des branches thématiques dans le dépôt du mainteneur d’une manière similaire à ce que j’ai décrit (<a href="{{< relurl "book/fr/v2/ch00/merwf_f" >}}">Série complexe de branches thématiques contribuées en parallèle.</a>).
À ce point, les fonctionnalités sont évaluées pour déterminer si elles sont stables et prêtes à être consommées ou si elles nécessitent un peaufinage.
Si elles sont stables, elles sont fusionnées dans <code>next</code> et cette branche est poussée sur le serveur public pour que tout le monde puisse essayer les fonctionnalités intégrées ensemble.</p>
</div>
<div id="merwf_f" class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/large-merges-1.png" >}}" alt="Série complexe de branches thématiques contribuées en parallèle.">
</div>
<div class="title">Figure 77. Série complexe de branches thématiques contribuées en parallèle.</div>
</div>
<div class="paragraph">
<p>Si les fonctionnalités nécessitent encore du travail, elles sont fusionnées plutôt dans <code>pu</code>.
Quand elles sont considérées comme totalement stables, elles sont re-fusionnées dans <code>master</code> et sont alors reconstruites à partir des fonctionnalités qui résidaient dans <code>next</code> mais n’ont pu intégrer <code>master</code>.
Cela signifie que <code>master</code> évolue quasiment toujours en mode avance rapide, tandis que <code>next</code> est rebasé assez souvent et <code>pu</code> est rebasé encore plus souvent :</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/large-merges-2.png" >}}" alt="Fusion des branches thématiques dans les branches à long terme.">
</div>
<div class="title">Figure 78. Fusion des branches thématiques dans les branches à long terme.</div>
</div>
<div class="paragraph">
<p>Quand une branche thématique a finalement été fusionnée dans <code>master</code>, elle est effacée du dépôt.
Le projet Git a aussi une branche <code>maint</code> qui est créée à partir de la dernière version pour fournir des patchs correctifs en cas de besoin de version de maintenance.
Ainsi, quand vous clonez le dépôt de Git, vous avez quatre branches disponibles pour évaluer le projet à différentes étapes de développement, selon le niveau de développement que vous souhaitez utiliser ou pour lequel vous souhaitez contribuer.
Le mainteneur a une gestion structurée qui lui permet d’évaluer et sélectionner les nouvelles contributions.</p>
</div>
</div>
<div class="sect4">
<h4 id="s_rebase_cherry_pick">Gestion par rebasage et sélection de <em>commit</em>
</h4>
<div class="paragraph">
<p>
D’autres mainteneurs préfèrent rebaser ou sélectionner les contributions sur le sommet de la branche <code>master</code>, plutôt que les fusionner, de manière à conserver un historique à peu près linéaire.
Lorsque plusieurs modifications sont présentes dans une branche thématique et que vous souhaitez les intégrer, vous vous placez sur cette branche et vous lancez la commande <code>rebase</code> pour reconstruire les modifications à partir du sommet courant de la branche <code>master</code> (ou <code>develop</code>, ou autre).
Si cela fonctionne correctement, vous pouvez faire une avance rapide sur votre branche <code>master</code> et vous obtenez finalement un historique de projet linéaire.</p>
</div>
<div class="paragraph">
<p>
L’autre moyen de déplacer des modifications introduites dans une branche vers une autre consiste à les sélectionner ou les picorer (<code>cherry-pick</code>).
Un picorage dans Git ressemble à un rebasage appliqué à un <em>commit</em> unique.
Cela consiste à prendre le patch qui a été introduit lors d’une validation et à essayer de l’appliquer sur la branche sur laquelle on se trouve.
C’est très utile si on a un certain nombre de <em>commits</em> sur une branche thématique et que l’on veut n’en intégrer qu’un seul, ou si on n’a qu’un <em>commit</em> sur une branche thématique et qu’on préfère le sélectionner plutôt que de lancer <code>rebase</code>.
Par exemple, supposons que vous ayez un projet ressemblant à ceci :</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/rebasing-1.png" >}}" alt="Historique d’exemple avant une sélection.">
</div>
<div class="title">Figure 79. Historique d’exemple avant une sélection.</div>
</div>
<div class="paragraph">
<p>Si vous souhaitez tirer le <em>commit</em> <code>e43a6</code> dans votre branche <code>master</code>, vous pouvez lancer :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf
Finished one cherry-pick.
[master]: created a0a41a9: "More friendly message when locking the index fails."
 3 files changed, 17 insertions(+), 3 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>La même modification que celle introduite en <code>e43a6</code> est tirée mais vous obtenez une nouvelle valeur de SHA-1 car les dates d’application sont différentes.
À présent, votre historique ressemble à ceci :</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/rebasing-2.png" >}}" alt="Historique après sélection d’un _commit_ dans une branche thématique.">
</div>
<div class="title">Figure 80. Historique après sélection d’un <em>commit</em> dans une branche thématique.</div>
</div>
<div class="paragraph">
<p>Maintenant, vous pouvez effacer votre branche thématique et abandonner les <em>commits</em> que vous n’avez pas tirés dans <code>master</code>.</p>
</div>
</div>
<div class="sect4">
<h4 id="_rerere">Rerere</h4>
<div class="paragraph">
<p>
Si vous fusionnez et rebasez beaucoup ou si vous maintenez une branche au long cours, la fonctionnalité appelée « rerere » peut s’avérer utile.</p>
</div>
<div class="paragraph">
<p>Rerere signifie « <em>ré</em> utiliser les <em>ré</em> solutions en <em>re</em> gistrées » (“ <em>reuse recorded resolution</em> ”) ‑ c’est un moyen de raccourcir les résolutions manuelles de conflit.
Quand rerere est actif, Git va conserver un jeu de couples d’images pré et post fusion des fichiers ayant présenté des conflits, puis s’il s’aperçoit qu’un conflit ressemble à une de ces résolutions, il va utiliser la même stratégie sans rien vous demander.</p>
</div>
<div class="paragraph">
<p>Cette fonctionnalité se traite en deux phases : une étape de configuration et une commande.
L’étape de configuration est <code>rerere.enabled</code> qui active la fonction et qu’il est facile de placer en config globale :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global rerere.enabled true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ensuite, quand vous fusionnez en résolvant des conflits, la résolution sera enregistrée dans le cache pour un usage futur.</p>
</div>
<div class="paragraph">
<p>Si besoin, vous pouvez interagir avec le cache rerere au moyen de la commande <code>git rerere</code>.
Quand elle est invoquée telle quelle, Git vérifie sa base de données de résolutions et essaie de trouver une correspondance avec les conflits en cours et les résout (bien que ce soit automatique si <code>rerere.enabled</code> est à <code>true</code>).
Il existe aussi des sous-commandes permettant de voir ce qui sera enregistré, d’effacer du cache une résolution spécifique ou d’effacer entièrement le cache.
rerere est traité plus en détail dans <a href="{{< relurl "book/fr/v2/ch00/s_sect_rerere" >}}">Rerere</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="s_tagging_releases">Étiquetage de vos publications</h3>
<div class="paragraph">
<p>
Quand vous décidez de créer une publication de votre projet, vous souhaiterez probablement étiqueter le projet pour pouvoir recréer cette version dans le futur.
Vous pouvez créer une nouvelle étiquette (<em>tag</em>) telle que décrite dans <a href="{{< relurl "book/fr/v2/ch00/ch02-git-basics-chapter" >}}">Les bases de Git</a>.
Si vous décidez de signer l’étiquette en tant que mainteneur, la commande ressemblera à ceci :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git tag -s v1.5 -m 'mon etiquette v1.5 signée'
Une phrase secrète est nécessaire pour déverrouiller la clef secrète de
l'utilisateur : "Scott Chacon &lt;schacon@gmail.com&gt;"
clé DSA de 1024 bits, identifiant F721C45A, créée le 2009-02-09</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si vous signez vos étiquettes, vous rencontrerez le problème de la distribution de votre clé publique PGP permettant de vérifier la signature.
Le mainteneur du projet Git a résolu le problème en incluant la clé publique comme blob dans le dépôt et en ajoutant une étiquette qui pointe directement sur ce contenu.
Pour faire de même, vous déterminez la clé de votre trousseau que vous voulez publier en lançant <code>gpg --list-keys</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ gpg --list-keys
/Users/schacon/.gnupg/pubring.gpg
---------------------------------
pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]
uid                  Scott Chacon &lt;schacon@gmail.com&gt;
sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ensuite, vous pouvez importer la clé directement dans la base de données Git en l’exportant de votre trousseau et en la redirigeant dans <code>git hash-object</code> qui écrit un nouveau blob avec son contenu dans Git et vous donne en sortie le SHA-1 du blob :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ gpg -a --export F721C45A | git hash-object -w --stdin
659ef797d181633c87ec71ac3f9ba29fe5775b92</code></pre>
</div>
</div>
<div class="paragraph">
<p>À présent, vous avez le contenu de votre clé dans Git et vous pouvez créer une étiquette qui pointe directement dessus en spécifiant la valeur SHA-1 que la commande <code>hash-object</code> vous a fournie :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si vous lancez <code>git push --tags</code>, l’étiquette <code>maintainer-pgp-pub</code> sera partagée publiquement.
Un tiers pourra vérifier une étiquette après import direct de votre clé publique PGP, en extrayant le blob de la base de donnée et en l’important dans GPG :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show maintainer-pgp-pub | gpg --import</code></pre>
</div>
</div>
<div class="paragraph">
<p>Il pourra alors utiliser cette clé pour vérifier vos étiquettes signées.
Si de plus, vous incluez des instructions d’utilisation pour la vérification de signature dans le message d’étiquetage, l’utilisateur aura accès à ces informations en lançant la commande <code>git show &lt;étiquette&gt;</code>.</p>
</div>
</div>
<div class="sect3">
<h3 id="s_build_number">Génération d’un nom de révision</h3>
<div class="paragraph">
<p>
Comme Git ne fournit pas par nature de nombres croissants tels que « r123 » à chaque validation, la commande <code>git describe</code> permet de générer un nom humainement lisible pour chaque <em>commit</em>.
Git concatène le nom de l’étiquette la plus proche, le nombre de validations depuis cette étiquette et un code SHA-1 partiel du <em>commit</em> que l’on cherche à définir :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git describe master
v1.6.2-rc1-20-g8c5b85c</code></pre>
</div>
</div>
<div class="paragraph">
<p>De cette manière, vous pouvez exporter un instantané ou le construire et le nommer de manière intelligible.
En fait, si Git est construit à partir du source cloné depuis le dépôt Git, <code>git --version</code> vous donne exactement cette valeur.
Si vous demandez la description d’un instantané qui a été étiqueté, le nom de l’étiquette est retourné.</p>
</div>
<div class="paragraph">
<p>La commande <code>git describe</code> repose sur les étiquettes annotées (étiquettes créées avec les options <code>-a</code> ou <code>-s</code>).
Les étiquettes de publication doivent donc être créées de cette manière si vous souhaitez utiliser <code>git describe</code> pour garantir que les <em>commits</em> seront décrits correctement.
Vous pouvez aussi utiliser ces noms comme cible lors d’une extraction ou d’une commande <code>show</code>, bien qu’ils reposent sur le SHA-1 abrégé et pourraient ne pas rester valides indéfiniment.
Par exemple, le noyau Linux a sauté dernièrement de 8 à 10 caractères pour assurer l’unicité des objets SHA-1 et les anciens noms <code>git describe</code> sont par conséquent devenus invalides.</p>
</div>
</div>
<div class="sect3">
<h3 id="s_preparing_release">Préparation d’une publication</h3>
<div class="paragraph">
<p>
Maintenant, vous voulez publier une version.
Une des étapes consiste à créer une archive du dernier instantané de votre code pour les malheureux qui n’utilisent pas Git.
La commande dédiée à cette action est <code>git archive</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git archive master --prefix='projet/' | gzip &gt; `git describe master`.tar.gz
$ ls *.tar.gz
v1.6.2-rc1-20-g8c5b85c.tar.gz</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lorsqu’on ouvre l’archive, on obtient le dernier instantané du projet sous un répertoire <code>projet</code>.
On peut aussi créer une archive au format zip de manière similaire en passant l’option <code>--format=zip</code> à la commande <code>git archive</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git archive master --prefix='project/' --format=zip &gt; `git describe master`.zip</code></pre>
</div>
</div>
<div class="paragraph">
<p>Voilà deux belles archives tar.gz et zip de votre projet prêtes à être téléchargées sur un site web ou envoyées par courriel.</p>
</div>
</div>
<div class="sect3">
<h3 id="s_the_shortlog">Shortlog</h3>
<div class="paragraph">
<p>
Il est temps d’envoyer une annonce à la liste de diffusion des nouveautés de votre projet.
Une manière simple d’obtenir rapidement une sorte de liste des modifications depuis votre dernière version ou courriel est d’utiliser la commande <code>git shortlog</code>.
Elle résume toutes les validations dans l’intervalle que vous lui spécifiez.
Par exemple, ce qui suit vous donne un résumé de toutes les validations depuis votre dernière version si celle-ci se nomme v1.0.1 :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git shortlog --no-merges master --not v1.0.1
Chris Wanstrath (8):
      Add support for annotated tags to Grit::Tag
      Add packed-refs annotated tag support.
      Add Grit::Commit#to_patch
      Update version and History.txt
      Remove stray `puts`
      Make ls_tree ignore nils

Tom Preston-Werner (4):
      fix dates in history
      dynamic version method
      Version bump to 1.0.2
      Regenerated gemspec for version 1.0.2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Vous obtenez ainsi un résumé clair de toutes les validations depuis v1.0.1, regroupées par auteur, prêt à être envoyé sur la liste de diffusion.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>