---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: fr
  chapter:
    title: Les branches avec Git
    number: 3
  section:
    title: Les branches en bref
    number: 1
    cs_number: '3.1'
    previous: book/fr/v2/Les-bases-de-Git-Résumé
    next: book/fr/v2/Les-branches-avec-Git-Branches-et-fusions :-les-bases
title: Git - Les branches en bref
---
<p>
Presque tous les VCS proposent une certaine forme de gestion de branches.
Créer une branche signifie diverger de la ligne principale de développement et continuer à travailler sans impacter cette ligne.
Pour de nombreux VCS, il s’agit d’un processus coûteux qui nécessite souvent la création d’une nouvelle copie du répertoire de travail, ce qui peut prendre longtemps dans le cas de gros projets.</p><p>Certaines personnes considèrent le modèle de gestion de branches de Git comme ce qu’il a de plus remarquable et il offre sûrement à Git une place à part au sein de la communauté des VCS.
En quoi est-il si spécial ?
La manière dont Git gère les branches est incroyablement légère et permet de réaliser les opérations sur les branches de manière quasi instantanée et, généralement, de basculer entre les branches aussi rapidement.
À la différence de nombreux autres VCS, Git encourage des méthodes qui privilégient la création et la fusion fréquentes de branches, jusqu’à plusieurs fois par jour.
Bien comprendre et maîtriser cette fonctionnalité vous permettra de faire de Git un outil puissant et unique et peut totalement changer votre manière de développer.</p>
<h2 id="s_git_branches_overview">Les branches en bref</h2>
<div class="paragraph">
<p>Pour réellement comprendre la manière dont Git gère les branches, nous devons revenir en arrière et examiner de plus près comment Git stocke ses données.</p>
</div>
<div class="paragraph">
<p>Si vous vous souvenez bien du chapitre <a href="{{< relurl "book/fr/v2/ch00/ch01-getting-started" >}}">Démarrage rapide</a>, Git ne stocke pas ses données comme une série de modifications ou de différences successives mais plutôt comme une série d’instantanés (appelés <em>snapshots</em>).</p>
</div>
<div class="paragraph">
<p>Lorsque vous faites un commit, Git stocke un objet <em>commit</em> qui contient un pointeur vers l’instantané (<em>snapshot</em>) du contenu que vous avez indexé.
Cet objet contient également les noms et prénoms de l’auteur, le message que vous avez renseigné ainsi que des pointeurs vers le ou les <em>commits</em> qui précèdent directement ce <em>commit</em> : aucun parent pour le <em>commit</em> initial, un parent pour un <em>commit</em> normal et de multiples parents pour un <em>commit</em> qui résulte de la fusion d’une ou plusieurs branches.</p>
</div>
<div class="paragraph">
<p>Pour visualiser ce concept, supposons que vous avez un répertoire contenant trois fichiers que vous indexez puis validez.
L’indexation des fichiers calcule une empreinte (<em>checksum</em>) pour chacun (via la fonction de hachage SHA-1 mentionnée au chapitre <a href="{{< relurl "book/fr/v2/ch00/ch01-getting-started" >}}">Démarrage rapide</a>), stocke cette version du fichier dans le dépôt Git (Git les nomme <em>blobs</em>) et ajoute cette empreinte à la zone d’index (<em>staging area</em>) :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add README test.rb LICENSE
$ git commit -m 'initial commit of my project'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lorsque vous créez le <em>commit</em> en lançant la commande <code>git commit</code>, Git calcule l’empreinte de chaque sous-répertoire (ici, seulement pour le répertoire racine) et stocke ces objets de type arbre dans le dépôt Git.
Git crée alors un objet <em>commit</em> qui contient les méta-données et un pointeur vers l’arbre de la racine du projet de manière à pouvoir recréer l’instantané à tout moment.</p>
</div>
<div class="paragraph">
<p>Votre dépôt Git contient à présent cinq objets :
un <em>blob</em> pour le contenu de chacun de vos trois fichiers, un arbre (<em>tree</em>) qui liste le contenu du répertoire et spécifie quels noms de fichiers sont attachés à quels <em>blobs</em> et enfin un objet <em>commit</em> portant le pointeur vers l’arbre de la racine ainsi que toutes les méta-données attachées au <em>commit</em>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/commit-and-tree.png" >}}" alt="Un commit et son arbre">
</div>
<div class="title">Figure 9. Un commit et son arbre</div>
</div>
<div class="paragraph">
<p>Si vous faites des modifications et validez à nouveau, le prochain <em>commit</em> stocke un pointeur vers le <em>commit</em> le précédant immédiatement.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/commits-and-parents.png" >}}" alt="Commits et leurs parents">
</div>
<div class="title">Figure 10. Commits et leurs parents</div>
</div>
<div class="paragraph">
<p>Une branche dans Git est simplement un pointeur léger et déplaçable vers un de ces <em>commits</em>.
La branche par défaut dans Git s’appelle <code>master</code>.
Au fur et à mesure des validations, la branche <code>master</code> pointe vers le dernier des <em>commits</em> réalisés.
À chaque validation, le pointeur de la branche <code>master</code> avance automatiquement.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>La branche <code>master</code> n’est pas une branche spéciale.
Elle est identique à toutes les autres branches.
La seule raison pour laquelle chaque dépôt en a une est que la commande <code>git init</code> la crée par défaut et que la plupart des gens ne s’embêtent pas à la changer.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/branch-and-history.png" >}}" alt="Une branche et l’historique de ses _commits_">
</div>
<div class="title">Figure 11. Une branche et l’historique de ses <em>commits</em>
</div>
</div>
<div class="sect3">
<h3 id="s_create_new_branch">Créer une nouvelle branche</h3>
<div class="paragraph">
<p>
Que se passe-t-il si vous créez une nouvelle branche ?
Eh bien, cela crée un nouveau pointeur pour vous.
Supposons que vous créez une nouvelle branche nommée <code>test</code>.
Vous utilisez pour cela la commande <code>git branch</code> : </p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch testing</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cela crée un nouveau pointeur vers le <em>commit</em> courant.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/two-branches.png" >}}" alt="Deux branches pointant vers la même série de _commits_">
</div>
<div class="title">Figure 12. Deux branches pointant vers la même série de <em>commits</em>
</div>
</div>
<div class="paragraph">
<p>Comment Git connaît-il alors la branche sur laquelle vous vous trouvez ?
Il conserve à cet effet un pointeur spécial appelé <code>HEAD</code>.
Vous remarquez que sous cette appellation se cache un concept très différent de celui utilisé dans les autres VCS tels que Subversion ou CVS.
Dans Git, il s’agit simplement d’un pointeur sur la branche locale où vous vous trouvez.
Dans ce cas, vous vous trouvez toujours sur <code>master</code>.
En effet, la commande <code>git branch</code> n’a fait que créer une nouvelle branche — elle n’a pas fait basculer la copie de travail vers cette branche.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/head-to-master.png" >}}" alt="HEAD pointant vers une branche">
</div>
<div class="title">Figure 13. HEAD pointant vers une branche</div>
</div>
<div class="paragraph">
<p>Vous pouvez vérifier cela facilement grâce à la commande <code>git log</code> qui vous montre vers quoi les branches pointent.
Il s’agit de l’option <code>--decorate</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --decorate
f30ab (HEAD, master, test) add feature #32 - ability to add new
34ac2 fixed bug #ch1328 - stack overflow under certain conditions
98ca9 initial commit of my project</code></pre>
</div>
</div>
<div class="paragraph">
<p>Vous pouvez voir les branches <code>master</code>  et <code>test</code> qui se situent au niveau du <em>commit</em> <code>f30ab</code>.</p>
</div>
</div>
<div class="sect3">
<h3 id="s_switching_branches">Basculer entre les branches</h3>
<div class="paragraph">
<p>
Pour basculer sur une branche existante, il suffit de lancer la commande <code>git checkout</code>.
Basculons sur la nouvelle branche <code>testing</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout testing</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cela déplace <code>HEAD</code> pour le faire pointer vers la branche <code>testing</code>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/head-to-testing.png" >}}" alt="HEAD pointe vers la branche courante">
</div>
<div class="title">Figure 14. HEAD pointe vers la branche courante</div>
</div>
<div class="paragraph">
<p>Qu’est-ce que cela signifie ?
Et bien, faisons une autre validation :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ vim test.rb
$ git commit -a -m 'made a change'</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/advance-testing.png" >}}" alt="La branche HEAD avance à chaque _commit_">
</div>
<div class="title">Figure 15. La branche HEAD avance à chaque <em>commit</em>
</div>
</div>
<div class="paragraph">
<p>C’est intéressant parce qu’à présent, votre branche <code>testing</code> a avancé tandis que la branche <code>master</code> pointe toujours sur le <em>commit</em> sur lequel vous étiez lorsque vous avez lancé la commande <code>git checkout</code> pour changer de branche.
Retournons sur la branche <code>master</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">
<code>git log</code> ne montre pas <em>toutes</em> les branches <em>tout</em> le temps</div>
<div class="paragraph">
<p>Si vous alliez lancer <code>git log</code> maintenant, vous pourriez vous demander où se trouve la branche « testing » que vous avez tout juste créée, car elle n’apparaît pas dans la sortie.</p>
</div>
<div class="paragraph">
<p>La branche n’a pas disparu ; Git ne sait juste pas que cette branche vous intéresse et il essaie de vous montrer ce qu’il pense être le plus pertinent.
Autrement dit, par défaut, <code>git log</code> ne montre que l’historique des commits sous la branche qui est extraite.</p>
</div>
<div class="paragraph">
<p>Pour montrer l’historique des commites de la branche désirée, vous devez la spécifier explicitement : <code>git log testing</code>.
Pour afficher toutes les branches, ajoutez l’option <code>--all</code> à la commande <code>git log</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/checkout-master.png" >}}" alt="HEAD est déplacé lors d’un _checkout_">
</div>
<div class="title">Figure 16. HEAD est déplacé lors d’un <em>checkout</em>
</div>
</div>
<div class="paragraph">
<p>Cette commande a réalisé deux actions.
Elle a remis le pointeur <code>HEAD</code> sur la branche <code>master</code> et elle a replacé les fichiers de votre répertoire de travail dans l’état du <em>snapshot</em> pointé par <code>master</code>.
Cela signifie aussi que les modifications que vous réalisez à partir de ce point divergeront de l’ancienne version du projet.
Cette commande annule les modifications réalisées dans la branche <code>testing</code> pour vous permettre de repartir dans une autre direction.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Changer de branche modifie les fichiers dans votre répertoire de travail</div>
<div class="paragraph">
<p>Il est important de noter que lorsque vous changez de branche avec Git, les fichiers de votre répertoire de travail sont modifiés.
Si vous basculez vers une branche plus ancienne, votre répertoire de travail sera remis dans l’état dans lequel il était lors du dernier <em>commit</em> sur cette branche.
Si git n’est pas en mesure d’effectuer cette action proprement, il ne vous laissera pas changer de branche.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Réalisons quelques autres modifications et validons à nouveau :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ vim test.rb
$ git commit -a -m 'made other changes'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Maintenant, l’historique du projet a divergé (voir <a href="{{< relurl "book/fr/v2/ch00/divergent_history" >}}">Divergence d’historique</a>).
Vous avez créé une branche et basculé dessus, y avez réalisé des modifications, puis vous avez rebasculé sur la branche principale et réalisé d’autres modifications.
Ces deux modifications sont isolées dans des branches séparées : vous pouvez basculer d’une branche à l’autre et les fusionner quand vous êtes prêt.
Et vous avez fait tout ceci avec de simples commandes : <code>branch</code>, <code>checkout</code> et <code>commit</code>.</p>
</div>
<div id="divergent_history" class="imageblock">
<div class="content">
<img src="{{< relurl "book/fr/v2/images/advance-master.png" >}}" alt="Divergence d’historique">
</div>
<div class="title">Figure 17. Divergence d’historique</div>
</div>
<div class="paragraph">
<p>Vous pouvez également voir ceci grâce à la commande <code>git log</code>.
La commande <code>git log --oneline --decorate --graph --all</code> va afficher l’historique de vos <em>commits</em>, affichant les endroits où sont positionnés vos pointeurs de branche ainsi que la manière dont votre historique a divergé.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --decorate --graph --all
* c2b9e (HEAD, master) made other changes
| * 87ab2 (test) made a change
|/
* f30ab add feature #32 - ability to add new formats to the
* 34ac2 fixed bug #ch1328 - stack overflow under certain conditions
* 98ca9 initial commit of my project</code></pre>
</div>
</div>
<div class="paragraph">
<p>Parce qu’une branche Git n’est en fait qu’un simple fichier contenant les 40 caractères de l’empreinte SHA-1 du <em>commit</em> sur lequel elle pointe, les branches ne coûtent quasiment rien à créer et à détruire.
Créer une branche est aussi simple et rapide qu’écrire 41 caractères dans un fichier (40 caractères plus un retour chariot).</p>
</div>
<div class="paragraph">
<p>C’est une différence de taille avec la manière dont la plupart des VCS gèrent les branches, qui implique de copier tous les fichiers du projet dans un second répertoire.
Cela peut durer plusieurs secondes ou même quelques minutes selon la taille du projet, alors que pour Git, le processus est toujours instantané.
De plus, comme nous enregistrons les parents quand nous validons les modifications, la détermination de l’ancêtre commun approprié pour la fusion est réalisée automatiquement pour nous et est généralement une opération très facile.
Ces fonctionnalités encouragent naturellement les développeurs à créer et utiliser souvent des branches.</p>
</div>
<div class="paragraph">
<p>Voyons pourquoi vous devriez en faire autant.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">Créer une branche et basculer dessus en même temps</div>
<div class="paragraph">
<p>Il est habituel de créer une nouvelle branche et de vouloir basculer sur cette nouvelle branche en même temps — ça peut être réalisé en une seule opération avec <code>git checkout -b &lt;nouvelle-branche&gt;</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Depuis Git version 2.23, on peut utiliser <code>git switch</code> au lieu de <code>git checkout</code> pour :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>basculer sur une branche existante : <code>git switch testing-branch</code>,</p>
</li>
<li>
<p>créer une branche et basculer dessus ; <code>git switch -c nouvelle-branche</code>; le drapeau <code>-c</code> signifie créer, vous pouvez aussi utiliser le drapeau complet <code>--create</code>,</p>
</li>
<li>
<p>revenir sur votre branche précédemment extraite : <code>git switch -</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>