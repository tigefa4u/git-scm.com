---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: tr
  chapter:
    title: Git ve Diğer Sistemler
    number: 9
  section:
    title: Git’e Geçiş
    number: 2
    cs_number: '9.2'
    previous: book/tr/v2/Git-ve-Diğer-Sistemler-İstemci-Olarak-Git
    next: book/tr/v2/Git-ve-Diğer-Sistemler-Özet
title: Git - Git’e Geçiş
url: "/book/tr/v2/Git-ve-Diğer-Sistemler-Git’e-Geçiş.html"
---
<h2 id="_migrating">Git’e Geçiş</h2>
<div class="paragraph">
<p>
Başka bir VCS’te mevcut bir kod tabanınız varsa ancak Git’i kullanmaya başlamaya karar verdiyseniz, projenizi bir şekilde taşımanız gerekir.
Bu bölüm, yaygın sistemler için bazı içe aktarıcıları ele alır ve ardından kendi özel içe aktarıcınızı nasıl geliştireceğinizi gösterir.
Profesyonel olarak kullanılan SCM sistemlerinin çoğunluğunu oluşturdukları ve yüksek kaliteli araçların bulunması kolay olduğu için, bu sistemlerden veri içe aktarma işlemini öğreneceksiniz.</p>
</div>
<div class="sect3">
<h3 id="_subversion">Subversion</h3>
<div class="paragraph">
<p>

<code>git svn</code> kullanımıyla ilgili önceki bölümü okuduysanız, bir repoyu svn ile kopyalamak (<code>git svn clone</code>) için bu talimatları kolayca kullanabilirsiniz: Sonra Subversion sunucusunu durdurup, yeni bir Git sunucusuna itin ve onu kullanmaya başlayın.
Geçmişi istiyorsanız, bunu Subversion sunucusundan verileri çektiğiniz kadar hızlı bir şekilde gerçekleştirebilirsiniz (bu biraz zaman alabilir).</p>
</div>
<div class="paragraph">
<p>Ancak içe aktarma tamamen mükemmel değildir; çok uzun süreceği için bunu doğru yapsanız iyi olur.
İlk sorun yazar bilgisidir.
Subversion’da katkıda bulunan her kişinin sistemde katkı bilgilerinde kayıtlı bir kullanıcısı vardır.
Önceki bölümdeki örneklerde, <code>blame</code> çıktısı ve <code>git svn log</code> gibi bazı yerlerde <code>schacon</code> gösterilmektedir.
Bunu daha iyi Git yazar verileriyle eşleştirmek istiyorsanız, Subversion kullanıcılarından Git yazarlarına bir eşleştirmeye ihtiyacınız vardır.
Bu eşlemeyi şu şekilde içeren <code>users.txt</code> adlı bir dosya oluşturun:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>schacon = Scott Chacon &lt;schacon@geemail.com&gt;
selse = Someo Nelse &lt;selse@geemail.com&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>SVN’nin kullandığı yazar adlarının bir listesini almak için şunu çalıştırabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ svn log --xml --quiet | grep author | sort -u | \
  perl -pe 's/.*&gt;(.*?)&lt;.*/$1 = /'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu komut dizini günlük (log) çıktısını XML biçiminde oluşturur, ardından yalnızca yazar bilgilerinin bulunduğu satırları tutar, yinelenenleri atar ve XML etiketlerini çıkarır (Bariz şekilde, bu yalnızca <em>grep</em>, <em>sort</em> ve <em>Perl</em> yüklü bir makinede çalışır.)
Ardından, her girişin yanına eşdeğer Git kullanıcı verilerini ekleyebilmeniz için bu çıktıyı <code>users.txt</code> dosyanıza yönlendirin.</p>
</div>
<div class="paragraph">
<p>Yazar verilerini daha doğru bir şekilde eşleştirmesine yardımcı olmak için bu dosyayı <code>git svn</code> 'ye sağlayabilirsiniz.
Ayrıca, <code>clone</code> veya <code>init</code> komutuna <code>--no-metadata</code> seçeneğini ileterek, <code>git svn</code> 'ye Subversion’ın normalde içe aktardığı meta verileri eklememesini de söyleyebilirsiniz (ancak senkronizasyon meta verilerini korumak istiyorsanız, bu parametreyi atlamakta özgürsünüz).
Bu, <code>import</code> komutunuzun şu şekilde görünmesini sağlar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn clone http://my-project.googlecode.com/svn/ \
      --authors-file=users.txt --no-metadata --prefix "" -s my_project
$ cd my_project</code></pre>
</div>
</div>
<div class="paragraph">
<p>Artık <code>my_project</code> dizininizde daha güzel bir Subversion içe aktarımına sahip olmalısınız.
Buna benzeyen katkılar yerine</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>commit 37efa680e8473b615de980fa935944215428a35a
Author: schacon &lt;schacon@4c93b258-373f-11de-be05-5f7a86268029&gt;
Date:   Sun May 3 00:12:22 2009 +0000

    fixed install - go to trunk

    git-svn-id: https://my-project.googlecode.com/svn/trunk@94 4c93b258-373f-11de-
    be05-5f7a86268029</code></pre>
</div>
</div>
<div class="paragraph">
<p>şunun gibi:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>commit 03a8785f44c8ea5cdb0e8834b7c8e6c469be2ff2
Author: Scott Chacon &lt;schacon@geemail.com&gt;
Date:   Sun May 3 00:12:22 2009 +0000

    fixed install - go to trunk</code></pre>
</div>
</div>
<div class="paragraph">
<p>Yazar alanı çok daha iyi görünmekle kalmıyor, aynı zamanda <code>git-svn-id</code> de artık orada değil.</p>
</div>
<div class="paragraph">
<p>Ayrıca biraz içe aktarma sonrası temizlik de yapmalısınız.
Bunlardan biri <code>git svn</code> 'nin oluşturduğu tuhaf referansları temizlemektir.
Öncelikle etiketleri, tuhaf uzak dallar yerine gerçek etiketler olacak şekilde, ve ardından geri kalan dalları da yerel olacak şekilde taşıyacaksınız.</p>
</div>
<div class="paragraph">
<p>Etiketleri uygun Git etiketleri olacak şekilde taşımak için şunu çalıştırın:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ for t in $(git for-each-ref --format='%(refname:short)' refs/remotes/tags); do git tag ${t/tags\//} $t &amp;&amp; git branch -D -r $t; done</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu, <code>refs/remotes/tags/</code> ile başlayan uzak dal referanslarını alır ve onları gerçek (hafif) etiketler haline getirir.</p>
</div>
<div class="paragraph">
<p>Ardından, referansların geri kalanını <code>refs/remotes</code> altında yerel şubelere taşıyın:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ for b in $(git for-each-ref --format='%(refname:short)' refs/remotes); do git branch $b refs/remotes/$b &amp;&amp; git branch -D -r $b; done</code></pre>
</div>
</div>
<div class="paragraph">
<p>Subversion’da yalnızca bir dal görürken, sonuna <code>@xxx</code> (burada xxx bir sayıdır) eklenmiş bazı ekstra dallar görebilirsiniz.
Bu aslında ``peg-revizyonlar`` adı verilen bir Subversion özelliğidir ve Git’te sözdizimsel karşılığı olmayan bir şeydir.
Bu nedenle <code>git svn</code>, svn sürüm numarasını dal adına ekler (tıpkı o dalın sabit revizyonunu ele almak için svn’de yazdığınız gibi) .
Artık sabit düzeltmeleri umursamıyorsanız, bunları kaldırmanız yeterlidir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ for p in $(git for-each-ref --format='%(refname:short)' | grep @); do git branch -D $p; done</code></pre>
</div>
</div>
<div class="paragraph">
<p>Artık tüm eski dallar gerçek Git dalları ve tüm eski etiketler gerçek Git etiketleridir.</p>
</div>
<div class="paragraph">
<p>Temizlenecek son bir şey daha var.
Ne yazık ki, <code>git svn</code> Subversion’un varsayılan dalına eşlenen <code>trunk</code> adında fazladan bir dal oluşturur, ancak <code>trunk</code> ref’i, <code>master</code> ile aynı yeri işaret eder.
<code>master</code> kelimesi Git’e daha uyggun bir ifade biçimi olduğundan, fazladan dalın nasıl kaldırılacağı aşağıda açıklanmıştır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch -d trunk</code></pre>
</div>
</div>
<div class="paragraph">
<p>Yapılacak son şey, yeni Git sunucunuzu uzak olarak eklemek ve ona itmektir.
Sunucunuzu uzak olarak eklemenin bir örneği:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add origin git@my-git-server:myrepository.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tüm dallarınızın ve etiketlerinizin üste çıkmasını istediğiniz için artık şunu çalıştırabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git push origin --all
$ git push origin --tags</code></pre>
</div>
</div>
<div class="paragraph">
<p>Artık tüm dal ve etiketleriniz güzel ve temiz bir içe aktarma işlemiyle yeni Git sunucunuzda olmalıdır.</p>
</div>
</div>
<div class="sect3">
<h3 id="_mercurial">Mercurial</h3>
<div class="paragraph">
<p>
Mercurial ve Git’in sürümleri temsil etme modelleri çok benzer olduğundan ve Git biraz daha esnek olduğundan; bir repoyu Mercurial’den Git’e dönüştürmek oldukça basittir.
Bu dönüşüm için <code>hg-fast-export</code> adlı bir araca ihtiyacınız olacak.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone https://github.com/frej/fast-export.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dönüşümün ilk adımı, dönüştürmek istediğiniz Mercurial reposunun tam kopyasını almaktır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ hg clone &lt;remote repo URL&gt; /tmp/hg-repo</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bir sonraki adım, bir yazar eşleştirme dosyası oluşturmaktır.
Değişiklik setlerindeki yazar alanına koyabileceği şeyler konusunda Mercurial, Git’ten biraz daha esnek olduğu için; temizlemek için bu iyi bir zamandır.
Bunu yapmak için bir <code>bash</code> shell’inde tek satırlık bir komut kullanabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cd /tmp/hg-repo
$ hg log | grep user: | sort | uniq | sed 's/user: *//' &gt; ../authors</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu projenizin geçmişinin ne kadar uzun olduğuna bağlı olarak birkaç saniye sürecektir ve sonrasında <code>/tmp/authors</code> dosyası şöyle görünecektir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>bob
bob@localhost
bob &lt;bob@company.com&gt;
bob jones &lt;bob &lt;AT&gt; company &lt;DOT&gt; com&gt;
Bob Jones &lt;bob@company.com&gt;
Joe Smith &lt;joe@company.com&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu örnekte, aynı kişi (Bob), dört farklı ad altında değişiklik setleri oluşturmuştur; bunlardan biri Git katkısı için doğru görünürken, biri tamamen geçersiz olacaktır.
Hg-fast-export her bir satırı bir kurala dönüştürerek bunu düzeltmemize izin verir: <code>"&lt;input&gt;"="&lt;output&gt;"</code>, bir <code>&lt;giriş&gt;</code> 'i bir <code>&lt;çıkış&gt;</code> 'a eşleyen bir kural.
<code>&lt;giriş&gt;</code> ve <code>&lt;çıkış&gt;</code> dizelerinin içinde, python <code>string_escape</code> kodlaması tarafından anlaşılan tüm kaçış dizileri desteklenir.
Eğer yazar eşleştirme dosyası eşleşen bir <code>&lt;input&gt;</code> içermiyorsa, bu yazar Git’e değiştirilmeden gönderilecektir.
Eğer tüm kullanıcı adları uygun görünüyorsa, bu dosyaya hiç ihtiyacımız olmayacaktır.
Bu örnekte, dosyamızın şu şekilde görünmesini istiyoruz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>"bob"="Bob Jones &lt;bob@company.com&gt;"
"bob@localhost"="Bob Jones &lt;bob@company.com&gt;"
"bob &lt;bob@company.com&gt;"="Bob Jones &lt;bob@company.com&gt;"
"bob jones &lt;bob &lt;AT&gt; company &lt;DOT&gt; com&gt;"="Bob Jones &lt;bob@company.com&gt;"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aynı türdeki eşleştirme dosyası, Mercurial adı Git tarafından izin verilmediğinde dalları ve etiketleri yeniden adlandırmak için de kullanılabilir.</p>
</div>
<div class="paragraph">
<p>Bir sonraki adım, yeni Git reposunu oluşturmak ve dışa aktarma komut dosyasını çalıştırmaktır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git init /tmp/converted
$ cd /tmp/converted
$ /tmp/fast-export/hg-fast-export.sh -r /tmp/hg-repo -A /tmp/authors</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>-r</code> bayrağı, dönüştürmek istediğimiz Mercurial reposunu bulması için hg-fast-export’a nerede bakacağını ve <code>-A</code> bayrağı da yazar eşleştirme dosyasını nerede bulacağını söyler (dallar ve etiket eşleştirme dosyaları sırasıyla <code>-B</code> ve <code>-T</code> bayrakları ile belirtilir).
Betik Mercurial değişiklik setlerini ayrıştırır ve bunları Git’in "fast-import" özelliği için bir betiğe dönüştürür (bu özelliği biraz sonra detaylı bir şekilde inceleyeceğiz).
Bu biraz zaman alır (ancak ağ üzerinden yapılmasından <em>çok</em> daha hızlıdır) ancak çıktı oldukça ayrıntılıdır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ /tmp/fast-export/hg-fast-export.sh -r /tmp/hg-repo -A /tmp/authors
Loaded 4 authors
master: Exporting full revision 1/22208 with 13/0/0 added/changed/removed files
master: Exporting simple delta revision 2/22208 with 1/1/0 added/changed/removed files
master: Exporting simple delta revision 3/22208 with 0/1/0 added/changed/removed files
[…]
master: Exporting simple delta revision 22206/22208 with 0/4/0 added/changed/removed files
master: Exporting simple delta revision 22207/22208 with 0/2/0 added/changed/removed files
master: Exporting thorough delta revision 22208/22208 with 3/213/0 added/changed/removed files
Exporting tag [0.4c] at [hg r9] [git :10]
Exporting tag [0.4d] at [hg r16] [git :17]
[…]
Exporting tag [3.1-rc] at [hg r21926] [git :21927]
Exporting tag [3.1] at [hg r21973] [git :21974]
Issued 22315 commands
git-fast-import statistics:
---------------------------------------------------------------------
Alloc'd objects:     120000
Total objects:       115032 (    208171 duplicates                  )
      blobs  :        40504 (    205320 duplicates      26117 deltas of      39602 attempts)
      trees  :        52320 (      2851 duplicates      47467 deltas of      47599 attempts)
      commits:        22208 (         0 duplicates          0 deltas of          0 attempts)
      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)
Total branches:         109 (         2 loads     )
      marks:        1048576 (     22208 unique    )
      atoms:           1952
Memory total:          7860 KiB
       pools:          2235 KiB
     objects:          5625 KiB
---------------------------------------------------------------------
pack_report: getpagesize()            =       4096
pack_report: core.packedGitWindowSize = 1073741824
pack_report: core.packedGitLimit      = 8589934592
pack_report: pack_used_ctr            =      90430
pack_report: pack_mmap_calls          =      46771
pack_report: pack_open_windows        =          1 /          1
pack_report: pack_mapped              =  340852700 /  340852700
---------------------------------------------------------------------

$ git shortlog -sn
   369  Bob Jones
   365  Joe Smith</code></pre>
</div>
</div>
<div class="paragraph">
<p>İşte hepsi bu kadar.
Tüm Mercurial etiketleri Git etiketlerine, Mercurial dalları ve yer imleri de Git dallarına dönüştürülmüştür.
Şimdi, reponuzu yeni sunucu ana dizinine gönderecek durumdasınız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add origin git@my-git-server:myrepository.git
$ git push origin --all</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_bazaar">Bazaar</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Bazaar, Git gibi bir Dağıtık Sürüm Kontrol Sistemi (DVCS) aracıdır ve sonuç olarak bir Bazaar reposunu bir Git reposuna dönüştürmek oldukça basittir.
Bunun için <code>bzr-fastimport</code> eklentisini içe aktarmanız gerekecek.</p>
</div>
<div class="sect4">
<h4 id="_bzr_fastimport_eklentisini_edinme">bzr-fastimport Eklentisini Edinme</h4>
<div class="paragraph">
<p>UNIX benzeri işletim sistemlerinde hızlı içe aktarma eklentisini kurmanın yolu ve Windows’tan farklıdır.
UNIX’te en kolayı gerekli tüm bağımlılıkları kuracak olan <code>bzr-fastimport</code> paketini kurmaktır.</p>
</div>
<div class="paragraph">
<p>Örneğin, Debian ve türevlerinde şunları yapabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ sudo apt-get install bzr-fastimport</code></pre>
</div>
</div>
<div class="paragraph">
<p>RHEL ile şunları yapabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ sudo yum install bzr-fastimport</code></pre>
</div>
</div>
<div class="paragraph">
<p>Fedora ile sürüm 22’den beri paket yöneticisi dnf’tir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ sudo dnf install bzr-fastimport</code></pre>
</div>
</div>
<div class="paragraph">
<p>Paket mevcut değilse, onu eklenti olarak yükleyebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ mkdir --parents ~/.bazaar/plugins     # creates the necessary folders for the plugins
$ cd ~/.bazaar/plugins
$ bzr branch lp:bzr-fastimport fastimport   # imports the fastimport plugin
$ cd fastimport
$ sudo python setup.py install --record=files.txt   # installs the plugin</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu eklentinin çalışması için ayrıca <code>fastimport</code> Python modülüne de ihtiyacınız olacaktır.
Onun mevcut olup olmadığını kontrol edebilir ve aşağıdaki komutlarla yükleyebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ python -c "import fastimport"
Traceback (most recent call last):
  File "&lt;string&gt;", line 1, in &lt;module&gt;
ImportError: No module named fastimport
$ pip install fastimport</code></pre>
</div>
</div>
<div class="paragraph">
<p>Eğer mevcut değilse, onu <a href="https://pypi.python.org/pypi/fastimport/" class="bare">https://pypi.python.org/pypi/fastimport/</a> adresinden indirebilirsiniz.</p>
</div>
<div class="paragraph">
<p>Windows’ta <code>bzr-fastimport</code> standalone (bağımsız) sürümüyle ve varsayılan kurulumla (tüm onay kutularını işaretleyerek) otomatik olarak kuruludır.
Bu durumda yapmanız gereken bir şey yoktur.</p>
</div>
<div class="paragraph">
<p>Bu noktada, bir Bazaar reposunu içe aktarma yöntemi, tek bir dalınızın olup olmadığına veya birçok dala sahip bir repoyla çalışıp çalışmadığınıza göre farklılık gösterir.</p>
</div>
</div>
<div class="sect4">
<h4 id="_tek_dallı_proje">Tek Dallı Proje</h4>
<div class="paragraph">
<p>Şimdi, Bazaar reposunu içeren dizine gidin ve Git reposunu başlatın:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cd /path/to/the/bzr/repository
$ git init</code></pre>
</div>
</div>
<div class="paragraph">
<p>Şimdi, Bazaar reposunu dışa aktarabilir ve aşağıdaki komutu kullanarak bir Git reposuna dönüştürebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ bzr fast-export --plain . | git fast-import</code></pre>
</div>
</div>
<div class="paragraph">
<p>Proje boyutuna bağlı olarak, Git reposunun oluşturulması birkaç saniye ile birkaç dakika arasında sürebilir.</p>
</div>
</div>
<div class="sect4">
<h4 id="_bir_anadal_ve_bir_çalışma_dalı_olan_proje_durumu">Bir Anadal ve Bir Çalışma Dalı Olan Proje Durumu</h4>
<div class="paragraph">
<p>Dallara sahip bir Bazaar reposunu da içe aktarabilirsiniz.
Diyelim ki iki dalınız var: biri ana dalı temsil eder (myProject.trunk), diğeri ise çalışma dalıdır (myProject.work).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ls
myProject.trunk myProject.work</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git reposunu oluşturun ve dizinine gidin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git init git-repo
$ cd git-repo</code></pre>
</div>
</div>
<div class="paragraph">
<p>Master dalını Git’e çekin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ bzr fast-export --export-marks=../marks.bzr ../myProject.trunk | \
git fast-import --export-marks=../marks.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Çalışma dalını Git’e çekin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ bzr fast-export --marks=../marks.bzr --git-branch=work ../myProject.work | \
git fast-import --import-marks=../marks.git --export-marks=../marks.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Şimdi <code>git branch</code> komutu hem <code>master</code> dalını, hem de <code>work</code> dalını gösterir.
Tamam olduğundan emin olmak için; log kayıtlarını kontrol edip, <code>marks.bzr</code> ve <code>marks.git</code> dosyalarını temizleyin.</p>
</div>
</div>
<div class="sect4">
<h4 id="_i̇zleme_alanını_stage_senkronize_etme">İzleme Alanını (Stage) Senkronize Etme</h4>
<div class="paragraph">
<p>Ne kadar çok dalınız olursa olsun ve hangi içe aktarma yöntemini kullanırsanız kullanın, izleme alanınız <code>HEAD</code> ile senkronize değildir; ve birden fazla dalın içe aktarılmasıyla, çalışma diziniz de senkronize değildir.</p>
</div>
<div class="paragraph">
<p>Bu durumu aşağıdaki komutla kolayca çözebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git reset --hard HEAD</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_bzrignore_ile_yoksayılmış_dosyaları_yoksaymak">.bzrignore ile Yoksayılmış Dosyaları Yoksaymak</h4>
<div class="paragraph">
<p>Şimdi yoksayılacak dosyalara bir göz atalım.
İlk yapmanız gereken <code>.bzrignore</code> dosyasını <code>.gitignore</code> olarak yeniden adlandırmaktır.
<code>.bzrignore</code> dosyası "!!" veya "RE:" ile başlayan bir veya birkaç satır içeriyorsa, bunu değiştirmeniz ve belki de Bazaar’ın yoksaydığı tam olarak aynı dosyaları yoksaymak için birkaç <code>.gitignore</code> dosyası oluşturmanız gerekebilir.</p>
</div>
<div class="paragraph">
<p>Son olarak, bu değişikliği içeren taşınma (migration) için bir katkı oluşturmanız gerekecektir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git mv .bzrignore .gitignore
$ # modify .gitignore if needed
$ git commit -am 'Migration from Bazaar to Git'</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_reponuzu_sunucuya_göndermek">Reponuzu Sunucuya Göndermek</h4>
<div class="paragraph">
<p>İşte oldu!
Artık reponuzu yeni ana sunucusuna aktarabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add origin git@my-git-server:mygitrepository.git
$ git push origin --all
$ git push origin --tags</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git reponuz kullanıma hazırdır.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_perforce_import">Perforce</h3>
<div class="paragraph">
<p>
İçe aktarmayı inceleyeceğimiz bir sonraki sistem Perforce’tur.
Yukarıda belirttiğimiz gibi Git ve Perforce’un birbirleriyle konuşmasına izin vermenin iki yolu vardır: git-p4 ve Perforce Git Fusion.</p>
</div>
<div class="sect4">
<h4 id="_perforce_git_fusion">Perforce Git Fusion</h4>
<div class="paragraph">
<p>Git Fusion bu süreci oldukça ağrısız hale getirir.
Proje ayarlarınızı, kullanıcı eşlemelerinizi ve dallarınızı bir yapılandırma dosyası kullanarak (<a href="{{< relurl "book/tr/v2/ch00/_p4_git_fusion" >}}">Git Fusion</a> bölümünde anlatıldığı gibi) yapılandırın ve repoyu kopyalayın.
Git Fusion size yerel bir Git reposuna benzer bir şey bırakır. Bunu daha sonra isterseniz yerel bir Git ana bilgisayarına gönderebilirsiniz.
İsterseniz Perforce’u Git sunucunuz olarak bile kullanabilirsiniz.</p>
</div>
</div>
<div class="sect4">
<h4 id="_git_p4">Git-p4</h4>
<div class="paragraph">
<p>Git-p4 aynı zamanda bir içe aktarma aracı görevi de görebilir.
Örnek olarak Jam projesini "Perforce Public Depot" 'dan içe aktaracağız.
İstemcinizi kurmak için P4PORT ortam değişkenini Perforce deposunu işaret edecek şekilde dışa aktarmanız gerekir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ export P4PORT=public.perforce.com:1666</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Not</div>
</td>
<td class="content">
<div class="paragraph">
<p>Takip etmek için bağlantı kurabileceğiniz bir Perforce deposuna ihtiyacınız olacak.
Örneklerimiz için public.perforce.com adresindeki genel depoyu kullanacağız, ancak erişiminiz olan herhangi bir depoyu da kullanabilirsiniz.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>
Jam projesini Perforce sunucusundan içe aktarmak için depo ve proje yolunu ve projeyi içe aktarmak istediğiniz yolu sağlayarak <code>git p4 clone</code> komutunu çalıştırın:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git-p4 clone //guest/perforce_software/jam@all p4import
Importing from //guest/perforce_software/jam@all into p4import
Initialized empty Git repository in /private/tmp/p4import/.git/
Import destination: refs/remotes/p4/master
Importing revision 9957 (100%)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu özel projenin yalnızca bir dalı vardır, ancak dal görünümleriyle (veya yalnızca bir dizin kümesi) yapılandırılmış dallarınız varsa; tüm dosyaları ve projenin alt dallarını içe aktarmak için <code>--detect-branches</code> işaretini <code>git p4 clone</code> komutuna ekleyerek kullanabilirsiniz.
Bu konuda biraz daha ayrıntılı bilgi için <a href="{{< relurl "book/tr/v2/ch00/_git_p4_branches" >}}">Dallandırma</a> konusuna bakın.</p>
</div>
<div class="paragraph">
<p>Bu noktada işiniz neredeyse bitti.
<code>p4import</code> dizinine gidip <code>git log</code> çalıştırırsanız, içe aktarılan çalışmanızı görebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -2
commit e5da1c909e5db3036475419f6379f2c73710c4e6
Author: giles &lt;giles@giles@perforce.com&gt;
Date:   Wed Feb 8 03:13:27 2012 -0800

    Correction to line 355; change &lt;/UL&gt; to &lt;/OL&gt;.

    [git-p4: depot-paths = "//public/jam/src/": change = 8068]

commit aa21359a0a135dda85c50a7f7cf249e4f7b8fd98
Author: kwirth &lt;kwirth@perforce.com&gt;
Date:   Tue Jul 7 01:35:51 2009 -0800

    Fix spelling error on Jam doc page (cummulative -&gt; cumulative).

    [git-p4: depot-paths = "//public/jam/src/": change = 7304]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>git-p4</code> 'ün her katkı mesajında ​​bir tanımlayıcı bıraktığını görebilirsiniz.
Daha sonra Perforce değişiklik numarasına başvurmanız gerekebileceği ihtimaline karşı, bu tanımlayıcıyı orada tutmanızda bir sakınca yoktur.
Ancak tanımlayıcıyı kaldırmak isterseniz (ki yeni repo üzerinde çalışmaya başlamadan önce bunu yapmanın tam zamanıdır),

tanımlayıcı dizeleri topluca kaldırmak için <code>git filter-branch</code> 'ı kullanabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git filter-branch --msg-filter 'sed -e "/^\[git-p4:/d"'
Rewrite e5da1c909e5db3036475419f6379f2c73710c4e6 (125/125)
Ref 'refs/heads/master' was rewritten</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>git log</code> 'u çalıştırırsanız, katkılara ilişkin tüm SHA-1 sağlama toplamlarının değiştiğini, ancak <code>git-p4</code> dizelerinin artık katkı mesajlarında olmadığını görebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -2
commit b17341801ed838d97f7800a54a6f9b95750839b7
Author: giles &lt;giles@giles@perforce.com&gt;
Date:   Wed Feb 8 03:13:27 2012 -0800

    Correction to line 355; change &lt;/UL&gt; to &lt;/OL&gt;.

commit 3e68c2e26cd89cb983eb52c024ecdfba1d6b3fff
Author: kwirth &lt;kwirth@perforce.com&gt;
Date:   Tue Jul 7 01:35:51 2009 -0800

    Fix spelling error on Jam doc page (cummulative -&gt; cumulative).</code></pre>
</div>
</div>
<div class="paragraph">
<p>İçe aktarma işleminiz yeni Git sunucunuza gönderilmeye hazırdır.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_git_tfs">TFS</h3>
<div class="paragraph">
<p>
Takımınız kaynak kontrolünü TFVC’den Git’e dönüştürüyorsa, bunu en yüksek doğrulukta gerçekleştirmek isteyeceksiniz.
Ara işlev bölümünde hem git-tfs’i hem de git-tf’yi ele aldığımızı göz önünde bulundurursak, bu bölümde yalnızca git-tfs’i ele alacağımız anlamına gelir. Çünkü git-tfs dallarını destekler ve bunu git-tf ile yapmak oldukça zordur.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Not</div>
</td>
<td class="content">
<div class="paragraph">
<p>Bu tek yönlü bir dönüşümdür.
Oluşan Git reposu, orijinal TFVC projesi ile bağlantı kuramaz.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>İlk yapmanız gereken şey, kullanıcı adlarını eşlemektir.
TFVC değişiklik setleri için yazar alanına neyin gireceği konusunda oldukça serbesttir, ancak Git okunabilir bir ad ve e-posta adresi ister.
Bu bilgiyi <code>tf</code> komut satırı istemcisinden şöyle alabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-powershell" data-lang="powershell">PS&gt; tf history $/myproject -recursive &gt; AUTHORS_TMP</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu projenin tarihindeki tüm değişiklik setlerini alır ve bunları işleyeceğimiz AUTHORS_TMP dosyasına koyar.
<em>User</em> sütununun (ikinci sütun) verilerini çıkarmak için dosyayı açın ve sütunun hangi karakterlerde başladığını ve bittiğini bulun, ardından aşağıdaki komut satırındaki <code>cut</code> komutunun <code>11-20</code> parametrelerini bulunanlarla değiştirin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-powershell" data-lang="powershell">PS&gt; cat AUTHORS_TMP | cut -b 11-20 | tail -n+3 | sort | uniq &gt; AUTHORS</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>cut</code> komutu her satırdan 11 ile 20 arasındaki karakterleri korur.
<code>tail</code> komutu başlık alanları ve ASCII alt çizgileri olan ilk iki satırı atlar.
Elde edilen sonuç, yinelenenleri ortadan kaldırmak için <code>sort</code> ve <code>uniq</code> e yönlendirilir ve <code>AUTHORS</code> adında bir dosyaya kaydedilir.
Sonraki adım el ile yapılmalıdır, git-tfs’nin bu dosyayı etkin bir şekilde kullanabilmesi için her satır bu formatta olmalıdır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">DOMAIN\username = User Name &lt;email@address.com&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sol taraftaki bölüm TFVC’den gelen "Kullanıcı" (user) alanıdır, eşittir işaretinin sağ tarafındaki bölüm ise Git işlemleri için kullanılacak olan kullanıcı adıdır.</p>
</div>
<div class="paragraph">
<p>Bu dosyayı aldıktan sonra, yapmanız gereken sıradaki şey ilgilendiğiniz TFVC projesinin bir kopyasını yapmaktır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-powershell" data-lang="powershell">PS&gt; git tfs clone --with-branches --authors=AUTHORS https://username.visualstudio.com/DefaultCollection $/project/Trunk project_git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aşağıdaki komut, katkı mesajlarının altındaki <code>git-tfs-id</code> bölümlerini temizleyecektir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-powershell" data-lang="powershell">PS&gt; git filter-branch -f --msg-filter 'sed "s/^git-tfs-id:.*$//g"' '--' --all</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu komut Git-bash ortamındaki <code>sed</code> komutunu kullanarak <code>git-tfs-id:</code> ile başlayan her satırı boş bir metinle değiştirir ve Git’in bu satırları görmezden gelmesini sağlar.</p>
</div>
<div class="paragraph">
<p>Hepsi tamamlandıktan sonra yeni bir uzak repo ekleyebilir, tüm dalları üstakıma itebilir ve ekibinizin Git üzerinden çalışmaya başlamasını sağlayabilirsiniz.</p>
</div>
</div>
<div class="sect3">
<h3 id="_custom_importer">Farklı Bir İçe-Aktarıcı</h3>
<div class="paragraph">
<p>

Eğer sisteminiz yukarıdakilerden biri değilse, çevrimiçi bir içe aktarıcı aramalısınız.
Bir çok farklı sistem için CVS, Clear Case, Visual Source Safe ve hatta dizinler için bir arşiv de içeren kaliteli aktarıcılar mevcuttur.
Eğer bu araçlardan hiçbiri sizin için uygun değilse, daha az bilinen bir araç kullanıyorsanız veya bir şekilde daha özel bir içe aktarma işlemine ihtiyacınız varsa, <code>git fast-import</code> 'u kullanmalısınız.
Bu komut belirli Git verilerini yazmak için stdin’den basit talimatlar okur.
Bu şekilde Git nesneleri oluşturmak, ham Git komutlarını çalıştırmaktan veya ham nesneleri yazmaya çalışmaktan çok daha kolaydır (daha fazla bilgi için <a href="{{< relurl "book/tr/v2/ch00/ch10-git-internals" >}}">Dahili Git Ögeleri</a> bölümüne bakın).
Bu şekilde, içe aktardığınız sistemden gerekli bilgileri okuyup, stdout’a basit talimatlar yazdıracak bir içe aktarma betiği oluşturabilirsiniz.
Ardından, bu programı çalıştırabilir ve çıktısını <code>git fast-import</code> üzerinden akıtarak içe aktarabilirsiniz.</p>
</div>
<div class="paragraph">
<p>Size hızlı bir şekilde öğretmek için, basit bir içe aktarıcı yazdıracağız.
Şimdi, mevcut bir dizinde çalıştığınızı varsayalım. Projenizi zaman zaman dizini zaman damgasıyla işaretlenmiş bir <code>back_YYYY_MM_DD</code> yedek dizinine kopyalayarak yedekliyorsunuz ve bunu Git’e içe aktarmak istiyorsunuz.
Dizin yapınız şöyle görünüyor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ls /opt/import_from
back_2014_01_02
back_2014_01_04
back_2014_01_14
back_2014_02_03
current</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git dizinini içe aktarmak için, Git’in verilerini nasıl depoladığını gözden geçirmeniz gerekir.
Hatırlayacağınız üzere, Git temel olarak, içeriğin pozlarına işaret eden katkı nesnelerinin bir listesinden oluşur.
Yapmanız gereken tek şey, <code>fast-import</code> ile içerik pozlarının ne olduğunu, onlara işaret eden katkı verilerini ve bunların sıralanma düzenini söylemektir.
Stratejiniz pozları tek tek geçerken, her dizinin içeriğini bir önceki katkıyla ilişkilendirekek yeni bir katkı oluşturmaktır.</p>
</div>
<div class="paragraph">
<p><a href="{{< relurl "book/tr/v2/ch00/_an_example_git_enforced_policy" >}}">Bir Örnek: Mecburi Git Politikası</a> bölümünde yaptığımız gibi, genellikle bununla çalıştığımız ve okuması kolay alduğu için kodumuzu Ruby’de yazacağız.
Siz aşina olduğunuz herhangi bir dilde de bunu yazabilirsiniz (yalnızca uygun bilgilerin <code>stdout</code> <em>a yazdırılması gerekmektedir).
Ve eğer Windows’ta çalışıyorsanız, sadece satır sonuna taşıma dönüşlerini (CRLF) koymamaya, özel bir dikkat göstermeniz gerekecektir.
'git fast-import</em> Windows’un kullandığı satır başı satır beslemelerini (CRLF) değil, yalnızca satır beslemelerini (LF) isteme konusunda çok hassasdır.</p>
</div>
<div class="paragraph">
<p>Başlamak için, hedef dizine gidip, her birinin bir katkı olarak içe aktarılmasını istediğiniz her alt dizini tanımlayacaksınız.
Her alt dizine geçip, onu dışa aktarmak için gerekli komutları yazdırırsınız.
Temel ana döngünüz şöyle görünecektir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">last_mark = nil

# loop through the directories
Dir.chdir(ARGV[0]) do
  Dir.glob("*").each do |dir|
    next if File.file?(dir)

    # move into the target directory
    Dir.chdir(dir) do
      last_mark = print_export(dir, last_mark)
    end
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Her dizin içinde <code>print_export</code> 'u çalıştırırsınız: bu önceki anlık görüntünün bildirimini ve işaretini alırarak sıradakinin bildirim ve işaretini döndürür.
Bu şekilde, onları uygun şekilde bağlayabilirsiniz.
<code>Mark</code> katkıya verdiğiniz bir "hızlı-içe-aktarma" tanımıdır: katkı oluşturduğunuzda, her birine başka katkılardan bağlantı kurmak için kullanabileceğiniz bir işaret verirsiniz.
Dolayısıyla, <code>print_export</code> yönteminizde yapmanız gereken ilk şey, dizin adından bir işaret oluşturmaktır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">mark = convert_dir_to_mark(dir)</code></pre>
</div>
</div>
<div class="paragraph">
<p>İşaretin bir tamsayı olması gerektiği için, bunu bir dizin serisi oluşturarak ve işaret olarak indeks değerini kullanarak yapacaksınız.
Yönteminiz şuna benzer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">$marks = []
def convert_dir_to_mark(dir)
  if !$marks.include?(dir)
    $marks &lt;&lt; dir
  end
  ($marks.index(dir) + 1).to_s
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Şimdi katkınız bir tam sayı temsilini aldığına göre, katkı meta verileri için bir tarih gerekmektedir.
Tarih dizinin adında ifade edildiğinden, bunu dışarı çıkarmanız gerekecektir.
<code>print_export</code> dosyanızdaki bir sonraki satır şu şekildedir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">date = convert_dir_to_date(dir)</code></pre>
</div>
</div>
<div class="paragraph">
<p>burada <code>convert_dir_to_date</code> şu şekilde tanımlanır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">def convert_dir_to_date(dir)
  if dir == 'current'
    return Time.now().to_i
  else
    dir = dir.gsub('back_', '')
    (year, month, day) = dir.split('_')
    return Time.local(year, month, day).to_i
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu her dizinin tarihi için bir tamsayı değeri döndürür.
Her katkı için ihtiyacınız olan son meta bilgi parçası, global bir değişkene kodladığınız katkı verileridir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">$author = 'John Doe &lt;john@example.com&gt;'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Artık aktarıcınız için katkı verilerini yazdırmaya başlamaya hazırsınız.
İlk bilgiler, bir katkı nesnesini tanımladığınızı ve bunun hangi dalda olduğunu; ardından, oluşturduğunuz işareti, katkılayanın bilgilerini ve katkı mesajını; ve onun ardından da -varsa- önceki katkıyı belirtir.
Kodunuz şuna benzer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby"># print the import information
puts 'commit refs/heads/master'
puts 'mark :' + mark
puts "committer #{$author} #{date} -0700"
export_data('imported from ' + dir)
puts 'from :' + last_mark if last_mark</code></pre>
</div>
</div>
<div class="paragraph">
<p>Yapması kolay olduğu için saat dilimini (-0700) kodlayın.
Başka bir sistemden içe aktarıyorsanız saat dilimini fark olarak belirtmeniz gerekir.
Katkı mesajı özel bir formatta ifade edilmelidir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>data (size)\n(contents)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Format: kelime verileri, okunacak verinin boyutu, yeni satır ve son olarak verilerden oluşur.
Daha sonra dosya içeriğini belirtmek için aynı biçimi kullanmanız gerektiğinden, <code>export_data</code> adında bir yardımcı yöntem oluşturursunuz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">def export_data(string)
  print "data #{string.size}\n#{string}"
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Geriye kalan tek şey, her poz için dosya içeriğini belirtmektir.
Bunların hepsi tek bir dizinde bulunduğu için bu da kolaydır; <code>deleteall</code> komutunu ve ardından dizindeki her dosyanın içeriğini yazdırabilirsiniz.
Git daha sonra her pozu uygun şekilde kaydedecektir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">puts 'deleteall'
Dir.glob("**/*").each do |file|
  next if !File.file?(file)
  inline_data(file)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Not: Birçok sistem, revizyonlarını bir katkıdan diğerine yapılan değişiklikler olarak düşündüğünden, hızlı içe aktarma, her bir katkıda hangi dosyaların eklendiğini, kaldırıldığını veya değiştirildiğini; ve yeni içeriklerin neler olduğunu belirtmek için komutlar alabilir.
Pozlar arasındaki farkları hesaplayabilir ve yalnızca bu verileri sağlayabilirsiniz, ancak bunu yapmak daha karmaşıktır: Git’e tüm verileri verip, onun çözmesine izin verebilirsiniz.
Eğer bu verileriniz için daha uygunsa, verilerinizi bu şekilde nasıl sağlayacağınıza ilişkin ayrıntılar için <em>hızlı içe aktarma</em> kılavuz sayfasına bakın.</p>
</div>
<div class="paragraph">
<p>Yeni dosya içeriklerini listeleme veya yeni içeriklerle değiştirilmiş bir dosyayı belirtme formatı aşağıdaki gibidir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>M 644 inline path/to/file
data (size)
(file contents)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Burada mod 644’tür (yürütülebilir dosyalarınız varsa, bunun yerine 755’i tespit edip belirtmeniz gerekir) ve satır içinde bu satırın hemen ardından içerikleri listeleyeceğiniz yazmaktadır.
<em>inline_data</em> yönteminiz şuna benzer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">def inline_data(file, code = 'M', mode = '644')
  content = File.read(file)
  puts "#{code} #{mode} inline #{file}"
  export_data(content)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Katkı mesajı verilerinizi belirttiğiniz yöntemle aynı olduğu için daha önce tanımladığınız <code>export_data</code> yöntemini yeniden kullanırsınız.</p>
</div>
<div class="paragraph">
<p>Yapmanız gereken son şey, bir sonraki yinelemeye aktarılabilmesi için mevcut işareti döndürmektir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">return mark</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Not</div>
</td>
<td class="content">
<div class="paragraph">
<p>Windows üzerinde çalışıyorsanız fazladan bir adım eklediğinizden emin olmanız gerekir.
Daha önce de belirtildiği gibi, Windows yeni satır karakterleri için CRLF’yi kullanırken <code>git fast-import</code> yalnızca LF’yi bekler.
Bu sorunu aşmak ve <code>git fast-import</code> 'u mutlu etmek için Ruby’ye CRLF yerine LF kullanmasını söylemeniz gerekir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">$stdout.binmode</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Bu kadar.
İşte senaryonun tamamı:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#!/usr/bin/env ruby

$stdout.binmode
$author = "John Doe &lt;john@example.com&gt;"

$marks = []
def convert_dir_to_mark(dir)
    if !$marks.include?(dir)
        $marks &lt;&lt; dir
    end
    ($marks.index(dir)+1).to_s
end

def convert_dir_to_date(dir)
    if dir == 'current'
        return Time.now().to_i
    else
        dir = dir.gsub('back_', '')
        (year, month, day) = dir.split('_')
        return Time.local(year, month, day).to_i
    end
end

def export_data(string)
    print "data #{string.size}\n#{string}"
end

def inline_data(file, code='M', mode='644')
    content = File.read(file)
    puts "#{code} #{mode} inline #{file}"
    export_data(content)
end

def print_export(dir, last_mark)
    date = convert_dir_to_date(dir)
    mark = convert_dir_to_mark(dir)

    puts 'commit refs/heads/master'
    puts "mark :#{mark}"
    puts "committer #{$author} #{date} -0700"
    export_data("imported from #{dir}")
    puts "from :#{last_mark}" if last_mark

    puts 'deleteall'
    Dir.glob("**/*").each do |file|
        next if !File.file?(file)
        inline_data(file)
    end
    mark
end

# Loop through the directories
last_mark = nil
Dir.chdir(ARGV[0]) do
    Dir.glob("*").each do |dir|
        next if File.file?(dir)

        # move into the target directory
        Dir.chdir(dir) do
            last_mark = print_export(dir, last_mark)
        end
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu betiği çalıştırırsanız şuna benzer bir içerik elde edersiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ruby import.rb /opt/import_from
commit refs/heads/master
mark :1
committer John Doe &lt;john@example.com&gt; 1388649600 -0700
data 29
imported from back_2014_01_02deleteall
M 644 inline README.md
data 28
# Hello

This is my readme.
commit refs/heads/master
mark :2
committer John Doe &lt;john@example.com&gt; 1388822400 -0700
data 29
imported from back_2014_01_04from :1
deleteall
M 644 inline main.rb
data 34
#!/bin/env ruby

puts "Hey there"
M 644 inline README.md
(...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aktarıcıyı çalıştırmak için, içe aktarmak istediğiniz Git dizinindeyken bu çıktıyı <code>git fast-import</code> aracılığıyla aktarın.
Yeni bir dizin oluşturabilir ve ardından başlangıç ​​noktası olarak bu dizin içinde <code>git init</code> 'i çalıştırabilir ve ardından betiğinizi çalıştırabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git init
Initialized empty Git repository in /opt/import_to/.git/
$ ruby import.rb /opt/import_from | git fast-import
git-fast-import statistics:
---------------------------------------------------------------------
Alloc'd objects:       5000
Total objects:           13 (         6 duplicates                  )
      blobs  :            5 (         4 duplicates          3 deltas of          5 attempts)
      trees  :            4 (         1 duplicates          0 deltas of          4 attempts)
      commits:            4 (         1 duplicates          0 deltas of          0 attempts)
      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)
Total branches:           1 (         1 loads     )
      marks:           1024 (         5 unique    )
      atoms:              2
Memory total:          2344 KiB
       pools:          2110 KiB
     objects:           234 KiB
---------------------------------------------------------------------
pack_report: getpagesize()            =       4096
pack_report: core.packedGitWindowSize = 1073741824
pack_report: core.packedGitLimit      = 8589934592
pack_report: pack_used_ctr            =         10
pack_report: pack_mmap_calls          =          5
pack_report: pack_open_windows        =          2 /          2
pack_report: pack_mapped              =       1457 /       1457
---------------------------------------------------------------------</code></pre>
</div>
</div>
<div class="paragraph">
<p>Gördüğünüz gibi, başarıyla tamamlandığında, size neleri başardığına dair bir sürü istatistik veriyor.
Burada, 1 dalda 4 katkı için toplam 13 nesneyi içe aktardınız.
Artık yeni geçmişinizi görmek için <code>git log</code> 'u çalıştırabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -2
commit 3caa046d4aac682a55867132ccdfbe0d3fdee498
Author: John Doe &lt;john@example.com&gt;
Date:   Tue Jul 29 19:39:04 2014 -0700

    imported from current

commit 4afc2b945d0d3c8cd00556fbe2e8224569dc9def
Author: John Doe &lt;john@example.com&gt;
Date:   Mon Feb 3 01:00:00 2014 -0700

    imported from back_2014_02_03</code></pre>
</div>
</div>
<div class="paragraph">
<p>İşte güzel ve temiz bir Git reposu.
Hiçbir şeyin henüz alınmadığını farketmeniz önemlidir (başlangıçta çalışma dizininizde herhangi bir dosya yoktur).
Bunları almak için dalınızı, şu anda <code>master</code> 'ın olduğu yere sıfırlamanız gerekmektedir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ls
$ git reset --hard master
HEAD is now at 3caa046 imported from current
$ ls
README.md main.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>fast-import</code> aracıyla çok daha fazlasını yapabilirsiniz; farklı modları, ikili verileri, birden fazla dallanmayı ve birleştirmeyi, etiketleri, ilerleme göstergelerini ve daha fazlasını yönetebilirsiniz.
Git kaynak kodunun <code>contrib/fast-import</code> dizininde daha karmaşık senaryoların bir dizi örneği mevcuttur.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>