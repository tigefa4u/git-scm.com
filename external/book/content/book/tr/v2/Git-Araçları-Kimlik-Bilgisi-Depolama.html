---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: tr
  chapter:
    title: Git Araçları
    number: 7
  section:
    title: Kimlik Bilgisi Depolama
    number: 14
    cs_number: '7.14'
    previous: book/tr/v2/Git-Araçları-Git-Nesnesini-Değiştirme
    next: book/tr/v2/Git-Araçları-Özet
title: Git - Kimlik Bilgisi Depolama
url: "/book/tr/v2/Git-Araçları-Kimlik-Bilgisi-Depolama.html"
---
<h2 id="_credential_caching">Kimlik Bilgisi Depolama</h2>
<div class="paragraph">
<p>

Eğer uzak sunuculara bağlanmak için SSH taşıyıcısını kullanıyorsanız, şifresiz bir anahtarınız olabilir ve bu da kullanıcı adı ve şifrenizi yazmadan veri aktarmanıza olanak sağlar.
Ancak, HTTP protokolleri için bu mümkün değildir; her bağlantıda bir kullanıcı adı ve şifre gereklidir.
Bu durum, iki faktörlü kimlik doğrulama sistemlerinde daha da zorlaşır, çünkü şifreniz için kullandığınız belirteç rastgele oluşturulmuştur ve okunması zor olabilir.</p>
</div>
<div class="paragraph">
<p>Neyse ki, Git’in bu konuda yardımcı olabilecek bir kimlik bilgisi sistemi vardır.
Git’in heybesinde sakladığı bazı seçenekler şunlardır:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Varsayılan olarak hiçbir şey önbelleğe alınmaz.
Her bağlantı, kullanıcı adınızı ve şifrenizi girmenizi isteyecektir.</p>
</li>
<li>
<p>``cache`` (Önbellek) modu, belirli bir süre boyunca kimlik bilgilerini bellekte tutar.
Hiçbir şifre hiçbir zaman diskte saklanmaz ve bunlar 15 dakika sonra önbellekten silinir.</p>
</li>
<li>
<p>``store`` (Depolama) modu, kimlik bilgilerini düz metin dosyası halinde diskte kaydeder ve bunlar hiçbir zaman zamanaşımına uğramaz.
Bu, git hesabınız için şifrenizi değiştirene kadar kimlik bilgilerinizi bir daha asla girmeniz gerekmeyeceği anlamına gelir.
Bu yaklaşımın dezavantajı, şifrelerinizin açık metin olarak home dizininizde düz bir dosyada saklanmasıdır.</p>
</li>
<li>
<p>Bir Mac kullanıyorsanız, Git ``osxkeychain`` moduyla gelir; bu da kimlik bilgilerini sisteminize bağlı güvenli anahtar zincirinde önbelleğe alır.
Bu yöntem, kimlik bilgilerini diske kaydeder ve bunların süresi hiçbir zaman dolmaz, ancak bunlar HTTPS sertifikalarını ve Safari otomatik doldurmalarını saklayan aynı sistemle şifrelenir.</p>
</li>
<li>
<p>Bir Windows kullanıyorsanız, ``Git Credential Manager for Windows`` adlı bir yardımcı programı yükleyebilirsiniz.
Bu, yukarıda açıklanan ``osxkeychain`` yardımcı programına benzer, ancak hassas bilgileri kontrol etmek için Windows Kimlik Bilgisi Deposunu kullanır.
Onu şu adresten bulabilirsiniz: <a href="https://github.com/Microsoft/Git-Credential-Manager-for-Windows" class="bare">https://github.com/Microsoft/Git-Credential-Manager-for-Windows</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Bu yöntemlerden birini, bir Git yapılandırma değeri belirleyerek seçebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global credential.helper cache</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bazı yardımcı programların çeşitli seçenekleri vardır.
``store`` yardımcısı, <code>--file &lt;dosya_yolu&gt;</code> argümanını alabilir, bu da düz metin dosyasının nerede kaydedileceğini özelleştirir (varsayılan <code>~/.git-credentials</code> dizinidir).
``cache`` yardımcısı, daemon işlemin ne kadar süreyle tutulacağını değiştiren <code>--timeout &lt;saniye&gt;</code> seçeneğini kabul eder (varsayılan ``900 saniye``, veya 15 dakikadır).
İşte ``store`` yardımcısını özel bir dosya adıyla nasıl yapılandıracağınıza dair bir örnek:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global credential.helper 'store --file ~/.my-credentials'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git, birkaç yardımcıyı yapılandırmanıza bile izin verir.
Belirli bir sunucu için kimlik bilgilerini ararken, Git bunları sırayla sorgular ve bir kez cevap verildikten sonra durur.
Kimlik bilgilerini kaydederken, Git kullanıcı adını ve şifreyi liste içindeki <strong>tüm</strong> yardımcılara gönderir ve onlar bunlarla ne yapacaklarına karar verebilirler.</p>
</div>
<div class="paragraph">
<p>Eğer taşınabilir sürücünüzde bir kimlik bilgileri dosyanız varsa, ancak sürücü takılı değilken bazı yazma işlemlerini kaydetmek için bellek içindeki önbelleği kullanmak istiyorsanız, <code>.gitconfig</code> şu şekilde görünecektir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">[credential]
    helper = store --file /mnt/thumbdrive/.git-credentials
    helper = cache --timeout 30000</code></pre>
</div>
</div>
<div class="sect3">
<h3 id="_şapkanın_altı">Şapkanın Altı</h3>
<div class="paragraph">
<p>Peki tüm bunlar nasıl çalışıyor?
Git’in kimlik bilgisi yardımcı sistemine yönelik kök komutu <code>git credential</code> 'dır. Bir komutu argüman olarak ve daha sonra daha fazla veri girişini <code>stdin</code> üzerinden alır.</p>
</div>
<div class="paragraph">
<p>Bir örnek ile bunu anlamak daha kolay olacaktır.
Diyelim ki yapılandırılmış bir kimlik bilgisi yardımcısı, <code>mygithost</code> için kimlik bilgilerini saklamış olsun.
İşte, Git’in bir sunucu için kimlik bilgilerini bulmaya çalışırken çağrılan ``fill`` komutunu kullanan bir oturum:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git credential fill <b class="conum">(1)</b>
protocol=https <b class="conum">(2)</b>
host=mygithost
<b class="conum">(3)</b>
protocol=https <b class="conum">(4)</b>
host=mygithost
username=bob
password=s3cre7
$ git credential fill <b class="conum">(5)</b>
protocol=https
host=unknownhost

Username for 'https://unknownhost': bob
Password for 'https://bob@unknownhost':
protocol=https
host=unknownhost
username=bob
password=s3cre7</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Bu etkileşimi başlatan komut satırıdır.</p>
</li>
<li>
<p>Ardından, Git-credential stdin üzerinden giriş bekler.
Bildiklerimizi giriyoruz: protokol ve sunucu adı.</p>
</li>
<li>
<p>Boş bir satır, girişin tamamlandığını ve kimlik bilgisi sisteminin ne bildiğini yanıtlaması gerektiğini gösterir.</p>
</li>
<li>
<p>Daha sonra, Git-credential işi devralır ve bulduğu bilgileri stdout ile yazar.</p>
</li>
<li>
<p>Kimlik bilgileri bulunamazsa; Git kullanıcıya kullanıcı adını ve şifreyi sorup, bunları başlatan stdout’a sağlar (burada aynı konsola bağlanmışlardır).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Kimlik bilgisi sistemi aslında Git’ten ayrı bir programı çağırır. Hangi programın çağrıldığı ve nasıl olduğu, <code>credential.helper</code> yapılandırma değerine bağlıdır.
Bu, birkaç farklı biçimde olabilir:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Yapılandırma Değeri</th>
<th class="tableblock halign-left valign-top">Davranış</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>foo</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>git-credential-foo</code> çalışır</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>foo -a --opt=bcd</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>git-credential-foo -a --opt=bcd</code> çalışır</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/absolute/path/foo -xyz</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/absolute/path/foo -xyz</code> çalışır</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>!f() { echo "password=s3cre7"; }; f</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>!</code> sonrasındaki kod kabukta (shell) değerlendirilir</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Yukarıda tanımlanan yardımcılar aslında <code>git-credential-cache</code>, <code>git-credential-store</code>, vb. şeklinde adlandırılmıştır ve onları komut satırı argümanları alacak şekilde yapılandırabiliriz.
Bunun genel formu ``git-credential-foo [args] &lt;eylem&gt;.`` şeklindedir.
Stdin/stdout protokolü git-credential ile aynıdır, ancak biraz farklı bir eylem kümesi kullanırlar:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>get</code>: Kullanıcı adı/şifre isteği.</p>
</li>
<li>
<p><code>store</code>: Bu yardımcının belleğine, bir kimlik bilgisi kümesini kaydetme isteği.</p>
</li>
<li>
<p><code>erase</code>: Belirtilen özelliklere sahip kimlik bilgilerini, bu yardımcının belleğinden silme işlemi.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>store</code> ve <code>erase</code> eylemleri için yanıt gerekli değildir (zaten Git tarafından görmezden gelinir).
Ancak Git, <code>get</code> eylemi için yardımcının ne söylediğini çok önemser.
Yardımcı işe yarar bir şey bilmiyorsa, herhangi bir çıktı olmadan doğrudan çıkış yapabilir; ancak biliyorsa, sağlanan bilgiyi depoladığı bilgilerle genişletmesi gerekir.
Çıktı, bir dizi atama ifadesi gibi işlenir; sağlanan her bir şey, Git’in zaten bildiği şeyi değiştirecektir.</p>
</div>
<div class="paragraph">
<p>İşte yukarıdaki örneğin, git-credential’ı atlayarak doğrudan git-credential-store’a geçen bir şekli:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git credential-store --file ~/git.store store <b class="conum">(1)</b>
protocol=https
host=mygithost
username=bob
password=s3cre7
$ git credential-store --file ~/git.store get <b class="conum">(2)</b>
protocol=https
host=mygithost

username=bob <b class="conum">(3)</b>
password=s3cre7</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Burada <code>git-credential-store</code> 'a bazı kimlik bilgilerini kaydetmesini söylüyoruz: <code>https://mygithost</code> erişildiğinde kullanıcı adı olarak ``bob`` ve şifre olarak ``s3cre7`` kullanılacaktır.</p>
</li>
<li>
<p>Şimdi bu kimlik bilgilerini alacağız.
Zaten bildiğimiz bağlantının parçalarını sağlıyoruz (<code>https://mygithost</code>) ve bir boş satır ekliyoruz.</p>
</li>
<li>
<p><code>git-credential-store</code>, yukarıda sakladığımız kullanıcı adı ve şifre ile yanıt verir.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>İşte <code>~/git.store</code> dosyasının içeriği:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">https://bob:s3cre7@mygithost</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu sadece kimlik bilgisiyle bezenmiş URL’lerini içeren bir dizi satırdır.
<code>osxkeychain</code> ve <code>wincred</code> yardımcıları, destek depolarının doğal formatını kullanırken, <code>cache</code> kendi bellek içi formatını kullanır (ki bu diğer hiçbir süreç tarafından okunamaz).</p>
</div>
</div>
<div class="sect3">
<h3 id="_a_custom_credential_cache">A Custom Credential Cache</h3>
<div class="paragraph">
<p><code>git-credential-store</code> ve benzerleri, Git’ten bağımsız ayrı programlardır, bu nedenle <em>herhangi bir</em> programın bir Git kimlik bilgisi yardımcısı olabileceğini anlamak pek de zor değildir.
Git’in sağladığı yardımcılar birçok yaygın kullanım durumunu kapsar, ancak hepsini değil.
Örneğin, diyelim ki ekibinizin, belki de dağıtım için, tüm ekiple paylaşılan bazı kimlik bilgileri var.
Bu kimlik bilgileri, paylaşılan bir dizinde saklanır, ancak sık sık değiştiği için bunları kendi kimlik bilgisi deposuna kopyalamak istemezsiniz.
Mevcut yardımcıların hiçbiri bu durumu kapsamaz. Şimdi kendimiz bir tane yazmak istersek ne gerektiğini görelim.
Bu programın sahip olması gereken birkaç temel özellik bulunmaktadır:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Dikkat etmemiz gereken tek işlem <code>get</code> işlemidir: <code>store</code> ve <code>erase</code> yazma işlemleri olduğu için, bunları aldığımızda sadece temiz bir şekilde çıkış yaparız.</p>
</li>
<li>
<p>Paylaşılan kimlik bilgisi dosyasının dosya biçimi, <code>git-credential-store</code> tarafından kullanılan dosya biçimi ile aynıdır.</p>
</li>
<li>
<p>Dosyanın yeri oldukça standarttır, ancak her ihtimale karşı kullanıcının özel bir dizin geçmesine izin vermeliyiz.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Bu uzantıyı yine Ruby’de yazacağız, ancak Git, bitmiş kodu çalıştırabileceği sürece herhangi bir dil de işe yarayacaktır.
İşte yeni kimlik bilgisi yardımcımızın tam kaynak kodu:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#!/usr/bin/env ruby

require 'optparse'

path = File.expand_path '~/.git-credentials' # <b class="conum">(1)</b>
OptionParser.new do |opts|
    opts.banner = 'USAGE: git-credential-read-only [options] &lt;action&gt;'
    opts.on('-f', '--file PATH', 'Specify path for backing store') do |argpath|
        path = File.expand_path argpath
    end
end.parse!

exit(0) unless ARGV[0].downcase == 'get' # <b class="conum">(2)</b>
exit(0) unless File.exists? path

known = {} # <b class="conum">(3)</b>
while line = STDIN.gets
    break if line.strip == ''
    k,v = line.strip.split '=', 2
    known[k] = v
end

File.readlines(path).each do |fileline| # <b class="conum">(4)</b>
    prot,user,pass,host = fileline.scan(/^(.*?):\/\/(.*?):(.*?)@(.*)$/).first
    if prot == known['protocol'] and host == known['host'] and user == known['username'] then
        puts "protocol=#{prot}"
        puts "host=#{host}"
        puts "username=#{user}"
        puts "password=#{pass}"
        exit(0)
    end
end</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Burada komut satırı seçeneklerini ayrıştırıyoruz ve kullanıcının giriş dosyasını belirtmesine izin veriyoruz.
Varsayılan <code>~/.git-credentials</code>'dır.</p>
</li>
<li>
<p>Bu program, sadece eylem <code>get</code> ise ve destek dosyası mevcutsa yanıt verir.</p>
</li>
<li>
<p>Bu döngü, ilk boş satıra ulaşılıncaya kadar stdin’den okur.
Girişler daha sonra başvurmak üzere <code>known</code> hash’inde saklanır.</p>
</li>
<li>
<p>Bu döngü, depolama dosyasının içeriğini okur ve eşleşmeleri arar.
<code>known</code>'dan gelen protokol ve sunucu bu satırla eşleşiyorsa, program sonuçları stdout’a yazdırır ve çıkar.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Yardımcımızı <code>git-credential-read-only</code> olarak kaydedeceğiz, bunu <code>PATH</code> içinde bir yere koyacağız ve çalıştırılabilir olarak işaretleyeceğiz.
İşte etkileşimli bir oturumun nasıl göründüğü:</p>
</div>
<div class="paragraph">
<p>We’ll save our helper as <code>git-credential-read-only</code>, put it somewhere in our <code>PATH</code> and mark it executable.
Here’s what an interactive session looks like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git credential-read-only --file=/mnt/shared/creds get
protocol=https
host=mygithost

protocol=https
host=mygithost
username=bob
password=s3cre7</code></pre>
</div>
</div>
<div class="paragraph">
<p>Adı "git-" ile başladığından, yapılandırma değeri için basit sözdizimini kullanabiliriz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global credential.helper 'read-only --file /mnt/shared/creds'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Gördüğünüz gibi, bu sistemi genişletmek oldukça basit ve sizin ve ekibinizin bazı yaygın sorunlarını çözebilir.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>