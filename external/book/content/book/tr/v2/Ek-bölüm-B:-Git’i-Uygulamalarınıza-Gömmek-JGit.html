---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: tr
  chapter:
    title: 'Ek bölüm B: Git’i Uygulamalarınıza Gömmek'
    number: 2
  section:
    title: JGit
    number: 3
    cs_number: A2.3
    previous: book/tr/v2/Ek-bölüm-B:-Git’i-Uygulamalarınıza-Gömmek-Libgit2
    next: book/tr/v2/Ek-bölüm-B:-Git’i-Uygulamalarınıza-Gömmek-go-git
title: Git - JGit
url: "/book/tr/v2/Ek-bölüm-B:-Git’i-Uygulamalarınıza-Gömmek-JGit.html"
---
<h2 id="_jgit">JGit</h2>
<div class="paragraph">
<p>
Git’i bir Java programından kullanmak istiyorsanız, JGIT adlı tam özellikli bir GIT kütüphanesi bulunmaktadır.
JGIT Java’da yerel olarak yazılmış, GIT’in nispeten tam özellikli bir uygulamasıdır ve Java topluluğunda yaygın olarak kullanılmaktadır.
JGIT projesi Eclipse şemsiyesi altındadır <a href="https://www.eclipse.org/jgit/" class="bare">https://www.eclipse.org/jgit/</a> adresinde bulunabilir.</p>
</div>
<div class="sect3">
<h3 id="_kurulum_7">Kurulum</h3>
<div class="paragraph">
<p>Projenizi JGit’e bağlamanın ve kod yazmaya başlamanın çeşitli yolları vardır.
Muhtemelen en kolayı Maven’i kullanmaktır; aşağıdaki kod parçacığını pom.xml dosyanızdaki &lt;dependencies&gt;` (bağımlılıklar) etiketine ekleyerek entegrasyonu gerçekleştirebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.eclipse.jgit&lt;/groupId&gt;
    &lt;artifactId&gt;org.eclipse.jgit&lt;/artifactId&gt;
    &lt;version&gt;3.5.0.201409260305-r&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Siz bunu okuduğunuzda <code>sürüm</code> büyük olasılıkla ilerlemiş olacaktır; Güncellenmiş repo bilgileri için <a href="https://mvnrepository.com/artifact/org.eclipse.jgit/org.eclipse.jgit" class="bare">https://mvnrepository.com/artifact/org.eclipse.jgit/org.eclipse.jgit</a> adresini kontrol edin.
Bu adım tamamlandığında Maven, ihtiyaç duyacağınız JGit kitaplıklarını otomatik olarak alacak ve kullanacaktır.</p>
</div>
<div class="paragraph">
<p>İkilik bağımlılıkları kendiniz yönetmeyi tercih ederseniz, önceden oluşturulmuş JGit ikilik dosyalarına <a href="https://www.eclipse.org/jgit/download" class="bare">https://www.eclipse.org/jgit/download</a> adresinden ulaşabilirsiniz.
Aşağıdaki gibi bir komut çalıştırarak bunları projenize dahil edebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">javac -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App.java
java -cp .:org.eclipse.jgit-3.5.0.201409260305-r.jar App</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_tesisat_plumbing">Tesisat (Plumbing)</h3>
<div class="paragraph">
<p>JGit’in iki temel API seviyesi vardır: tesisat ve döşeme.
Bunların terminolojisi Git’in kendisinden gelir ve JGit aşağı yukarı aynı türden alanlara bölünmüştür: döşeme API’leri, ortak kullanıcı düzeyindeki eylemler (normal bir kullanıcının Git komut satırını kullanacağı türden şeyler) için kullanıcı dostu bir ön yüzdür, tesisat API’leri ise düşük seviyeli repo nesneleriyle doğrudan etkileşim kurmak içindir.</p>
</div>
<div class="paragraph">
<p>Çoğu JGit oturumunun başlangıç ​​noktası <code>Repository</code> sınıfıdır ve yapmak isteyeceğiniz ilk şey onun bir örneğini oluşturmaktır.
Dosya sistemi tabanlı bir repo için (evet, JGit diğer depolama modellerine izin verir), bu <code>FileRepositoryBuilder</code> kullanılarak gerçekleştirilir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Create a new repository
Repository newlyCreatedRepo = FileRepositoryBuilder.create(
    new File("/tmp/new_repo/.git"));
newlyCreatedRepo.create();

// Open an existing repository
Repository existingRepo = new FileRepositoryBuilder()
    .setGitDir(new File("my_repo/.git"))
    .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Oluşturucu, programınızın tam olarak nerede bulunduğunu bilse de bilmese de, bir Git reposu bulmak için ihtiyaç duyduğu her şeyi sağlayan akıcı bir API’ye sahiptir.
Ortam değişkenlerini (<code>.readEnvironment()</code>) kullanabilir, çalışma dizinindeki bir yerden başlayıp, arama yapabilir (<code>.setWorkTree(…).findGitDir()</code>) veya yukarıdaki gibi bilinen bir <code>.git</code> dizinini açabilir.</p>
</div>
<div class="paragraph">
<p>Bir <code>Repository</code> örneğine sahip olduğunuzda, onunla her türlü şeyi yapabilirsiniz.
İşte hızlı bir örnekleme:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Get a reference
Ref master = repo.getRef("master");

// Get the object the reference points to
ObjectId masterTip = master.getObjectId();

// Rev-parse
ObjectId obj = repo.resolve("HEAD^{tree}");

// Load raw object contents
ObjectLoader loader = repo.open(masterTip);
loader.copyTo(System.out);

// Create a branch
RefUpdate createBranch1 = repo.updateRef("refs/heads/branch1");
createBranch1.setNewObjectId(masterTip);
createBranch1.update();

// Delete a branch
RefUpdate deleteBranch1 = repo.updateRef("refs/heads/branch1");
deleteBranch1.setForceUpdate(true);
deleteBranch1.delete();

// Config
Config cfg = repo.getConfig();
String name = cfg.getString("user", null, "name");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Burada pek çok şey gerçekleştiği için her seferinde bir bölüm üzerinden geçelim.</p>
</div>
<div class="paragraph">
<p>İlk satır <code>master</code> referansa bir işaretçi alır.
JGit <code>refs/heads/master</code> konumunda bulunan <em>gerçek</em> <code>master</code> referansını otomatik olarak alır ve referans hakkında bilgi almanıza olanak tanıyan bir nesne döndürür.
Adı (<code>.getName()</code>) ve doğrudan referansın hedef nesnesini (<code>.getObjectId()</code>) ya da sembolik bir referansla gösterilen referansı (<code>.getTarget()</code>) alabilirsiniz.
Ref nesneleri ayrıca etiket referanslarını ve nesnelerini temsil etmek için de kullanılır; bu nedenle, etiketin (potansiyel olarak uzun) bir etiket nesneleri dizisinin son hedefini işaret ettiği anlamına gelen <code>peeled</code> (soyulmuş) olup olmadığını sorabilirsiniz.</p>
</div>
<div class="paragraph">
<p>İkinci satır, ObjectId örneği olarak döndürülen <code>master</code> referansının hedefini alır.
ObjectId Git’in nesne veritabanında bulunabilen veya bulunmayan bir nesnenin SHA-1 karmasını temsil eder.
Üçüncü satır benzerdir ancak JGit’in ters ayrıştırma sözdizimini nasıl işlediğini gösterir (bununla ilgili daha fazla bilgi için bkz. <a href="{{< relurl "book/tr/v2/ch00/_branch_references" >}}">Dal Referansları</a>).
Git’in anladığı herhangi bir nesne belirtecini iletebilirsiniz ve JGit o nesne için geçerli bir ObjectId veya <code>null</code> döndürecektir.</p>
</div>
<div class="paragraph">
<p>Sonraki iki satır, bir nesnenin ham içeriğinin nasıl yükleneceğini gösterir.
Bu örnekte, nesnenin içeriğini doğrudan stdout’a aktarmak için <code>ObjectLoader.copyTo()'yu çağırıyoruz, ancak ObjectLoader'ın ayrıca bir nesnenin türünü ve boyutunu okumak ve onu bir bayt dizisi olarak döndürmek için de yöntemleri vardır.
Büyük nesneler için (burada `.isLarge()</code>, <code>true</code> değerini döndürür), ham nesne verilerini hepsini aynı anda belleğe çekmeden okuyabilen OutputStream benzeri bir nesne elde etmek için <code>.openStream()</code> çağrısını yapabilirsiniz.</p>
</div>
<div class="paragraph">
<p>Sonraki birkaç satır yeni bir dal oluşturmak için ne gerektiğini gösteriyor.
Bir RefUpdate örneği oluşturuyoruz, bazı parametreleri yapılandırıyoruz ve değişikliği tetiklemek için <code>.update()</code> çağrısını yapıyoruz.
Doğrudan bunu takip eden kod aynı dalı silmek için kullanılır.
Bunun çalışması için <code>.setForceUpdate(true)`nin gerekli olduğunu unutmayın; aksi takdirde `.delete()</code> çağrısı <code>REJECTED</code> sonucunu döndürecek ve hiçbir şey olmayacaktır.</p>
</div>
<div class="paragraph">
<p>Son örnek, Git yapılandırma dosyalarından <code>user.name</code> değerinin nasıl alınacağını gösterir.
Bu Config örneği, yerel yapılandırma için daha önce açtığımız repoyu kullanır, ancak genel ve sistem yapılandırma dosyalarını otomatik olarak algılayacak ve onlardan değerleri okuyacaktır.</p>
</div>
<div class="paragraph">
<p>Bu, tam tesisat API’sinin yalnızca küçük bir örneğidir (daha birçok yöntem ve sınıf mevcuttur).
Ayrıca burada JGit’in istisnaları kullanarak hataları nasıl ele aldığı gösterilmemiştir.
JGit API’leri bazen standart Java istisnaları (<code>IOException</code> gibi) atar, ancak aynı zamanda JGit’e özgü sağlanan bir dizi istisna türü de vardır (<code>NoRemoteRepositoryException</code>, <code>CorruptObjectException</code>, ve <code>NoMergeBaseException</code> gibi).</p>
</div>
</div>
<div class="sect3">
<h3 id="_döşeme_porcelain">Döşeme (Porcelain)</h3>
<div class="paragraph">
<p>Tesisat API’leri oldukça eksiksizdir ancak dizine bir dosya eklemek veya yeni bir katkıda bulunmak gibi ortak hedeflere ulaşmak için bunları bir araya getirmek zahmetli olabilir.
JGit bu konuda yardımcı olmak için daha üst düzeyde bir API seti sağlar ve bu API’lerin giriş noktası <code>Git</code> sınıfıdır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Repository repo;
// construct repo...
Git git = new Git(repo);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git sınıfı, oldukça karmaşık bazı davranışlar oluşturmak için kullanılabilecek <em>builder</em> tarzı, bir dizi üst düzey yönteme sahiptir.
<code>git ls-remote</code> gibi bir şey yaparak şu örneğe bakalım:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">CredentialsProvider cp = new UsernamePasswordCredentialsProvider("username", "p4ssw0rd");
Collection&lt;Ref&gt; remoteRefs = git.lsRemote()
    .setCredentialsProvider(cp)
    .setRemote("origin")
    .setTags(true)
    .setHeads(false)
    .call();
for (Ref ref : remoteRefs) {
    System.out.println(ref.getName() + " -&gt; " + ref.getObjectId().name());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu Git sınıfında ortak bir kalıptır; metodlar, parametreleri ayarlamak için metod çağrılarını zincirlemenize izin veren bir komut nesnesi döndürür. Bunlar <code>.call()</code> çağrısı yaptığınızda yürütülür.
Bu durumda, <code>origin</code> uzaktan reposundan etiketler istiyoruz, ancak uçları (HEAD) istemiyoruz.
Ayrıca kimlik doğrulama için <code>CredentialsProvider</code> nesnesinin kullanıldığına da dikkat edin.</p>
</div>
<div class="paragraph">
<p>Git sınıfı aracılığıyla; <code>add</code>, <code>blame</code>, <code>commit</code>, <code>clean</code>, <code>push</code>, <code>rebase</code>, <code>revert</code>, <code>reset</code> ve daha birçok başka komut mevcuttur.</p>
</div>
</div>
<div class="sect3">
<h3 id="_i̇leri_okumalar_2">İleri Okumalar</h3>
<div class="paragraph">
<p>Bu JGit’in tüm parçalarının sadece küçük bir örneklemesidir.
Eğer daha fazla bilgi edinmek istiyorsanız, daha fazla bilgi ve ilham alabileceğiniz yerleri burada bulabilirsiniz:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Resmi JGit API kılavuzlarını <a href="https://www.eclipse.org/jgit/documentation" class="bare">https://www.eclipse.org/jgit/documentation</a> adresinde bulabilirsiniz.
Bunlar standart Javadoc’tur, dolayısıyla favori JVM IDE’niz bunları yerel olarak da yükleyebilecektir.</p>
</li>
<li>
<p><a href="https://github.com/centic9/jgit-cookbook" class="bare">https://github.com/centic9/jgit-cookbook</a> adresindeki JGit Kullanım Kitabı, JGit ile belirli görevlerin nasıl yapılacağına dair birçok örnek içerir.</p>
</li>
</ul>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>