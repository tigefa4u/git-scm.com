---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: tr
  chapter:
    title: Dağıtık Git
    number: 5
  section:
    title: Bir Projeyi Yürütme
    number: 3
    cs_number: '5.3'
    previous: book/tr/v2/Dağıtık-Git-Projenin-Gelişiminde-Rol-Almak
    next: book/tr/v2/Dağıtık-Git-Özet
title: Git - Bir Projeyi Yürütme
url: "/book/tr/v2/Dağıtık-Git-Bir-Projeyi-Yürütme.html"
---
<h2 id="_bir_projeyi_yürütme">Bir Projeyi Yürütme</h2>
<div class="paragraph">
<p>
Projeye katkı sağlamanın yanı sıra genellikle bilmeniz gereken bir diğer beceri de Bir projeyi etkili bir şekilde yürütmektir.
Bu  <code>format-patch</code> ile oluşturulan ve size e-posta yoluyla gönderilen yamaları kabul etmek ve uygulamak veya eklediğiniz uzak dallardaki değişiklikleri projenize birleştirmekten oluşabilir.
İster klasik bir repoyu yürütüyor olun, ister yamaları doğrulayarak veya onaylayarak projeye yardımcı olun; diğer katkıda bulunanlar için en açık ve sizin için uzun vadede en sürdürülebilir kabul yöntemini bilmeniz gerekir.</p>
</div>
<div class="sect3">
<h3 id="_tematik_dallarda_çalışma">Tematik Dallarda Çalışma</h3>
<div class="paragraph">
<p>
Yeni bir çalışmayı birleştirmeyi düşündüğünüzde, sırf bunu denemek için geçici bir <em>tematik dal</em> oluşturmak iyi bir fikirdir.
Bu şekilde, bir yamanın detaylarını bireysel olarak ayarlamak ve işe yaramıyorsa daha sonra geri dönmek üzere bir kenara ayırmak için zamanınız olur.
Denemeyi yapacağınız işin konusuna dayanan basit ve açıklayıcı bir dal adı oluşturursanız (ör. <code>ruby_client</code> vb); bir süre terk edip daha sonra geri dönmek zorunda kalırsanız, kolaylıkla hatırlayabilirsiniz.</p>
</div>
<div class="paragraph">
<p>Git projesinin yürütücüsü de genellikle bu dalları isimlendirir (ör. <code>sc/ruby_client</code>. Surada <code>sc</code> çalışmayı ekleyen kişinin kısaltmasıdır).
Hatırlayacağınız gibi, bunu <code>master</code> dalınızdan şu şekilde oluşturabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch sc/ruby_client master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Veya doğrudan o dala geçmek istiyorsanız, <code>checkout -b</code> seçeneğini kullanabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b sc/ruby_client master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Şimdi aldığınız çalışmayı bu tematik dala eklemeye hazırsınız ve onu daha uzun vadeli dallarınıza birleştirip birleştirmeyeceğinize karar verebilirsiniz.</p>
</div>
</div>
<div class="sect3">
<h3 id="_patches_from_email">E-Postadan gelen Yamaları Uygulamak</h3>
<div class="paragraph">
<p>
E-posta yoluyla alınan bir yamayı projenize birleştirmeniz gerekiyorsa, yamayı test etmek için tematik dalınıza uygulamanız gerekir.
E-postayla gönderilen bir yamayı uygulamanın iki yolu vardır: <code>git apply</code> ve <code>git am</code>.</p>
</div>
<div class="sect4">
<h4 id="_bir_yamayı_apply_ile_uygulamak">Bir Yamayı <code>apply</code> ile Uygulamak</h4>
<div class="paragraph">
<p>
Eğer birisi yamayı <code>git diff</code> veya Unix’un <code>diff</code> komutunun bir türevi ile oluşturduysa (ki bir sonraki bölümde göreceğiniz üzere bu önerilmez), yamayı <code>git apply</code> komutu ile uygulayabilirsiniz.
Yamayı <code>/tmp/patch-ruby-client.patch</code> dosyasına kaydettiğinizi farzedersek, şu şekilde uygulayabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git apply /tmp/patch-ruby-client.patch</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu, çalışma dizininizdeki dosyaları değiştirir.
Bir yama uygulamak için <code>patch -p1</code> komutunu çalıştırmakla neredeyse aynıdır; ancak daha paranoiddir ve patch’e göre daha az belirsiz eşleşme (fuzzy match) kabul eder.
Ayrıca, <code>git diff</code> formatında açıklanmış dosya ekleme, silme ve yeniden adlandırma işlemlerini, <code>patch</code> 'in yapmayacağı şekilde ele alır.
Son olarak, <code>git apply</code> uygulamanızda "tümünü uygula" veya "hiçbirini uygulama" kararını vermeniz gereken bir modelidir: <code>patch</code> ise yamaları kısmen uygulayabilir ve çalışma dizenizi tuhaf bir durumda bırakabilir.
<code>git apply</code> genel olarak <code>patch</code> 'den çok daha katı davranır.
Size bir katkı kaydı oluşturmaz: çalıştırdıktan sonra, değişiklikleri elle aşamalandırmanız ve katkı işlemeniz gerekir.</p>
</div>
<div class="paragraph">
<p><code>git apply</code> komutunu, bir yamayı gerçekten uygulamadan önce, düzgün bir şekilde uygulanıp uygulanamayacağını kontrol etmek için de kullanabilirsiniz.
Bunun için <code>git apply --check</code> komutu yamayla birlikte çalıştırabilirsiniz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git apply --check 0001-seeing-if-this-helps-the-gem.patch
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply</code></pre>
</div>
</div>
<div class="paragraph">
<p>Eğer çıktı yoksa, yama temiz bir şekilde uygulanabilir demektir.
Bu komut ayrıca, kontrolün başarısız olduğu durumlarda da sonucu sıfır olmayan bir durumla (non-zero status) çıkar, bu nedenle isterseniz bu komutu betiklerde de kullanabilirsiniz.</p>
</div>
</div>
<div class="sect4">
<h4 id="_git_am">
<code>git am</code> Komutuyla Yama Uygulama</h4>
<div class="paragraph">
<p>
Eğer geliştirici yamasını oluşturmak için <code>format-patch</code> komutunu kullanacak tecrübede bir Git kullanıcısıysa; yama yazar bilgisi ve bir katkı mesajı da içereceği için, işiniz daha kolay olur.
Mümkünse, geliştiricilerinizi yamalarını oluşturmak için <code>diff</code> yerine <code>format-patch</code> kullanmaları yönünde teşvik edin.
Yalnızca eski yamalar (legacy patch) ve benzeri durumlar için <code>git apply</code> kullanmanız gerekir.</p>
</div>
<div class="paragraph">
<p><code>format-patch</code> ile oluşturulan bir yamayı uygulamak için <code>git am</code> ("bir posta kutusundan bir dizi yamayı uygulamak" için bu komut kullanıldığından <code>am</code> olarak adlandırılır) kullanılır.
<code>git am</code> komutu teknik olarak, bir veya daha fazla e-posta mesajını tek bir metin dosyasında depolamak için oluşturulan basit bir düz-metin biçimi olan "mbox" dosyasını okumak amacıyla oluşturulmuştur.
Ve şuna benzer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith &lt;jessica@example.com&gt;
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu, önceki bölümde gördüğünüz <code>git format-patch</code> komutunun çıktısının başlangıcıdır; aynı zamanda geçerli bir mbox e-posta biçimini temsil eder.
Eğer biri size yamayı <code>git send-email</code> komutunu kullanarak düzgün şekilde e-posta ile gönderdiyse; ve siz de bunu mbox biçiminde indirir ve <code>git am</code> 'i o mbox dosyasına işaret edecek şekilde ayarlarsanız; gördüğü tüm yamaları uygulamaya başlayacaktır.
Eğer bir mbox formatında birkaç e-postayı kaydedebilen bir posta istemcisi çalıştırıyorsanız, tüm yama serilerini bir dosyaya kaydedip, bunların hepsini tek seferde uygulamak için <code>git am</code> 'i kullanabilirsiniz.</p>
</div>
<div class="paragraph">
<p>Ancak, birisi <code>git format-patch</code> kullanarak oluşturulan bir yama dosyasını bir bilet sistemi veya benzer bir yere yüklediyse; bu dosyayı yerel olarak kaydedip, ardından diskte kaydedilen bu dosyayı uygulamak için <code>git am</code> 'e iletebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git am 0001-limit-log-function.patch
Applying: add limit to log function</code></pre>
</div>
</div>
<div class="paragraph">
<p>Gördüğünüz gibi, temiz bir şekilde uygulandı ve otomatik olarak yeni bir katkı oluşturuldu.
Yazar bilgileri, e-postanın <code>From</code> (gönderici) ve <code>Date</code> (tarih) başlıklarından; katkı mesajı, e-postanın <code>Subject</code> (konu) ve yamadan önceki gövde kısmından alınır.
Örneğin, yukarıdaki mbox örneğinden uyarlanan bir yama için oluşturulan katkı şöyle görünecektir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --pretty=fuller -1
commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
Author:     Jessica Smith &lt;jessica@example.com&gt;
AuthorDate: Sun Apr 6 10:17:23 2008 -0700
Commit:     Scott Chacon &lt;schacon@gmail.com&gt;
CommitDate: Thu Apr 9 09:19:06 2009 -0700

   add limit to log function

   Limit log functionality to the first 20</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Commit</code> (katkı) bilgileri yamayı uygulayan kişiyi ve uygulanma zamanını gösterir.
<code>Author</code> (yazar) bilgileri ise özgün yamayı oluşturan kişiyi ve ne zaman oluşturduğunu gösterir.</p>
</div>
<div class="paragraph">
<p>Ama yamanın temiz bir şekilde uygulanamaması ihtimal dahilindedir.
Belki ana dalınız, yamanın oluşturulduğu daldan çok uzaklaşmıştır veya yama henüz uygulamadığınız başka bir yamaya bağlıdır.
Bu durumda, <code>git am</code> işlemi başarısız olacak ve ne yapmak istediğinizi size soracaktır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git am 0001-seeing-if-this-helps-the-gem.patch
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Patch failed at 0001.
When you have resolved this problem run "git am --resolved".
If you would prefer to skip this patch, instead run "git am --skip".
To restore the original branch and stop patching run "git am --abort".</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu komut, sorun yaşadığı dosyalara "çatışan birleştirme" veya "yeniden temelleme işlemi" gibi çatışma işaretçileri koyar.
Bu sorunu çözmenin yolu neredeyse aynıdır: dosyayı çatışmayı çözecek şekilde düzenleyin, yeni dosyayı hazırlayın ve ardından bir sonraki yamaya devam etmek için <code>git am --resolved</code> komutunu çalıştırın:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ (fix the file)
$ git add ticgit.gemspec
$ git am --resolved
Applying: seeing if this helps the gem</code></pre>
</div>
</div>
<div class="paragraph">
<p>Eğer Git’in çatışmayı biraz daha akıllıca çözmesini istiyorsanız <code>-3</code> seçeneğini kullanarak, Git’in üç yollu bir birleştirme yapmayı denemesini sağlarsınız.
Yama üzerindeki işlenecek olan katkı, sizin reposunuzda bulunmuyorsa çalışmayacağı için, bu seçenek varsayılan olarak etkinleştirilmemiştir.
Eğer o katkı sizin reposunuzda mevcutsa (eğer yama bir halka açık katkıya dayanıyorsa), o zaman <code>-3</code> seçeneği genellikle bir çatışmalı yamanın uygulanması konusunda daha akıllıdır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git am -3 0001-seeing-if-this-helps-the-gem.patch
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
No changes -- Patch already applied.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Yukarıdaki durumda <code>-3</code> seçeneği olmasaydı, yama bir çatışma olarak kabul edilirdi.
<code>-3</code> seçeneği kullanıldığı için temiz bir şekilde uygulandı.</p>
</div>
<div class="paragraph">
<p>Eğer bir mbox’tan bir dizi yama uyguluyorsanız; her bulduğu yamada durup, onu uygulamak isteyip istemediğinizi soran, etkileşimli <code>am</code> komutunu da çalıştırabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git am -3 -i mbox
Commit Body is:
--------------------------
seeing if this helps the gem
--------------------------
Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all</code></pre>
</div>
</div>
<div class="paragraph">
<p>Eğer kaydedilmiş birkaç yamanız varsa ve hangilerini zaten uyguladığınızı veya uygulayacağınızı hatırlayamıyorsanız; öncesinde yamayı görmenize olanak sağladığı için, bu özellik oldukça kullanışlıdır.</p>
</div>
<div class="paragraph">
<p>Bir tema için tüm yamalar uygulandığında ve dalınıza katkı olarak işlendiğinde, bunları uzun vadeli çalışan bir dala birleştirip birleştirmeyeceğinizi veya nasıl birleştireceğinizi seçebilirsiniz.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_checking_out_remotes">Uzak Dallara Geçmek</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Eğer bu katkı; kendi reposunu kuran, bir dizi değişiklik yapıp, buraya iten ve ardından değişikliklerin URL’sini ve değişikliklerin bulunduğu uzak dalın adını size gönderen bir Git kullanıcısından geldiyse, onları bir uzak repo olarak ekleyebilir ve yerel olarak birleştirebilirsiniz.</p>
</div>
<div class="paragraph">
<p>Örneğin, Jessica size kendi reposunun <code>ruby-client</code> dalında harika bir yeni özellik olduğunu söyleyen bir e-posta gönderirse; onun uzak reposunu ekleyip, bu yerelde dala geçiş yaparak, bu özelliği test edebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add jessica git://github.com/jessica/myproject.git
$ git fetch jessica
$ git checkout -b rubyclient jessica/ruby-client</code></pre>
</div>
</div>
<div class="paragraph">
<p>Daha sonra, size başka bir harika özelliğe sahip başka bir dalı içeren yeni bir e-posta gönderirse, zaten uzak sunucuyu kurduğunuz için doğrudan <code>fetch</code> ve <code>checkout</code> yapabilirsiniz.</p>
</div>
<div class="paragraph">
<p>Biriyle sürekli birlikte çalışıyorsanız en kullanışlı olan yöntem budur.
Eğer birisi arada bir ve sadece tek bir yama eklemek istiyorsa, o zaman bu değişiklikleri e-posta yoluyla kabul etmek, herkesin kendi sunucusunu çalıştırmasından ve birkaç yama almak için sürekli olarak uzak sunucular ekleyip, kaldırmasından daha tasarruflu bir zaman yönetimidir.
Ayrıca, muhtemelen yalnızca bir veya iki yama sağlayan herkes için yüzlerce uzak sunucu eklemek istemezsiniz.
Her ne kadar, betikler ve barındırılan hizmetler bu işi kolaylaştırabilse de, bu büyük ölçüde sizin ve katkı sağlayan geliştiricilerin nasıl geliştirme yaptığına bağlıdır.</p>
</div>
<div class="paragraph">
<p>Bu yaklaşımın bir diğer avantajı ise geçmişini de almanızdır.
Geçerli birleştirme sorunlarına sahip olabilseniz dahi, bu çalışmalarının geçmişinizde nerede olduğunu bilirsiniz.
Varsayılan olarak sağlanan düzgün bir üç yollu birleştirme, <code>-3</code> sağlamak zorunda kalmaktan ve yamanın erişiminiz olan herkese açık bir katkıya dayanmasını ummaktan iyidir.</p>
</div>
<div class="paragraph">
<p>Eğer sürekli olarak bir kişiyle çalışmıyor ama yine de yamayı onlardan bu şekilde çekmek istiyorsanız, <code>git pull</code> komutuna uzak repo URL’sini girebilirsiniz.
Bu, tek seferlik bir çekme işlemi yapar ama URL’yi uzak bir referans olarak kaydetmez:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git pull https://github.com/onetimeguy/project
From https://github.com/onetimeguy/project
 * branch            HEAD       -&gt; FETCH_HEAD
Merge made by the 'recursive' strategy.</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_what_is_introduced">Katkıları Tanımlamak</h3>
<div class="paragraph">
<p>
Şimdi, üzerinde katkı yapılan bir tematik dalınız var.
Bu noktada, onunla ne yapmak istediğinizi belirleyebilirsiniz.
Bu bölümde, ana dalınıza bir yamayı birleştirdiğinizde, tam olarak neyi tanıtacağınızı incelemek için birkaç komutu tekrar ele alacağız.</p>
</div>
<div class="paragraph">
<p>Tematik dalda olan, ancak ana dalınızda olmayan tüm katkıların gözden geçirilmesinde fayda vardır.
Ana dalınızda bulunan katkıları bundan hariç tutmak için <code>--not</code> seçeneğini dal adının önüne ekleyebilirsiniz.
Bu, daha önce kullandığımız <code>master..contrib</code> biçimiyle aynı işlemi yapar.
Örneğin, katkılayıcınız size iki yama gönderirse ve siz <code>contrib</code> adında bir dal oluşturup bunları oraya uygularsanız, şunu çalıştırabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log contrib --not master
commit 5b6235bd297351589efc4d73316f0a68d484f118
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Oct 24 09:53:59 2008 -0700

    seeing if this helps the gem

commit 7482e0d16d04bea79d0dba8988cc78df655f16a0
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Mon Oct 22 19:38:36 2008 -0700

    updated the gemspec to hopefully work better</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hatırlayacağınız üzere her katkının hangi değişiklikleri içerdiğini görmek için, <code>git log</code> komutuna <code>-p</code> seçeneğini ekleyebilirsiniz. Ayrıca her katkıyla gelen fark da gösterilecektir.</p>
</div>
<div class="paragraph">
<p>Ana dal ve tematik dalı birleştirirseniz kodda ne gibi farklılıklar olacağının tam bir resmini görmek isterseniz, doğru sonuçları elde etmek için garip bir hile kullanmanız gerekebilir.
Şunu çalıştırmayı düşünebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu komut size bir fark gösterir, ancak sonuç yanıltıcı olabilir.
Eğer <code>master</code> dalınız, tematik dalınızı oluşturduğunuzdan bu yana ilerlemişse, çok garip sonuçlar elde edebilirsiniz.
Bunun sebebi, Git’in üzerinde bulunduğunuz tema dalındaki son katkının pozuyla, <code>master</code> dalındaki son katkının pozunu doğrudan karşılaştırmasıdır.
Örneğin, <code>master</code> dalındaki bir dosyaya bir satır eklerseniz; pozların doğrudan karşılaştırılması, tematik dalın bu satırı kaldıracakmış gibi görünmesine neden olur.</p>
</div>
<div class="paragraph">
<p>Eğer <code>master</code> dalı tematik dalınızın doğrudan bir atası ise, bu bir sorun değildir; ancak eğer iki geçmiş ayrıldıysa, fark <code>master</code> dalına özgü olan her şeyi kaldırıyor ve tema dalınızdaki tüm yeni şeyleri ekliyormuş gibi görünecektir.</p>
</div>
<div class="paragraph">
<p>Gerçekte görmek istediğiniz şey, konu dalına eklenen değişikliklerdir, yani bu dalı ana dala birleştirdiğinizde getireceğiniz çalışma.
Bunu görmek için, Git’in tema dalınızın son katkısını, master üzerindeki ilk ortak atasıyla karşılaştırması neticesinde görebilirsiniz.</p>
</div>
<div class="paragraph">
<p>Teknik olarak bunu yapmanın yolu: ortak atayı açıkça bulup ardından diff’i üzerinde çalıştırmaktır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge-base contrib master
36c7dba2c95e6bbb78dfa822519ecfec6e1ca649
$ git diff 36c7db</code></pre>
</div>
</div>
<div class="paragraph">
<p>or, more concisely:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff $(git merge-base contrib master)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Yine de bunlar özellikle kullanışlı yöntemler değil, bu yüzden Git aynı işi yapmak için başka bir kısaltma sağlar: üç nokta sözdizimi.
<code>git diff</code> komutu bağlamında: <code>diff</code> yapmak için üzerinde bulunduğunuz dalın son katkısı ile başka bir dalın son ortak atası arasına üç nokta (…​) koyabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff master...contrib</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu komut, mevcut tema dalınızın, master ile ortak atasından bu yana getirdiği çalışmayı gösterir.
Bu akılda tutmaya değer ve çok kullanışlı bir sözdizimidir.</p>
</div>
</div>
<div class="sect3">
<h3 id="_katkılanan_i̇şi_birleştirmek">Katkılanan İşi Birleştirmek</h3>
<div class="paragraph">
<p>
Tema dalınızdaki tüm çalışma, ana dala daha yakın bir dala birleştirilmeye hazır olduğunda, sıradaki soru bunun nasıl yapılacağıdır.
Bunun da ötesinde, projenizi yürütmek için hangi genel iş akışını kullanmak istiyorsunuz?
Şimdi elinizdeki pek çok seçenekten birkaçını ele alacağız.</p>
</div>
<div class="sect4">
<h4 id="_i̇ş_akışlarını_birleştirmek">İş Akışlarını Birleştirmek</h4>
<div class="paragraph">
<p>
En temel iş akışı, tüm çalışmayı doğrudan <code>master</code> dalınıza birleştirmektir.
Bu senaryoda, kararlı kodu içeren bir <code>master</code> dalınız bulunmaktadır.
Tematik dalda tamamlandığını düşündüğünüz veya bir başkasının katkıda bulunduğu ama sizin onayladığınız bir çalışma varsa, bunu ana dalınıza birleştirir ve artık ihtiyaç duymadığınız tema dalını silersiniz. Bu süreci her defasında tekrar edersiniz.</p>
</div>
<div class="paragraph">
<p>Örneğin, <code>ruby_client</code> ve <code>php_client</code> adlı iki dalında çalışma yapılan <a href="{{< relurl "book/tr/v2/ch00/merwf_a" >}}">Bir kaç tematik dallı bir geçmiş.</a> gibi bir repomuz olduğunu varsayalım.
Eğer, önce <code>ruby_client</code> ve ardından da <code>php_client</code> dalını birleştirirsek, geçmişiniz <a href="{{< relurl "book/tr/v2/ch00/merwf_b" >}}">Bir tema dalını birleştirdikten sonrası.</a> gibi görünecektir.</p>
</div>
<div id="merwf_a" class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/merging-workflows-1.png" >}}" alt="Bir kaç tematik dallı bir geçmiş.">
</div>
<div class="title">Görsel 73. Bir kaç tematik dallı bir geçmiş.</div>
</div>
<div id="merwf_b" class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/merging-workflows-2.png" >}}" alt="ABir tema dalını birleştirdikten sonrası.">
</div>
<div class="title">Görsel 74. Bir tema dalını birleştirdikten sonrası.</div>
</div>
<div class="paragraph">
<p>Bu muhtemelen en basit iş akışıdır; ancak neyi değiştirdiğinize çok dikkat ettiğiniz, daha büyük ve istikrarlı projelerle uğraşıyorsanız, sorun yaşayabilirsiniz.</p>
</div>
<div class="paragraph">
<p>Daha önemli bir projeniz varsa, iki aşamalı bir birleştirme döngüsü kullanmak isteyebilirsiniz.
Bu senaryoda, sadece çok kararlı bir sürüm çıktığında güncellenecek olan <code>master</code> ve her yeni kodunuzu üzerinde geliştirip denediğiniz <code>develop</code> adında, iki adet uzun ömürlü dalınız var:</p>
</div>
<div class="paragraph">
<p>Her iki dalı da düzenli olarak açık reponuza (public repository) itiyorsunuz.
Birleştirilecek yeni bir tema dalınız olduğunda (<a href="{{< relurl "book/tr/v2/ch00/merwf_c" >}}">Tema dalı birleşmesi öncesi.</a>), bunu <code>develop</code> dalına birleştirirsiniz (<a href="{{< relurl "book/tr/v2/ch00/merwf_d" >}}">Tema dalı birleşmesi sonrası.</a>); ardından, yeni bir sürüm etiketlediğinizde, <code>master</code> dalını ileri sararak (fast-forward) şu anda istikrarlı olan <code>develop</code> dalını bulunduğu yere getirirsiniz (<a href="{{< relurl "book/tr/v2/ch00/merwf_e" >}}">Yeni sürüm sonrası.</a>).</p>
</div>
<div id="merwf_c" class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/merging-workflows-3.png" >}}" alt="Tema dalı birleşmesi öncesi.">
</div>
<div class="title">Görsel 75. Tema dalı birleşmesi öncesi.</div>
</div>
<div id="merwf_d" class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/merging-workflows-4.png" >}}" alt="Tema dalı birleşmesi sonrası.">
</div>
<div class="title">Görsel 76. Tema dalı birleşmesi sonrası.</div>
</div>
<div id="merwf_e" class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/merging-workflows-5.png" >}}" alt="Yeni sürümü sonrası.">
</div>
<div class="title">Görsel 77. Yeni sürüm sonrası.</div>
</div>
<div class="paragraph">
<p>Bu şekilde, insanlar reponuzu kopyaladığında; ya en son "kararlı" sürümü derlemek ve bunu kolayca güncellemek için <code>master</code> dalına geçebilir ya da daha en "güncel" içeriği içeren <code>develop</code> dalına.
Ayrıca, tüm çalışmaların birleştirildiği bir <code>integrate</code> dalı oluşturarak bu anlayışı genişletebilirsiniz.
Bu dal üzerindeki kod tabanı kararlı hale gelip, testleri geçtiğinde, bunu bir <code>develop</code> dalına birleştirebilirsiniz; ve burada kararlı  durumu kanıtlandığında, <code>master</code> dalınızı bu noktaya doğru ileri sararsınız.</p>
</div>
</div>
<div class="sect4">
<h4 id="_büyük_birleştirme_i̇ş_akışı">Büyük Birleştirme İş Akışı</h4>
<div class="paragraph">
<p>
Bu Git projesinde dört uzun ömürlü dal bulunmaktadır: <code>master</code>, <code>next</code>, yeni güncellemeler için <code>pu</code> (proposed updates) ve bakım geri portları için <code>maint</code> (maintenance).
Yeni çalışma görücüye çıktığında, bunlar daha önce anlatılana benzer şekilde (bkz <a href="{{< relurl "book/tr/v2/ch00/merwf_f" >}}">Çoklu paralel tema dallarının karmaşıklığını yönetmek.</a>) yürütücünün reposundaki tema dallarına toplanır (bkz. <a href="{{< relurl "book/tr/v2/ch00/merwf_f" >}}">Çoklu paralel tema dallarının karmaşıklığını yönetmek.</a>).
Bu noktada, çalışmalar, "güvenilir ve canlıya çıkmaya hazır mı, yoksa üzerinde biraz daha çalışılması mı gerekiyor" kararı verilmek üzere değerlendirilirler.
Güvenilir olanlar <code>next</code> dalına birleştirilir ve bu dal herkesin deneyebilmesi için yukarı itilir.</p>
</div>
<div id="merwf_f" class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/large-merges-1.png" >}}" alt="Çoklu paralel tema dallarının karmaşıklığını yönetmek.">
</div>
<div class="title">Görsel 78. Çoklu paralel tema dallarının karmaşıklığını yönetmek.</div>
</div>
<div class="paragraph">
<p>Eğer konular halen geliştirilmeye ihtiyaç duyuyorsa, bunlar <code>next</code> yerine <code>pu</code> dalına birleştirilir.
Tamamen istikrarlı oldukları belirlendiğinde, yeniden <code>master</code> dalına birleştirilirler.
<code>next</code> ve <code>pu</code> dalları daha sonra <code>master</code> dalından yeniden inşa edilir.
Bu, <code>master</code> dalının neredeyse her zaman ileri gitmesi, <code>next</code> dalının zaman zaman yeniden temellenmesi (rebase) ve <code>pu</code> dalının daha da sık yeniden temellenmesi, anlamına gelir:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/large-merges-2.png" >}}" alt="Katkı sağlanan tema dallarını uzun ömürlü birleşim dallarına birleştirmek.">
</div>
<div class="title">Görsel 79. Katkı sağlanan tema dallarını uzun ömürlü birleşim dallarına birleştirmek.</div>
</div>
<div class="paragraph">
<p>Bir tema dalı nihayet <code>master</code> dalına birleştirildiğinde, artık repodan kaldırılır.
Git projesinin ayrıca son sürümden çatallanmış <code>maint</code> adlı bir bakım dalı vardır.
Bu dal, bir bakım sürümü gerektiğinde geriye dönük yamalar sağlamak için kullanılır.</p>
</div>
<div class="paragraph">
<p>Bu sistemde, yürütücünün yeni katkıları değerlendirmesine yardımcı olmak için yapılandırılmış özelleştirilmiş bir iş akışı vardır.
Git reposunu kopyaladığınızda, projeye nasıl katkıda bulunmak istediğinize veya geliştirme döngüsünde ne kadar ilerlemek istediğinize bağlı olarak; projenin farklı gelişim aşamalarını gözlemlemek amacıyla geçiş yapabileceğiniz, dört farklı dalınız olur.
Bu iş akışını daha iyi anlamak için <a href="https://github.com/git/git/blob/master/Documentation/howto/maintain-git.txt">Git Yürütücü Kılavuzu</a>'nu inceleyebilirsiniz.</p>
</div>
</div>
<div class="sect4">
<h4 id="_rebase_cherry_pick">Temelleme ve Ayıklama (Cherry-Picking) İş Akışları</h4>
<div class="paragraph">
<p>
Diğer yürütücüler, doğrusal bir geçmişe sahip olmak için genellikle için katkılanan çalışmaları master dalının üstüne yeniden temellemeyi (rebase) veya  ayıklamayı tercih ederler.
Bir tema dalında birleştirmek istediğiniz bir çalışmanız varsa, o dala geçer ve değişiklikleri mevcut <code>master</code> (veya <code>develop</code>, vb.) dalı üstüne yeniden inşa etmek için temelleme (rebase) komutunu çalıştırırsınız.
Bu işlem sorunsuz tamamlanırsa, <code>master</code> dalınızı ileri sarabilir ve sonuçta doğrusal bir proje geçmişine sahip olursunuz.</p>
</div>
<div class="paragraph">
<p>
Tanıtılan bir çalışmayı bir daldan başka bir dala taşımanın bir diğer yolu da onu ayıklamaktır.
Git’te ayıklama işlemi, bir tek katkı için bir yeniden temelleme gibidir.
Bir katkıyla yapılan değişiklikleri alır ve bunları şu anda bulunduğunuz dala tekrar uygulamaya çalışır.
Bir tema dalında birkaç katkımız varsa ve bunları ayıklayıp yalnızca birini almak istiyorsanız veya bir tema dalında yalnızca bir katkınız varsa ve yeniden temellemek yerine bunu tercih etmek istiyorsanız, bu özellik kullanışlıdır.
Örneğin, şöyle bir projeniz olduğunu varsayalım:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/rebasing-1.png" >}}" alt="Ayıklama öncesi örnek geçmiş.">
</div>
<div class="title">Görsel 80. Ayıklama öncesi örnek geçmiş.</div>
</div>
<div class="paragraph">
<p>Eğer <code>e43a6</code> katkısını ana dalınıza çekmek istiyorsanız, şunu çalıştırabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cherry-pick e43a6
Finished one cherry-pick.
[master]: created a0a41a9: "More friendly message when locking the index fails."
 3 files changed, 17 insertions(+), 3 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu, <code>e43a6</code> ile tanıtılan değişikliği çeker, ancak uygulanan tarihi farklı olduğu için yeni bir katkı SHA-1 değeri alırsınız.
Artık geçmişiniz şöyle görünür:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/rebasing-2.png" >}}" alt="Tema dalındaki katkı ayıklandıktan sonra geçmiş.">
</div>
<div class="title">Görsel 81. Tema dalındaki katkı ayıklandıktan sonra geçmiş.</div>
</div>
<div class="paragraph">
<p>Şimdi tema dalınızı kaldırabilir ve içe almak istemediğiniz katkıları atabilirsiniz.</p>
</div>
</div>
<div class="sect4">
<h4 id="_rerere">Rerere</h4>
<div class="paragraph">
<p>
Eğer çok sayıda birleştirme ve yeniden temelleme yapıyorsanız veya uzun ömürlü bir tema dalını sürdürüyorsanız; Git’in <code>rerere</code> olarak adlandırılan yardımcı bir özelliği vardır.</p>
</div>
<div class="paragraph">
<p>Rerere, "reuse recorded resolution" (kaydedilmiş çözümü yeniden kullan) anlamına gelir ve çakışmaları manuel olarak çözmeniz gerektiğinde kullanabileceğiniz kestirme bir yoldur.
Rerere etkinleştirildiğinde, Git başarılı birleştirmelerin öncel ve ardıl pozlar kümesini saklar; ve eğer daha önce düzelttiğiniz bir çakışma ile tam olarak aynı görünen yeni bir çakışma fark ederse, sizi bununla meşgul etmeden, daha önceki çözümü kullanır.</p>
</div>
<div class="paragraph">
<p>Bu özellik iki kısımdan oluşur: bir yapılandırma ayarı ve bir komut.
Yapılandırma ayarı <code>rerere.enabled</code> şeklindedir ve genel yapılandırmanıza eklemek oldukça kullanışlıdır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global rerere.enabled true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Böylece, çakışmaları çözen bir birleştirme yaptığınızda, bu çözüm gelecekte ihtiyaç duymanız ihtimaline binaen önbelleğe kaydedilecektir.</p>
</div>
<div class="paragraph">
<p>İhtiyacınız olduğunda, <code>git rerere</code> komutunu kullanarak rerere önbelleğiyle etkileşime geçebilirsiniz.
Tek başına çağrıldığında; Git, çözümler veritabanını kontrol ederek, mevcut birleştirme çatışmasıyla bir eşleşme bulmaya ve bunu çözmeye çalışır (<code>rerere.enabled</code> yapılandırması <code>true</code> olarak ayarlandıysa, bu işlem otomatik olarak yapılır).
Kaydedilecek ögeleri görmek, önbellekten belirli bir çözümü silmek veya tüm önbelleği temizlemek için kullanılabilecek, alt komutlar da vardır.
<code>rerere</code> komutunu <a href="{{< relurl "book/tr/v2/ch00/ref_rerere" >}}">Rerere</a> bölümünde daha detaylı olarak ele alacağız.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_tagging_releases">Sürümü Etiketlemek</h3>
<div class="paragraph">
<p>
Bir sürüm yayımlamaya karar verdiğinizde, bu sürümü gelecekte yeniden oluşturabilmek için etiketlemek isteyebilirsiniz.
Yeni bir etiketi <a href="{{< relurl "book/tr/v2/ch00/ch02-git-basics" >}}">Git Temelleri</a> bölümünde anlatıldığı gibi oluşturabilirsiniz.
Eğer etiketi yürütücü olarak imzalamaya karar verirseniz, etiketleme işlemi şöyle görünebilir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git tag -s v1.5 -m 'my signed 1.5 tag'
You need a passphrase to unlock the secret key for
user: "Scott Chacon &lt;schacon@gmail.com&gt;"
1024-bit DSA key, ID F721C45A, created 2009-02-09</code></pre>
</div>
</div>
<div class="paragraph">
<p>Etiketlerinizi imzalarsanız, etiketlerinizi imzalamak için kullandığınız genel PGP anahtarını dağıtma sorunuyla karşılaşabilirsiniz.
Git proje yürütücüsü, genel anahtarlarını repoya bir blob olarak dahil edip, ardından doğrudan bu içeriğe işaret eden bir etiket ekleyerek bu sorunu çözmüştür.
Bunu yapmak için, <code>gpg --list-keys</code> komutunu çalıştırarak hangi anahtarı kullanmak istediğinizi belirleyebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ gpg --list-keys
/Users/schacon/.gnupg/pubring.gpg
---------------------------------
pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]
uid                  Scott Chacon &lt;schacon@gmail.com&gt;
sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Daha sonra, anahtarı dışa aktarıp, bu içeriği <code>git hash-object</code> üzerinden yönlendirerek, anahtarı doğrudan Git veritabanına aktarabilirsiniz.
Bu şekilde Git, bu içeriğe sahip yeni bir blob oluşturur ve blob’un SHA-1 değerini size geri verir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ gpg -a --export F721C45A | git hash-object -w --stdin
659ef797d181633c87ec71ac3f9ba29fe5775b92</code></pre>
</div>
</div>
<div class="paragraph">
<p>Artık anahtar içeriğiniz Git’te olduğuna göre, <code>hash-object</code> komutunun size verdiği yeni SHA-1 değerini belirterek doğrudan ona işaret eden bir etiket oluşturabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>git push --tags</code> komutunu çalıştırırsanız, <code>maintainer-pgp-pub</code> etiketi herkesle paylaşılacaktır.
Bir etiketi doğrulamak isteyen biri; PGP anahtarınızı doğrudan içe aktarmak için, blob’u veritabanından çekip, GPG’ye aktarabilir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show maintainer-pgp-pub | gpg --import</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu anahtar, imzalı tüm etiketlerinizi doğrulamak için kullanabilir.
Ayrıca, etiket mesajında talimatlar eklerseniz; <code>git show &lt;etiket&gt;</code> komutuyla son kullanıcıya etiket doğrulaması hakkında daha belirli yönergeler verebilirsiniz.</p>
</div>
</div>
<div class="sect3">
<h3 id="_build_number">Yapı Numarası Oluşturma</h3>
<div class="paragraph">
<p>
Git’in her katkıyla tekdüze olarak artan, <em>v123</em> gibi numaraları veya benzer bir şeyi olmadığından; bir katkıyı insanlar tarafından okunabilir bir isimle eşleştirmek için, o katkı üzerinde <code>git describe</code> komutunu çalıştırabilirsiniz.
Bunun sonucunda, Git; o katkıdan önceki en son etiketin adını, arkasından bu etiketten bu katkıya kadar işlenen katkı sayısını ve en arkaya da tanımlanan katkının kısmi SHA-1 değerini içeren bir dize oluşturur (en başa Git’i simgeleyen "g" harfi eklenir):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git describe master
v1.6.2-rc1-20-g8c5b85c</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu şekilde, bir poz veya derleme oluşturup okunaklı bir isim verebilirsiniz.
Aslında, eğer Git’i kendi reposundan kopyaladığınız kaynak kodundan derlemişseniz, <code>git --version</code> komutu size şuna benzeyen bir çıktı verir.
Eğer doğrudan etiketlediğiniz bir katkıyı tanımlıyorsanız, size sadece etiket adını verir.</p>
</div>
<div class="paragraph">
<p><code>git describe</code> komutu, varsayılan olarak, (<code>-a</code> veya <code>-s</code> bayrağı ile oluşturulan) dipnotlu etiketlere ihtiyaç duyar. Eğer hafif (dipnotsuz) etiketlerden de faydalanmak istiyorsanız, komuta <code>--tags</code> seçeneğini ekleyin.
Bu dizeyi <code>git checkout</code> veya <code>git show</code> komutunun hedefi olarak da kullanabilirsiniz, ancak sonundaki kısaltılmış SHA-1 değerine dayansa da sonsuza kadar geçerli olmayabilir.
Örneğin, Linux çekirdeği son zamanlarda SHA-1 nesne benzersizliğini sağlamak için 8’den 10 karaktere geçti, bu nedenle eski <code>git describe</code> çıktı adları geçersiz hale geldi.</p>
</div>
</div>
<div class="sect3">
<h3 id="_preparing_release">Bir Sürüm Hazırlama</h3>
<div class="paragraph">
<p>
Diyelimk ki şimdi bir sürüm yayımlamak istiyorsunuz.
Bunun için yapmanız gerekenlerden biri, Git’i kullanmayan garibanlar için kodunuzun en son pozunun bir arşivini oluşturmaktır.
Bunun için <code>git archive</code> komutunu kullanmalısınız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git archive master --prefix='project/' | gzip &gt; `git describe master`.tar.gz
$ ls *.tar.gz
v1.6.2-rc1-20-g8c5b85c.tar.gz</code></pre>
</div>
</div>
<div class="paragraph">
<p>Eğer birisi bu sıkıştırılmış tar dosyasını açarsa, projenizin en son pozunu bir proje dizini altına almış olur.
Aynı şekilde bir zip arşivi de oluşturabilirsiniz, ancak bunu <code>git archive</code> komutuna <code>--format=zip</code> seçeneğini bağlayarak yapabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git archive master --prefix='project/' --format=zip &gt; `git describe master`.zip</code></pre>
</div>
</div>
<div class="paragraph">
<p>Artık projenizin sürümünün, web sitenize yükleyebileceğiniz veya birilerine e-posta ile gönderebileceğiniz, güzel bir tar dosyası ve zip arşivi vardır.</p>
</div>
</div>
<div class="sect3">
<h3 id="_the_shortlog">Kısa Günlük</h3>
<div class="paragraph">
<p>
Artık, projenizdeki son değişiklikler hakkında bilgi sahibi olmak isteyenlere bir e-posta gönderme zamanı geldi.
Son sürüm veya e-postanızdan bu yana projenizde yapılan değişiklikleri tutan değişim günlüğünü hızlıca elde etmek için <code>git shortlog</code> komutunu kullanabilirsiniz.
Bu komut, veerdiğiniz aralıktaki tüm katkıları özetler.
Örneğin, son sürümünüz v1.0.1 ise, aşağıdaki komut size son sürümünüzden bu yana yapılan tüm katkıların bir özetini verir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git shortlog --no-merges master --not v1.0.1
Chris Wanstrath (6):
      Add support for annotated tags to Grit::Tag
      Add packed-refs annotated tag support.
      Add Grit::Commit#to_patch
      Update version and History.txt
      Remove stray `puts`
      Make ls_tree ignore nils

Tom Preston-Werner (4):
      fix dates in history
      dynamic version method
      Version bump to 1.0.2
      Regenerated gemspec for version 1.0.2</code></pre>
</div>
</div>
<div class="paragraph">
<p>v1.0.1’den bu yana yapılan tüm katkıların yazarlarına göre gruplandırılmış temiz bir özet elde eder ve ardından bu özeti listenize e-posta olarak gönderebilirsiniz.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>