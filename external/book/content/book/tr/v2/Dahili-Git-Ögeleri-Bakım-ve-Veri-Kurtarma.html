---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: tr
  chapter:
    title: Dahili Git Ögeleri
    number: 10
  section:
    title: Bakım ve Veri Kurtarma
    number: 7
    cs_number: '10.7'
    previous: book/tr/v2/Dahili-Git-Ögeleri-Transfer-Protokolleri
    next: book/tr/v2/Dahili-Git-Ögeleri-Ortam-Değişkenleri
title: Git - Bakım ve Veri Kurtarma
url: "/book/tr/v2/Dahili-Git-Ögeleri-Bakım-ve-Veri-Kurtarma.html"
---
<h2 id="_bakım_ve_veri_kurtarma">Bakım ve Veri Kurtarma</h2>
<div class="paragraph">
<p>Bazen veri havuzunu daha derli toplu hale getirmek, içe aktarılan bir veri havuzunu temizlemek veya kaybolan çalışmaları kurtarmak için bir miktar temizlik yapmanız gerekebilir.
Bu bölümde bu senaryolardan bazıları ele alınacaktır.</p>
</div>
<div class="sect3">
<h3 id="_git_gc">Bakım</h3>
<div class="paragraph">
<p>Arada sırada, Git otomatik olarak <code>auto gc</code> adlı bir komut çalıştırır.
Çoğu zaman bu komut hiçbir şey yapmaz.
Ancak, fazla sayıda gevşek nesne (paket dosyasında olmayan nesneler) veya fazla sayıda paket dosyası varsa, Git tam donanımlı bir <code>git gc</code> komutunu başlatır.
<code>gc</code> çöp toplama (garbage collection) anlamına gelir ve bu komut birkaç şey yapar: tüm gevşek nesneleri toplayarak bunları paket dosyalarına yerleştirir, paket dosyalarını birleştirerek tek bir büyük paket dosyası haline getirir, birkaç ay öncesine dayanan ve hiçbir katkısına erişilemeyen nesneleri kaldırır.</p>
</div>
<div class="paragraph">
<p>Auto <code>gc</code> 'yi aşağıdaki gibi manuel olarak çalıştırabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git gc --auto</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tekrar belirtmek gerekirse, bu genellikle hiçbir şey yapmaz.
Gerçek bir <code>gc</code> komutunu çalıştırmak için yaklaşık 7.000 gevşek nesneye veya 50’den fazla paket dosyasına ihtiyacınız vardır.
Bu sınırları sırasıyla <code>gc.auto</code> ve <code>gc.autopacklimit</code> yapılandırma ayarları ile değiştirebilirsiniz.</p>
</div>
<div class="paragraph">
<p><code>gc</code> 'nin yapacağı diğer bir şey de referanslarınızı tek bir dosyaya paketlemektir.
Diyelim ki repo şu dalları ve etiketleri içeriyor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ find .git/refs -type f
.git/refs/heads/experiment
.git/refs/heads/master
.git/refs/tags/v1.0
.git/refs/tags/v1.1</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>git gc</code> komutunu çalıştırırsanız, bu dosyalar artık <code>refs</code> dizininde bulunmaz.
Git verimlilik açısından onları <code>.git/packed-refs</code> adlı, şu şekilde gözüken bir dosyaya taşır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .git/packed-refs
# pack-refs with: peeled fully-peeled
cac0cab538b970a37ea1e769cbbde608743bc96d refs/heads/experiment
ab1afef80fac8e34258ff41fc1b867c702daa24b refs/heads/master
cac0cab538b970a37ea1e769cbbde608743bc96d refs/tags/v1.0
9585191f37f7b0fb9444f35a9bf50de191beadc2 refs/tags/v1.1
^1a410efbd13591db07496601ebc7a059dd55cfe9</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bir referansı güncellerseniz Git bu dosyayı düzenlemez, bunun yerine <code>refs/heads</code> 'e yeni bir dosya yazar.
Belirli bir referans için uygun SHA-1’i almak amacıyla Git, <code>refs</code> dizininde bu referansı kontrol eder ve ardından bir yedek olarak <code>packed-refs</code> dosyasını kontrol eder.
Ancak, <code>refs</code> dizininde bir referans bulamazsanız, bu muhtemelen <code>packed-refs</code> dosyanızdadır.</p>
</div>
<div class="paragraph">
<p>Dosyanın <code>^</code> ile başlayan son satırına dikkat edin.
Bu, doğrudan yukarıdaki etiketin açıklamalı bir etiket olduğu ve bu satırın açıklamalı etiketin işaret ettiği katkı olduğu anlamına gelir.</p>
</div>
</div>
<div class="sect3">
<h3 id="_data_recovery">Veri Kurtarma</h3>
<div class="paragraph">
<p>Git yolculuğunuzun bir noktasında, bir katkıyı kazara kaybedebilirsiniz.
Bunu genellikle, üzerinde çalışma olan bir dalı zorla silip, sonunda dala yine ihtiyacınız olduğunu fark ettiğinizde yaşarsınız; veya bir dala sert sıfırlama yaparsınız, böylece ihtiyacınız olan bazı katkıları kaybetmiş olursunuz.
Bu durum gerçekleşirse, katkıları nasıl geri alabilirsiniz?</p>
</div>
<div class="paragraph">
<p>İşte test repomdaki ana dalı bir önceki katkıya sert sıfırlayan ve sonra kaybolan katkıları kurtaran bir örnek:
Önce, repomun şu anda nerede olduğunu gözden geçirelim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --pretty=oneline
ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
484a59275031909e19aadb7c92262719cfcdf19a added repo.rb
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Şimdi, <code>master</code> dalını ortadaki katkıya taşıyalım:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git reset --hard 1a410efbd13591db07496601ebc7a059dd55cfe9
HEAD is now at 1a410ef third commit
$ git log --pretty=oneline
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Etkili bir şekilde en üstteki iki katkıyı kaybettiniz ve bu katkılara erişilebilecek hiçbir dalınız yok.
Bu katkıların SHA-1’ini bulmanız ve sonra ona işaret eden bir dal eklemeniz gerekiyor.
Sorun, bu en son katkının SHA-1’ini bulmaktadır (neticede onu ezberlemediniz, değil mi)?</p>
</div>
<div class="paragraph">
<p>Genellikle, en hızlı yol <code>git reflog</code> adı verilen bir araç kullanmaktır.
Çalışırken, Git HEAD’i her değiştirdiğinizde ne olduğunu sessizce kaydeder.
Her bir katkı veya dal değiştirdiğinizde reflog güncellenir.
Reflog ayrıca <code>git update-ref</code> komutu tarafından da güncellenir, bu da sadece SHA-1 değerini ref dosyalarınıza yazmak yerine onu kullanmanın başka bir nedenidir (<a href="{{< relurl "book/tr/v2/ch00/_git_refs" >}}">Git Referansları</a> bölümünde ele aldığımız gibi).
Herhangi bir zamanda nerede olduğunuzu görmek için <code>git reflog</code> komutunu çalıştırarak geçmişinizi görebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git reflog
1a410ef HEAD@{0}: reset: moving to 1a410ef
ab1afef HEAD@{1}: commit: modified repo.rb a bit
484a592 HEAD@{2}: commit: added repo.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Burada kontrol ettiğimiz iki katkıyı görebiliriz, ancak burada pek fazla bilgi yok.
Aynı bilgiyi çok daha kullanışlı bir şekilde görmek için <code>git log -g</code> komutunu çalıştırabiliriz, bu size reflog’unuz için normal bir günlük (log) çıktısı verecektir.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -g
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Reflog: HEAD@{0} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: updating HEAD
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:22:37 2009 -0700

		third commit

commit ab1afef80fac8e34258ff41fc1b867c702daa24b
Reflog: HEAD@{1} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: updating HEAD
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:15:24 2009 -0700

       modified repo.rb a bit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Görünüşe göre kaybettiğiniz katkı en alttaki katkıdır, bu yüzden onu o katkıya işaret eden yeni bir dal oluşturarak kurtarabilirsiniz.
Örneğin, o katkıya (ab1afef) işaret eden <code>recover-branch</code> adında bir dal başlatabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch recover-branch ab1afef
$ git log --pretty=oneline recover-branch
ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
484a59275031909e19aadb7c92262719cfcdf19a added repo.rb
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Harika – artık <code>master</code> dalınızın bulunduğu yerde olan <code>recover-branch</code> adında bir dalınız var, böylece ilk iki katkıya yeniden ulaşabilirsiniz.
Şimdi, varsayalım ki kaybınız reflog’da değildi (<code>recover-branch</code>'i kaldırarak ve reflog’u silerek bu durumu canlandırabilirsiniz edebilirsiniz).
Şimdi, ilk iki katkı hiçbir şey tarafından ulaşılamaz durumda:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch -D recover-branch
$ rm -Rf .git/logs/</code></pre>
</div>
</div>
<div class="paragraph">
<p>Çünkü reflog verileri <code>.git/logs/</code> dizininde saklanır, hiçbir etkin reflog’unuz yoktur.
Bu noktada bu katkıyı nasıl kurtarabilirsiniz?
Bir yol, veritabanınızı bütünlük açısından kontrol eden <code>git fsck</code> yardımcı programını kullanmaktır.
Onu <code>--full</code> seçeneği ile çalıştırırsanız, başka bir nesne tarafından işaret edilmeyen tüm nesneleri size gösterir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git fsck --full
Checking object directories: 100% (256/256), done.
Checking objects: 100% (18/18), done.
dangling blob d670460b4b4aece5915caf5c68d12f560a9fe3e4
dangling commit ab1afef80fac8e34258ff41fc1b867c702daa24b
dangling tree aea790b9a58f6cf6f2804eeac9f0abbe9631e4c9
dangling blob 7108f7ecb345ee9d0084193f147cdad4d2998293</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu durumda, eksik katkınızı ``dangling commit`` (sallantıdaki katkı) dizgesinden sonra görebilirsiniz.
Aynı şekilde, o SHA-1’e işaret eden bir dal ekleyerek onu kurtarabilirsiniz.</p>
</div>
</div>
<div class="sect3">
<h3 id="_removing_objects">Nesneleri Silmek</h3>
<div class="paragraph">
<p>Git’in harika birçok özelliği olsa da, sorunlara da neden olabilen bir özelligi: <code>git clone</code> komutunun projenin her dosyasının tüm sürümlerini de içermekte olan "tüm geçmişini" indirmesidir.
Bu, hepsinin kaynak kodu olduğu durumlar için sorun değildir, çünkü Git bu veriyi etkili bir şekilde sıkıştırmak için yüksek derecede optimize edilmiştir.
Ancak, projenizin geçmişinde herhangi bir noktada tek bir büyük dosya ekleyen biri olduğunda, her zaman için her klonun o büyük dosyayı indirmek zorunda kalacak olması - o dosya sonraki katkıda projeden kaldırılmış olsa bile - geçerli bir durumdur.
Çünkü geçmişten erişilebilirdir ve her zaman orada olacaktır.</p>
</div>
<div class="paragraph">
<p>Bu, Subversion veya Perforce repolarını Git’e dönüştürürken büyük bir sorun olabilir.
Bu sistemlerde tüm geçmişi indirmediğiniz için, bu tür bir eklemenin bazı sonuçları vardır.
Başka bir sistemden bir içe aktarma yaptıysanız veya başka bir şekilde deponuzun beklenenden çok daha büyük olduğunu görürseniz, büyük nesneleri bulup kaldırmanın bir yolunu aşağıda bulabilirsiniz.</p>
</div>
<div class="paragraph">
<p><strong>Dikkat: Bu teknik, katkı geçmişinize zarar vericidir.</strong>
Büyük bir dosyanın referansını kaldırmak için değiştirirseniz, ilk ağacınızdan itibaren her katkı nesnesini yeniden yazacaktır.
Bunu, bir içe aktarmadan hemen sonra ve henüz hiç kimse çalışmaya başlamamışken yaparsanız, sorunsuzdur.
Aksi takdirde, tüm katkıda bulunanlara, çalışmalarını yeni katkılara dayandırmaları gerektiğini bildirmeniz gerekir.</p>
</div>
<div class="paragraph">
<p>Bu tekniği göstermek için, test repomuza büyük bir dosya ekleyecek, bir sonraki katkıda onu kaldıracak, ardından onu bulup repodan kalıcı olarak sileceğiz.
İlk olarak, geçmişinize büyük bir nesne ekleyin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ curl https://www.kernel.org/pub/software/scm/git/git-2.1.0.tar.gz &gt; git.tgz
$ git add git.tgz
$ git commit -m 'add git tarball'
[master 7b30847] add git tarball
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 git.tgz</code></pre>
</div>
</div>
<div class="paragraph">
<p>Eyvah! Projenize devasa bir tarball eklemek istememiştiniz.
Onu kaldırmak daha iyi olur:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rm git.tgz
rm 'git.tgz'
$ git commit -m 'oops - removed large tarball'
[master dadf725] oops - removed large tarball
 1 file changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 git.tgz</code></pre>
</div>
</div>
<div class="paragraph">
<p>Şimdi (<code>gc</code> komutuyla) veritabanınızı temizleyin ve kullandığınız alanı görün:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git gc
Counting objects: 17, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (13/13), done.
Writing objects: 100% (17/17), done.
Total 17 (delta 1), reused 10 (delta 0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Kullandığınız alanı hızlı bir şekilde görmek için <code>count-objects</code> komutunu çalıştırabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git count-objects -v
count: 7
size: 32
in-pack: 17
packs: 1
size-pack: 4868
prune-packable: 0
garbage: 0
size-garbage: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>size-pack</code> girişi, paket dosyalarınızın kilobayt cinsinden boyutudur, bu yüzden neredeyse 5MB kullanıyorsunuz.
Son katkıdan önce yaklaşık 2K kullanıyordunuz: açıkçası, dosyayı önceki katkıdan kaldırmak onu geçmişinizden kaldırmadı.
Bu repoyu kopyalayan herkes, bu küçük projeyi almak için 5MB’lik tümünü kopyalamak zorunda kalacak, çünkü yanlışlıkla büyük bir dosya eklediniz.
Hadi onu kaldıralım.</p>
</div>
<div class="paragraph">
<p>İlk olarak, onu bulmanız gerekiyor.
Bu durumda, zaten hangi dosyanın olduğunu biliyorsunuz.
Ancak öyle olmadığını varsayalım; bu kadar çok alanı alan dosyayı veya dosyaları nasıl tanımlarsınız?
<code>git gc</code> komutunu çalıştırırsanız, tüm nesneler bir paket dosyasında bulunur; büyük nesneleri tanımlamak için <code>git verify-pack</code> adlı başka bir işleme komutunu çalıştırabilir ve çıktıdaki üçüncü alana göre sıralayabilirsiniz, işte bu dosya boyutudur.
Ayrıca, yalnızca en büyük birkaç dosyaya ilgilendiğiniz için çıktıyı <code>tail</code> komutuyla borudan (pipe) geçirebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git verify-pack -v .git/objects/pack/pack-29…69.idx \
  | sort -k 3 -n \
  | tail -3
dadf7258d699da2c8d89b09ef6670edb7d5f91b4 commit 229 159 12
033b4468fa6b2a9547a70d88d1bbe8bf3f9ed0d5 blob   22044 5792 4977696
82c99a3e86bb1267b236a4b6eff7868d97489af1 blob   4975916 4976258 1438</code></pre>
</div>
</div>
<div class="paragraph">
<p>Büyük nesne en alttadır: 5MB.
Bu dosyanın ne olduğunu bulmak için, kısa bir süre önce <a href="{{< relurl "book/tr/v2/ch00/_enforcing_commit_message_format" >}}">Belirli Bir Katkı Mesajı Formatını Zorunlu Hale Getirme</a> bölümünde kullandığınız <code>rev-list</code> komutunu kullanacaksınız.
<code>rev-list</code>'e <code>--objects</code> parametresini ilettiğinizde, tüm katkı SHA-1’leri ve bunlarla ilişkilendirilmiş dosya yollarıyla birlikte blok SHA-1’lerini listeler.
Bunu blob’un adını bulmak için kullanabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rev-list --objects --all | grep 82c99a3
82c99a3e86bb1267b236a4b6eff7868d97489af1 git.tgz</code></pre>
</div>
</div>
<div class="paragraph">
<p>Şimdi, bu dosyayı geçmişinizdeki tüm ağaçlardan kaldırmanız gerekiyor.
Bu dosyayı değiştiren tüm katkıları kolayca görebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --branches -- git.tgz
dadf725 oops - removed large tarball
7b30847 add git tarball</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>7b30847</code> 'den sonraki tüm katkıları bu dosyayı tamamen Git geçmişinizden kaldırmak için yeniden yazmalısınız.
Bunu yapmak için, <a href="{{< relurl "book/tr/v2/ch00/_rewriting_history" >}}">Geçmişi Yeniden Yazma</a> bölümünde kullandığınız <code>filter-branch</code> komutunu kullanırsınız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git filter-branch --index-filter \
  'git rm --ignore-unmatch --cached git.tgz' -- 7b30847^..
Rewrite 7b30847d080183a1ab7d18fb202473b3096e9f34 (1/2)rm 'git.tgz'
Rewrite dadf7258d699da2c8d89b09ef6670edb7d5f91b4 (2/2)
Ref 'refs/heads/master' was rewritten</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>--index-filter</code> seçeneği, <a href="{{< relurl "book/tr/v2/ch00/_rewriting_history" >}}">Geçmişi Yeniden Yazma</a> bölümünde kullanılan <code>--tree-filter</code> seçeneğine benzer, ancak her seferinde diske çıkarılan dosyaları değiştiren bir komut yerine, indeksinizi veya dizin belirtmenizi sağlar.</p>
</div>
<div class="paragraph">
<p><code>rm dosya</code> gibi belirli bir dosyayı kaldırmak yerine, onu <code>git rm --cached</code> ile kaldırmalısınız; bu onu dizinden değil, indeksten kaldırır.
Bunu bu şekilde yapmamızın nedeni hızdır; çünkü Git, filtrelerinizi çalıştırmadan önce her revizyonu diske çıkarmak zorunda kalmadığı için, işlem çok daha hızlı olabilir.
Aynı görevi <code>--tree-filter</code> ile de gerçekleştirebilirsiniz.
<code>git rm</code> 'nin <code>--ignore-unmatch</code> seçeneği, kaldırmaya çalıştığınız desen orada olmadığında hata vermemesini sağlar.
Son olarak, bu sorunun başladığı yere yani <code>7b30847</code> katkısından başlayarak yalnızca geçmişinizi yeniden yazmasını istersiniz, aksi takdirde işlem başlangıçtan başlayacak ve gereksiz yere daha uzun sürecektir.</p>
</div>
<div class="paragraph">
<p>Geçmişiniz artık o dosyaya bir referans içermiyor.
Yine de reflog’unuz ve <code>filter-branch</code> yaptığınızda Git’in eklediği yeni bir dizi refs, hala bu dosyaya işaret ediyor; bu yüzden onları kaldırmanız ve ardından veritabanını yeniden paketlemeniz gerekiyor.
Yeniden paketlemeden önce bu eski katkılara dönük bir işaretçisi olan her şeyden kurtulmanız gerekiyor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ rm -Rf .git/refs/original
$ rm -Rf .git/logs/
$ git gc
Counting objects: 15, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (11/11), done.
Writing objects: 100% (15/15), done.
Total 15 (delta 1), reused 12 (delta 0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ne kadar alan kazandığınızı görelim.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git count-objects -v
count: 11
size: 4904
in-pack: 15
packs: 1
size-pack: 8
prune-packable: 0
garbage: 0
size-garbage: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Paketlenmiş repo boyutu 8K’ya kadardır, bu da 5 MB’tan çok daha iyidir.
Boyut değerinden, büyük nesnenin hala gevşek nesnelerinizin içinde olduğunu, yani gitmediğini görebilirsiniz; ancak bir itme veya sonraki kopyalamayla (clone) aktarılmayacaktır ki önemli olan da budur.
Eğer gerçekten isterseniz`git prune` komutunu <code>--expire</code> seçeneğiyle çalıştırarak nesneyi tamamen kaldırabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git prune --expire now
$ git count-objects -v
count: 0
size: 0
in-pack: 15
packs: 1
size-pack: 8
prune-packable: 0
garbage: 0
size-garbage: 0</code></pre>
</div>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>