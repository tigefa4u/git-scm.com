---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: tr
  chapter:
    title: Dahili Git Ögeleri
    number: 10
  section:
    title: Git Referansları
    number: 3
    cs_number: '10.3'
    previous: book/tr/v2/Dahili-Git-Ögeleri-Git-Nesneleri
    next: book/tr/v2/Dahili-Git-Ögeleri-Packfiles
title: Git - Git Referansları
url: "/book/tr/v2/Dahili-Git-Ögeleri-Git-Referansları.html"
---
<h2 id="_git_refs">Git Referansları</h2>
<div class="paragraph">
<p>Eğer, örneğin <code>1a410e</code> katkısından ulaşılabilen reposunuzun geçmişini görmek isterseniz, bu geçmişi görüntülemek için <code>git log 1a410e</code> gibi bir şey çalıştırabilirsiniz, ancak yine de <code>1a410e</code> 'nin bu geçmişin başlangıç noktası olarak kullanılacak katkı olduğunu hatırlamanız gerekecektir.
Bunun yerine, bu SHA-1 karmasını basit bir isimle saklayabileceğiniz bir dosyanız olsaydı, bu adı ham SHA-1 değeri yerine kullanabilirdiniz.</p>
</div>
<div class="paragraph">
<p>Git’te, bu basit adlar "referanslar" veya "refs" olarak adlandırılır.
Bu SHA-1 değerlerini içeren dosyaları <code>.git/refs</code> dizininde bulabilirsiniz.
Mevcut projede, bu dizin hiç dosya içermiyor, ancak basit bir yapıya sahip:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ find .git/refs
.git/refs
.git/refs/heads
.git/refs/tags
$ find .git/refs -type f</code></pre>
</div>
</div>
<div class="paragraph">
<p>En son katkınızın nerede olduğunu hatırlamanıza yardımcı olacak yeni bir referans oluşturmak için teknik olarak şunu yapabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 1a410efbd13591db07496601ebc7a059dd55cfe9 &gt; .git/refs/heads/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Şimdi, Git komutlarınızda SHA-1 değeri yerine oluşturduğunuz baş referansını kullanabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --pretty=oneline master
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Referans dosyalarını doğrudan düzenlemeniz önerilmez; bunun yerine, bir referansı güncellemek isterseniz, Git size bunu yapmak için daha güvenli olan <code>git update-ref</code> komutunu sağlar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bir Git dalı, aslında sadece bir iş hattının başını gösteren bir işaretçi veya referanstır.
İkinci katkıya bir dal oluşturmak için şunu yapabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git update-ref refs/heads/test cac0ca</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dalınız sadece o katkıdan aşağıdaki işi içerecektir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --pretty=oneline test
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Şimdi, Git veritabanınız kavramsal olarak şuna benziyor:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/data-model-4.png" >}}" alt="Dal başı referansları içeren Git dizini nesneleri.">
</div>
<div class="title">Görsel 151. Dal başı referansları içeren Git dizini nesneleri.</div>
</div>
<div class="paragraph">
<p><code>git branch &lt;dal&gt;</code> gibi komutları çalıştırdığınızda, Git <code>update-ref</code> komutunu çalıştırarak, üzerinde bulunduğunuz dalın son katkısının SHA-1’ini istediğiniz yeni referansa ekler.</p>
</div>
<div class="sect3">
<h3 id="ref_the_ref">HEAD (baş/uç)</h3>
<div class="paragraph">
<p>Şimdi, <code>git branch &lt;dal&gt;</code> komutunu çalıştırdığınızda, Git son katkının SHA-1’ini nasıl bilir?
Cevap HEAD dosyasındır.</p>
</div>
<div class="paragraph">
<p>Genellikle HEAD dosyası, üzerinde bulunduğunuz dalın sembolik bir referansıdır.
Sembolik referans olarak, normal bir referansın aksine, başka bir referansa dönük bir işaretçi içerir.</p>
</div>
<div class="paragraph">
<p>Ancak bazı nadir durumlarda HEAD dosyası, bir git nesnesinin SHA-1 değerini içerebilir.
Bu durum, bir etiket, katkı veya uzak dalı checkout ettiğinizde, reponuzu <a href="https://git-scm.com/docs/git-checkout#_detached_head">"bağlantısız HEAD"</a> durumuna sokar.</p>
</div>
<div class="paragraph">
<p>Dosyaya baktığınızda, genellikle şöyle bir şey görürsünüz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .git/HEAD
ref: refs/heads/master</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>git checkout test</code> komutunu çalıştırırsanız, Git dosyayı şuna benzer bir şekilde günceller:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .git/HEAD
ref: refs/heads/test</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>git commit</code> komutu katkı nesnesini oluştururken; HEAD’deki referansın işaret ettiği SHA-1 değerini, o katkı nesnesinin önceli olarak belirtir.</p>
</div>
<div class="paragraph">
<p>Bu dosyayı manuel olarak da düzenleyebilirsiniz, ancak yine de bunu yapmanın daha güvenli bir yolu vardır: <code>git symbolic-ref</code>.
Bu komutla HEAD’in değerini okuyabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git symbolic-ref HEAD
refs/heads/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aynı komutu kullanarak HEAD’in değerini de ayarlayabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git symbolic-ref HEAD refs/heads/test
$ cat .git/HEAD
ref: refs/heads/test</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sembolik bir referansı refs stilinin dışında ayarlayamazsınız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git symbolic-ref HEAD test
fatal: Refusing to point HEAD outside of refs/</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_etiketler_tag">Etiketler (Tag)</h3>
<div class="paragraph">
<p>Git’in üç ana nesne türünü (<em>blob</em>, <em>ağaç</em> (tree) ve <em>katkı</em> (commit)) inceledik, ancak bir dördüncüsü vardır.
<em>Etiket</em> (tag) nesnesi, bir katkı nesnesine çok benzeyen bir yapıya sahiptir: bir etiketleyici, bir tarih, bir ileti ve bir işaretçi içerir.
Temel fark, bir etiket nesnesinin genellikle bir ağaca değil, bir katkıya işaret etmesidir.
Bu bir dal referansına benzer, ancak asla hareket etmez: her zaman aynı katkıya işaret eder, ancak ona daha dostane bir ad verir.</p>
</div>
<div class="paragraph">
<p><a href="{{< relurl "book/tr/v2/ch00/ch02-git-basics" >}}">Git Temelleri</a> bölümünde anlatıldığı gibi, iki tür etiket vardır: anotasyonlu (annotated) ve hafif.
Hafif bir etiket oluşturmak için şunu çalıştırabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu asla hareket etmeyen bir referansa sahip hafif bir etikettir.
Ancak, anotasyonlu bir etiket daha karmaşıktır.
Eğer anotasyonlu bir etiket oluşturursanız, Git bir etiket nesnesi oluşturur; ve ardından doğrudan katkı yerine bu etikete işaret eden bir referans yazar.
Bunu (<code>-a</code> seçeneğiyle) anotasyonlu bir etiket oluşturarak görebilirsiniz :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m 'test tag'</code></pre>
</div>
</div>
<div class="paragraph">
<p>İşte oluşturduğu nesnenin SHA-1 değeri:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .git/refs/tags/v1.1
9585191f37f7b0fb9444f35a9bf50de191beadc2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Şimdi, bu SHA-1 değeri üzerinde <code>git cat-file -p</code> komutunu çalıştırın:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2
object 1a410efbd13591db07496601ebc7a059dd55cfe9
type commit
tag v1.1
tagger Scott Chacon &lt;schacon@gmail.com&gt; Sat May 23 16:48:58 2009 -0700

test tag</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nesne girişinin etiketlediğiniz SHA-1 katkı değerini işaret ettiğine dikkat edin.
Ayrıca bir katkıya işaret etmesi gerekmediğine de dikkat edin; herhangi bir Git nesnesini etiketleyebilirsiniz.
Örneğin Git kaynak kodunda, bakımcı GPG ortak anahtarını bir blob nesnesi olarak ekledi ve ardından onu etiketledi.
Bunu Git reposunun bir kopyasında çalıştırarak ortak anahtarı görüntüleyebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file blob junio-gpg-pub</code></pre>
</div>
</div>
<div class="paragraph">
<p>Linux çekirdeği reposunda aynı zamanda katkı dışı işaret eden bir etiket nesnesi bulunur: kaynak kodun içe aktarımının ilk ağacını işaret eden, oluşturulmuş ilk etiket.</p>
</div>
</div>
<div class="sect3">
<h3 id="_uzaklar">Uzaklar</h3>
<div class="paragraph">
<p>Göreceğiniz üçüncü referans türü uzak referanstır.
Origin’a bir uzak repo ekler ve bu repoya iterseniz, Git her dal için bu repoya en son neyi ittiğinizi <code>refs/remotes</code> dizininde saklar.
Örneğin, <code>origin</code> adında bir uzak repo ekleyebilir ve <code>master</code> dalını ona itebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add origin git@github.com:schacon/simplegit-progit.git
$ git push origin master
Counting objects: 11, done.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (7/7), 716 bytes, done.
Total 7 (delta 2), reused 4 (delta 1)
To git@github.com:schacon/simplegit-progit.git
  a11bef0..ca82a6d  master -&gt; master</code></pre>
</div>
</div>
<div class="paragraph">
<p>O zaman, sunucuyla en son iletişim kurduğunuz zaman <code>origin</code> uzak reposundaki <code>master</code> dalının ne olduğunu kontrol etmek için <code>refs/remotes/origin/master</code> dosyasına bakabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .git/refs/remotes/origin/master
ca82a6dff817ec66f44342007202690a93763949</code></pre>
</div>
</div>
<div class="paragraph">
<p>Uzak referanslar (<code>refs/remotes</code> referansları), dallarla (<code>refs/heads</code> referansları) karşılaştırıldığında, genellikle salt okunur olarak kabul edilir.
<code>git checkout</code> komutuyla buraya geçebilirsiniz, ancak Git onu HEAD ile işaretlemeyecektir; bu yüzden <code>commit</code> komutuyla asla güncellenmezler.
Git bunları, bu sunuculardaki dalların en son bilinen durumuna işaret eden yer işaretleri olarak yönetir.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>