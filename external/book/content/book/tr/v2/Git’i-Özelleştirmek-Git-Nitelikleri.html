---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: tr
  chapter:
    title: Git’i Özelleştirmek
    number: 8
  section:
    title: Git Nitelikleri
    number: 2
    cs_number: '8.2'
    previous: book/tr/v2/Git’i-Özelleştirmek-Git-Yapılandırması
    next: book/tr/v2/Git’i-Özelleştirmek-Git-Kancaları-Hooks
title: Git - Git Nitelikleri
url: "/book/tr/v2/Git’i-Özelleştirmek-Git-Nitelikleri.html"
---
<h2 id="_git_nitelikleri">Git Nitelikleri</h2>
<div class="paragraph">
<p>
Bu ayarlardan bazıları bir yol için de belirtilebilir, böylece Git bu ayarları yalnızca bir alt dizine veya dosyaların alt kümesine uygular.
Bu yola özel ayarlara Git nitelikleri adı verilir ve dizinlerinizden birindeki (normalde proje kök dizini) bir ".gitattributes" dosyasında ya da eğer öznitelik dosyasının projenizde katkılanmasını istemiyorsanız ".git/info/attributes" dosyasında ayarlanır.</p>
</div>
<div class="paragraph">
<p>Nitelikleri kullanarak, projenizdeki tek tek dosyalar veya dizinler için ayrı birleştirme stratejileri belirlemek, Git’e metin olmayan dosyaların farkını nasıl ayıracağını söylemek veya ekleme veya çıkarma yapmadan önce Git’in içeriği filtrelemesini sağlamak gibi şeyler yapabilirsiniz.
Bu bölümde Git proje dizinlerinizde ayarlayabileceğiniz bazı nitelikleri öğrenecek ve bu özelliğin pratikte kullanımına ilişkin birkaç örnek göreceksiniz.</p>
</div>
<div class="sect3">
<h3 id="_i̇kilik_binary_dosyalar">İkilik (Binary) Dosyalar</h3>
<div class="paragraph">
<p>
Git özniteliklerini kullanarak yapabileceğiniz harika bir hile, Git’e hangi dosyaların ikilik olduğunu (aksi halde bunu kendisinin belirleyemeyeceği durumlarda) ve bu dosyaların nasıl işleneceği konusunda özel talimatlar verme yeteneğidir.
Örneğin, bazı metin dosyaları makine tarafından oluşturulmuş olabilir ve farklanabilir (diff’i hesaplanabilir) olmayabilir, diğer yandan bazı ikili dosyalar ise farklanabilir olabilir.
Git’e bunların hangisi olduğunu nasıl söyleyeceğinizi göreceksiniz.</p>
</div>
<div class="sect4">
<h4 id="_i̇kilik_dosyaları_tanımlamak">İkilik Dosyaları Tanımlamak</h4>
<div class="paragraph">
<p>Bazı dosyalar metin dosyalarına benzer ancak her amaç için ikilik veri olarak işlenmelidir.
Örneğin, macOS’taki Xcode projeleri, IDE tarafından diske yazılan ve derleme ayarlarınızı vb. kaydeden bir JSON (düz metin JavaScript veri formatı) veri kümesi olan <code>.pbxproj</code> ile biten bir dosya içerir.
Teknik olarak bir metin dosyası olmasına rağmen (çünkü tümü UTF-8’dir), aslında mini bir bir veritabanı olduğu için, bunu öyle işlemek istemezsiniz. İçeriği iki kişi değiştirdiğinde birleştiremezsiniz ve farkları bulmak genellikle yardımcı olmaz.
Dosya bir makine tarafından tüketilmek üzere tasarlanmıştır.
Temelde, onu ikilik bir dosya gibi işlemek istersiniz.</p>
</div>
<div class="paragraph">
<p>Git’e tüm <code>pbxproj</code> dosyalarını ikilik veri olarak işlemesini söylemek için <code>.gitattributes</code> dosyanıza aşağıdaki satırı ekleyin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">*.pbxproj binary</code></pre>
</div>
</div>
<div class="paragraph">
<p>Artık Git, proje dosyalarınız üzerinde <code>git show</code> veya <code>git diff</code> komutunu çalıştırdığınızda bu dosyadaki değişiklikler için bir fark hesaplamaya veya yazdırmaya çalışmayacak; aynı zamanda CRLF sorunlarını çözmeye veya düzeltmeye de çalışmayacaktır.</p>
</div>
</div>
<div class="sect4">
<h4 id="_i̇kilik_dosyaların_farkını_diff_bulma">İkilik Dosyaların Farkını (Diff) Bulma</h4>
<div class="paragraph">
<p>Git öznitelikleri işlevselliğini kullanarak ikilik dosyaları etkin bir şekilde farklılaştırabilirsiniz.
Bunu, Git’e ikili verinizi normal diff aracılığıyla karşılaştırılabilir bir metin biçimine nasıl dönüştüreceğini söyleyerek yaparsınız.</p>
</div>
<div class="paragraph">
<p>Öncelikle, bu tekniği insanlık tarihinde bilinen en sinir bozucu sorunlardan birini çözmek için kullanacaksınız: Microsoft Word belgelerini sürüm kontrolüne almak.
İlginç şekilde, Word’ün en berbat metin düzenleyicisi olduğunu bilmesine rağmen, herkes halen onu kullanmaktadır.
Word belgelerini sürüm kontrolüne almak istiyorsanız, onları bir Git reposuna koyabilir ve ara sıra katkı işleyebilirsiniz. Peki bu ne işe yarar?
Normalde <code>git diff</code> komutunu çalıştırırsanız, yalnızca şunu görürsünüz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --git a/chapter1.docx b/chapter1.docx
index 88839c4..4afcb7c 100644
Binary files a/chapter1.docx and b/chapter1.docx differ</code></pre>
</div>
</div>
<div class="paragraph">
<p>İki sürümü doğrudan karşılaştıramazsınız, bunun için onları kontrol etmeniz ve manuel olarak taramanız gerekir, değil mi?
Git özniteliklerini kullanarak bunu kolayca yapabilirsiniz.
<code>.gitattributes</code> dosyanıza aşağıdaki satırı ekleyin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">*.docx diff=word</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu komut Git’e, eğer değişiklik içeren dosyaların değişimini görmek isterseniz, bu örüntüyle eşleşen herhangi bir dosyayla karşılaştığınızda, Git’in ``word`` filtresini kullanması gerektiğini söyler.
Peki ``word`` filtresi nedir?
Önce onu yapılandırmanız gerekir.
Burada, Git’in Word belgelerini okunabilir metin dosyalarına dönüştürmek için <code>docx2txt</code> programını kullanmasını yapılandırıyoruz, böylece bunların farkını doğru şekilde karşılaştırabilirsiniz.</p>
</div>
<div class="paragraph">
<p>Bunun için öncelikle, <code>docx2txt</code> 'yi kurmanız gerekecek; onu <a href="https://sourceforge.net/projects/docx2txt" class="bare">https://sourceforge.net/projects/docx2txt</a> adresinden indirebilirsiniz.
<code>INSTALL</code> dosyasındaki yönergeleri izleyerek, onu shell’inizin bulabileceği bir yere koyun.
Sonraki adımda, çıktıyı Git’in beklediği formata dönüştüren bir sargı betiği yazacaksınız.
Dizininizde <code>docx2txt</code> adında bir dosya oluşturun ve şu içeriği ekleyin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">#!/bin/bash
docx2txt.pl "$1" -</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dosyanın <code>chmod a+x</code> ile yürütülebilir olması gerektiğini unutmayın.
Son olarak, bu betiği kullanması için Git’i yapılandırabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config diff.word.textconv docx2txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>Artık Git, iki poz arasındaki farkı bulmaya çalışırken, dosyalardan herhangi birinin <code>.docx</code> uzantısıyla bittiğini görürse; bu dosyaları <code>docx2txt</code> programı olarak tanımlanan ``word`` filtresinden geçirmesi gerektiğini bilir.
Böylece, ilgili dosyaların farkını bulmadan önce, onları metin tabanlı sürümlere dönüştürür.</p>
</div>
<div class="paragraph">
<p>İşte bir örnek:
Bu kitabın 1. bölümü Word biçimine dönüştürüldü ve bir Git reposuna katkılandı.
Ardından, yeni bir paragraf daha eklendi.
İşte <code>git diff</code> komutunun şu anda gösterdiği sonuç:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --git a/chapter1.docx b/chapter1.docx
index 0b013ca..ba25db5 100644
--- a/chapter1.docx
+++ b/chapter1.docx
@@ -2,6 +2,7 @@
 This chapter will be about getting started with Git. We will begin at the beginning by explaining some background on version control tools, then move on to how to get Git running on your system and finally how to get it setup to start working with. At the end of this chapter you should understand why Git is around, why you should use it and you should be all setup to do so.
 1.1. About Version Control
 What is "version control", and why should you care? Version control is a system that records changes to a file or set of files over time so that you can recall specific versions later. For the examples in this book you will use software source code as the files being version controlled, though in reality you can do this with nearly any type of file on a computer.
+Testing: 1, 2, 3.
 If you are a graphic or web designer and want to keep every version of an image or layout (which you would most certainly want to), a Version Control System (VCS) is a very wise thing to use. It allows you to revert files back to a previous state, revert the entire project back to a previous state, compare changes over time, see who last modified something that might be causing a problem, who introduced an issue and when, and more. Using a VCS also generally means that if you screw things up or lose files, you can easily recover. In addition, you get all this for very little overhead.
 1.1.1. Local Version Control Systems
 Many people's version-control method of choice is to copy files into another directory (perhaps a time-stamped directory, if they're clever). This approach is very common because it is so simple, but it is also incredibly error prone. It is easy to forget which directory you're in and accidentally write to the wrong file or copy over files you don't mean to.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git bize eklediğimiz "Testing: 1, 2, 3." dizesini doğru bir şekilde bildiriyor.
Belki mükemmel değil - biçim (font, büyüklük, vs) değişikliklerini göremezsiniz - ama kesinlikle işe yarıyor.</p>
</div>
<div class="paragraph">
<p>Bu şekilde çözebileceğiniz başka ilginç bir sorun da resim dosyalarını farklılaştırmaktır.
Bunu yapmanın yollarından biri, resim dosyalarını EXIF bilgilerini (çoğu resim formatında kaydedilmekte olan metaveriler) çıkaran bir filtreden geçirmektir.
<code>exiftool</code> programını indirip kurarsanız, onu resimlerinizi metaveri içeren metin biçiminde dönüştürmek için kullanabilirsiniz. Böylece fark en azından yapılan herhangi bir değişikliğin metinleştirilmiş halini gösterir.
<code>.gitattributes</code> dosyanıza şu satırı ekleyin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">*.png diff=exif</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git’i bu aracı kullanması için yapılandırın:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config diff.exif.textconv exiftool</code></pre>
</div>
</div>
<div class="paragraph">
<p>Projede bir resmi değiştirirseniz ve <code>git diff</code> komutunu çalıştırırsanız, şuna benzer bir şey görürsünüz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-diff" data-lang="diff">diff --git a/image.png b/image.png
index 88839c4..4afcb7c 100644
--- a/image.png
+++ b/image.png
@@ -1,12 +1,12 @@
 ExifTool Version Number         : 7.74
-File Size                       : 70 kB
-File Modification Date/Time     : 2009:04:21 07:02:45-07:00
+File Size                       : 94 kB
+File Modification Date/Time     : 2009:04:21 07:02:43-07:00
 File Type                       : PNG
 MIME Type                       : image/png
-Image Width                     : 1058
-Image Height                    : 889
+Image Width                     : 1056
+Image Height                    : 827
 Bit Depth                       : 8
 Color Type                      : RGB with Alpha</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dosya boyutu ve görüntü boyutlarının her ikisinin de değiştiğini kolayca görebilirsiniz.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_keyword_expansion">Anahtar Kelime Genişletmesi</h3>
<div class="paragraph">
<p>
SVN veya CVS tarzı anahtar kelime genişletmesi, bu sistemlere alışkın olan geliştiriciler tarafından sıkça istenir.
Git’teki temel sorun şudur ki, Git öncelikle dosyanın özetini çıkardığı için, bir dosya katkılandıktan sonra, katkı hakkında bilgi içeren bir dosyayı değiştiremezsiniz.
Ancak, bir dosya katkılanırken içine metin ekleyebilir ve katkı işlenmeden önce tekrar kaldırabilirsiniz.
Git öznitelikleri size bunu yapmanın iki yolunu sunar.</p>
</div>
<div class="paragraph">
<p>İlk olarak, bir dosyadaki <code>$Id$</code> alanına otomatik olarak bir blokun SHA-1 özeti enjekte edebilirsiniz.
Bu özniteliği bir dosyaya veya dosya kümesine ayarlarsanız, bir sonraki sefer o dala geçtiğinizde, Git bu alanı blokun SHA-1’i ile değiştirir.
Önemli olan, bu özetin katkının SHA-1’i değil, bloğun kendi SHA-1’i olduğunu bilmenizdir.
Şimdi <code>.gitattributes</code> dosyanıza şu satırı ekleyin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">*.txt ident</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bir test dosyasına bir <code>$Id$</code> referansı ekleyin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo '$Id$' &gt; test.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bir sonraki sefer bu dosyayı çıkardığınızda, Git blokun SHA-1 özetini enjekte eder:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ rm test.txt
$ git checkout -- test.txt
$ cat test.txt
$Id: 42812b7653c7b88933f8a9d6cad0ca16714b9bb3 $</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ancak, bu sonuç sınırlı bir kullanıma sahiptir.
Eğer CVS veya Subversion’da anahtar kelime yerine başka bir şey koyduysanız (mesela bir tarih damgası ekleyebilirsiniz); SHA-1 rasgele üretilen bir karma olduğu için, bir SHA-1’in diğerinden daha eski veya daha yeni olup olmadığını sadece bakarak anlayamazsınız.</p>
</div>
<div class="paragraph">
<p>Dosya işleme/çıkarma işlemlerinde yerine koyma yapmak için kendi filtrelerinizi yazabilirsiniz.
Bunlara <code>clean</code> (temizleme, arındırma) ve <code>smudge</code> (lekeleme, bulaştırma) filtreleri denir.
<code>.gitattributes</code> dosyasında, belirli dizinlere bir filtre belirleyebilir ve dosyaları çıkarmadan hemen önce ("smudge", bkz. <a href="{{< relurl "book/tr/v2/ch00/filters_a" >}}">``smudge`` filtresi checkout işleminde çalışıyor.</a>) veya izleme alınmadan hemen önce ("clean", bkz. <a href="{{< relurl "book/tr/v2/ch00/filters_b" >}}">``clean`` filtresi stage işleminde çalışıyor.</a>) çalışacak betikler kurabilirsiniz.
Bu filtreler çeşitli eğlenceli işlemleri gerçekleştirmek üzere ayarlanabilir.</p>
</div>
<div id="filters_a" class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/smudge.png" >}}" alt="``smudge`` filtresi checkout işleminde çalışıyor.">
</div>
<div class="title">Görsel 143. ``smudge`` filtresi checkout işleminde çalışıyor.</div>
</div>
<div id="filters_b" class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/clean.png" >}}" alt="``clean`` filtresi stage işleminde çalışıyor.">
</div>
<div class="title">Görsel 144. ``clean`` filtresi stage işleminde çalışıyor.</div>
</div>
<div class="paragraph">
<p>Bu özelliğin orijinal katkı mesajı, tüm C kaynak kodlarınızı katkılamadan önce <code>indent</code> programından geçirmenin basit bir örneğini verir.
<code>.gitattributes</code> dosyanızdaki filtre özniteliğini <code>*.c</code> dosyalarını ``indent`` filtresi ile süzmek üzere ayarlayarak bunu kurabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">*.c filter=indent</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ardından, Git’e ``indent`` filtresinin "smudge" ve "clean" işlemlerinde ne yapacağını söyleyin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global filter.indent.clean indent
$ git config --global filter.indent.smudge cat</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu durumda, <code>*.c</code> ile eşleşen dosyaları katkıladığınızda, Git önce onları izleme almadan önce indent programından geçirecek ve sonra onları diske geri çıkarmadan önce de <code>cat</code> programından geçirecektir.
<code>cat</code> programı aslında hiçbir şey yapmaz: aldığı veriyi aynı şekilde verir.
Bu kombinasyon, katkı işlemeden önce tüm C kaynak kodu dosyalarını <code>indent</code> ile filtreler.</p>
</div>
<div class="paragraph">
<p>Başka bir ilginç örnek, <code>$Date$</code> anahtar kelime genişlemesidir, RCS stili.
Bunu düzgün yapmak için, bir dosya adını alıp, bu projenin son katkı tarihini bulan ve tarihi dosyaya yerleştiren küçük bir betik gerekmektedir.
İşte bunu yapan küçük bir Ruby betiği:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby
data = STDIN.read
last_date = `git log --pretty=format:"%ad" -1`
puts data.gsub('$Date$', '$Date: ' + last_date.to_s + '$')</code></pre>
</div>
</div>
<div class="paragraph">
<p>Betik, yalnızca <code>git log</code> komutundan en son katkı tarihini alır, bunu stdin’de gördüğü herhangi bir <code>$Date$</code> dizesine yerleştirip, sonuçları yazdırır - bu işlemi isteğiniz dilde kolayca yapabilirsiniz.
Bu dosyayı <code>expand_date</code> adıyla adlandırıp, dizininize ekleyebilirsiniz.
Şimdi, Git’te (<code>dater</code> olarak adlandıracağınız) bir filtre kurmanız gerekiyor ve çıkışta dosyaları bulaştırmak (smudge) için <code>expand_date</code> filtresini kullanmasını söyleyin.
Bunu katkıda temizlemek (clean) için bir Perl ifadesi kullanılacaktır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config filter.dater.smudge expand_date
$ git config filter.dater.clean 'perl -pe "s/\\\$Date[^\\\$]*\\\$/\\\$Date\\\$/"'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu Perl kodcuğu, <code>$Date$</code> dizesinde gördüğü her şeyi ayıklar ve başlangıç durumuna geri döner.
Artık filtre hazır olduğuna göre, yeni filtreyi devreye sokan ve <code>$Date$</code> anahtarını içeren bir dosya oluşturarak test edebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">date*.txt filter=dater</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo '# $Date$' &gt; date_test.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu değişiklikleri yapıp ve dosyayı kontrol ederseniz, anahtar kelime doğru şekilde değiştirilmiş olacaktır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add date_test.txt .gitattributes
$ git commit -m "Testing date expansion in Git"
$ rm date_test.txt
$ git checkout date_test.txt
$ cat date_test.txt
# $Date: Tue Apr 21 07:26:52 2009 -0700$</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu tekniğin özelleştirilmiş uygulamalar için ne kadar güçlü olabileceğini görebilirsiniz.
Ancak dikkatli olmanız gerekir: çünkü <code>.gitattributes</code> dosyası projeye dahil edilir ve projeyle birlikte dolaşır, ancak sürücü (bu durumda <code>dater</code>) dahil edilmez; bu yüzden her yerde çalışmayabilir.
Bu filtreleri tasarlarken şunu hedefleyin: bunlar başarısız olurken bile bunu zarif bir şekilde yapmalı ve projenin düzgün çalışmasını engellememesi gerekir.</p>
</div>
</div>
<div class="sect3">
<h3 id="_repoyu_dışa_aktarma">Repoyu Dışa Aktarma</h3>
<div class="paragraph">
<p>
Git öznitelik verileri, proje arşivini dışa aktarırken bazı ilginç işlemler yapmanıza olanak tanır.</p>
</div>
<div class="sect4">
<h4 id="_export_ignore"><code>export-ignore</code></h4>
<div class="paragraph">
<p>Arşiv oluşturulurken belirli dosyaların veya dizinlerin dışa aktarılmamasını söyleyebilirsiniz.
Projenizin arşiv dosyasına dahil etmek istemediğiniz ancak projenizde kontrol edilmesini istediğiniz bir alt dizin veya dosya varsa, bu dosyaları <code>export-ignore</code> özniteliği aracılığıyla belirleyebilirsiniz.</p>
</div>
<div class="paragraph">
<p>Örneğin, bir <code>test/</code> alt dizininde bazı test dosyalarınız var ve bu dosyaların projenizin arşiv tar dosyasına dahil edilmesi mantıklı değilse, aşağıdaki satırı Git öznitelik dosyanıza ekleyebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">test/ export-ignore</code></pre>
</div>
</div>
<div class="paragraph">
<p>Artık projenizin bir arşiv tar dosyasını oluşturmak için <code>git archive</code> komutunu çalıştırdığınızda, bu dizin arşivde yer almayacak.</p>
</div>
</div>
<div class="sect4">
<h4 id="_export_subst"><code>export-subst</code></h4>
<div class="paragraph">
<p>Dağıtım için dosyaları dışa aktarırken, <code>export-subst</code> özniteliğiyle işaretlenmiş dosyaların belirli bölümlerine <code>git log</code> 'un biçimlendirme ve anahtar-kaynak genişletme işlemi uygulayabilirsiniz.</p>
</div>
<div class="paragraph">
<p>Projenize bir <code>LAST_COMMIT</code> adlı bir dosya eklemek ve <code>git archive</code> çalıştığında son taahhüt hakkında otomatik olarak meta verileri enjekte etmek isterseniz, <code>.gitattributes</code> ve <code>LAST_COMMIT</code> dosyalarınızı örneğin aşağıdaki gibi ayarlayabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">LAST_COMMIT export-subst</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 'Last commit date: $Format:%cd by %aN$' &gt; LAST_COMMIT
$ git add LAST_COMMIT .gitattributes
$ git commit -am 'adding LAST_COMMIT file for archives'</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>git archive</code> komutunu çalıştırdığınızda, arşivlenmiş dosyanın içeriği şöyle görünecektir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git archive HEAD | tar xCf ../deployment-testing -
$ cat ../deployment-testing/LAST_COMMIT
Last commit date: Tue Apr 21 08:38:48 2009 -0700 by Scott Chacon</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dönüşümler, örneğin katkı mesajını ve herhangi bir <code>git notes</code> içerebilir veya <code>git log</code> basit kelime sarmalama yapabilir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo '$Format:Last commit: %h by %aN at %cd%n%+w(76,6,9)%B$' &gt; LAST_COMMIT
$ git commit -am 'export-subst uses git log'\''s custom formatter

git archive uses git log'\''s `pretty=format:` processor
directly, and strips the surrounding `$Format:` and `$`
markup from the output.
'
$ git archive @ | tar xfO - LAST_COMMIT
Last commit: 312ccc8 by Jim Hill at Fri May 8 09:14:04 2015 -0700
       export-subst uses git log's custom formatter

         git archive uses git log's `pretty=format:` processor directly, and
         strips the surrounding `$Format:` and `$` markup from the output.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Oluşan arşiv, dağıtım çalışması için uygun olsa da, herhangi bir dışa aktarılmış arşiv gibi, daha fazla geliştirme çalışmasına uygun değildir.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_birleştirme_stratejileri">Birleştirme Stratejileri</h3>
<div class="paragraph">
<p>
Projedeki belirli dosyalar için farklı birleştirme stratejileri kullanmasını söylemek için de Git özniteliklerini kullanabilirsiniz.
Çok kullanışlı bir seçenek, belirli dosyaların çakışmaları olduğunda Git’in bu dosyaları birleştirmeye çalışmamasını, bunun yerine çakışma olduğunda sizin kodunuzu başkasınınkinin üzerine yazmasını istemektir.</p>
</div>
<div class="paragraph">
<p>Bu, bir projedeki bir dalın ayrıştığı veya özelleştiği, ancak bu dalı geri birleştirmek istediğinizde belirli dosyaları yok saymak istediğiniz durumlarda faydalıdır.
Örneğin, iki dalda farklı olan <code>database.xml</code> adında bir veritabanı ayar dosyanız varsa ve veritabanı dosyasını bozmadan diğer daldan birleştirmek istiyorsanız, şöyle bir öznitelik kurabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">database.xml merge=ours</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ve ardından bir <code>ours</code> birleştirme stratejisi tanımlayın:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global merge.ours.driver true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Diğer dalı birleştirirseniz, <code>database.xml</code> dosyasında birleştirme çakışmaları yerine şunu görürsünüz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge topic
Auto-merging database.xml
Merge made by recursive.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu durumda, <code>database.xml</code> dosyası, ilk başta sahip olduğunuz sürümde kalır.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>