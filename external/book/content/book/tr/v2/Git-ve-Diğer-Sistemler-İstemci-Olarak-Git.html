---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: tr
  chapter:
    title: Git ve Diğer Sistemler
    number: 9
  section:
    title: İstemci Olarak Git
    number: 1
    cs_number: '9.1'
    previous: book/tr/v2/Git’i-Özelleştirmek-Özet
    next: book/tr/v2/Git-ve-Diğer-Sistemler-Git’e-Geçiş
title: Git - İstemci Olarak Git
url: "/book/tr/v2/Git-ve-Diğer-Sistemler-İstemci-Olarak-Git.html"
---
<p>Dünya malesef mükemmel değil.
Genellikle, dokunduğunuz her projeyi hemen Git’e geçiremezsiniz.
Bazen başka bir VCS kullanan bir projede sıkışıp kalırsınız ve onun Git olmasını dilersiniz.
Bu bölümün ilk kısmında, üzerinde çalıştığınız proje başka bir sistemde barındırıldığında, Git’i istemci olarak nasıl kullanabileceğiniz hakkında bilgi edineceksiniz.</p><p>Bir noktada, mevcut projenizi Git’e dönüştürmek isteyebilirsiniz.
Bu bölümün ikinci kısmı, projenizi birkaç belirli sistemden Git’e nasıl taşıyacağınızı kapsar. Ayrıca önceden yapılandırılmış bir içe aktarma aracı mevcut değilse kullanabileceğiniz bir yöntemi de içerir.</p>
<h2 id="_i̇stemci_olarak_git">İstemci Olarak Git</h2>
<div class="paragraph">
<p>
Geliştiriciler için Git, o kadar güzel bir deneyim sunar ki, birçok insan ekibin geri kalanının tamamen farklı bir VCS kullandığı durumlarda bile onu kendi çalışma istasyonlarında nasıl kullanacaklarını bulmuştur.
Bu bağdaştırıcılardan bazılarına "köprüler" denir ve sayıları pek çoktur.
Burada vahşi doğada karşılaşmanız en olası olanları ele alacağız.</p>
</div>
<div class="sect3">
<h3 id="_git_svn">Git ve Subversion</h3>
<div class="paragraph">
<p>
Subversion, kaynak kodlarını yönetmek için çoğu açık kaynak geliştirme projesin ve birçok kurumsal proje tarafından kullanılmaktadır.
On yıldan fazla bir süredir mevcuttur ve çoğu zaman açık kaynak projeleri için <em>de facto</em> VCS seçimi olmuştur.
Ayrıca, CVS öncesi kaynak kontrol dünyasının büyük oyuncusu olan CVS ile birçok açıdan benzerdir.</p>
</div>
<div class="paragraph">
<p>
Git’in harika özelliklerinden biri, <code>git svn</code> olarak adlandırılan Subversion’a iki yönlü bir köprüdür.
Bu araç, Git’i bir Subversion sunucusuna geçerli bir istemci olarak kullanmanızı sağlar, böylece Git’in tüm yerel özelliklerini kullanabilir ve ardından sanki yerel olarak Subversion kullanıyormuş gibi bir Subversion sunucusuna gönderebilirsiniz.
Bunun anlamı iş arkadaşlarınızın karanlık ve eski yöntemlerle çalışmaya devam ederken, sizin yerel dal oluşturma, birleştirme, izleme alanı kullanma, yeniden temelleme ve cherry-picking gibi işlemleri yapabilmenizdir.
Bu Git’i kurumsal ortamınıza sızdırmanın ve altyapının tamamen Git’i destekleyecek şekilde değiştirilmesi için lobi yaparken, diğer geliştiricilerinizi daha verimli hale getirmenin iyi bir yoludur.
Subversion köprüsü, DVCS dünyasına giriş ilacıdır.</p>
</div>
<div class="sect4">
<h4 id="_git_svn_2"><code>git svn</code></h4>
<div class="paragraph">
<p>Git’in tüm Subversion köprüleme komutları için temel komutu <code>git svn</code> 'dir.
Birkaç basit iş akışını incelerken en yaygın olanlarını göstereceğiz.</p>
</div>
<div class="paragraph">
<p><code>git svn</code> kullanırken, Git’ten çok farklı bir çalışma sistemine sahip olan Subversion ile etkileşimde bulunduğunuzu unutmamalısınız.
Yerel dal oluşturup birleştirebilirsiniz, ancak genellikle çalışmanızı yeniden temelleyerek mümkün olduğunca çizgisel tutmak ve bir Git uzak deposuyla eş zamanlı etkileşimde bulunmaktan kaçınmak en iyisidir.</p>
</div>
<div class="paragraph">
<p>Geçmişinizi yeniden yazıp, tekrar göndermeye çalışmayın ve bir Git reposuna başka geliştiricilerle eş zamanlı itmeye çalışmayın.
Subversion yalnızca tek bir çizgisel geçmişe sahip olabilir ve onun kafasını karıştırmak çok kolaydır.
Bir ekip ile çalışıyorsanız ve bazıları SVN kullanırken diğerleri Git kullanıyorsa, herkesin işbirliği yapmak için SVN sunucusunu kullandığından emin olun (bu hayatınızı kolaylaştıracaktır).</p>
</div>
</div>
<div class="sect4">
<h4 id="_kurulum_2">Kurulum</h4>
<div class="paragraph">
<p>Bu işlevselliği göstermek için yazma erişiminiz olan tipik bir SVN reposuna ihtiyacınız var.
Bu örnekleri kopyalamak istiyorsanız, yazılabilir bir SVN test reposunun bir kopyasını oluşturmanız gerekecektir.
Bunu kolayca yapmak için, Subversion ile birlikte gelen <code>svnsync</code> adlı bir aracı kullanabilirsiniz.</p>
</div>
<div class="paragraph">
<p>Takip edebilmek için önce yeni bir yerel Subversion reposu oluşturmanız gerekiyor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ mkdir /tmp/test-svn
$ svnadmin create /tmp/test-svn</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sonra, tüm kullanıcıların revprops’ları değiştirmesine izin verin: kolay yol, her zaman 0 (sıfır) çıkışlı bir <code>pre-revprop-change</code> betiği eklemektir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat /tmp/test-svn/hooks/pre-revprop-change
#!/bin/sh
exit 0;
$ chmod +x /tmp/test-svn/hooks/pre-revprop-change</code></pre>
</div>
</div>
<div class="paragraph">
<p>Şimdi <code>svnsync init</code> komutunu "to" ve "from" repolarıyla kullanarak bu projeyi yerel makinenize senkronize edebilirsiniz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ svnsync init file:///tmp/test-svn \
  http://your-svn-server.example.org/svn/</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu komut senkronizasyonu çalıştırmak için özellikleri ayarlar.
Kodu kopyalamak için şunu çalıştırabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ svnsync sync file:///tmp/test-svn
Committed revision 1.
Copied properties for revision 1.
Transmitting file data .............................[...]
Committed revision 2.
Copied properties for revision 2.
[…]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu işlem normalde sadece birkaç dakika sürmesine rağmen, eğer orijinal repoyu başka bir uzak repoya kopyalamaya çalışırsanız, neredeyse bir saat sürecektir (100’den az katkı olsa bile).
Subversion her bir revizyonu tek tek kopyalamak ve ardından başka bir repoya geri itmek zorundadır.
Gülünç derecede verimsiz olmasına rağmen, bunu yapmanın tek kolay yolu budur.</p>
</div>
</div>
<div class="sect4">
<h4 id="_başlarken">Başlarken</h4>
<div class="paragraph">
<p>Şimdi yazma erişimimiz olan bir Subversion reposuna sahip olduğumuza göre, tipik bir iş akışının üzerinden geçebiliriz.
Bir Subversion reposunu yerel bir Git reposuna aktaran <code>git svn clone</code> komutuyla başlayacağız.
Eğer canlıda olan gerçek bir Subversion reposundan içe aktarıyorsanız, buradaki <code>file:///tmp/test-svn</code> 'yi Subversion reposunuzun URL’siyle değiştirmeyi unutmayın:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn clone file:///tmp/test-svn -T trunk -b branches -t tags
Initialized empty Git repository in /private/tmp/progit/test-svn/.git/
r1 = dcbfb5891860124cc2e8cc616cded42624897125 (refs/remotes/origin/trunk)
    A	m4/acx_pthread.m4
    A	m4/stl_hash.m4
    A	java/src/test/java/com/google/protobuf/UnknownFieldSetTest.java
    A	java/src/test/java/com/google/protobuf/WireFormatTest.java
…
r75 = 556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae (refs/remotes/origin/trunk)
Found possible branch point: file:///tmp/test-svn/trunk =&gt; file:///tmp/test-svn/branches/my-calc-branch, 75
Found branch parent: (refs/remotes/origin/my-calc-branch) 556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae
Following parent with do_switch
Successfully followed parent
r76 = 0fb585761df569eaecd8146c71e58d70147460a2 (refs/remotes/origin/my-calc-branch)
Checked out HEAD:
  file:///tmp/test-svn/trunk r75</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu girdiğiniz URL üzerinde <code>git svn init</code> ve ardından <code>git svn fetch</code> komutlarının eşdeğerini çalıştırır.
İşlemin gerçekleşmesi biraz zaman alabilir.
Örneğin, test projesinde yaklaşık 75 katkı varsa ve kod tabanı çok büyük değilse, Git yine de her sürümü tek tek kontrol etmeli ve bunu bireysel olarak katkılamaladır.
Yüzlerce veya binlerce katkı içeren bir proje için, bunun tamamlanması gerçekten saatler, hatta günler alabilir.</p>
</div>
<div class="paragraph">
<p><code>-T trunk -b branches -t tags</code> kısmı, bu Subversion reposunun temelleme ve etiketleme kurallarını takip ettiğini Git’e belirtir.
Eğer ana dalınızı (trunk), dallarınızı veya etiketlerinizi farklı adlandırırsanız, bu seçenekleri değiştirebilirsiniz.
Bu çok yaygın olduğu için, ilgili kısmı -s ile değiştirebilirsiniz: bu standart düzeni ima eder ve tüm bu seçenekleri içerir.
Aşağıdaki komuta eşdeğerdir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn clone file:///tmp/test-svn -s</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu noktada, dallarınızı ve etiketlerinizi içe aktarmış geçerli bir Git reponuz olmalıdır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch -a
* master
  remotes/origin/my-calc-branch
  remotes/origin/tags/2.0.2
  remotes/origin/tags/release-2.0.1
  remotes/origin/tags/release-2.0.2
  remotes/origin/tags/release-2.0.2rc1
  remotes/origin/trunk</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu aracın Subversion etiketlerini uzak referanslar olarak nasıl yönettiğine dikkat edin.

Git tesisat (plumbing) komutu <code>show-ref</code> ile daha yakından inceleyelim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show-ref
556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae refs/heads/master
0fb585761df569eaecd8146c71e58d70147460a2 refs/remotes/origin/my-calc-branch
bfd2d79303166789fc73af4046651a4b35c12f0b refs/remotes/origin/tags/2.0.2
285c2b2e36e467dd4d91c8e3c0c0e1750b3fe8ca refs/remotes/origin/tags/release-2.0.1
cbda99cb45d9abcb9793db1d4f70ae562a969f1e refs/remotes/origin/tags/release-2.0.2
a9f074aa89e826d6f9d30808ce5ae3ffe711feda refs/remotes/origin/tags/release-2.0.2rc1
556a3e1e7ad1fde0a32823fc7e4d046bcfd86dae refs/remotes/origin/trunk</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git, bir Git sunucusundan kopyaladığında bunu yapmaz; işte taze bir kopya sonrası etiketlere sahip bir reponun görüntüsü:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show-ref
c3dcbe8488c6240392e8a5d7553bbffcb0f94ef0 refs/remotes/origin/master
32ef1d1c7cc8c603ab78416262cc421b80a8c2df refs/remotes/origin/branch-1
75f703a3580a9b81ead89fe1138e6da858c5ba18 refs/remotes/origin/branch-2
23f8588dde934e8f33c263c6d8359b2ae095f863 refs/tags/v0.1.0
7064938bd5e7ef47bfd79a685a62c1e2649e2ce7 refs/tags/v0.2.0
6dcb09b5b57875f334f61aebed695e2e4193db5e refs/tags/v1.0.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git etiketleri uzak dallar gibi işlemek yerine doğrudan <code>refs/tags</code> içine çeker.</p>
</div>
</div>
<div class="sect4">
<h4 id="_katkıları_subversiona_i̇şlemek">Katkıları Subversion’a İşlemek</h4>
<div class="paragraph">
<p>Artık bir çalışma dizininiz olduğuna göre, Git’i bir SVN istemcisi olarak etkili bir şekilde kullanarak proje üzerinde biraz çalışabilir ve katkılarınızı üst-akıma itebilirsiniz.
Dosyalardan birini düzenleyip katkılarsanız, Git’te yerel olarak işlenmiş ancak henüz Subversion sunucusunda bulunmayan bir katkıya sahip olursunuz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git commit -am 'Adding git-svn instructions to the README'
[master 4af61fd] Adding git-svn instructions to the README
 1 file changed, 5 insertions(+)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sonraki adım, değişikliklerinizi yukarı akıma itmektir.
Subversion ile çalışma şeklinizin değiştiğine dikkat edin: çevrimdışı olarak birkaç katkı yapabilir ve ardından hepsini aynı anda Subversion sunucusuna itebilirsiniz.
Bir Subversion sunucusuna itmek için <code>git svn dcommit</code> komutunu çalıştırırsınız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	README.txt
Committed r77
    M	README.txt
r77 = 95e0222ba6399739834380eb10afcd73e0670bc5 (refs/remotes/origin/trunk)
No changes between 4af61fd05045e07598c553167e0f31c84fd6ffe1 and refs/remotes/origin/trunk
Resetting to the latest refs/remotes/origin/trunk</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu, Subversion sunucusu kodunun üstüne yaptığınız tüm katkıları alır, her biri için bir Subversion katkısı yapar ve ardından yerel Git katkınızı benzersiz bir kimlik içerecek şekilde yeniden yazar.
Bu tüm katkılarınızın SHA-1 kontrol toplamlarının değiştiği anlamına gelmesi yönünden önemlidir.
Kısmen bu nedenle, eşzamanlı olarak projelerinizin Git tabanlı uzak sürümleriyle ve bir Subversion sunucusuyla çalışmak iyi bir fikir değildir.
Son katkıya baktığınızda, eklenen yeni `git-svn-id`yi görebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -1
commit 95e0222ba6399739834380eb10afcd73e0670bc5
Author: ben &lt;ben@0b684db3-b064-4277-89d1-21af03df0a68&gt;
Date:   Thu Jul 24 03:08:36 2014 +0000

    Adding git-svn instructions to the README

    git-svn-id: file:///tmp/test-svn/trunk@77 0b684db3-b064-4277-89d1-21af03df0a68</code></pre>
</div>
</div>
<div class="paragraph">
<p>İlk olarak katkıladığınız <code>4af61fd</code> ile başlayan SHA-1 kontrol toplamının şimdi <code>95e0222</code> ile başladığını görüyorsunuz.
Eğer hem bir Git sunucusuna hem de bir Subversion sunucusuna itmek istiyorsanız, katkı verilerinizin değişmesi nedeniyle önce Subversion sunucusuna (<code>dcommit</code>) itmelisiniz.</p>
</div>
</div>
<div class="sect4">
<h4 id="_yeni_değişiklikleri_çekmek">Yeni Değişiklikleri Çekmek</h4>
<div class="paragraph">
<p>Diğer geliştiricilerle çalışıyorsanız, o zaman biriniz bir noktada kodunu itecek ve ardından diğeri öbürüyle çakışan bir değişiklik itmeye çalışacaktır.
Bu değişiklik, siz onların çalışmasını kendinizinkiyle birleştirmedikçe reddedilecektir.
<code>git svn</code> 'de durum şöyle görünür:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...

ERROR from SVN:
Transaction is out of date: File '/trunk/README.txt' is out of date
W: d5837c4b461b7c0e018b49d12398769d2bfc240a and refs/remotes/origin/trunk differ, using rebase:
:100644 100644 f414c433af0fd6734428cf9d2a9fd8ba00ada145 c80b6127dd04f5fcda218730ddf3a2da4eb39138 M	README.txt
Current branch master is up to date.
ERROR: Not all changes have been committed into SVN, however the committed
ones (if any) seem to be successfully integrated into the working tree.
Please see the above messages for details.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu durumu çözmek için <code>git svn rebase</code> komutunu çalıştırabilirsiniz.
Bu komut, sunucudaki henüz sahip olmadığınız tüm değişiklikleri indirir ve yaptığınız çalışmayı sunucudaki mevcut durumun üstüne yerleştirir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn rebase
Committing to file:///tmp/test-svn/trunk ...

ERROR from SVN:
Transaction is out of date: File '/trunk/README.txt' is out of date
W: eaa029d99f87c5c822c5c29039d19111ff32ef46 and refs/remotes/origin/trunk differ, using rebase:
:100644 100644 65536c6e30d263495c17d781962cfff12422693a b34372b25ccf4945fe5658fa381b075045e7702a M	README.txt
First, rewinding head to replay your work on top of it...
Applying: update foo
Using index info to reconstruct a base tree...
M	README.txt
Falling back to patching base and 3-way merge...
Auto-merging README.txt
ERROR: Not all changes have been committed into SVN, however the committed
ones (if any) seem to be successfully integrated into the working tree.
Please see the above messages for details.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Şimdi, tüm çalışmanız Subversion sunucusundaki durumun üstüne yerleşmiş olduğu için, başarıyla <code>dcommit</code> yapabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	README.txt
Committed r85
    M	README.txt
r85 = 9c29704cc0bbbed7bd58160cfb66cb9191835cd8 (refs/remotes/origin/trunk)
No changes between 5762f56732a958d6cfda681b661d2a239cc53ef5 and refs/remotes/origin/trunk
Resetting to the latest refs/remotes/origin/trunk</code></pre>
</div>
</div>
<div class="paragraph">
<p>Kodunuzu itmeden önce henüz sahip olmadığınız değişikleri yukarı akımdan çekmenizi gerektiren Git’in aksine, <code>git svn</code> bunu ancak değişiklikler çakıştığında yapmanızı gerektirir (Subversion’ın çalışma şekli gibi).
Birisi bir dosyaya bir değişiklik yaptıktan sonra siz de başka bir dosyada bir değişiklik yaparsanız, <code>dcommit</code> sorunsuz çalışacaktır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	configure.ac
Committed r87
    M	autogen.sh
r86 = d8450bab8a77228a644b7dc0e95977ffc61adff7 (refs/remotes/origin/trunk)
    M	configure.ac
r87 = f3653ea40cb4e26b6281cec102e35dcba1fe17c4 (refs/remotes/origin/trunk)
W: a0253d06732169107aa020390d9fefd2b1d92806 and refs/remotes/origin/trunk differ, using rebase:
:100755 100755 efa5a59965fbbb5b2b0a12890f1b351bb5493c18 e757b59a9439312d80d5d43bb65d4a7d0389ed6d M	autogen.sh
First, rewinding head to replay your work on top of it...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Kodunuzu ittiğinizde herhangi birinizin bilgisayarında var olmayan bir proje durumu elde edeceğiniz için bu önemlidir.
Değişiklikler ister uyumsuz olsun ister çakışmasın, teşhis etmesi zor sorunlarla karşılaşabilirsiniz.
Bu bir Git sunucusu kullanmaktan farklıdır: Git’te, yayınlamadan önce istemcinizdeki durumu tamamen test edebilirsiniz, SVN’de ise katkı öncesi ve sonrası durumların aynı olduğundan kesinlikle emin olamazsınız.</p>
</div>
<div class="paragraph">
<p>Kendiniz katkı işlemeye hazır olmasanız bile, bu komutu Subversion sunucusundan değişiklikleri çekmek için çalıştırmalısınız.
Yeni verileri almak için <code>git svn fetch</code> komutunu çalıştırabilirsiniz ancak <code>git svn rebase</code> hem çekme yapar hem de yerel katkılarınızı günceller.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn rebase
    M	autogen.sh
r88 = c9c5f83c64bd755368784b444bc7a0216cc1e17b (refs/remotes/origin/trunk)
First, rewinding head to replay your work on top of it...
Fast-forwarded master to refs/remotes/origin/trunk.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Arada bir <code>git svn rebase</code> 'i çalıştırmak kodunuzun her zaman güncel olmasını sağlar.
Ancak bunu çalıştırdığınızda çalışma dizininizin temiz olduğundan emin olmalısınız.
Yerel değişiklikleriniz varsa, <code>git svn rebase</code> 'i çalıştırmadan önce çalışmanızı saklamanız veya geçici olarak kaydetmeniz gerekir; aksi takdirde, rebase’in birleştirme çakışmasına yol açacağını görürse komut duracaktır.</p>
</div>
</div>
<div class="sect4">
<h4 id="_git_dallanma_sorunları">Git Dallanma Sorunları</h4>
<div class="paragraph">
<p>Git iş akışına alıştığınızda, muhtemelen konu dalları oluşturacak, bunlar üzerinde çalışacak ve sonra bunları birleştireceksiniz.
Eğer bir Subversion sunucusuna <code>git svn</code> yoluyla itiyorsanız, dalları birleştirmek yerine çalışmanızı her seferinde tek bir dal üzerinde yeniden temellemek isteyebilirsiniz.
Yeniden temellemeyi tercih etmenin nedeni, Subversion’un doğrusal bir geçmişe sahip olması ve Git gibi birleştirmelerle ilgilenmemesidir.
Dolayısıyla <code>git svn</code>, anlık pozları Subversion katkılarına dönüştürürken yalnızca ilk önceli takip eder.</p>
</div>
<div class="paragraph">
<p>Geçmişinizin şuna benzediğini varsayalım: bir <code>experiment</code> dalı oluşturdunuz, iki katkı işlediniz ve ardından bunları tekrar <code>master</code> olarak birleştirdiniz.
<code>Dcommit</code> yaptığınızda şöyle bir çıktı görürsünüz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn dcommit
Committing to file:///tmp/test-svn/trunk ...
    M	CHANGES.txt
Committed r89
    M	CHANGES.txt
r89 = 89d492c884ea7c834353563d5d913c6adf933981 (refs/remotes/origin/trunk)
    M	COPYING.txt
    M	INSTALL.txt
Committed r90
    M	INSTALL.txt
    M	COPYING.txt
r90 = cb522197870e61467473391799148f6721bcf9a0 (refs/remotes/origin/trunk)
No changes between 71af502c214ba13123992338569f4669877f55fd and refs/remotes/origin/trunk
Resetting to the latest refs/remotes/origin/trunk</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git proje geçmişinize bakmadığınız sürece birleştirilmiş geçmişe sahip bir dalda <code>dcommit</code> çalıştırmak sorunsuz çalışır.
Ancak <code>experiment</code> dalında yaptığınız katkıların hiçbirinin yeniden yazmılamış, bunun yerine tüm bu değişikliklerin SVN sürücüsünde tek bir birleştirme katkısının altında toplanmış olduğunu görürsünüz.</p>
</div>
<div class="paragraph">
<p>Başka biri bu çalışmayı kopyaladığında, sanki <code>git merge --squash</code> çalıştırmışsınız gibi, tüm çalışmaların içine sıkıştırıldığı birleştirme katkısını görürler.
Bunların nereden geldiğine veya ne zaman işlendiğine ilişkin katkı verilerini göremezler.</p>
</div>
</div>
<div class="sect4">
<h4 id="_subversionda_dallandırma">Subversion’da Dallandırma</h4>
<div class="paragraph">
<p>Subversion’daki dallanma Git’tekiyle aynı değildir: en iyisi, onu çok fazla kullanmaktan kaçınmaktır.
Ancak Subversion’da <code>git svn</code> kullanarak dallar oluşturabilir ve bunlara katkı işleyebilirsiniz.</p>
</div>
</div>
<div class="sect4">
<h4 id="_yeni_bir_svn_dalı_oluşturma">Yeni Bir SVN Dalı Oluşturma</h4>
<div class="paragraph">
<p>Subversion’da yeni bir dal oluşturmak için <code>git svn Branch [new-branch]</code> komutunu çalıştırın:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn branch opera
Copying file:///tmp/test-svn/trunk at r90 to file:///tmp/test-svn/branches/opera...
Found possible branch point: file:///tmp/test-svn/trunk =&gt; file:///tmp/test-svn/branches/opera, 90
Found branch parent: (refs/remotes/origin/opera) cb522197870e61467473391799148f6721bcf9a0
Following parent with do_switch
Successfully followed parent
r91 = f1b64a3855d3c8dd84ee0ef10fa89d27f1584302 (refs/remotes/origin/opera)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu, Subversion’daki <code>svn copy trunk Branch/Opera</code> komutunun eşdeğerini yapar ve Subversion sunucusunda çalışır.
Sizi o dala geçirmediğini akılda tutmak önemlidir; eğer bu noktada katkıda bulunursanız, bu katkı sunucudaki <code>opera</code> 'ya değil <code>trunk</code> 'a gidecektir.</p>
</div>
</div>
<div class="sect4">
<h4 id="_aktif_dalları_değiştirme">Aktif Dalları Değiştirme</h4>
<div class="paragraph">
<p>Git geçmişinizdeki herhangi bir Subversion dalınızın ipucunu arayarak <code>dcommit</code>'lerinizin hangi şubeye gittiğini belirler.
Yalnızca bir taneye sahip olmalısınız ve bu, mevcut dal geçmişinizde <code>git-svn-id</code> 'ye sahip son dal olmalıdır.</p>
</div>
<div class="paragraph">
<p>Aynı anda birden fazla dal üzerinde çalışmak istiyorsanız, yerel dalları belirli Subversion şubelerine <code>dcommit</code> edecek şekilde ayarlayabilirsiniz.
Bunları o dal için içe aktarılan Subversion işleminde başlatabilirsiniz.
Ayrı ayrı çalışabileceğiniz bir <code>opera</code> dalı istiyorsanız aşağıdaki komutu çalıştırabilirsiniz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch opera remotes/origin/opera</code></pre>
</div>
</div>
<div class="paragraph">
<p>Şimdi, eğer <code>opera</code> dalınızı <code>trunk</code> (<code>master</code> dalınız) ile birleştirmek istiyorsanız, bunu normal bir <code>git merge</code> ile yapabilirsiniz.
Ancak (<code>-m</code> aracılığıyla) açıklayıcı bir katkı mesajı girmeniz gerekir, aksi takdirde birleştirme, yararlı bir şey yerine "opera dalını birleştir" diyecektir.</p>
</div>
<div class="paragraph">
<p>Bu işlemi gerçekleştirmek için <code>git merge</code> kullanıyor olsanız ve (Git sizin için uygun birleştirme tabanını otomatik olarak algılayacağı için) birleştirme muhtemelen Subversion’dakinden çok daha kolay olsa da, bunun normal bir birleştirme işlemi olmadığını unutmayın.
Bu verileri, birden fazla önceli olan bir katkıyı işleyemeyen bir Subversion sunucusuna geri göndermeniz gerekir.
Yani onu üst akıma ittikten sonra, başka bir dalın tüm çalışmalarını tek bir katkı altında sıkıştıran bir katkı gibi görünecektir.
Bir dalı diğeriyle birleştirdikten sonra, Git’te normalde yaptığınız gibi kolayca geri dönüp o dal üzerinde çalışmaya devam edemezsiniz.
Çalıştırdığınız <code>dcommit</code> komutu, hangi dalın birleştirildiğini belirten tüm bilgileri siler, dolayısıyla daha sonraki birleştirme temeli hesaplamaları yanlış olur (<code>dcommit</code> komutu sizin <code>git merge</code> sonucunuzu sanki <code>git merge --squash</code> komutunu çalıştırmışsınız gibi görünmesini sağlar).</p>
</div>
<div class="paragraph">
<p>Ne yazık ki, bu durumu önlemenin iyi bir yolu yoktur (Subversion bu bilgiyi saklayamadığı için, onu sunucunuz olarak kullanırken her zaman sınırlamalarından dolayı bazı şeyler eksik kalacaktır).
Sorunları önlemek için, yerel dalı (burada <code>opera</code>) ana dalla birleştirdikten sonra silmelisiniz.</p>
</div>
</div>
<div class="sect4">
<h4 id="_subversion_komutları">Subversion Komutları</h4>
<div class="paragraph">
<p><code>git svn</code> araç seti Subversion’da sahip olduğunuza benzer bazı işlevler sağlayarak, Git’e geçişi kolaylaştırmaya yardımcı olacak bir dizi komut sunar.
Subversion’un eskiden ne yaptığını size veren birkaç komut:</p>
</div>
<div class="sect5">
<h6 id="_svn_geçmiş_stili">SVN Geçmiş Stili</h6>
<div class="paragraph">
<p>Subversion’a alışkınsanız ve geçmişinizi SVN çıktı tarzında görmek istiyorsanız, katkı geçmişinizi SVN formatında görüntülemek için <code>git svn log</code> komutunu çalıştırabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn log
------------------------------------------------------------------------
r87 | schacon | 2014-05-02 16:07:37 -0700 (Sat, 02 May 2014) | 2 lines

autogen change

------------------------------------------------------------------------
r86 | schacon | 2014-05-02 16:00:21 -0700 (Sat, 02 May 2014) | 2 lines

Merge branch 'experiment'

------------------------------------------------------------------------
r85 | schacon | 2014-05-02 16:00:09 -0700 (Sat, 02 May 2014) | 2 lines

updated the changelog</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>git svn log</code> hakkında iki önemli şeyi bilmelisiniz:
İlk olarak, Subversion sunucusundan veri isteyen gerçek <code>svn log</code> komutunun aksine çevrimdışı çalışır.
İkincisi, yalnızca Subversion sunucusuna işlenen edilen katkıları gösterir.
<code>dcommit</code> yapmadığınız yerel katkılar görünmediği gibi, bu arada başkalarının Subversion sunucusuna gönderdiği katkılar da görünmez.
Daha ziyade Subversion sunucusundaki katkıların bilinen son durumuna benzer.</p>
</div>
</div>
<div class="sect5">
<h6 id="_svn_ek_açıklaması">SVN Ek Açıklaması</h6>
<div class="paragraph">
<p><code>git svn log</code> komutu <code>svn log</code> komutunu çevrimdışı olarak simüle ettiği gibi, <code>git svn blame [DOSYA]</code> komutunu çalıştırarak <code>svn annotate</code> in eşdeğerini elde edebilirsiniz.
Çıktıtı aşağıdaki gibi görünür:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn blame README.txt
 2   temporal Protocol Buffers - Google's data interchange format
 2   temporal Copyright 2008 Google Inc.
 2   temporal http://code.google.com/apis/protocolbuffers/
 2   temporal
22   temporal C++ Installation - Unix
22   temporal =======================
 2   temporal
79    schacon Committing in git-svn.
78    schacon
 2   temporal To build and install the C++ Protocol Buffer runtime and the Protocol
 2   temporal Buffer compiler (protoc) execute the following:
 2   temporal</code></pre>
</div>
</div>
<div class="paragraph">
<p>Yine Git’te yerel olarak yaptığınız veya geçen zamanda Subversion’a aktarılan katkıları göstermez.</p>
</div>
</div>
<div class="sect5">
<h6 id="_svn_sunucu_bilgileri">SVN Sunucu Bilgileri</h6>
<div class="paragraph">
<p>Ayrıca <code>svn info</code> 'nun size sağladığı bilgilerin aynısını <code>git svn info</code> 'yu çalıştırarak da alabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn info
Path: .
URL: https://schacon-test.googlecode.com/svn/trunk
Repository Root: https://schacon-test.googlecode.com/svn
Repository UUID: 4c93b258-373f-11de-be05-5f7a86268029
Revision: 87
Node Kind: directory
Schedule: normal
Last Changed Author: schacon
Last Changed Rev: 87
Last Changed Date: 2009-05-02 16:07:37 -0700 (Sat, 02 May 2009)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu kod <code>blame</code> ve <code>log</code> gibi çevrimdışı çalışır ve en son Subversion sunucusuyla iletişim kurduğunuz zaman kadar günceldir.</p>
</div>
</div>
<div class="sect5">
<h6 id="_subversionın_yoksaydığı_şeyleri_yoksaymak">Subversion’ın Yoksaydığı Şeyleri Yoksaymak</h6>
<div class="paragraph">
<p>Eğer herhangi bir yerde <code>svn:ignore</code> özellikleri ayarlanmış bir Subversion reposunu kopyalarsanız, muhtemelen göndermemeniz gereken dosyaları yanlışlıkla göndermemek için <code>.gitignore</code> dosyalarını ayarlamak istersiniz.</p>
</div>
<div class="paragraph">
<p>Bu sorunu çözmeye yardımcı olan iki <code>git svn</code> komutu vardır:</p>
</div>
<div class="paragraph">
<p>Bunlardan ilki, bir sonraki işleminizin bunları içerebilmesi için otomatik olarak ilgili <code>.gitignore</code> dosyalarını sizin için oluşturan git svn create-ignore` komutudur.</p>
</div>
<div class="paragraph">
<p>İkinci komut ise <code>git svn show-ignore</code> olup, çıktıyı proje hariç tutma (ignore) dosyanıza yeniden yönlendirebilmeniz için bir <code>.gitignore</code> dosyasına koymanız gereken satırları stdout olarak yazdırır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn show-ignore &gt; .git/info/exclude</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu şekilde, projeyi <code>.gitignore</code> dosyalarıyla kirletmemiş olursunuz.
Bu Subversion ekibinde tek Git kullanıcısı olduğunuz ve ekip arkadaşlarınızın projede <code>.gitignore</code> dosyalarını istemediği durumlar için iyi bir seçenektir.</p>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_özet_olarak_git_svn">Özet Olarak Git-Svn</h4>
<div class="paragraph">
<p><code>git svn</code> araçları bir Subversion sunucusunda sıkışıp kaldıysanız veya başka bir geliştirme ortamında bir Subversion sunucusunu çalıştırmanız gerekiyorsa faydalıdır.
Ancak bu araçları kısıtlı Git olarak düşünmelisiniz, aksi takdirde sizin ve ekip arkadaşlarınızın kafasını karıştıracak çeviri sorunlarıyla karşılaşabilirsiniz.</p>
</div>
<div class="paragraph">
<p>Sorun yaşamamak için şu kuralları izlemeye çalışın:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>git merge</code> ile yapılan birleştirme işlemleri içermeyen çizgisel bir Git geçmişi tutun.
Ana dalınız dışındaki herhangi bir işi birleştirmek yerine anadala geri dönerek yeniden temmelleyin.</p>
</li>
<li>
<p>Ayrı bir Git sunucusu kurmayın ve üzerinde işbirliği yapmayın.
Yeni geliştiriciler için kopyalamaları hızlandırmak için bir taneniz olabilir, ancak <code>git-svn-id</code> girişi olmayan hiçbir şeyi itmek için kullanmayın.
Her bir katkı mesajını <code>git-svn-id</code> için kontrol ederek, mesajı olmayan katkıları reddecek bir <code>pre-receive</code> kancası dahi ekleyebilirsiniz.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Bu kuralları izlerseniz, bir Subversion sunucusu ile çalışmak daha katlanılabilir bir hale gelir.
Ancak, mümkünse gerçek bir Git sunucusuna geçmek, takımınıza çok daha fazla fayda sağlayabilir.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_git_ve_mercurial">Git ve Mercurial</h3>
<div class="paragraph">
<p>

DVCS evreni yalnızca Git’ten ibaret değildir.
Aslında bu alanda, dağıtılmış sürüm kontrolünün doğru şekilde nasıl yapılacağı konusunda her birinin kendi bakış açısı olan birçok sistem daha vardır.
Git’ten sonra en popüler olanı Mercurial’dır ve bu ikisi birçok yönden çok benzer.</p>
</div>
<div class="paragraph">
<p>Git’in istemci tarafı davranışını tercih ediyorsanız ancak kaynak kodu Mercurial tarafından kontrol edilen bir projeyle çalışıyorsanız; iyi haber, Git’i Mercurial tarafından barındırılan bir reponun istemcisi olarak kullanmanın bir yolu vardır.
Git’in sunucu repolarıyla iletişim kurma şekli uzak repolar aracılığıyla olduğu için, bu köprünün bir uzak yardımcı olarak uygulandığı şaşırtıcı olmamalıdır.
Projenin adı git-remote-hg’dir ve <a href="https://github.com/felipec/git-remote-hg" class="bare">https://github.com/felipec/git-remote-hg</a> adresinde bulunabilir.</p>
</div>
<div class="sect4">
<h4 id="_git_remote_hg">git-remote-hg</h4>
<div class="paragraph">
<p>Öncelikle git-remote-hg’yi kurmanız gerekiyor.
Bu, temel olarak dosyasını yolunuzun üzerinde bir yere bırakmayı gerektirir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ curl -o ~/bin/git-remote-hg \
  https://raw.githubusercontent.com/felipec/git-remote-hg/master/git-remote-hg
$ chmod +x ~/bin/git-remote-hg</code></pre>
</div>
</div>
<div class="paragraph">
<p>…<em>~/bin</em> öğesinin <em>$PATH</em> dizininizde olduğunu varsayıyoruz.
Git-remote-hg’nin başka bir bağımlılığı daha var: Python için "Mercurial" kütüphanesi.
Python’u yüklediyseniz, bu şu kadar basittir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ pip install mercurial</code></pre>
</div>
</div>
<div class="paragraph">
<p>(Python yüklü değilse <a href="https://www.python.org/" class="bare">https://www.python.org/</a> adresini ziyaret edin ve önce onu kurun.)</p>
</div>
<div class="paragraph">
<p>İhtiyacınız olan son şey Mercurial istemcisidir.
<a href="https://www.mercurial-scm.org/" class="bare">https://www.mercurial-scm.org/</a> adresine gidin ve henüz yapmadıysanız yükleyin.</p>
</div>
<div class="paragraph">
<p>Artık dansa hazırsınız.
İhtiyacınız olan tek şey, itebileceğiniz bir Mercurial reposudur.
Neyse ki, her Mercurial reposu bu şekilde davranır, bu nedenle herkesin Mercurial’ı öğrenmek için kullandığı "merhaba dünya" reposunu kullanacağız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ hg clone http://selenic.com/repo/hello /tmp/hello</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_başlarken_2">Başlarken</h4>
<div class="paragraph">
<p>Artık uygun bir “sunucu tarafı” repomuz olduğuna göre, tipik bir iş akışını gerçekleştirebiliriz.
Göreceğiniz üzere, bu iki sistem fazla sürtünme olmayacak kadar benzerdir.</p>
</div>
<div class="paragraph">
<p>Git’te her zaman olduğu gibi önce repoyu kopyalarız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone hg::/tmp/hello /tmp/hello-git
$ cd /tmp/hello-git
$ git log --oneline --graph --decorate
* ac7955c (HEAD, origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master, master) Create a makefile
* 65bb417 Create a standard "hello, world" program</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mercurial reposuyla çalışmanın standart "git clone" komutunu kullandığını fark edeceksiniz.
Bunun nedeni, git-remote-hg’nin Git’in HTTP/S protokolünün uygulanmasına (uzaktan yardımcılar) benzer bir mekanizma kullanarak oldukça düşük bir düzeyde çalışmasıdır.
Git ve Mercurial’ın her ikisi de her kullanıcının repo geçmişinin tam bir kopyasına sahip olması için tasarlandığından, bu komut tüm projenin geçmişini içeren tam bir kopya oluşturur ve bunu çok hızlı bir şekilde yapar.</p>
</div>
<div class="paragraph">
<p>Log komutu, en sonuncusu bir dizi referans tarafından işaret edilen iki işlemi gösterir.
Bunlardan bazılarının aslında orada olmadığı ortaya çıktı.
<code>.git</code> dizininde gerçekte ne olduğuna bir bakalım:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ tree .git/refs
.git/refs
├── heads
│   └── master
├── hg
│   └── origin
│       ├── bookmarks
│       │   └── master
│       └── branches
│           └── default
├── notes
│   └── hg
├── remotes
│   └── origin
│       └── HEAD
└── tags

9 directories, 5 files</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git-remote-hg işleri daha deyimsel olarak Git benzeri hale getirmeye çalışır, ancak aslında birbirinden biraz farklı iki sistem arasındaki kavramsal eşlemeyi yönetir.
<em>refs/hg</em> dizini gerçek uzak referansların saklandığı yerdir.
Örneğin, "refs/hg/origin/branches/default", "master"ın işaret ettiği katkı olan "ac7955c" ile başlayan SHA-1’i içeren bir Git ref dosyasıdır.
Yani <em>refs/hg</em> dizini bir nevi sahte <em>refs/remotes/Origin</em> gibidir, ancak yer imleri ve dallar arasında ek bir ayrım vardır.</p>
</div>
<div class="paragraph">
<p><em>notes/hg</em> dosyası, git-remote-hg’nin Git katkı karmalarını Mercurial değişiklik kümesi kimlikleriyle nasıl eşlediğinin başlangıç noktasıdır.
Hadi biraz araştıralım:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat notes/hg
d4c10386...

$ git cat-file -p d4c10386...
tree 1781c96...
author remote-hg &lt;&gt; 1408066400 -0800
committer remote-hg &lt;&gt; 1408066400 -0800

Notes for master

$ git ls-tree 1781c96...
100644 blob ac9117f...	65bb417...
100644 blob 485e178...	ac7955c...

$ git cat-file -p ac9117f
0a04b987be5ae354b710cefeba0e2d9de7ad41a9</code></pre>
</div>
</div>
<div class="paragraph">
<p>Yani <em>refs/notes/hg</em>, Git nesne veritabanında adları olan diğer nesnelerin listesi olan bir ağaca işaret eder.
<em>git ls-tree</em> bir ağacın içinde yer alan öğeler için: mod, tür, nesne karması ve dosya adını verir.
Ağaç öğelerinden birini incelediğimizde, içinde “ac9117f” ("master" ile gösterilen katkının SHA-1 karması) adında ve “0a04b98” içeriğine sahip bir blob olduğunu görürüz (bu, <em>varsayılan</em> dalın ucundaki Mercurial değişiklik kümesinin kimliğidir).</p>
</div>
<div class="paragraph">
<p>Güzel olan şu ki, çoğunlukla tüm bunlar için endişelenmemize gerek yoktur.
Tipik iş akışı Git uzaktan reposuyla çalışmaktan çok farklı olmayacaktır.</p>
</div>
<div class="paragraph">
<p>Devam etmeden önce ilgilenmemiz gereken bir şey daha var: yoksayılanlar.
Mercurial ve Git bunun için çok benzer bir mekanizma kullanır, ancak muhtemelen bir <code>.gitignore</code> dosyasını Mercurial reposuna işlemek istemezsiniz.
Neyse ki Git’in diskteki bir repoda yerel olan dosyaları yok saymanın bir yolu var ve bu Mercurial formatı Git ile uyumludur; dolayısıyla onu kopyalamanız yeterli:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cp .hgignore .git/info/exclude</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>.git/info/exclude</code> dosyası tıpkı <code>.gitignore</code> gibi davranır ancak katkılara dahil edilmez.</p>
</div>
</div>
<div class="sect4">
<h4 id="_i̇ş_akışı_2">İş Akışı</h4>
<div class="paragraph">
<p>Diyelim ki <em>master</em> dalında bazı değişiklikler yaptık ve bazı katkılar işledik ve siz de bunu uzak repoya göndermeye hazırsınız.
Repomuz şu anda şöyle görünüyor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --graph --decorate
* ba04a2a (HEAD, master) Update makefile
* d25d16f Goodbye
* ac7955c (origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master) Create a makefile
* 65bb417 Create a standard "hello, world" program</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bizim <em>master</em> dalımız, <code>Origin/master</code> 'dan iki katkı ileridedir, ancak bu iki katkı yalnızca yerel makinemizde mevcuttur.
Bakalım aynı anda, başka biri de önemli işler yapıyor mu:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git fetch
From hg::/tmp/hello
   ac7955c..df85e87  master     -&gt; origin/master
   ac7955c..df85e87  branches/default -&gt; origin/branches/default
$ git log --oneline --graph --decorate --all
* 7b07969 (refs/notes/hg) Notes for default
* d4c1038 Notes for master
* df85e87 (origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master) Add some documentation
| * ba04a2a (HEAD, master) Update makefile
| * d25d16f Goodbye
|/
* ac7955c Create a makefile
* 65bb417 Create a standard "hello, world" program</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>--all</code> bayrağını kullandığımız için, git-remote-hg tarafından dahili olarak kullanılan ``notes`` referanslarını görüyoruz, ancak onları görmezden gelebiliriz.
Gerisi beklediğimiz gibidir; <em>Origin/master</em> tek bir katkı ilerledi ve artık geçmişimiz ayrıştı.
Bu bölümde üzerinde çalıştığımız diğer sistemlerden farklı olarak; Mercurial, birleştirme işlemlerini gerçekleştirebilir, dolayısıyla havalı bir şey yapmayacağız.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge origin/master
Auto-merging hello.c
Merge made by the 'recursive' strategy.
 hello.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
$ git log --oneline --graph --decorate
*   0c64627 (HEAD, master) Merge remote-tracking branch 'origin/master'
|\
| * df85e87 (origin/master, origin/branches/default, origin/HEAD, refs/hg/origin/branches/default, refs/hg/origin/bookmarks/master) Add some documentation
* | ba04a2a Update makefile
* | d25d16f Goodbye
|/
* ac7955c Create a makefile
* 65bb417 Create a standard "hello, world" program</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mükemmel.
Testleri yapıyoruz ve her şey başarılı oluyor, böylece çalışmalarımızı ekibin geri kalanıyla paylaşmaya hazırız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git push
To hg::/tmp/hello
   df85e87..0c64627  master -&gt; master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu kadar!
Mercurial reposuna bakarsanız, bunun beklediğimiz şeyi yaptığını göreceksiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ hg log -G --style compact
o    5[tip]:4,2   dc8fa4f932b8   2014-08-14 19:33 -0700   ben
|\     Merge remote-tracking branch 'origin/master'
| |
| o  4   64f27bcefc35   2014-08-14 19:27 -0700   ben
| |    Update makefile
| |
| o  3:1   4256fc29598f   2014-08-14 19:27 -0700   ben
| |    Goodbye
| |
@ |  2   7db0b4848b3c   2014-08-14 19:30 -0700   ben
|/     Add some documentation
|
o  1   82e55d328c8c   2005-08-26 01:21 -0700   mpm
|    Create a makefile
|
o  0   0a04b987be5a   2005-08-26 01:20 -0700   mpm
     Create a standard "hello, world" program</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>2</em> numaralı değişiklik seti Mercurial tarafından, <em>3</em> ve <em>4</em> numaralı değişiklik seti ise Git-remote-hg tarafından Git ile yapılan katkıların itilmesiyle yapıldı.</p>
</div>
</div>
<div class="sect4">
<h4 id="_dallar_ve_yer_i̇mleri_bookmarks">Dallar ve Yer İmleri (Bookmarks)</h4>
<div class="paragraph">
<p>Git’in yalnızca tek bir tür dalı vardır: katkılar işlendiğinde hareket eden bir referans.
Mercurial’da bu tür bir referansa ``yer imi`` (bookmark) adı verilir ve Git dalıyla hemen hemen aynı şekilde davranır.</p>
</div>
<div class="paragraph">
<p>Mercurial’ın ``dal`` kavramı daha ağırdır.
Değişiklik kümesinin yapıldığı dal, değişiklik kümesiyle birlikte kaydedilir. Bu da her zaman repo geçmişinde yeralacağı anlamına gelir.
<code>develop</code> dalında yapılan bir katkı örneği:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ hg log -l 1
changeset:   6:8f65e5e02793
branch:      develop
tag:         tip
user:        Ben Straub &lt;ben@straub.cc&gt;
date:        Thu Aug 14 20:06:38 2014 -0700
summary:     More documentation</code></pre>
</div>
</div>
<div class="paragraph">
<p>``branch`` ile başlayan satıra dikkat edin.
Git bunu gerçekten kopyalayamaz (her iki dal türü de Git referansı olarak temsil edilebildiği için gerek de yoktur zaten), ancak Mercurial bunu önemsediği için git-remote-hg’nin farkı anlaması gereklidir.</p>
</div>
<div class="paragraph">
<p>Mercurial yer imleri oluşturmak Git dalları oluşturmak kadar kolaydır.
Git tarafında:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b featureA
Switched to a new branch 'featureA'
$ git push origin featureA
To hg::/tmp/hello
 * [new branch]      featureA -&gt; featureA</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hepsi bu kadardır.
Mercurial tarafında ise şöyle görünür:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ hg bookmarks
   featureA                  5:bd5ac26f11f9
$ hg log --style compact -G
@  6[tip]   8f65e5e02793   2014-08-14 20:06 -0700   ben
|    More documentation
|
o    5[featureA]:4,2   bd5ac26f11f9   2014-08-14 20:02 -0700   ben
|\     Merge remote-tracking branch 'origin/master'
| |
| o  4   0434aaa6b91f   2014-08-14 20:01 -0700   ben
| |    update makefile
| |
| o  3:1   318914536c86   2014-08-14 20:00 -0700   ben
| |    goodbye
| |
o |  2   f098c7f45c4f   2014-08-14 20:01 -0700   ben
|/     Add some documentation
|
o  1   82e55d328c8c   2005-08-26 01:21 -0700   mpm
|    Create a makefile
|
o  0   0a04b987be5a   2005-08-26 01:20 -0700   mpm
     Create a standard "hello, world" program</code></pre>
</div>
</div>
<div class="paragraph">
<p>Revizyon 5’teki yeni <code>[featureA]</code> etiketine dikkat edin.
Bunlar, bir istisna dışında Git tarafındaki Git dalları gibi davranır (Git tarafından bir yer işaretini silemezsiniz: bu, uzak yardımcılara yönelik bir sınırlamadır).</p>
</div>
<div class="paragraph">
<p>Ayrıca “ağır” bir Mercurial dalı üzerinde de çalışabilirsiniz: ``branches`` ad alanına (namespace) bir dal koymanız yeterlidir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b branches/permanent
Switched to a new branch 'branches/permanent'
$ vi Makefile
$ git commit -am 'A permanent change'
$ git push origin branches/permanent
To hg::/tmp/hello
 * [new branch]      branches/permanent -&gt; branches/permanent</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mercurial tarafın şöyle görünür:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ hg branches
permanent                      7:a4529d07aad4
develop                        6:8f65e5e02793
default                        5:bd5ac26f11f9 (inactive)
$ hg log -G
o  changeset:   7:a4529d07aad4
|  branch:      permanent
|  tag:         tip
|  parent:      5:bd5ac26f11f9
|  user:        Ben Straub &lt;ben@straub.cc&gt;
|  date:        Thu Aug 14 20:21:09 2014 -0700
|  summary:     A permanent change
|
| @  changeset:   6:8f65e5e02793
|/   branch:      develop
|    user:        Ben Straub &lt;ben@straub.cc&gt;
|    date:        Thu Aug 14 20:06:38 2014 -0700
|    summary:     More documentation
|
o    changeset:   5:bd5ac26f11f9
|\   bookmark:    featureA
| |  parent:      4:0434aaa6b91f
| |  parent:      2:f098c7f45c4f
| |  user:        Ben Straub &lt;ben@straub.cc&gt;
| |  date:        Thu Aug 14 20:02:21 2014 -0700
| |  summary:     Merge remote-tracking branch 'origin/master'
[...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>``permanent`` (kalıcı) dal adı, <em>7</em> işaretli değişiklik kümesiyle kaydedildi.</p>
</div>
<div class="paragraph">
<p>Git açısından bakıldığında, bu dal stillerinden herhangi biriyle çalışmak aynıdır: normalde yaptığınız gibi yalnızca geçiş yapın, kaydedin, getirin, birleştirin, çekin ve itin.
Bilmeniz gereken bir şey de Mercurial’ın tarihin yeniden yazılmasını desteklememesidir. Ona yalnızca ekleme yapabilirsiniz.
Etkileşimli bir yeniden temelleme (rebase) ve zorla itme (forced push) sonrasında Mercurial repomuz şu şekilde görünür:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ hg log --style compact -G
o  10[tip]   99611176cbc9   2014-08-14 20:21 -0700   ben
|    A permanent change
|
o  9   f23e12f939c3   2014-08-14 20:01 -0700   ben
|    Add some documentation
|
o  8:1   c16971d33922   2014-08-14 20:00 -0700   ben
|    goodbye
|
| o  7:5   a4529d07aad4   2014-08-14 20:21 -0700   ben
| |    A permanent change
| |
| | @  6   8f65e5e02793   2014-08-14 20:06 -0700   ben
| |/     More documentation
| |
| o    5[featureA]:4,2   bd5ac26f11f9   2014-08-14 20:02 -0700   ben
| |\     Merge remote-tracking branch 'origin/master'
| | |
| | o  4   0434aaa6b91f   2014-08-14 20:01 -0700   ben
| | |    update makefile
| | |
+---o  3:1   318914536c86   2014-08-14 20:00 -0700   ben
| |      goodbye
| |
| o  2   f098c7f45c4f   2014-08-14 20:01 -0700   ben
|/     Add some documentation
|
o  1   82e55d328c8c   2005-08-26 01:21 -0700   mpm
|    Create a makefile
|
o  0   0a04b987be5a   2005-08-26 01:20 -0700   mpm
     Create a standard "hello, world" program</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>8</em>, <em>9</em> ve <em>10</em> değişiklik kümeleri oluşturuldu ve <code>permanent</code> dalına aitler, ancak eski değişiklik kümeleri hâlâ duruyor.
Bu, Mercurial kullanan takım arkadaşlarınız için <strong>çok</strong> kafa karıştırıcı olabilir, bu yüzden bundan kaçınmaya çalışın.</p>
</div>
</div>
<div class="sect4">
<h4 id="_özetle_mercurial">Özetle Mercurial</h4>
<div class="paragraph">
<p>Git ve Mercurial, sınırın ötesinde çalışmanın oldukça sancısız olmasını sağlayacak kadar benzerdir.
(Genellikle önerildiği üzere) makinenizden kalan geçmişi değiştirmekten kaçınırsanız, diğer ucun Mercurial olduğunun farkına bile varmazsınız.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_git_ve_bazaar">Git ve Bazaar</h3>
<div class="paragraph">
<p>Dağıtık versiyon kontrol sistemleri arasında, bir diğeri <a href="http://bazaar.canonical.com">Bazaar</a> olarak bilinir.
Bazaar, özgür ve açık kaynaklıdır ve <a href="https://www.gnu.org">GNU Projesi</a>'nin bir parçasıdır.
Git’ten oldukça farklı davranır.
Git ile aynı şeyi yapabilmek için bazen farklı bir anahtar kelime kullanmanız gerekebilir ve bazı yaygın anahtar kelimelerin aynı anlamı taşımadığı görülebilir.
Özellikle, dalların yönetimi çok farklıdır ve Git evreninden gelen birisi için özellikle kafa karıştırıcı olabilir.
Bununla birlikte, bir Git reposunda bir Bazaar reposunda çalışmak mümkündür.</p>
</div>
<div class="paragraph">
<p>Git’i bir Bazaar istemcisi olarak kullanmanıza izin veren birçok proje bulunmaktadır.
Burada, Felipe Contreras’in projesini kullanacağız ve bu projeyi şurada bulabilirsiniz: <a href="https://github.com/felipec/git-remote-bzr" class="bare">https://github.com/felipec/git-remote-bzr</a>.
Kurulum için, sadece git-remote-bzr dosyasını $PATH içeren bir klasöre indirmeniz yeterlidir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ wget https://raw.github.com/felipec/git-remote-bzr/master/git-remote-bzr -O ~/bin/git-remote-bzr
$ chmod +x ~/bin/git-remote-bzr</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ayrıca Bazaar’ın da kurulu olması gerekmektedir.
Hepsi bu kadar!</p>
</div>
<div class="sect4">
<h4 id="_bazaar_reposundan_bir_git_reposu_oluşturmak">Bazaar Reposundan Bir Git Reposu Oluşturmak</h4>
<div class="paragraph">
<p>Kullanımı oldukça basittir.
Bir Bazaar reposunu kopyalamak için onu <code>bzr::</code> önekiyle kopyalamak yeterlidir.
Hem Git hem de Bazaar, makinanıza tam kopyalar yapar; bu nedenle bir Git kopyasını yerel Bazaar kopyanıza bağlamak mümkündür, ancak önerilmez.
Git kopyanızı doğrudan Bazaar kopyanızın bağlı olduğu yere (merkezi repo) bağlamak çok daha kolaydır.</p>
</div>
<div class="paragraph">
<p>Varsayalım ki <code>bzr+ssh://developer@mybazaarserver:myproject</code> adresinde bir uzak repo ile çalıştınız.
O zaman onu şu şekilde kopyalamalısınız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone bzr::bzr+ssh://developer@mybazaarserver:myproject myProject-Git
$ cd myProject-Git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu noktada, Git reposu oluşturulmuş olsa da, disk kullanımı için optimize edilmiş değildir.
Bu yüzden, özellikle büyük bir repo ise, Git reposunuzu temizlemeniz ve sıkıştırmanız gerekmektedir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git gc --aggressive</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_bazaar_dalları">Bazaar Dalları</h4>
<div class="paragraph">
<p>Bazaar sadece dalları kopyalamanıza izin verir, ancak bir repo birden çok dal içerebilir ve <code>git-remote-bzr</code> her ikisini de kopyalayabilir.
Örneğin, bir dalı kopyalamak için:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone bzr::bzr://bzr.savannah.gnu.org/emacs/trunk emacs-trunk</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ve tüm repoyu kopyalamak için:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone bzr::bzr://bzr.savannah.gnu.org/emacs emacs</code></pre>
</div>
</div>
<div class="paragraph">
<p>İkinci komut, emacs reposunda bulunan tüm dalları kopyalar; yine de, belirli bazı dalları işaretlemek mümkündür:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config remote-bzr.branches 'trunk, xwindow'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bazı uzak repolar, dallarını listeleme izni vermez; bu durumda onları manuel olarak belirtmeniz gerekir.
Kpyalama komutunda yapılandırmayı belirtmenize rağmen, bu yöntemi daha kolay bulabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git init emacs
$ git remote add origin bzr::bzr://bzr.savannah.gnu.org/emacs
$ git config remote-bzr.branches 'trunk, xwindow'
$ git fetch</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_bzrignore_dosyasında_neyin_yok_sayılacağını_yoksayın">.bzrignore dosyasında neyin yok sayılacağını yoksayın.</h4>
<div class="paragraph">
<p>Bazaar tarafından yönetilen bir projede çalıştığınızdan, <code>.gitignore</code> dosyası oluşturmamalısınız.
Çünkü <em>yanlışlıkla</em> sürüm kontrolü altına alabilirsiniz ve Bazaar ile çalışan diğer kişiler bundan rahatsız olabilir.
Çözüm, simgesel bir bağ olarak veya düzenli bir dosya olarak <code>.git/info/exclude</code> dosyasını oluşturmaktır.
Bu sorunu nasıl çözeceğimizi daha sonra göreceğiz.</p>
</div>
<div class="paragraph">
<p>Bazaar, dosyaları yok saymak için Git ile aynı modeli kullanır, ancak benzersiz iki özelliğe de sahiptir.
Tam açıklamayı <a href="http://doc.bazaar.canonical.com/bzr.2.7/en/user-reference/ignore-help.html">dokümantasyonda</a> bulabilirsiniz.
Bahsettiğimiz iki özellik şunlardır:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>"!!", bir "!" kuralı kullanılarak belirtilse bile belirli dosya kalıplarını yok saymanızı sağlar.</p>
</li>
<li>
<p>Bir satırın başında "RE:" yazmak, bir <a href="https://docs.python.org/3/library/re.html">Python düzenli ifadesi</a> belirtmenizi sağlar (Git yalnızca shell globlarını destekler).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Sonuç olarak, düşünülmesi gereken iki farklı durum vardır:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Eğer <code>.bzrignore</code> dosyası bu iki belirli önekten herhangi birini içermiyorsa, o zaman sadece bir sembolik bağ oluşturabilirsiniz: <code>ln -s .bzrignore .git/info/exclude</code></p>
</li>
<li>
<p>Aksi takdirde, <code>.git/info/exclude</code> dosyasını oluşturmalı ve onu <code>.bzrignore</code> içindeki tam olarak aynı dosyaları yok sayacak şekilde uyarlamalısınız.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Ne olursa olsun, <code>.bzrignore</code> 'daki herhangi bir değişikliğe karşı dikkatli olmalı ve <code>.git/info/exclude</code> dosyasının her zaman <code>.bzrignore</code> 'u yansıttığından emin olmalısınız.
Gerçekten de, eğer <code>.bzrignore</code> dosyası değişirse ve "!!" veya "RE:" ile başlayan bir veya daha fazla satır içeriyorsa; Git bu satırları yorumlayamadığından, <code>.git/info/exclude</code> dosyanızı <code>.bzrignore</code> ile aynı dosyaları yok sayacak şekilde uyarlamalısınız.
Ayrıca, <code>.git/info/exclude</code> dosyası sembolik bir bağsa, önce sembolik bağı silmeniz, <code>.bzrignore</code>'u <code>.git/info/exclude</code>'a kopyalamanız ve daha sonra ikincisini uyarlamanız gerekecektir.
Ancak dikkatli olun, çünkü Git’te bir dosyanın üst dizinini hariç tutarsanız, dosyayı yeniden dahil etmek imkansızdır.</p>
</div>
</div>
<div class="sect4">
<h4 id="_uzak_repodaki_değişiklikleri_getirmek">Uzak Repodaki Değişiklikleri Getirmek</h4>
<div class="paragraph">
<p>Uzak repodaki değişiklikleri getirmek için, Git komutlarını kullanarak değişiklikleri her zamanki gibi çekersiniz.
Değişikliklerinizin "master" dalında olduğunu varsayarak, çalışmanızı "Origin/master" dalında birleştirir veya yeniden temellendirirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git pull --rebase origin</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_çalışmalarınızı_uzak_repoya_i̇tmek">Çalışmalarınızı Uzak Repoya İtmek</h4>
<div class="paragraph">
<p>Bazaar’ın da birleştirme işlemi kavramı olduğu için, birleştirme işlemi içeren bir işlem yaparsanız sorun yaşamayacaksınız.
Bu nedenle bir dalda çalışabilir, değişiklikleri `master`a birleştirebilir ve çalışmanızı gönderebilirsiniz.
Sonra, dallarınızı oluşturur, çalışmanızı test eder ve normal şekilde kaydedersiniz.
Son olarak, çalışmanızı Bazaar reposuna gönderirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git push origin master</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_uyarılar">Uyarılar</h4>
<div class="paragraph">
<p>Git’in uzak yardımcılar çerçevesinin geçerli bazı sınırlamaları vardır.
Özellikle şu komutlar çalışmaz:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>git Push Origin :branch-to-delete (Bazaar bu şekilde ref silme işlemlerini kabul edemez.)</p>
</li>
<li>
<p>git Push Origin old:new ("old" itilecektir)</p>
</li>
<li>
<p>git Push --dry-run Origin &lt;dal&gt; (itecektir)</p>
</li>
<li>
<p>git push origin :branch-to-delete (Bazaar can’t accept ref deletions in this way.)</p>
</li>
<li>
<p>git push origin old:new (it will push <em>old</em>)</p>
</li>
<li>
<p>git push --dry-run origin branch (it will push)</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h4 id="_özet_12">Özet</h4>
<div class="paragraph">
<p>Git’in ve Bazaar’ın modelleri benzer olduğundan sınırın ötesinde çalışırken çok fazla direnç görülmez.
Sınırlamalara dikkat ettiğiniz ve uzak reponun yerel olarak Git olmadığının her zaman farkında olduğunuz sürece sorun olmaz.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_git_ve_perforce">Git ve Perforce</h3>
<div class="paragraph">
<p>

Perforce, kurumsal ortamlarda çok popüler olan bir sürüm kontrol sistemidir.
Bu, bu bölümde ele alınan, 1995’ten beri varolan en eski sistemdir.
Bu nedenle, o günün kısıtlamaları dahilinde tasarlanmıştır: her zaman tek bir merkezi sunucuya bağlı olduğunuzu ve yerel diskte yalnızca bir sürümünün tutulduğunu varsayar.
Elbette, özellikleri ve kısıtlamaları belirli problemlere yönelik çok uygun olmakla beraber, aslında Git’in daha iyi çalışacabileceği birçok projede yine de Perforce kullanılmaktadır.</p>
</div>
<div class="paragraph">
<p>Perforce ve Git’i karıştırmak isterseniz iki seçeneğiniz bulunmaktadır.
İlk olarak, Perforce’un yapımcılarından <code>Git Fusion</code> köprüsünü ele alacağız, bu size Perforce depo ağacının alt kısımlarını okuma-yazma Git repoları olarak açmanızı sağlar.
İkincisi, Perforce sunucusunun yeniden yapılandırılmasını gerektirmeyen Git’i bir Perforce istemcisi olarak kullanmanıza izin veren bir istemci tarafı köprüsü olan git-p4’tür.</p>
</div>
<div class="sect4">
<h4 id="_p4_git_fusion">Git Fusion</h4>
<div class="paragraph">
<p>
Perforce, bir Perforce sunucusunu sunucu tarafındaki Git repolarıyla senkronize eden "Git Fusion" adlı bir ürün sağlar. Bu ürünü <a href="http://www.perforce.com/git-fusion" class="bare">http://www.perforce.com/git-fusion</a> adresinden temin edebilirsiniz.</p>
</div>
<div class="sect5">
<h6 id="_kurulum_3">Kurulum</h6>
<div class="paragraph">
<p>Örneklerimiz için, Git Fusion’ın en kolay kurulum yöntemini kullanacağız.
Bu yöntem, Perforce cini (daemon) ve Git Fusion’ı çalıştıran bir sanal makine indirmeyi içerir.
Sanal makine görüntüsünü <a href="http://www.perforce.com/downloads/Perforce/20-User" class="bare">http://www.perforce.com/downloads/Perforce/20-User</a> adresinden edinebilir ve indirme tamamlandıktan sonra dilediğiniz bir  sanallaştırma yazılımıyla (biz VirtualBox kullanacağız) içe aktarabilirsiniz.</p>
</div>
<div class="paragraph">
<p>Makineyi ilk çalıştırdığınızda, üç Linux kullanıcısı (<code>root</code>, <code>perforce</code> ve <code>git</code>) için özel şifre belirlemenizi ve bu kurulumu ağdaki diğer kurulumlardan ayırt etmek için bir örnek adı girmeniz istenir.</p>
</div>
<div class="paragraph">
<p>Bu işlemler tamamlandığında aşağıdakini göreceksiniz:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/git-fusion-boot.png" >}}" alt="Git Fusion sanal makinesi başlangıç ekranı.">
</div>
<div class="title">Görsel 145. Git Fusion sanal makinesi başlangıç ekranı.</div>
</div>
<div class="paragraph">
<p>İleride kullanacağınız için burada gösterilen IP adresini not etmelisiniz.
Sonraki adımda bir Perforce kullanıcısı oluşturacağız.
Alt kısımda bulunan <code>Login</code> seçeneğini seçin ve <code>root</code> olarak giriş yapın.
Ardından aşağıdaki komutları kullanarak bir kullanıcı oluşturun:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ p4 -p localhost:1666 -u super user -f john
$ p4 -p localhost:1666 -u john passwd
$ exit</code></pre>
</div>
</div>
<div class="paragraph">
<p>İlk komut, kullanıcıyı özelleştirmek için bir VI düzenleyici açacak, ancak varsayılanları kabul ederek <code>:wq</code> yazıp enter tuşuna basarak çıkabilirsiniz.
İkinci komut, sizden iki kez bir şifre girmenizi isteyecektir.
Shell komut istemimizle yapmamız gereken bu kadar, bu yüzden oturumu kapatabilirsiniz.</p>
</div>
<div class="paragraph">
<p>İlerlemek için yapmanız gereken bir sonraki adım, Git’in SSL sertifikalarını doğrulamamasını söylemektir.
Git Fusion görüntüsü bir sertifika ile birlikte gelir; ancak bu, sanal makinenizin IP adresiyle eşleşmeyecek bir alan adı için olduğundan, Git HTTPS bağlantısını reddedecektir.
Bu kalıcı bir kurulum olacaksa, farklı bir sertifika yüklemek için Perforce Git Fusion kılavuzuna başvurun; ancak örnek amaçlarımız için, bu yeterlidir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ export GIT_SSL_NO_VERIFY=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Şimdi her şeyin çalışıp çalışmadığını test edebiliriz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone https://10.0.1.254/Talkhouse
Cloning into 'Talkhouse'...
Username for 'https://10.0.1.254': john
Password for 'https://john@10.0.1.254':
remote: Counting objects: 630, done.
remote: Compressing objects: 100% (581/581), done.
remote: Total 630 (delta 172), reused 0 (delta 0)
Receiving objects: 100% (630/630), 1.22 MiB | 0 bytes/s, done.
Resolving deltas: 100% (172/172), done.
Checking connectivity... done.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sanal makine görüntüsü, kopyalayabileceğiniz bir örnek proje ile birlikte gelir.
Aşağıda, yukarıda oluşturduğumuz <code>john</code> kullanıcısı ile HTTPS üzerinden kopyalama işlemini gerçekleştiriyoruz; Git bu bağlantı için kimlik bilgisi isteyecek, ancak kimlik bilgisi önbelleği sonraki isteklerde bu adımı atlamamıza izin verecektir.</p>
</div>
</div>
<div class="sect5">
<h6 id="_fusion_yapılandırması">Fusion Yapılandırması</h6>
<div class="paragraph">
<p>Git Fusion’ı kurduktan sonra yapılandırmayı ayarlamak isteyeceksiniz.
Aslında bunu favori Perforce istemciniz kullanarak kolayca yapabilirsiniz; sadece Perforce sunucusundaki <code>//.git-fusion</code> dizinini çalışma alanınıza eşleyin.
Dosya yapısı şuna benzer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ tree
.
├── objects
│   ├── repos
│   │   └── [...]
│   └── trees
│       └── [...]
│
├── p4gf_config
├── repos
│   └── Talkhouse
│       └── p4gf_config
└── users
    └── p4gf_usermap

498 directories, 287 files</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>objects</code> dizini, Perforce nesnelerini Git’e ve tersine eşlemek için Git Fusion tarafından içsel olarak kullanılır.
Bu dizindeki herhangi bir şeyle uğraşmanız gerekmez.
Bu dizinde bir tane global <code>p4gf_config</code> dosyası bulunur ve her bir repo için de ayrı bir tane (bunlar, Git Fusion’ın nasıl davrandığını belirleyen yapılandırma dosyalarıdır).
Şimdi, kök dizindeki dosyaya bir göz atalım:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">[repo-creation]
charset = utf8

[git-to-perforce]
change-owner = author
enable-git-branch-creation = yes
enable-swarm-reviews = yes
enable-git-merge-commits = yes
enable-git-submodules = yes
preflight-commit = none
ignore-author-permissions = no
read-permission-check = none
git-merge-avoidance-after-change-num = 12107

[perforce-to-git]
http-url = none
ssh-url = none

[@features]
imports = False
chunked-push = False
matrix2 = False
parallel-push = False

[authentication]
email-case-sensitivity = no</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu bayrakların anlamlarına burada girmeyeceğiz, ancak bunun yalnızca Git yapılandırması için kullanılan INI dosyaları gibi biçimlendirildiğini unutmayın.
Bu dosya, <code>repos/Talkhouse/p4gf_config</code> gibi özel repo yapılandırma dosyaları tarafından geçersiz kılınabilecek global seçenekleri belirtir.
Bu dosyayı açarsanız, global varsayılanlardan farklı olan bazı ayarları içeren <code>[@repo]</code> bölümünü göreceksiniz.
Ayrıca şu şekilde görünen bölümler de göreceksiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">[Talkhouse-master]
git-branch-name = master
view = //depot/Talkhouse/main-dev/... ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu, bir Perforce dalı ile bir Git dalı arasındaki eşlemeyi belirtir.
Bölüm adı benzersiz olduğu sürece istediğiniz şekilde adlandırabilirsiniz.
<code>git-branch-name</code>, Git altında sıkıntılı olabilecek bir depo yolunu daha dostane bir isme dönüştürmenize olanak tanır.
<code>view</code> ayarı, Perforce dosyalarının Git reposuna eşlenme şeklini, standart görünüm eşleme sözdizimini (standard view mapping syntax) kullanarak kontrol eder.
Bu örnekte olduğu gibi birden fazla eşleme belirtilebilir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">[multi-project-mapping]
git-branch-name = master
view = //depot/project1/main/... project1/...
       //depot/project2/mainline/... project2/...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu şekilde, normal çalışma alanı eşlemeleriniz dizin yapılarında değişiklikler içeriyorsa, bunu bir Git reposuyla çoğaltabilirsiniz.</p>
</div>
<div class="paragraph">
<p>Bahsedeceğimiz son dosya, Perforce kullanıcılarını Git kullanıcılarına eşleyen ve belki de hiç ihtiyaç duymayacağınız <code>users/p4gf_usermap</code> dosyasıdır.
Bir Perforce değişiklik kümesi bir Git katkısına dönüştürülürken, Git Fusion’ın varsayılan davranışı; Perforce kullanıcısını aramak ve Git’teki yazar/adlandırıcı alanı için orada saklanan e-posta adresini ve tam adı kullanmaktır.
Diğer yöne dönüştürülürken, varsayılan olarak, Git katkısının yazar alanında saklanan e-posta adresine sahip Perforce kullanıcısını aramak ve değişiklik kümesini, (uygulanan izinlerle) o kullanıcı olarak göndermektir.
Çoğu durumda, bu yeterli olacaktır, ancak aşağıdaki eşleme dosyasını düşünün:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>john john@example.com "John Doe"
john johnny@appleseed.net "John Doe"
bob employeeX@example.com "Anon X. Mouse"
joe employeeY@example.com "Anon Y. Mouse"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Her satır, bir kullanıcı eşlemesi oluşturan <code>&lt;user&gt; &lt;email&gt; "&lt;tam ad&gt;"</code> formatındadır.
İlk iki satır, iki farklı e-posta adresini aynı Perforce kullanıcı hesabına eşler.
Bu, birkaç farklı e-posta adresi altında (veya e-posta adreslerini değiştirip) Git katkıları oluşturduysanız, ancak bunların aynı Perforce kullanıcısına eşlenmesini istiyorsanız faydalıdır.
Bir Git katkısı oluşturulurken, Perforce kullanıcısını eşleştiren ilk satır Git yazar bilgileri için kullanılır.</p>
</div>
<div class="paragraph">
<p>Son iki satır, Bob ve Joe’nun gerçek adlarını ve e-posta adreslerini oluşturulan Git katkılarından gizler.
Bu, iç bir projeyi açık kaynağa dönüştürmek istiyorsanız, ancak çalışan dizininizi herkese yayınlamak istemiyorsanız iyidir.
E-posta adreslerinin ve tam adların benzersiz olması gerektiğini unutmayın, aksi takdirde tüm Git katkıları tek bir kurgusal yazarla ilişkilendirilir.</p>
</div>
</div>
<div class="sect5">
<h6 id="_i̇ş_akışı_3">İş Akışı</h6>
<div class="paragraph">
<p>Perforce Git Fusion, Perforce ve Git sürüm kontrolü arasında iki yönlü bir köprüdür.
Şimdi Git tarafından çalışmak nasıl hissettiriyor, ona bir göz atalım.
Yukarıda gösterildiği gibi bir yapılandırma dosyasını kullanarak <code>Jam</code> projesini eşlediğimizi varsayalım.
Şu şekilde kopyalayabiliriz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone https://10.0.1.254/Jam
Cloning into 'Jam'...
Username for 'https://10.0.1.254': john
Password for 'https://john@10.0.1.254':
remote: Counting objects: 2070, done.
remote: Compressing objects: 100% (1704/1704), done.
Receiving objects: 100% (2070/2070), 1.21 MiB | 0 bytes/s, done.
remote: Total 2070 (delta 1242), reused 0 (delta 0)
Resolving deltas: 100% (1242/1242), done.
Checking connectivity... done.
$ git branch -a
* master
  remotes/origin/HEAD -&gt; origin/master
  remotes/origin/master
  remotes/origin/rel2.1
$ git log --oneline --decorate --graph --all
* 0a38c33 (origin/rel2.1) Create Jam 2.1 release branch.
| * d254865 (HEAD, origin/master, origin/HEAD, master) Upgrade to latest metrowerks on Beos -- the Intel one.
| * bd2f54a Put in fix for jam's NT handle leak.
| * c0f29e7 Fix URL in a jam doc
| * cc644ac Radstone's lynx port.
[...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bunu ilk kez yaptığınızda, biraz zaman alabilir.
Olup biten şey, Git Fusion’ın Perforce geçmişindeki tüm uygun değişiklikleri Git katkılarına dönüştürmesidir.
Bu, sunucuda yerel olarak gerçekleştiği için, nispeten hızlıdır, ancak geçmişiniz çok kalabalıksa, biraz zaman alabilir.
Sonraki çekmeler, artımlı dönüşüm yapar, bu yüzden Git’in kendi hızı gibi hissettirecektir.</p>
</div>
<div class="paragraph">
<p>Görebileceğiniz gibi, repomuz Git ile çalıştığınız diğer herhangi bir Git reposuna benzer.
Üç dal var ve Git, <code>origin/master</code>'ı izleyen bir yerel <code>master</code> dalı oluşturdu.
Biraz çalışıp birkaç yeni katkı oluşturalım:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console"># ...
$ git log --oneline --decorate --graph --all
* cfd46ab (HEAD, master) Add documentation for new feature
* a730d77 Whitespace
* d254865 (origin/master, origin/HEAD) Upgrade to latest metrowerks on Beos -- the Intel one.
* bd2f54a Put in fix for jam's NT handle leak.
[...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>İki yeni katkımız var.
Şimdi başka birinin de çalışıp çalışmadığını kontrol edelim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git fetch
remote: Counting objects: 5, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 2), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://10.0.1.254/Jam
   d254865..6afeb15  master     -&gt; origin/master
$ git log --oneline --decorate --graph --all
* 6afeb15 (origin/master, origin/HEAD) Update copyright
| * cfd46ab (HEAD, master) Add documentation for new feature
| * a730d77 Whitespace
|/
* d254865 Upgrade to latest metrowerks on Beos -- the Intel one.
* bd2f54a Put in fix for jam's NT handle leak.
[...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Görünüşe göre biri çalışmış!
Bu ekrandan bunu bilmezsiniz, ancak <code>6afeb15</code> katkısı aslında bir Perforce istemcisi kullanılarak oluşturuldu.
Git’in açısından sadece başka bir katkı gibi görünüyor, işte bahsettiğimiz tam olarak bu.
Şimdi Perforce sunucusunun bir birleştirme katkısı ile nasıl başa çıktığına bakalım:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge origin/master
Auto-merging README
Merge made by the 'recursive' strategy.
 README | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
$ git push
Counting objects: 9, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (9/9), done.
Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, done.
Total 9 (delta 6), reused 0 (delta 0)
remote: Perforce: 100% (3/3) Loading commit tree into memory...
remote: Perforce: 100% (5/5) Finding child commits...
remote: Perforce: Running git fast-export...
remote: Perforce: 100% (3/3) Checking commits...
remote: Processing will continue even if connection is closed.
remote: Perforce: 100% (3/3) Copying changelists...
remote: Perforce: Submitting new Git commit objects to Perforce: 4
To https://10.0.1.254/Jam
   6afeb15..89cba2b  master -&gt; master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git’e göre iş tamam.
Şimdi de Perforce açısından, <code>p4v</code> 'nin revizyon grafiği özelliğini kullanarak <code>README</code> dosyasının geçmişine bir göz atalım:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/git-fusion-perforce-graph.png" >}}" alt="Git itmesinden kaynaklanan Perforce revizyon grafiği.">
</div>
<div class="title">Görsel 146. Git itmesinden kaynaklanan Perforce revizyon grafiği.</div>
</div>
<div class="paragraph">
<p>Bu görüntüyü daha önce hiç görmediyseniz, kafa karıştırıcı görünebilir ancak tıpkı Git geçmişi için tasarlanan bir grafiksel görüntüleyici gibi çalışır.
<code>README</code> dosyasının geçmişine bakıyoruz, bu yüzden sol üst köşedeki dizin ağacı, dosyanın çeşitli dallarda nasıl göründüğünü göstermetderir.
Sağ üstte, dosyanın farklı revizyonlarının nasıl ilişkilendirildiğini gösteren bir görsel grafik vardır, sağ altta ise bu grafiğin genel görünümü bulunur.
Geri kalan görünüm, seçilen revizyonun detaylı görünümüne (burada <code>2</code>) ayrılmıştır.</p>
</div>
<div class="paragraph">
<p>Dikkat edilmesi gereken bir şey de, grafiğin tam olarak Git geçmişindeki gibi görünmesidir.
Perforce, <code>1</code> ve <code>2</code> katkılarını depolamak için adlandırılmış bir dalı olmadığı için, onu saklamak için <code>.git-fusion</code> dizininde "isimsiz" bir dal oluşturdu.
Bu davranış ismi olan Git dalları için de gerçekleşir (bu dalları daha sonra bir Perforce dalına yapılandırma dosyasını kullanarak eşleştirebilirsiniz).</p>
</div>
<div class="paragraph">
<p>Bunların çoğu arka planda gerçekleşir, ancak sonuç olarak bir ekip içinde bir kişi Git’i kullanırken, diğeri Perforce’u kullanabilir ve ikisi de diğerinin tercihinden haberdar olmaz.</p>
</div>
</div>
<div class="sect5">
<h6 id="_özet_olarak_git_fusion">Özet Olarak Git-Fusion</h6>
<div class="paragraph">
<p>Perforce sunucunuza erişiminiz varsa (veya edinebilirseniz), Git Fusion’ın Git ve Perforce’un birbirleriyle iletişim kurmasının harika bir yolu olduğunu göreceksiniz.
Bunun için biraz yapılandırma gereklidir, ancak öğrenme eğrisi çok dik değildir.
Bu bölüm, Git’in tam gücünü kullanmanın sakıncalarıyla ilgili uyarıların pek yer almadığı nadir bölümlerden biridir.
Bu, Perforce’un üzerine fırlattığınız her şeyden mutlu olacağı anlamına gelmez (mesela, zaten gönderilmiş olan geçmişi yeniden yazmaya çalışırsanız, Git Fusion bunu reddedecektir) ancak Git Fusion normal davranmak için çok çaba sarf eder.
Hatta Git altmodüllerini bile kullanabilirsiniz (ancak bunlar Perforce kullanıcıları için garip görünebilir) ve dalları birleştirebilirsiniz (bu, Perforce tarafında bir entegrasyon olarak kaydedilecektir).</p>
</div>
<div class="paragraph">
<p>Sunucunuzun yöneticisini Git Fusion’ı kurmaya ikna edemezseniz, bu araçları birlikte kullanmanın yine de bir yolu vardır.</p>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_git_p4_client">Git-p4</h4>
<div class="paragraph">
<p>
Git-p4, Git ile Perforce arasında iki yönlü bir köprüdür.
 Tamamen Git reposu içinde çalışır, bu nedenle Perforce sunucusuna erişim sağlamanıza gerek yoktur (elbette kullanıcı kimlik bilgilerine ihtiyacınız olacaktır).
 Git-p4, Git Fusion kadar esnek veya tam bir çözüm değildir, ancak sunucu ortamına aşırı müdahale etmeden istediğiniz çoğu şeyi yapmanıza izin verir.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Not</div>
</td>
<td class="content">
<div class="paragraph">
<p>You’ll need the <code>p4</code> tool somewhere in your <code>PATH</code> to work with git-p4.
As of this writing, it is freely available at <a href="http://www.perforce.com/downloads/Perforce/20-User" class="bare">http://www.perforce.com/downloads/Perforce/20-User</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="_kurulum_4">Kurulum</h6>
<div class="paragraph">
<p>Örnek amaçlar için yukarıda gösterildiği gibi Git Fusion OVA’sından Perforce sunucusunu çalıştıracağız, ancak Git Fusion sunucusunu atlayacak ve doğrudan Perforce sürüm kontrolüne gideceğiz.</p>
</div>
<div class="paragraph">
<p>Git-p4’ün bağımlı olduğu <code>p4</code> komut satırı istemcisini kullanabilmek için birkaç ortam değişkenini ayarlamanız gerekecektir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ export P4PORT=10.0.1.254:1666
$ export P4USER=john</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_başlarken_3">Başlarken</h6>
<div class="paragraph">
<p>Git’teki herşeyde olduğu gibi, ilk iş kopyalamaktır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git p4 clone //depot/www/live www-shallow
Importing from //depot/www/live into www-shallow
Initialized empty Git repository in /private/tmp/www-shallow/.git/
Doing initial import of //depot/www/live/ from revision #head into refs/remotes/p4/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu, Git terimleriyle bir "yüzeysel" bir kopya oluşturur; sadece en son Perforce revizyonu Git’e aktarılır.
Unutmayın, Perforce, her revizyonu her kullanıcıya vermek için tasarlanmamıştır!
Bu, Git’i bir Perforce istemcisi olarak kullanmak için yeterlidir, ancak diğer amaçlar için yeterli değildir.</p>
</div>
<div class="paragraph">
<p>İşlem tamamlandığında, tamamen işlevsel bir Git reposuna sahip olacaksınız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cd myproject
$ git log --oneline --all --graph --decorate
* 70eaf78 (HEAD, p4/master, p4/HEAD, master) Initial import of //depot/www/live/ from the state at revision #head</code></pre>
</div>
</div>
<div class="paragraph">
<p>Perforce sunucusu için uzak bir <code>p4</code> reposu var gibi görünse de, diğer her şey standart bir kopya gibi görünür.
Aslında, bu biraz yanıltıcıdır; zira aslında bir uzak repo yoktur.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote -v</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu repoda hiçbir uzak repo yoktur.
Git-p4 sunucunun durumunu temsil etmek için bazı referanslar oluşturmuştur ve bunlar <code>git log</code> için uzak referanslara benzeyebilir, ancak Git’in kendisi tarafından yönetilmezler ve bunlara itme işlemi gerçekleştiremezsiniz.</p>
</div>
</div>
<div class="sect5">
<h6 id="_i̇ş_akışı_4">İş Akışı</h6>
<div class="paragraph">
<p>Hadi, biraz iş yapalım.
Varsayalım ki çok önemli bir özellik üzerinde biraz ilerleme kaydettiniz ve geri kalan ekibinize göstermeye hazırsınız.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --all --graph --decorate
* 018467c (HEAD, master) Change page title
* c0fb617 Update link
* 70eaf78 (p4/master, p4/HEAD) Initial import of //depot/www/live/ from the state at revision #head</code></pre>
</div>
</div>
<div class="paragraph">
<p>Perforce sunucusuna gönderilmeye hazır iki yeni katkımız var.
Bugün başka birinin çalışıp çalışmadığını kontrol edelim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git p4 sync
git p4 sync
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
Import destination: refs/remotes/p4/master
Importing revision 12142 (100%)
$ git log --oneline --all --graph --decorate
* 75cd059 (p4/master, p4/HEAD) Update copyright
| * 018467c (HEAD, master) Change page title
| * c0fb617 Update link
|/
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</code></pre>
</div>
</div>
<div class="paragraph">
<p>Görünüşe göre <code>master</code> ile <code>p4/master</code> ayrışmış durumda.
Perforce’un dal sistemi <em>kesinlikle</em> Git’inki gibi değil, bu nedenle birleştirme katkılarını göndermek hiçbir anlam ifade etmez.
Git-p4 katkılarınızı yeniden temellemenizi önerir ve hatta bunu yapmanız için size bir kısayol sunar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git p4 rebase
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
No changes to import!
Rebasing the current branch onto remotes/p4/master
First, rewinding head to replay your work on top of it...
Applying: Update link
Applying: Change page title
 index.html | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Çıktıdan anlayabilirsiniz ama <code>git p4 rebase</code>, <code>git rebase p4/master</code>'ı takiben <code>git p4 sync</code> için bir kısayoldur.
Özellikle birden fazla dal üzerinde çalışırken biraz daha akılcı bir yöntem ve iyi bir yaklaşımdır.</p>
</div>
<div class="paragraph">
<p>Şimdi geçmişimiz tekrar çizgisel hale geldi ve değişikliklerimizi Perforce’a tekrar katkıda bulunmaya hazırız.
<code>git p4 submit</code> komutu, <code>p4/master</code> ile <code>master</code> arasındaki her Git katkısı için yeni bir Perforce revizyonu oluşturmaya çalışacaktır. Çalıştırdığımızda, bizi favori metin düzenleyicimize götürür ve dosyanın içeriği şuna benzemektedir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console"># A Perforce Change Specification.
#
#  Change:      The change number. 'new' on a new changelist.
#  Date:        The date this specification was last modified.
#  Client:      The client on which the changelist was created.  Read-only.
#  User:        The user who created the changelist.
#  Status:      Either 'pending' or 'submitted'. Read-only.
#  Type:        Either 'public' or 'restricted'. Default is 'public'.
#  Description: Comments about the changelist.  Required.
#  Jobs:        What opened jobs are to be closed by this changelist.
#               You may delete jobs from this list.  (New changelists only.)
#  Files:       What opened files from the default changelist are to be added
#               to this changelist.  You may delete files from this list.
#               (New changelists only.)

Change:  new

Client:  john_bens-mbp_8487

User: john

Status:  new

Description:
   Update link

Files:
   //depot/www/live/index.html   # edit


######## git author ben@straub.cc does not match your p4 account.
######## Use option --preserve-user to modify authorship.
######## Variable git-p4.skipUserNameCheck hides this message.
######## everything below this line is just the diff #######
--- //depot/www/live/index.html  2014-08-31 18:26:05.000000000 0000
+++ /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/index.html   2014-08-31 18:26:05.000000000 0000
@@ -60,7 +60,7 @@
 &lt;/td&gt;
 &lt;td valign=top&gt;
 Source and documentation for
-&lt;a href="http://www.perforce.com/jam/jam.html"&gt;
+&lt;a href="jam.html"&gt;
 Jam/MR&lt;/a&gt;,
 a software build tool.
 &lt;/td&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Bir Perforce Değişiklik Belgesi.

Değişiklik: Değişiklik numarası. Yeni bir değişiklik listesi için 'new.
Tarih:      Bu belgenin son olarak ne zaman değiştirildiği.
İstemci:    Değişiklik listesinin oluşturulduğu istemci. Salt okunur.
Kullanıcı:  Değişiklik listesini oluşturan kullanıcı.
Durum:      'pending' veya 'submitted' olabilir. Salt okunur.
Tür:        'public' veya 'restricted' olabilir. Varsayılan olarak 'public'.
Açıklama:   Değişiklik listesi hakkındaki yorumlar. Gereklidir.
İşler:      Bu değişiklik listesi tarafından kapatılacak açık işler.
            Bu listeden işleri silebilirsiniz. (Yeni değişiklik listeleri için.)
Dosyalar:   What opened files from the default changelist are to be added to this changelist.
            You may delete files from this list. (New changelists only.)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu, <code>p4 submit</code> komutunu çalıştırarak görebileceğiniz içeriğin çoğunlukla aynısıdır, ancak git-p4’ün yardımcı olarak dahil ettiği son kısımdan farklıdır.
Git-p4, bir katkı veya değişiklik kümesi için bir isim sağlamak zorunda kaldığında, Git ve Perforce ayarlarınızı ayrı ayrı dikkate almaya çalışır, ancak bazı durumlarda bunu geçersiz kılmak isteyebilirsiniz.
Örneğin, içe aktardığınız Git katkısı bir Perforce kullanıcı hesabı olmayan bir katılımcı tarafından yazılmışsa; sonuçta oluşan değişiklik kümesinin, sizin tarafınızdan değil de onun tarafından yazıldığı gibi görünmesini isteyebilirsiniz.</p>
</div>
<div class="paragraph">
<p>Git-p4, bu Perforce değişiklik listesi için içerik olarak Git katkı mesajı ithal ettiği için, yapmamız gereken tek şey her bir katkı için kaydetmek ve çıkmaktır.
Sonuçta oluşan shell çıktısı şuna benzer olacaktır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git p4 submit
Perforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Synchronizing p4 checkout...
... - file(s) up-to-date.
Applying dbac45b Update link
//depot/www/live/index.html#4 - opened for edit
Change 12143 created with 1 open file(s).
Submitting change 12143.
Locking 1 files ...
edit //depot/www/live/index.html#5
Change 12143 submitted.
Applying 905ec6a Change page title
//depot/www/live/index.html#5 - opened for edit
Change 12144 created with 1 open file(s).
Submitting change 12144.
Locking 1 files ...
edit //depot/www/live/index.html#6
Change 12144 submitted.
All commits applied!
Performing incremental import into refs/remotes/p4/master git branch
Depot paths: //depot/www/live/
Import destination: refs/remotes/p4/master
Importing revision 12144 (100%)
Rebasing the current branch onto remotes/p4/master
First, rewinding head to replay your work on top of it...
$ git log --oneline --all --graph --decorate
* 775a46f (HEAD, p4/master, p4/HEAD, master) Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sonuçta, aslında <code>git push</code> yapmışız gibi oldu, bu gerçekte olan şeye en yakın benzetimdir.</p>
</div>
<div class="paragraph">
<p>Bu süreçte her Git katkısı bir Perforce değişiklik kümesine dönüştürülür.
Eğer onları tek bir değişiklik kümesine sıkıştırmak istiyorsanız, bunu <code>git p4 submit</code> komutunu çalıştırmadan önce, etkileşimli bir temelleme ile yapabilirsiniz.
Ayrıca, değişiklik kümesi olarak gönderilen tüm katkıların SHA-1 karmalarının değiştiğini unutmayın.
Bu, git-p4’ün dönüştürdüğü her katkıya bir satır eklemesinden kaynaklanır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -1
commit 775a46f630d8b46535fc9983cf3ebe6b9aa53145
Author: John Doe &lt;john@example.com&gt;
Date:   Sun Aug 31 10:31:44 2014 -0800

    Change page title

    [git-p4: depot-paths = "//depot/www/live/": change = 12144]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Birleştirme katkısını göndermeye çalışırsak ne olacağını bir görelim.
İşte kendimizi içine soktuğumuz durum:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --all --graph --decorate
* 3be6fd8 (HEAD, master) Correct email address
*   1dcbf21 Merge remote-tracking branch 'p4/master'
|\
| * c4689fc (p4/master, p4/HEAD) Grammar fix
* | cbacd0a Table borders: yes please
* | b4959b6 Trademark
|/
* 775a46f Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git ve Perforce geçmişi 775a46f sonrasında ayrılıyor.
Git tarafında iki katkı var, ardından Perforce başı ile birleştirme katkısı, ve onun ardından başka bir katkı daha.
Bu katkıları tek bir değişiklik kümesinin üzerine Perforce tarafında göndermeyi deneyeceğiz.
Şimdi göndermeye çalışırsak ne olacağını görelim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git p4 submit -n
Perforce checkout for depot path //depot/www/live/ located at /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Would synchronize p4 checkout in /Users/ben/john_bens-mbp_8487/john_bens-mbp_8487/depot/www/live/
Would apply
  b4959b6 Trademark
  cbacd0a Table borders: yes please
  3be6fd8 Correct email address</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>-n</code> bayrağı, <code>--dry-run</code> için kısaltmadır ve gönderme komutunun gerçekten çalıştırılsaydı ne olacağını rapor etmeye çalışır.
Burada, üç adet Perforce değişiklik kümesi oluşturacağımızı gösteriyor.
Bunlar Perforce sunucusunda henüz bulunmayan birleştirmesiz (non-merge) üç katkıya karşılık gelir.
Tam olarak istediğimiz gibi görünüyor.
Şimdi nasıl sonuçlandığını görelim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git p4 submit
[…]
$ git log --oneline --all --graph --decorate
* dadbd89 (HEAD, p4/master, p4/HEAD, master) Correct email address
* 1b79a80 Table borders: yes please
* 0097235 Trademark
* c4689fc Grammar fix
* 775a46f Change page title
* 05f1ade Update link
* 75cd059 Update copyright
* 70eaf78 Initial import of //depot/www/live/ from the state at revision #head</code></pre>
</div>
</div>
<div class="paragraph">
<p>Geçmişimiz, katkıları göndermeden önce yeniden temellemişiz gibi çizgisel hale geldi (gerçekte olan budur).
Bu, Git tarafında dallar oluşturabileceğiniz, üzerinde çalışabileceğiniz, silebileceğiniz, birleştirebileceğiniz ve geçmişinizin Perforce ile uyumsuz hale gelme korkusu olmadan özgürce çalışabileceğiniz anlamına gelir.
Yeniden temelleme yaparsanız, bunu bir Perforce sunucusuna gönderebilirsiniz.</p>
</div>
</div>
<div class="sect5">
<h6 id="_git_p4_branches">Dallandırma</h6>
<div class="paragraph">
<p>Perforce projenizde birden fazla dal bulunuyorsa, şansınız tükenmiş değil, git-p4 bunu Gitmişçesine yönetebilir.
Diyelim ki Perforce deponuz şu şekilde düzenlenmiş:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>//depot
  └── project
      ├── main
      └── dev</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ve diyelim ki <code>dev</code> adında bir dalınız var ve bu dalın bir görünüm özelliği şu şekilde görünüyor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>//depot/project/main/... //depot/project/dev/...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git-p4 bu durumu otomatik olarak algılayabilir ve doğru işlemi yapabilir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git p4 clone --detect-branches //depot/project@all
Importing from //depot/project@all into project
Initialized empty Git repository in /private/tmp/project/.git/
Importing revision 20 (50%)
    Importing new branch project/dev

    Resuming with change 20
Importing revision 22 (100%)
Updated branches: main dev
$ cd project; git log --oneline --all --graph --decorate
* eae77ae (HEAD, p4/master, p4/HEAD, master) main
| * 10d55fb (p4/project/dev) dev
| * a43cfae Populate //depot/project/main/... //depot/project/dev/....
|/
* 2b83451 Project init</code></pre>
</div>
</div>
<div class="paragraph">
<p>Depo yolundaki ``@all`` belirleyicisine dikkat edin: git-p4’e yalnızca bu alt ağaç için en son değişiklik kümesini değil, bu dizinlere dokunmuş tüm değişiklik kümelerini kopyalamasını söyler.
Bu Git’in kopya (clone) kavramına daha yakındır, ancak geçmişi uzun bir projede çalışıyorsanız, biraz zaman alabilir.</p>
</div>
<div class="paragraph">
<p><code>--detect-branches</code> bayrağı git-p4’ün Perforce’un dal özelliklerini kullanarak dalları Git referanslarına eşlemesini söyler.
Bu eşlemeler Perforce sunucusunda bulunmuyorsa (bu, Perforce’u kullanmanın tamamen geçerli bir yoludur), git-p4’e dal eşlemelerinin ne olduğunu söyleyebilirsiniz ve aynı sonucu alırsınız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git init project
Initialized empty Git repository in /tmp/project/.git/
$ cd project
$ git config git-p4.branchList main:dev
$ git clone --detect-branches //depot/project@all .</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>git-p4.branchList</code> yapılandırma değişkenini <code>main:dev</code> olarak ayarlamak, git-p4’e ``main`` ve ``dev`` 'in her ikisinin de dallar olduğunu ve ikincisinin birincisinin bir alt dalı olduğunu söyler.</p>
</div>
<div class="paragraph">
<p>Şimdi <code>git checkout -b dev p4/project/dev</code> yapar ve bazı katkılar işlersek, <code>git p4 submit</code> yaptığımızda git-p4’ün doğru dala hedef alacak kadar akıllı olduğunu göreceğiz.
Ne yazık ki, git-p4 sığ kopyaları ve birden fazla dalı karıştıramaz.
Büyük bir projede ve birden fazla dalda çalışmak istiyorsanız, göndermek istediğiniz her dal için bir kez <code>git p4 clone</code> yapmanız gerekecektir.</p>
</div>
<div class="paragraph">
<p>Dallar oluşturmak veya entegre etmek için bir Perforce istemcisini kullanmanız gerekecektir.
Git-p4 yalnızca mevcut dalları senkronize edip ve kaydedebilir ve bunu da sadece bir çizgisel değişiklik kümesiyle yapabilir.
Eğer Git’te iki dalı birleştirir ve yeni değişiklik kümesini göndermeye çalışırsanız, kaydedilen tek şey bir sürü dosya değişikliği olacaktır. Entegrasyona hangi dalların katıldığına dair meta veriler kaybolacaktır.</p>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_özetle_git_ve_perforce">Özetle Git ve Perforce</h4>
<div class="paragraph">
<p>Git-p4, bir Perforce sunucusu ile Git iş akışını kullanmayı mümkün kılar ve bu konuda oldukça iyidir.
Ancak kaynakların kontrolünün Perforce’da olduğunu ve Git’i sadece yerelde çalışmak için kullandığınızı unutmamalısınız.
Git katkılarını paylaşırken çok dikkatli olun.
Başkalarıyla ortak kullandığız bir uzak sunucunuz varsa, Perforce sunucusuna göndermediğiniz hiçbir katkıyı oraya göndermeyin.</p>
</div>
<div class="paragraph">
<p>Eğer Perforce ve Git’i özgürce kaynak kontrolü istemcileri olarak karıştırmak ister ve sunucu yöneticisini bunu kurmaya ikna edebilirseniz; Git Fusion, Git’i bir Perforce sunucusu için birinci sınıf bir versiyon kontrol istemcisi olarak kullanmanızı sağlar.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_git_ve_tfs">Git ve TFS</h3>
<div class="paragraph">
<p>

Git Windows geliştiricileri arasında gittikçe daha popüler hale gelmektedir ve eğer Windows üzerinde kod yazıyorsanız, Microsoft’un Team Foundation Server (TFS) kullanma olasılığınız yüksektir.
TFS, hata ve iş öğesi izleme, Scrum ve diğerleri için süreç desteği, kod incelemesi ve sürüm kontrolü gibi işbirliği paketini içerir.
Ancak önümüzde biraz kafa karışıklığı vardır: TFS kendi özel VCS’leri olan <strong>TFVC</strong> (Team Foundation Version Control) ile birlikte Git’i de destekleyen bir sunucudur.
Git desteği TFS’in nispeten yeni bir özelliğidir (2013 sürümü ile birlikte gelmiştir), bu yüzden daha öncesindeki tüm araçlar, çoğunlukla TFVC ile çalışsalar da sürüm kontrol kısmını "TFS" olarak adlandırırlar.</p>
</div>
<div class="paragraph">
<p>Eğer kendinizi TFVC kullanan bir takımda bulursanız ve sürüm kontrol istemci olarak Git’i tercih ediyorsanız, sizin için bir proje bulunmaktadır.</p>
</div>
<div class="sect4">
<h4 id="_hangi_araç">Hangi Araç</h4>
<div class="paragraph">
<p>
İki tane bulunmaktadır: git-tf ve git-tfs.</p>
</div>
<div class="paragraph">
<p><strong>Git-tfs</strong> (<a href="https://github.com/git-tfs/git-tfs" class="bare">https://github.com/git-tfs/git-tfs</a> adresinde bulabilirsiniz) yalnızca Windows’ta çalışın bir .NET projesidir.
Git repolarıyla çalışmak için libgit2 için .NET bağlantılarını kullanır.
Libgit2 Git’in kütüphane odaklı bir uygulamasıdır ve Git reposunun iç yapısında esneklik ve yüksek performans sağlar.
Libgit2, Git’in tam bir uygulaması değildir, bu yüzden farklılıkları kapsamak için bazı işlemlerde aslında komut satırı Git istemcisini çağırır.
Yani, Git repolarıyla yapabileceği işlemler üzerinde yapay sınırlamalar yoktur.
Sunucu işlemleri için Visual Studio derlemelerini kullandığı için, TFVC özelliklerine olan desteği çok ileri seviyededir.
Bu, bu derlemelere erişiminizin olması gerektiği anlamına gelir, yani son sürüm bir Visual Studio (2010 sürümünden itibaren herhangi bir sürüm, 2012 sürümünden itibaren Express sürümleri dahil) veya Visual Studio SDK’sı kurmanız gerekir.</p>
</div>
<div class="paragraph">
<p><strong>Git-tf</strong> (<a href="https://gittf.codeplex.com" class="bare">https://gittf.codeplex.com</a> adresinde bulabilirsiniz) bir Java projesidir ve Java çalışma ortamına (runtime environment) sahip her bilgisayarda çalışır.
Git repolarıyla JGit (Git’in JVM uygulaması) aracılığıyla etkileşir, bu da Git işlevleri açısından neredeyse hiçbir kısıtlaması olmadığı anlamına gelir.
Ancak, git-tfs’e kıyasla TFVC desteği sınırlıdır (örneğin dalları desteklemez).</p>
</div>
<div class="paragraph">
<p>Her bir aracın avantajları ve dezavantajları vardır ve birini diğerine tercih eden birçok durum bulunur.
Bu kitapta her ikisinin de temel kullanımını ele alacağız.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Not</div>
</td>
<td class="content">
<div class="paragraph">
<p>Bu yönergeleri takip etmek için TFVC tabanlı bir repoya erişiminiz olması gerekecek.
Bunlar genelde Git veya Subversion repoları kadar yaygın değildir, bu yüzden kendi TFVC tabanlı reponuzu oluşturmanız gerekebilir.
Codeplex (<a href="https://www.codeplex.com" class="bare">https://www.codeplex.com</a>) veya Visual Studio Online (<a href="https://visualstudio.microsoft.com" class="bare">https://visualstudio.microsoft.com</a>) araçlarının her ikisi de bunun için iyi seçeneklerdir.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h4 id="_git_tf_giriş">
<code>git-tf</code> Giriş</h4>
<div class="paragraph">
<p>Herhangi bir Git projesi gibi, ilk yapmanız gereken kopyalamadır.
İşte <code>git-tf</code> ile bunun nasıl yapıldığı:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git tf clone https://tfs.codeplex.com:443/tfs/TFS13 $/myproject/Main project_git</code></pre>
</div>
</div>
<div class="paragraph">
<p>İlk argüman, bir TFVC koleksiyonunun URL’sidir, ikincisi <code>$ / proje / dal</code> formunda ve üçüncüsü oluşturulacak yerel Git reposunun dizinidir (bu sonuncusu isteğe bağlıdır).
Git-tf tek seferde yalnızca bir dalda çalışabilir: farklı bir TFVC dalında geçiş yapmak istiyorsanız, o daldan yeni bir klon oluşturmanız gerekecektir.</p>
</div>
<div class="paragraph">
<p>Bu tam olarak işlevsel bir Git reposu oluşturur:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cd project_git
$ git log --all --oneline --decorate
512e75a (HEAD, tag: TFS_C35190, origin_tfs/tfs, master) Checkin message</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu, yalnızca en son değişiklik setinin indirildiği <em>sığ</em> bir klon denir.
TFVC her istemcinin tüm geçmişin tam bir kopyasına sahip olması için tasarlanmamıştır, bu nedenle git-tf varsayılan olarak yalnızca en son sürümü almak için ayarlanmıştır ki bu çok daha hızlıdır.</p>
</div>
<div class="paragraph">
<p>Eğer zamanınız varsa <code>--deep</code> seçeneğini kullanarak tüm proje geçmişini kopyalamakta fayda vardır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git tf clone https://tfs.codeplex.com:443/tfs/TFS13 $/myproject/Main \
  project_git --deep
Username: domain\user
Password:
Connecting to TFS...
Cloning $/myproject into /tmp/project_git: 100%, done.
Cloned 4 changesets. Cloned last changeset 35190 as d44b17a
$ cd project_git
$ git log --all --oneline --decorate
d44b17a (HEAD, tag: TFS_C35190, origin_tfs/tfs, master) Goodbye
126aa7b (tag: TFS_C35189)
8f77431 (tag: TFS_C35178) FIRST
0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
        Team Project Creation Wizard</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>TFS_C35189</code> gibi adlara sahip etiketlere dikkat edin: bu hangi Git commit’lerinin TFVC değişiklik setleri ile ilişkilendirildiğini bilmeye yardımcı olan bir özelliktir.
Bu basit bir log komutu ile hangi katkılarınızın TFVC’de de bulunan bir poz ile ilişkili olduğunu görebileceğiniz, hoş bir yoldur.
Bunlar aslında gerekli değildir (<code>git config git-tf.tag false</code> ile de bunları kapatabilirsiniz).
git-tf gerçek katkı-değişiklik seti eşlemelerini <code>.git/git-tf</code> dosyasında tutar.</p>
</div>
</div>
<div class="sect4">
<h4 id="_git_tfs_giriş">
<code>git-tfs</code> Giriş</h4>
<div class="paragraph">
<p>Git-tfs klonlaması biraz farklı davranır.
İnceleyin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-powershell" data-lang="powershell">PS&gt; git tfs clone --with-branches \
    https://username.visualstudio.com/DefaultCollection \
    $/project/Trunk project_git
Initialized empty Git repository in C:/Users/ben/project_git/.git/
C15 = b75da1aba1ffb359d00e85c52acb261e4586b0c9
C16 = c403405f4989d73a2c3c119e79021cb2104ce44a
Tfs branches found:
- $/tfvc-test/featureA
The name of the local branch will be : featureA
C17 = d202b53f67bde32171d5078968c644e562f1c439
C18 = 44cd729d8df868a8be20438fdeeefb961958b674</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>--with-branches</code> bayrağına dikkat edin.
Git-tfs TFVC dallarını Git dallarına eşleyecek yetenektedir ve bu bayrak her TFVC dalı için yerel bir Git dalı kurmasını söyler.
Bu TFS’de şimdiye kadar dallandırma veya birleştirme yaptıysanı kesinlikle önerilir, ancak TFS 2010’dan önceki bir sunucu ile çalışmaz (bu sürümden önce "dallar" sadece klasörlerdi, bu yüzden git-tfs onları normal klasörlerden ayırt edemez).</p>
</div>
<div class="paragraph">
<p>Şimdi oluşan Git reposuna bir göz atalım:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-powershell" data-lang="powershell">PS&gt; git log --oneline --graph --decorate --all
* 44cd729 (tfs/featureA, featureA) Goodbye
* d202b53 Branched from $/tfvc-test/Trunk
* c403405 (HEAD, tfs/default, master) Hello
* b75da1a New project
PS&gt; git log -1
commit c403405f4989d73a2c3c119e79021cb2104ce44a
Author: Ben Straub &lt;ben@straub.cc&gt;
Date:   Fri Aug 1 03:41:59 2014 +0000

    Hello

    git-tfs-id: [https://username.visualstudio.com/DefaultCollection]$/myproject/Trunk;C16</code></pre>
</div>
</div>
<div class="paragraph">
<p>İki yerel dal vardır: <code>master</code> ve <code>featureA</code>.
Bu da kopyalamanın başlangıç noktasını (TFVC’de <code>Trunk</code>) ve bir alt dalı (TFVC’de <code>featureA</code>) temsil eder.
Ayrıca <code>tfs</code> "remote" <em>da</em> TFVC dallarını temsil eden bir çift referans da bulunur: <code>default</code> ve <code>featureA</code>.
Git-tfs kopyaladığınız dalı <code>tfs/default</code> ile eşler, diğerleri kendi adlarını alır.</p>
</div>
<div class="paragraph">
<p>Dikkate değer bir başka bir şey de Katkı mesajlarındaki <code>git-tfs-id:</code> satırlarıdır.
git-tfs etiketler yerine bu işaretleri kullanarak TFVC değişiklik setlerini Git katkılarıyla ilişkilendirir.
Bu Git katkılarınızın TFVC’ye gönderilmeden önce ve sonra farklı SHA-1 karma değerlerine sahip olacağı anlamına gelir.</p>
</div>
</div>
<div class="sect4">
<h4 id="_git_tfs_i̇ş_akışı">Git-tf[s] İş Akışı</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Not</div>
</td>
<td class="content">
<div class="paragraph">
<p>Hangi aracı kullandığınızdan bağımsız olarak, sorunlarla karşılaşmamak için birkaç Git yapılandırma değerini ayarlamanız önerilir.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config set --local core.ignorecase=true
$ git config set --local core.autocrlf=false</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sıradaki işiniz bir projede çalışmak olacaktır.
TFVC ve TFS iş akışınıza karmaşıklık katabilecek birkaç özellik sunar:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>TFVC’de temsil edilmeyen özellik dalları karmaşıklığı arttırır.
Bu TFVC ve Git’in dalları temsil etme şekillerinin <strong>çok</strong> farklı olmasından kaynaklanır.</p>
</li>
<li>
<p>TFVC kullanıcıların dosyaları sunucudan "checkout" yapıp kilitleyerek, başkalarının onları değiştirmesini engellemenize izin verir.
Bu, elbette, dosyaları yerel repoda düzenlemeyi engellemeyecektir, ancak değişikliklerinizi TFVC sunucusuna yüklerken engel olabilir.</p>
</li>
<li>
<p>TFS’nin "gated" checkin kavramı vardır, burada bir TFS derleme-test döngüsünün başarıyla tamamlanması gerekmektedir.
Bu, TFVC’de <code>shelve</code> işlevini kullanır, ancak burada bunu incelemeyeceğiz.
Bu işlemi git-tf ile manuel olarak taklit edebilirsiniz ve git-tfs gate bilgisine sahip olan <code>checkintool</code> komutunu sağlar.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Kısa ve öz olması adına, burada kapsayacağımız şey, çoğu bu sorunları atlatmanızı veya onlardan kaçınmanızı sağlayacak "mutlu patika" olacaktır.</p>
</div>
</div>
<div class="sect4">
<h4 id="_git_tf_i̇ş_akışı">
<code>git-tf</code> İş Akışı</h4>
<div class="paragraph">
<p>Diyelim ki biraz çalışma yaptınız, <code>master</code> üzerinde birkaç Git katkısı yaptınız ve ilerlemenizi TFVC sunucusuyla paylaşmaya hazırsınız.
İşte Git repomuz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --graph --decorate --all
* 4178a82 (HEAD, master) update code
* 9df2ae3 update readme
* d44b17a (tag: TFS_C35190, origin_tfs/tfs) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>4178a82</code> katkısındaki pozu almak ve bunu TFVC sunucusuna yüklemek istiyoruz.
Öncelikle, son bağlandığımızdan beri takım arkadaşlarımızın bir şeyler yapıp yapmadığını kontrol edelim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git tf fetch
Username: domain\user
Password:
Connecting to TFS...
Fetching $/myproject at latest changeset: 100%, done.
Downloaded changeset 35320 as commit 8ef06a8. Updated FETCH_HEAD.
$ git log --oneline --graph --decorate --all
* 8ef06a8 (tag: TFS_C35320, origin_tfs/tfs) just some text
| * 4178a82 (HEAD, master) update code
| * 9df2ae3 update readme
|/
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard</code></pre>
</div>
</div>
<div class="paragraph">
<p>Görünüşe göre başka biri de çalışıyor ve şimdi farklı geçmişlerimiz var.
İşte Git’in parladığı yer burasıdır, ancak ilerlemek için iki seçeneğimiz var:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Birleştirme bir Git kullanıcısı olarak doğal hissettirir (sonuçta bu <code>git pull</code> 'un yaptığı şeydir) ve git-tf bunu basit bir <code>git tf pull</code> ile yapabilir.
Ancak TFVC bu şekilde düşünmez ve birleştirme işlemlerini gönderirseniz; geçmişiniz her iki tarafta da farklı görünmeye başlayacaktır, bu da kafa karıştırıcı olabilir.
Bununla birlikte, tüm değişikliklerinizi bir değişiklik seti olarak göndermeyi planlıyorsanız, bu muhtemelen en kolay seçenektir.</p>
</li>
<li>
<p>Yeniden temelleme katkı geçmişimizi çizgisel hale getirir, bu da her bir Git katkısını bir TFVC değişiklik setine dönüştürme seçeneğimizin olduğu anlamına gelir.
En fazla seçeneği açık bıraktığından, bunu yapmanızı öneririz (git-tf bunu bile <code>git tf pull --rebase</code> ile size kolaylaştırır).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Tercih sizin.
Biz bu örnekte yeniden temelleme yapacağız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rebase FETCH_HEAD
First, rewinding head to replay your work on top of it...
Applying: update readme
Applying: update code
$ git log --oneline --graph --decorate --all
* 5a0e25e (HEAD, master) update code
* 6eb3eb5 update readme
* 8ef06a8 (tag: TFS_C35320, origin_tfs/tfs) just some text
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard</code></pre>
</div>
</div>
<div class="paragraph">
<p>Şimdi TFVC sunucusuna bir geçmeye hazırız.
Git-tf son değişiklikten bu yana tüm değişiklikleri temsil eden tek bir değişiklik seti yapma (varsayılan seçenek olan <code>--shallow</code>) veya her Git katkısı için yeni bir değişiklik seti oluşturma (<code>--deep</code>) seçeneği sunar.
Bu örnekte sadece bir değişiklik seti oluşturacağız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git tf checkin -m 'Updating readme and code'
Username: domain\user
Password:
Connecting to TFS...
Checking in to $/myproject: 100%, done.
Checked commit 5a0e25e in as changeset 35348
$ git log --oneline --graph --decorate --all
* 5a0e25e (HEAD, tag: TFS_C35348, origin_tfs/tfs, master) update code
* 6eb3eb5 update readme
* 8ef06a8 (tag: TFS_C35320) just some text
* d44b17a (tag: TFS_C35190) Goodbye
* 126aa7b (tag: TFS_C35189)
* 8f77431 (tag: TFS_C35178) FIRST
* 0745a25 (tag: TFS_C35177) Created team project folder $/tfvctest via the \
          Team Project Creation Wizard</code></pre>
</div>
</div>
<div class="paragraph">
<p>Yeni bir <code>TFS_C35348</code> etiketi var, bu da TFVC’nin tam olarak <code>5a0e25e</code> katkısındaki aynı pozu sakladığını gösteriyor.
Her Git katkısının TFVC’de tam bir karşılığa sahip olması gerekmediğini bilmek önemlidir: örneğin, <code>6eb3eb5</code> katkısı sunucudaki hiçbir yerde mevcut değildir.</p>
</div>
<div class="paragraph">
<p>Bu ana iş akışıdır.
Aklınızda bulundurmanız gereken birkaç başka husus var:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Dallanma yoktur.
Git-tf bir TFVC dalından yalnızca bir Git reposu oluşturabilir.</p>
</li>
<li>
<p>TFVC veya Git kullanarak işbirliği yapın, ancak her ikisini birden kullanmayın.
Aynı TFVC reposunun farklı git-tf kopyaları farklı SHA-1 karma değerlerine sahip olabilir, bu da baş ağrısına neden olabilir.</p>
</li>
<li>
<p>Takımınızın iş akışı, Git’te işbirliği yapmayı ve düzenli aralıklarla TFVC ile senkronize etmeyi içeriyorsa, TFVC’ye sadece Git repolarından biriyle bağlanın.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h4 id="_git_tfs_i̇ş_akışı_2">
<code>git-tfs</code> İş Akışı</h4>
<div class="paragraph">
<p>Aynı senaryoyu git-tfs kullanarak adım adım geçelim.
İşte Git reposundaki <code>master</code> dalına işlediğimiz yeni katkılar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-powershell" data-lang="powershell">PS&gt; git log --oneline --graph --all --decorate
* c3bd3ae (HEAD, master) update code
* d85e5a2 update readme
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 (tfs/default) Hello
* b75da1a New project</code></pre>
</div>
</div>
<div class="paragraph">
<p>Şimdi, biz çalışırken başka birinin iş yapmış olup olmadığını görelim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-powershell" data-lang="powershell">PS&gt; git tfs fetch
C19 = aea74a0313de0a391940c999e51c5c15c381d91d
PS&gt; git log --all --oneline --graph --decorate
* aea74a0 (tfs/default) update documentation
| * c3bd3ae (HEAD, master) update code
| * d85e5a2 update readme
|/
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project</code></pre>
</div>
</div>
<div class="paragraph">
<p>Evet, iş arkadaşımız <code>aea74a0</code> katkısıyla yeni bir TFVC değişiklik seti eklemiş ve <code>tfs/default</code> uzak dalı hareket etmiş.</p>
</div>
<div class="paragraph">
<p>Git-tf ile olduğu gibi, bu ayrık geçmişi nasıl çözeceğimize dair iki temel seçeneğimiz var:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>çizgisel geçmişi korumak için yeniden temelleme.</p>
</li>
<li>
<p>Gerçekte ne olduğunu korumak için birleştirme.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Bu durumda, her Git katkısının bir TFVC değişiklik seti haline geldiği bir <code>deep</code> (derin) katkılama yapacağız, bu yüzden yeniden temellemek istiyoruz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-powershell" data-lang="powershell">PS&gt; git rebase tfs/default
First, rewinding head to replay your work on top of it...
Applying: update readme
Applying: update code
PS&gt; git log --all --oneline --graph --decorate
* 10a75ac (HEAD, master) update code
* 5cec4ab update readme
* aea74a0 (tfs/default) update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project</code></pre>
</div>
</div>
<div class="paragraph">
<p>Şimdi katkımızı tamamlamak için kodumuzu TFVC sunucusuna işlemeye hazırız.
Burada her Git katkısının HEAD kısmandan, ilk bulunan <code>tfs</code> uzak dalına kadar olan yol boyunca bir TFVC değişiklik seti oluşturmak için <code>rcheckin</code> komutunu kullanacağız (<code>checkin</code> komutu Git katkılarını birleştirmek gibi, sadece bir değişiklik seti oluşturur).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-powershell" data-lang="powershell">PS&gt; git tfs rcheckin
Working with tfs remote: default
Fetching changes from TFS to minimize possibility of late conflict...
Starting checkin of 5cec4ab4 'update readme'
 add README.md
C20 = 71a5ddce274c19f8fdc322b4f165d93d89121017
Done with 5cec4ab4b213c354341f66c80cd650ab98dcf1ed, rebasing tail onto new TFS-commit...
Rebase done successfully.
Starting checkin of b1bf0f99 'update code'
 edit .git\tfs\default\workspace\ConsoleApplication1/ConsoleApplication1/Program.cs
C21 = ff04e7c35dfbe6a8f94e782bf5e0031cee8d103b
Done with b1bf0f9977b2d48bad611ed4a03d3738df05ea5d, rebasing tail onto new TFS-commit...
Rebase done successfully.
No more to rcheckin.
PS&gt; git log --all --oneline --graph --decorate
* ff04e7c (HEAD, tfs/default, master) update code
* 71a5ddc update readme
* aea74a0 update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project</code></pre>
</div>
</div>
<div class="paragraph">
<p>Her başarılı checkin işleminin ardından, git-tfs’in kalan işi yeni yaptığı işin üzerine yeniden temellemesi dikkatinizi çekmiş olabilir.
Bunun nedeni, katkı mesajlarının altına <code>git-tfs-id</code> alanını eklemesidir, bu da SHA-1 karma değerlerini değiştirir.
Bu tam olarak tasarlandığı gibidir ve endişelenecek bir şey yoktur, ancak özellikle de Git katkılarını başkalarıyla paylaşıyorsanız, bunun farkında olmanız önemlidir.</p>
</div>
<div class="paragraph">
<p>TFS’nin birçok özelliği, iş öğeleri, atanmış gözden geçirenler, kontrollü checkinler vb. gibi sürüm kontrol sistemi ile entegre olan özellikleri bulunmaktadır.
Sadece komut satırı aracını kullanarak bu özelliklerle çalışmak sıkıcı olabilir, ancak neyse ki git-tfs çok kolay bir şekilde grafiksel bir checkin aracı başlatabilmenizi sağlar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-powershell" data-lang="powershell">PS&gt; git tfs checkintool
PS&gt; git tfs ct</code></pre>
</div>
</div>
<div class="paragraph">
<p>Biraz şöyle şunun gibi görünür:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/git-tfs-ct.png" >}}" alt="git-tfs checkin aracı.">
</div>
<div class="title">Görsel 147. git-tfs checkin aracı.</div>
</div>
<div class="paragraph">
<p>Bu TFS kullanıcılarının aşina olduğu şekilde, Visual Studio içinden başlatılan iletişim kutusuna benzer.</p>
</div>
<div class="paragraph">
<p>Git-tfs ayrıca Git reposundan TFVC dallarını kontrol etmenizi sağlar.
Bir örnek olarak, bir tane oluşturalım:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-powershell" data-lang="powershell">PS&gt; git tfs branch $/tfvc-test/featureBee
The name of the local branch will be : featureBee
C26 = 1d54865c397608c004a2cadce7296f5edc22a7e5
PS&gt; git log --oneline --graph --decorate --all
* 1d54865 (tfs/featureBee) Creation branch $/myproject/featureBee
* ff04e7c (HEAD, tfs/default, master) update code
* 71a5ddc update readme
* aea74a0 update documentation
| * 44cd729 (tfs/featureA, featureA) Goodbye
| * d202b53 Branched from $/tfvc-test/Trunk
|/
* c403405 Hello
* b75da1a New project</code></pre>
</div>
</div>
<div class="paragraph">
<p>TFVC’de bir dal oluşturmak, bu dalın artık bulunduğu bir değişiklik seti eklemeyi ve bu değişiklik setinin bir Git katkısı olarak yansıtıldığı anlamına gelir.
Ayrıca git-tfs’nin <code>tfs/featureBee</code> uzak dalını <strong>oluşturduğunu</strong>, ancak <code>HEAD</code> 'in hâlâ <code>main</code> 'i gösterdiğini unutmayın.
Yeni oluşturulan dal üzerinde çalışmak istiyorsanız, belki de bu katkıdan bir konu dalı oluşturarak yeni katkılarınızı <code>1d54865</code> katkısına dayandırmak isteyebilirsiniz.</p>
</div>
</div>
<div class="sect4">
<h4 id="_git_ve_tfs_özeti">Git ve TFS Özeti</h4>
<div class="paragraph">
<p>Git-tf ve Git-tfs TFVC sunucusuyla etkileşimde bulunmak için harika araçlardır.
Size yerelde Git’in gücünü kullanma, sürekli olarak merkezi TFVC sunucusuna yolculuk yapmaktan kaçınma ve geliştirici olarak hayatınızı çok daha kolay hale getirme imkanı sağlarlar, ancak tüm ekibinizi Git’e taşımaya zorlamazlar.
Eğer Windows’ta çalışıyorsanız (ki ekibiniz TFS kullanıyorsa muhtemelen durum budur), muhtemelen özellik seti daha tam olduğu için git-tfs’i kullanmak isteyeceksiniz, ancak başka bir platformda çalışıyorsanız, daha sınırlı olan git-tf’i kullanacaksınız.
Bu bölümdeki çoğu araç gibi, bu versiyon kontrol sistemlerinden birini standart olarak seçmeli ve diğerini yardımcı bir şekilde kullanmalısınız (ya Git ya da TFVC işbirliğinin merkezi olmalı, ancak ikisi birden değil).</p>
</div>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>