---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: tr
  chapter:
    title: 'Ek bölüm B: Git’i Uygulamalarınıza Gömmek'
    number: 2
  section:
    title: Libgit2
    number: 2
    cs_number: A2.2
    previous: book/tr/v2/Ek-bölüm-B:-Git’i-Uygulamalarınıza-Gömmek-Git-Komut-Satırı
    next: book/tr/v2/Ek-bölüm-B:-Git’i-Uygulamalarınıza-Gömmek-JGit
title: Git - Libgit2
url: "/book/tr/v2/Ek-bölüm-B:-Git’i-Uygulamalarınıza-Gömmek-Libgit2.html"
---
<h2 id="_libgit2">Libgit2</h2>
<div class="paragraph">
<p>
Elinizdeki diğer bir seçenek de Libgit2’yi kullanmaktır.
Libgit2, diğer programlarda kullanım için güzel bir API’ye sahip olmaya odaklanan, Git’in bağımlılık içermeyen bir uygulamasıdır.
Bunu <a href="https://libgit2.org" class="bare">https://libgit2.org</a> adresinde bulabilirsiniz.</p>
</div>
<div class="paragraph">
<p>Öncelikle C API’nin neye benzediğine bir göz atalım.
İşte kısa bir gezinti:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">// Open a repository
git_repository *repo;
int error = git_repository_open(&amp;repo, "/path/to/repository");

// Dereference HEAD to a commit
git_object *head_commit;
error = git_revparse_single(&amp;head_commit, repo, "HEAD^{commit}");
git_commit *commit = (git_commit*)head_commit;

// Print some of the commit's properties
printf("%s", git_commit_message(commit));
const git_signature *author = git_commit_author(commit);
printf("%s &lt;%s&gt;\n", author-&gt;name, author-&gt;email);
const git_oid *tree_id = git_commit_tree_id(commit);

// Cleanup
git_commit_free(commit);
git_repository_free(repo);</code></pre>
</div>
</div>
<div class="paragraph">
<p>İlk birkaç satır Git reposunu açar.
<code>git_repository</code> türü, önbellekte bulunan bir repoya yönelik tanıtıcıyı temsil eder.
Bir reponun çalışma dizinine veya <code>.git</code> klasörüne giden tam yolu bildiğinizde, bu en basit yöntemdir.
Ayrıca, arama seçeneklerini içeren <code>git_repository_open_ext</code>, uzak bir reponun yerel klonunu oluşturmak için <code>git_clone</code> ve arkadaşları ve tamamen yeni bir repo oluşturmak için ise <code>git_repository_init</code> bulunmaktadır.</p>
</div>
<div class="paragraph">
<p>İkinci kod parçası, HEAD işaret ettiği katkıyı almak için rev-parse sözdizimini kullanır (bu konu hakkında daha fazla bilgi için <a href="{{< relurl "book/tr/v2/ch00/_branch_references" >}}">Dal Referansları</a> bakınız).
Döndürülen tür, bir repodaki Git nesnesi veritabanında var olan bir şeyi temsil eden bir <code>git_object</code> işaretçisidir.
<code>git_object</code> aslında birkaç farklı türde nesnenin bir <em>üst</em> türüdür; her bir <em>alt</em> türü için bellek düzeni <code>git_object</code> ile aynı olduğu için, doğru olan bir türe güvenli bir şekilde dönüştürebilirsiniz.
<code>git_object_type(commit)</code> burada <code>GIT_OBJ_COMMIT</code> döndüreceği için, <code>git_commit</code> işaretçisine dönüştürmek güvenlidir.</p>
</div>
<div class="paragraph">
<p>Bir sonraki parça, katkının özelliklerine nasıl erişileceğini gösterir.
Buradaki son satırda kullanılan <code>git_oid</code> türü, bu Libgit2’nin SHA-1 karmasının temsilidir.</p>
</div>
<div class="paragraph">
<p>Bu örnekten birkaç model ortaya çıkar:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Eğer bir işaretçi bildirir, ve onu bir Libgit2 çağrısına bir referans olarak geçirirseniz; o çağrı muhtemelen, tamsayı olan bir hata kodu döndürecektir.
Bir <code>0</code> değeri başarıyı, daha küçük herhangi bir değer ise bir hatayı gösterir.</p>
</li>
<li>
<p>Eğer Libgit2 bir işaretçiyi sizin için doldurursa, onu serbest bırakmak sizin sorumluluğunuzdadır.</p>
</li>
<li>
<p>Libgit2 bir çağrıdan bir <code>const</code> işaretçi döndürürse, onu serbest bırakmanız gerekmez, ancak ait olduğu nesne serbest bırakıldığında geçersiz hale gelir.</p>
</li>
<li>
<p>C yazmak biraz sıkıntılıdır.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>
Sonuncu madde, Libgit2’yi kullanırken C yazmanızın pek olası olmadığı anlamına gelir.
Neyse ki, belirli dil ve ortamını kullanırken Git repolarıyla çalışmayı oldukça kolaylaştıran, bir dizi özel dil bağlamı mevcuttur.
Yukarıdaki örneği kullanarak, Libgit2 için <a href="https://github.com/libgit2/rugged" class="bare">https://github.com/libgit2/rugged</a> adresinde bulabileceğiniz Ruby bağlamı olan, "Rugged" kullanarak yazılmış örneğe bir göz atalım.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">repo = Rugged::Repository.new('path/to/repository')
commit = repo.head.target
puts commit.message
puts "#{commit.author[:name]} &lt;#{commit.author[:email]}&gt;"
tree = commit.tree</code></pre>
</div>
</div>
<div class="paragraph">
<p>Görüldüğü gibi, kod çok daha temiz.
İlk olarak, Rugged istisnaları kullanır; <code>ConfigError</code> veya <code>ObjectError</code> gibi şeyler fırlatabilir ve hata durumlarını belirtebilir.
İkinci olarak, Ruby’nin çöp toplama (garbage-collection) özelliği olduğundan, kaynakları açıkça serbest bırakma işlemi yoktur.
Biraz daha karmaşık bir örneğe bakalım: sıfırdan bir katkı oluşturma</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">blob_id = repo.write("Blob contents", :blob) # <b class="conum">(1)</b>

index = repo.index
index.read_tree(repo.head.target.tree)
index.add(:path =&gt; 'newfile.txt', :oid =&gt; blob_id) # <b class="conum">(2)</b>

sig = {
    :email =&gt; "bob@example.com",
    :name =&gt; "Bob User",
    :time =&gt; Time.now,
}

commit_id = Rugged::Commit.create(repo,
    :tree =&gt; index.write_tree(repo), # <b class="conum">(3)</b>
    :author =&gt; sig,
    :committer =&gt; sig, # <b class="conum">(4)</b>
    :message =&gt; "Add newfile.txt", # <b class="conum">(5)</b>
    :parents =&gt; repo.empty? ? [] : [ repo.head.target ].compact, # <b class="conum">(6)</b>
    :update_ref =&gt; 'HEAD', # <b class="conum">(7)</b>
)
commit = repo.lookup(commit_id) # <b class="conum">(8)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Yeni bir dosyanın içeriğini içeren bir blob oluşturun.</p>
</li>
<li>
<p>İndex’i baş katkının ağacıyla doldurun ve yeni dosyayı <code>newfile.txt</code> yoluna ekleyin.</p>
</li>
<li>
<p>Bunu yapmak ODB’de yeni bir ağaç oluşturur ve bunu yeni katkı için kullanır.</p>
</li>
<li>
<p>Hem yazar hem de işleyici alanları için aynı imzayı kullanıyoruz.</p>
</li>
<li>
<p>Katkı mesajı.</p>
</li>
<li>
<p>Bir katkı oluştururken, yeni katkının öncellerini belirtmelisiniz.
Bu, tek öncel için HEAD’in ucu kullanır.</p>
</li>
<li>
<p>Rugged (ve Libgit2) bir katkı yaparken isteğe bağlı olarak bir referansı güncelleyebilir.</p>
</li>
<li>
<p>Dönüş değeri, yeni bir katkı nesnesinin SHA-1 karmasıdır ve ardından bir <code>Commit</code> nesnesini almak için kullanabilirsiniz.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Ruby kodu güzel ve temizdir, ancak işin ağır kısmını Libgit2 yaptığından, bu kod da oldukça hızlı çalışacaktır.
Eğer bir rubyci değilseniz, <a href="{{< relurl "book/tr/v2/ch00/_libgit2_bindings" >}}">Diğer Bağlamlar</a> bölümünde diğer bağlantılara da değiniyoruz.</p>
</div>
<div class="sect3">
<h3 id="_gelişmiş_i̇şlevsellik">Gelişmiş İşlevsellik</h3>
<div class="paragraph">
<p>Libgit2’nin çekirdek Git’in kapsamının dışında birkaç yeteneği daha vardır.
Örneğin takılabilirlik: Libgit2 bazı işlemler için özel ``backend`` sağlamanıza izin verir, böylece birşeyleri stok Git’in yaptığından farklı bir şekilde depolayabilirsiniz.
Libgit2 yapılandırma, referans depolama ve nesne veritabanı dahil olmak üzere birçok şey için özel backendlere izin verir.</p>
</div>
<div class="paragraph">
<p>Bunu nasıl çalıştığını inceleyelim.
Aşağıdaki kod, Libgit2 ekibi tarafından sağlanan backend örneklerinin bir parçasıdır (bu örnekler <a href="https://github.com/libgit2/libgit2-backends" class="bare">https://github.com/libgit2/libgit2-backends</a> adresinde bulunabilir).
İşte nesne veritabanı için özel bir backendin kurulumu:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">git_odb *odb;
int error = git_odb_new(&amp;odb); // <b class="conum">(1)</b>

git_odb_backend *my_backend;
error = git_odb_backend_mine(&amp;my_backend, /*…*/); // <b class="conum">(2)</b>

error = git_odb_add_backend(odb, my_backend, 1); // <b class="conum">(3)</b>

git_repository *repo;
error = git_repository_open(&amp;repo, "some-path");
error = git_repository_set_odb(odb); // <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>(Burada hata yakalanır ancak işlenmez. Umarım sizin kodunuz bizimkinden daha iyidir.)</em></p>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Boş bir nesne veritabanı (ODB) ``frontend`` 'i başlatın; gerçek işi yapan ``backend`` 'ler için bu bir konteyner işi görecektir.</p>
</li>
<li>
<p>Özel bir ODB backend’i başlatın.</p>
</li>
<li>
<p>Backend’i frontend’e ekleyin.</p>
</li>
<li>
<p>Bir repoyu açın ve nesneleri aramak için ODB’mizi kullanacak şekilde ayarlayın.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Peki bu <code>git_odb_backend_mine</code> zımbırtısı nedir?
Bu sizin kendi ODB uygulamanızın kurucusudur ve içinde istediğiniz her şeyi yapabilirsiniz; yeter ki <code>git_odb_backend</code> yapısını uygun şekilde doldurun.
İşte nasıl görünebileceği:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">typedef struct {
    git_odb_backend parent;

    // Some other stuff
    void *custom_context;
} my_backend_struct;

int git_odb_backend_mine(git_odb_backend **backend_out, /*…*/)
{
    my_backend_struct *backend;

    backend = calloc(1, sizeof (my_backend_struct));

    backend-&gt;custom_context = …;

    backend-&gt;parent.read = &amp;my_backend__read;
    backend-&gt;parent.read_prefix = &amp;my_backend__read_prefix;
    backend-&gt;parent.read_header = &amp;my_backend__read_header;
    // …

    *backend_out = (git_odb_backend *) backend;

    return GIT_SUCCESS;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Buradaki en gözden kaçabilecek kısıtlama, <code>my_backend_struct</code> 'ın ilk elemanının bir <code>git_odb_backend</code> yapısı olması gerekliliğidir; bu, bellek düzeninin Libgit2 kodunun beklediği gibi olmasını sağlar.
Gerisi keyfidir; bu yapı, ihtiyacınıza göre istediğiniz kadar büyük veya küçük olabilir.</p>
</div>
<div class="paragraph">
<p>Başlatma fonksiyonu, yapı için bellek ayırır, özel bağlamı kurar ve sonra desteklediği <code>üst</code> yapının elemanlarını doldurur.
Libgit2 kaynaklarında <code>include/git2/sys/odb_backend.h</code> dosyasına bakarak tam bir çağrı imza setini görebilirsiniz; kullanım durumunuz, hangi çağrıları desteklemek isteyeceğinizi belirlemenize yardımcı olacaktır.</p>
</div>
</div>
<div class="sect3">
<h3 id="_libgit2_bindings">Diğer Bağlamlar</h3>
<div class="paragraph">
<p>Libgit2 birçok dil için bağlamlara sahiptir.
Bu yazının yazıldığı an itibariyle kapsamlı sayılabilecek bağlam paketlerinden birkaçını kullanarak küçük bir örnek gösteriyoruz; C++, Go, Node.js, Erlang ve JVM dahil olmak üzere birçok başka dil için farklı gelişmişlik seviyelerinde kütüphaneler bulunmaktadır.
Resmi bağlam koleksiyonunu <a href="https://github.com/libgit2" class="bare">https://github.com/libgit2</a> adresindeki repolara göz atarak bulabilirsiniz.
Yazacağımız kod, sonunda HEAD tarafından işaret edilen katkının mesajını döndürecektir (<code>git log -1</code> gibi).</p>
</div>
<div class="sect4">
<h4 id="_libgit2sharp">LibGit2Sharp</h4>
<div class="paragraph">
<p>
Eğer bir .NET veya Mono uygulaması yazıyorsanız, LibGit2Sharp (<a href="https://github.com/libgit2/libgit2sharp" class="bare">https://github.com/libgit2/libgit2sharp</a>) aradığınız şeydir.
Bağlamlar C# dilinde yazılmıştır ve ham Libgit2 çağrılarıyla uyumlu hissettiren CLR API’leriyle sarmak için büyük özen gösterilmiştir.
Örnek programımızın şöyle görünür:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-csharp" data-lang="csharp">new Repository(@"C:\path\to\repo").Head.Tip.Message;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Windows masaüstü uygulamaları için, hızlı başlamanıza yardımcı olacak bir NuGet paketi bile vardır.</p>
</div>
</div>
<div class="sect4">
<h4 id="_objective_git">objective-git</h4>
<div class="paragraph">
<p>
Uygulamanız bir Apple platformunda çalışıyorsa, muhtemelen uygulama dili olarak Objective-C kullanıyorsunuzdur.
Objective-Git (<a href="https://github.com/libgit2/objective-git" class="bare">https://github.com/libgit2/objective-git</a>) bu ortam için Libgit2 bağlamlarının adıdır.
Örnek program şu şekildedir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-objc" data-lang="objc">GTRepository *repo =
    [[GTRepository alloc] initWithURL:[NSURL fileURLWithPath: @"/path/to/repo"] error:NULL];
NSString *msg = [[[repo headReferenceWithError:NULL] resolvedTarget] message];</code></pre>
</div>
</div>
<div class="paragraph">
<p>Objective-git Swift ile tamamen uyumludur, bu yüzden Objective-C’yi geride bıraktıysanız endişelenmeyin.</p>
</div>
</div>
<div class="sect4">
<h4 id="_pygit2">pygit2</h4>
<div class="paragraph">
<p>
Libgit2 için Python bağlamları Pygit2 olarak adlandırılır ve <a href="https://www.pygit2.org" class="bare">https://www.pygit2.org</a> adresinde bulunur.
Örnek programımız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">pygit2.Repository("/path/to/repo") # open repository
    .head                          # get the current branch
    .peel(pygit2.Commit)           # walk down to the commit
    .message                       # read the message</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_i̇leri_okumalar">İleri Okumalar</h3>
<div class="paragraph">
<p>Tabii ki Libgit2’nin yeteneklerine dair kapsamlı bir açıklama bu kitabın hedefi dışındadır.
Libgit2 hakkında daha fazla bilgi istiyorsanız, API belgeleri <a href="https://libgit2.github.com/libgit2" class="bare">https://libgit2.github.com/libgit2</a> adresinde bulunabilir ve kılavuzlar <a href="https://libgit2.github.com/docs" class="bare">https://libgit2.github.com/docs</a> adresindedir.
Diğer bağlamlar için, paketlenmiş README belgesine ve testlere bakın; genellikle orada küçük örnekler ve daha fazla okuma için yönlendirmeler bulunmaktadır.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>