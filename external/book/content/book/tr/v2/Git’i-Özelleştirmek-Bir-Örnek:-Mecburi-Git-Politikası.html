---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: tr
  chapter:
    title: Git’i Özelleştirmek
    number: 8
  section:
    title: 'Bir Örnek: Mecburi Git Politikası'
    number: 4
    cs_number: '8.4'
    previous: book/tr/v2/Git’i-Özelleştirmek-Git-Kancaları-Hooks
    next: book/tr/v2/Git’i-Özelleştirmek-Özet
title: 'Git - Bir Örnek: Mecburi Git Politikası'
url: "/book/tr/v2/Git’i-Özelleştirmek-Bir-Örnek:-Mecburi-Git-Politikası.html"
---
<h2 id="_an_example_git_enforced_policy">Bir Örnek: Mecburi Git Politikası</h2>
<div class="paragraph">
<p>
Bu bölümde, öğrendiklerinizi kullanarak, özel bir katkı mesaj biçimini kontrol eden ve belirli kullanıcıların bir projedeki belirli alt dizinleri değiştirmesine izin veren bir Git iş akışı oluşturacaksınız.
Geliştiricinin itmesinin reddedilip reddedilmeyeceğini bilmesine yardımcı olan istemci betikleri oluşturacak ve politikaları uygulayan sunucu betikleri oluşturacaksınız.</p>
</div>
<div class="paragraph">
<p>Göstereceğimiz betikler (kısmen zihinsel ataletimizden dolayı) Ruby dilinde yazılmıştır, ancak bir diğer sebebi de yazamıyor olsanız bile, Ruby’nin okunması kolay bir dil olmasıdır.
Ancak herhangi bir dil işe yarayacaktır (Git ile birlikte dağıtılan tüm örnek kanca betikleri Perl veya Bash’te yazılmıştır ve örnekleri inceleyerek, bu dillerdeki kancaları görebilirsiniz).</p>
</div>
<div class="sect3">
<h3 id="_sunucu_tarafı_kancası">Sunucu Tarafı Kancası</h3>
<div class="paragraph">
<p>Tüm sunucu tarafı işlemleriniz, <code>hooks</code> dizininizdeki <code>update</code> dosyasına gidecektir.
<code>update</code> kancası, itilen her dal için bir kez çalışır ve üç argüman alır:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>İtinilen referansın adı</p>
</li>
<li>
<p>O dalın eski sürümü</p>
</li>
<li>
<p>İtilen yeni sürüm</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ayrıca, itmenin SSH üzerinden gerçekleştirilip gerçekleştirilmediğine bağlı olarak iten kullanıcıya da erişiminiz vardır.
Herkesin tek bir kullanıcıyla (örneğin, <code>git</code>) genel anahtar kimlik doğrulaması yoluyla bağlanmasına izin verdiyseniz, bu kullanıcıya, hangi kullanıcının genel anahtara dayanarak bağlandığını belirleyen ve buna göre bir ortam değişkeni ayarlayan bir kabuk sarmalayıcı (shell wrapper) vermeniz gerekebilir.
Burada, bağlantı kuran kullanıcının <code>$USER</code> ortam değişkeninde olduğunu varsayacağız, bu nedenle güncelleme betiğiniz ihtiyacınız olan tüm bilgileri toplayarak işe başlar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#!/usr/bin/env ruby

$refname = ARGV[0]
$oldrev  = ARGV[1]
$newrev  = ARGV[2]
$user    = ENV['USER']

puts "Enforcing Policies..."
puts "(#{$refname}) (#{$oldrev[0,6]}) (#{$newrev[0,6]})"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Evet bunlar global değişkenler.
Bizi yargılamayın; bu şekilde göstermek daha kolay.</p>
</div>
<div class="sect4">
<h4 id="_enforcing_commit_message_format">Belirli Bir Katkı Mesajı Formatını Zorunlu Hale Getirme</h4>
<div class="paragraph">
<p>Zorlanacağınız ilk konu, her katkı mesajının belirli bir formata uygun olmasını sağlamaktır.
Sırf bir hedefiniz olsun diye, diyelim ki her katkının iş takip sisteminizde bir iş ögesine bağlanmasını istediğiniz için, her katkı mesajının <code>ref: 1234</code> gibi görünen bir dize içermesi şartını koydunuz.
Her itilen katkı mesajında bu dizenin olup olmadığını kontrol etmeli ve eğer dize herhangi bir katkıda yoksa, itmenin reddedilmesi için çıkış yapmalısınız.</p>
</div>
<div class="paragraph">
<p><code>$newrev</code> ve <code>$oldrev</code> değerlerini alıp bunları <code>git rev-list</code> adlı bir Git tesisat komutuna ileterek itilen tüm katkıların SHA-1 değerlerinin bir listesini alabilirsiniz.
Bu, temelde <code>git log</code> komutudur; ancak varsayılan olarak SHA-1 değerleri dışında hiçbir bilgi yazdırmaz.
Bu nedenle, bir katkı SHA-1 değeri ile diğer bir katkı SHA-1 değeri arasında tanıtılan tüm katkı SHA-1’lerinin bir listesini almak için şöyle bir şey çalıştırabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rev-list 538c33..d14fc7
d14fc7c847ab946ec39590d87783c69b031bdfb7
9f585da4401b0a3999e84113824d15245c13f0be
234071a1be950e2a8d078e6141f5cd20c1e61ad3
dfa04c9ef3d5197182f13fb5b9b1fb7717d2222a
17716ec0f1ff5c77eff40b7fe912f9f6cfd0e475</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu çıktıyı alıp, her bir katkı SHA-1’i üzerinden dönebilir, onun için mesajı alabilir ve bir model arayan bir düzenli ifadeye karşı test edebilirsiniz.</p>
</div>
<div class="paragraph">
<p>Her bir katkı mesajını test etmek için bu katkılardan nasıl katkı mesajını alacağınızı bulmanız gerekmektedir.
Ham katkı verilerini almak için, <code>git cat-file</code> adlı başka bir tesisat komutunu kullanabilirsiniz.
Bu tesisat komutlarını detaylı olarak <a href="{{< relurl "book/tr/v2/ch00/ch10-git-internals" >}}">Dahili Git Ögeleri</a> bölümünde ele alacağız; ancak şu anda, bu komutun size ne verdiğini aşağıda gösteriyoruz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file commit ca82a6
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
author Scott Chacon &lt;schacon@gmail.com&gt; 1205815931 -0700
committer Scott Chacon &lt;schacon@gmail.com&gt; 1240030591 -0700

changed the version number</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bir katkının SHA-1 değerine sahipken katkı mesajını almanın basit bir yolu, ilk boş satıra gitmek ve o satırdan sonrasını almaktır.
Bunu Unix sistemlerinde <code>sed</code> komutuyla yapabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file commit ca82a6 | sed '1,/^$/d'
changed the version number</code></pre>
</div>
</div>
<div class="paragraph">
<p>incantation’ı kullanarak itilmeye çalışılan her katkının mesajını alabilir ve eşleşmeyen herhangi bir şey gördüğünüzde çıkabilirsiniz.
İtmeyi reddederek betiği sonlandırmak için sıfırsız (non-zero) çıkış yapın.
Yöntemin tamamı şöyle görünüyor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">$regex = /\[ref: (\d+)\]/

# enforced custom commit message format
def check_message_format
  missed_revs = `git rev-list #{$oldrev}..#{$newrev}`.split("\n")
  missed_revs.each do |rev|
    message = `git cat-file commit #{rev} | sed '1,/^$/d'`
    if !$regex.match(message)
      puts "[POLICY] Your message is not formatted correctly"
      exit 1
    end
  end
end
check_message_format</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bunu <code>update</code> betiğinize koyarak, kuralınıza uymayan mesajları içeren katkıların reddedilmesini sağlayabilirsiniz.</p>
</div>
</div>
<div class="sect4">
<h4 id="_kullanıcı_tabanlı_bir_acl_sisteminin_uygulanması">Kullanıcı Tabanlı bir ACL Sisteminin Uygulanması</h4>
<div class="paragraph">
<p>Kullanıcıların, hangi projelerin, hangi bölümlerine değişiklik yapmalarına izin verildiğini belirten bir erişim kontrol listesi (ACL) mekanizması eklemek istediğinizi varsayalım.
Bazı kullanıcılar tam erişime sahipken, diğerleri yalnızca belirli alt dizin veya dosyalarad değişiklik yapabilirler.
Bu kısıtlamaları uygulamak için, bu kuralları sunucudaki çıplak Git reponuzda bulunan bir <code>acl</code> dosyasına yazacaksınız. <code>update</code> kancası bu kurallara bakacaktır: itilen tüm katkılar için tanıtılan dosyaları görecek ve itme işlemini gerçekleştiren kullanıcının tüm bu dosyalara erişiminin olup olmadığını belirleyecektir.</p>
</div>
<div class="paragraph">
<p>İlk yapmanız gereken şey ACL’nizi yazmaktır.
Burada, CVS ACL mekanizmasıyla oldukça benzer bir biçim kullanacaksınız: İlk alan <code>avail</code> veya <code>unavail</code>; bir sonraki alan, kuralın uygulandığı kullanıcıların virgülle ayrılmış bir listesi, ve son alan ise kuralın uygulandığı dizin (boşluk karakteri açık erişim anlamına gelir) şeklinde bir dizi satır kullanılır.
Tüm bu alanlar bir boru (<code>|</code>) karakteri ile ayrılmıştır.</p>
</div>
<div class="paragraph">
<p>Senaryomuzda, birkaç yönetici, <code>doc</code> dizinine erişimi olan bazı belge yazarları ve yalnızca <code>lib</code> ve <code>tests</code> dizinlerine erişimi olan bir geliştiriciniz var ve ACL dosyanız şöyle görünüyor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>avail|nickh,pjhyett,defunkt,tpw
avail|usinclair,cdickens,ebronte|doc
avail|schacon|lib
avail|schacon|tests</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu veriyi, onu kullanabileceğiniz bir yapıya okuyarak başlıyorsunuz.
Bu örneği basit tutmak için sadece <code>avail</code> direktiflerini uygulayacaksınız.
İşte, kullanıcı adının anahtar olduğu ve kullanıcının yazma erişimine sahip olduğu yol dizinini içeren ilişkisel bir dizi (array) veren bir yöntem:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">def get_acl_access_data(acl_file)
  # read in ACL data
  acl_file = File.read(acl_file).split("\n").reject { |line| line == '' }
  access = {}
  acl_file.each do |line|
    avail, users, path = line.split('|')
    next unless avail == 'avail'
    users.split(',').each do |user|
      access[user] ||= []
      access[user] &lt;&lt; path
    end
  end
  access
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Önceki incelediğiniz ACL dosyasına göre, bu <code>get_acl_access_data</code> yöntemi aşağıdaki gibi bir veri yapısı döndürür:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">{"defunkt"=&gt;[nil],
 "tpw"=&gt;[nil],
 "nickh"=&gt;[nil],
 "pjhyett"=&gt;[nil],
 "schacon"=&gt;["lib", "tests"],
 "cdickens"=&gt;["doc"],
 "usinclair"=&gt;["doc"],
 "ebronte"=&gt;["doc"]}</code></pre>
</div>
</div>
<div class="paragraph">
<p>İzinleri düzenledikten sonra, itilen katkıların değiştirdiği yolları belirlemeniz gerekiyor. Böylece iten kullanıcının hepsine erişimi olduğundan emin olabilirsiniz.</p>
</div>
<div class="paragraph">
<p><code>git log</code> komutuna <code>--name-only</code> seçeneğini ekleyerek, tek bir katkıda hangi dosyaların değiştirildiğini oldukça kolayca görebilirsiniz (<a href="{{< relurl "book/tr/v2/ch00/ch02-git-basics" >}}">Git Temelleri</a> bölümünde bundan kısaca bahsedilmektedir):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -1 --name-only --pretty=format:'' 9f585d

README
lib/test.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>get_acl_access_data</code> yönteminden dönen ACL yapısını kullanarak ve her bir katkıda listelenen dosyaları bu yapıyla karşılaştırarak, kullanıcının tüm katkılarını itmek için erişime sahip olup olmadığını belirleyebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby"># only allows certain users to modify certain subdirectories in a project
def check_directory_perms
  access = get_acl_access_data('acl')

  # see if anyone is trying to push something they can't
  new_commits = `git rev-list #{$oldrev}..#{$newrev}`.split("\n")
  new_commits.each do |rev|
    files_modified = `git log -1 --name-only --pretty=format:'' #{rev}`.split("\n")
    files_modified.each do |path|
      next if path.size == 0
      has_file_access = false
      access[$user].each do |access_path|
        if !access_path  # user has access to everything
           || (path.start_with? access_path) # access to this path
          has_file_access = true
        end
      end
      if !has_file_access
        puts "[POLICY] You do not have access to push to #{path}"
        exit 1
      end
    end
  end
end

check_directory_perms</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sunucunuza itilen yeni katkıların bir listesini <code>git rev-list</code> kullanarak alırsınız.
Ardından, bu katkıların her biri için değiştirilen dosyaları bulur ve iten kullanıcının değiştirilen tüm yollara erişimi olduğundan emin olursunuz.</p>
</div>
<div class="paragraph">
<p>Artık kullanıcılarınız, kötü biçimlendirilmiş mesajlara veya belirlenmiş yolların dışında değiştirilmiş dosyalara sahip katkıları itemezler.</p>
</div>
</div>
<div class="sect4">
<h4 id="_deneme">Deneme</h4>
<div class="paragraph">
<p><code>chmod u+x .git/hooks/update</code> komutunu çalıştırırsanız, bu kodları yerleştirmeniz gereken dosya olan <code>.git/hooks/update</code> dosyasına erişim izni verirsiniz. Ardından, uyumsuz bir mesajla bir katkı itmeye çalıştığınızda, aşağıdakine benzer bir çıktı alırsınız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git push -f origin master
Counting objects: 5, done.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 323 bytes, done.
Total 3 (delta 1), reused 0 (delta 0)
Unpacking objects: 100% (3/3), done.
Enforcing Policies...
(refs/heads/master) (8338c5) (c5b616)
[POLICY] Your message is not formatted correctly
error: hooks/update exited with error code 1
error: hook declined to update refs/heads/master
To git@gitserver:project.git
 ! [remote rejected] master -&gt; master (hook declined)
error: failed to push some refs to 'git@gitserver:project.git'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Burada birkaç ilginç şey var.
Öncelikle kancanın çalışmaya başladığı yeri görüyorsunuz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">Enforcing Policies...
(refs/heads/master) (fb8c72) (c56860)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bunu güncelleme komut dosyanızın en başında yazdırdığınızı unutmayın.
Komut dosyanızın <code>stdout</code> 'a yansıttığı her şey istemciye aktarılacaktır.</p>
</div>
<div class="paragraph">
<p>Bir sonraki fark edeceğiniz şey hata mesajıdır.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">[POLICY] Your message is not formatted correctly
error: hooks/update exited with error code 1
error: hook declined to update refs/heads/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>İlk satır sizin tarafınızdan yazdırıldı, diğer ikisi Git’in size güncelleme komut dosyasının sıfırsız (non-zero) bir durumdan çıktığını ve gönderiminizi reddeden şeyin bu olduğunu söylemesiydi.
Son olarak şunu görürsünüz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">To git@gitserver:project.git
 ! [remote rejected] master -&gt; master (hook declined)
error: failed to push some refs to 'git@gitserver:project.git'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Her reddedilen referans için bir "uzak repo reddedildi" mesajı göreceksiniz ve bu mesaj kancanın başarısız olması nedeniyle özellikle reddedildiğini size bildirir.</p>
</div>
<div class="paragraph">
<p>Dahası, birinin erişim izni olmayan bir dosyayı düzenlemeye ve içeren bir katkıyı itmeye çalıştığında, benzer bir şey görürler. Örneğin, bir belge yazarı, <code>lib</code> dizininde bir şeyi değiştiren bir katkıyı itmeye çalışırsa, aşağıdakine benzer bir çıktı alır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">[POLICY] You do not have access to push to lib/test.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Artık o <code>update</code> betiği orada ve çalıştırılabilir olduğu sürece, repo hiçbir zaman istediğiniz biçimde olmayan bir katkı mesajı içermeyecek ve kullanıcılarınız izole edilecekler.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_i̇stemci_tarafı_kancaları_2">İstemci Tarafı Kancaları</h3>
<div class="paragraph">
<p>Bu yaklaşımın dezavantajı, kullanıcıların katkı itmelerinin reddedilmesiyle kaçınılmaz olarak ortaya çıkacak olan şikayetlerdir.
Dikkatle hazırladıkları çalışmalarının son anda reddedilmesi, son derece sinir bozucu ve kafa karıştırıcı olabilir. Ayrıca, bunu düzeltmek için geçmişlerini düzenlemeleri gerekeceğinden, uygulaması her zaman kolay değildir.</p>
</div>
<div class="paragraph">
<p>Bu ikileme çözüm, kullanıcıların sunucunun muhtemelen reddedeceği bir şey yaptıklarında onları bilgilendirmek için çalıştırabilecekleri bazı istemci tarafı kancaları sağlamaktır.
Böylece, katkı işlemeden önce ve bu sorunlar daha zor çözülebilir hale gelmeden önce o sorunu düzeltebilirler.
Kancalar bir projenin kopyasıyla aktarılmadığından, bu betikleri başka bir şekilde dağıtmanız ve ardından kullanıcılarınızın bunları <code>.git/hooks</code> dizinlerine kopyalamalarını ve çalıştırılabilir hale getirmelerini sağlamanız gerekir.
Bu kancaları projenin içinde veya ayrı bir projede dağıtabilirsiniz, ancak Git bunları otomatik olarak kurmaz.</p>
</div>
<div class="paragraph">
<p>Öncelikle, her katkı kaydedilmeden hemen önce katkı mesajınızı kontrol etmelisiniz, böylece sunucunun kötü biçimlendirilmiş katkı mesajları nedeniyle değişikliklerinizi reddetmeyeceğini bilirsiniz.
Bunu yapmak için, <code>commit-msg</code> kancasını ekleyebilirsiniz.
İlk argüman olarak geçirilen dosyadan mesajı okuyup, bunu modele karşılaştırırsanız; eşleşme yoksa Git’i katkıyı iptal etmeye zorlayabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#!/usr/bin/env ruby
message_file = ARGV[0]
message = File.read(message_file)

$regex = /\[ref: (\d+)\]/

if !$regex.match(message)
  puts "[POLICY] Your message is not formatted correctly"
  exit 1
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Eğer o betik (<code>.git/hooks/commit-msg</code> içinde) yerinde ve çalıştırılabilir durumdaysa ve düzgün biçimlendirilmemiş mesajlı bir katkı işlerseniz, şunu görürsünüz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git commit -am 'test'
[POLICY] Your message is not formatted correctly</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu durumda hiçbir katkı tamamlanmaz.
Ancak, mesajınız uygun modeli içeriyorsa, Git katkıyı işlemenize izin verir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git commit -am 'test [ref: 132]'
[master e05c914] test [ref: 132]
 1 file changed, 1 insertions(+), 0 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sonraki adım olarak, ACL kapsamınız dışındaki dosyaları değiştirmediğinizden emin olmak isterseniz.
Projenizin <code>.git</code> dizini, önceki kullandığınız ACL dosyasının bir kopyasını içeriyorsa, aşağıdaki <code>pre-commit</code> betiği bu kısıtlamaları sizin için uygulayacaktır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#!/usr/bin/env ruby

$user    = ENV['USER']

# [ insert acl_access_data method from above ]

# only allows certain users to modify certain subdirectories in a project
def check_directory_perms
  access = get_acl_access_data('.git/acl')

  files_modified = `git diff-index --cached --name-only HEAD`.split("\n")
  files_modified.each do |path|
    next if path.size == 0
    has_file_access = false
    access[$user].each do |access_path|
    if !access_path || (path.index(access_path) == 0)
      has_file_access = true
    end
    if !has_file_access
      puts "[POLICY] You do not have access to push to #{path}"
      exit 1
    end
  end
end

check_directory_perms</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu betik, sunucu tarafı kısmıyla hemen hemen aynıdır, ancak iki önemli fark vardır:
İlk olarak, ACL dosyası farklı bir yerde bulunur, çünkü bu betik <code>.git</code> dizininizden değil, çalışma dizininizden çalıştırılır.
Bu nedenle ACL dosyasının yolunu değiştirmeniz gerekmektedir.</p>
</div>
<div class="paragraph">
<p>Bundan:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">access = get_acl_access_data('acl')</code></pre>
</div>
</div>
<div class="paragraph">
<p>şuna:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">access = get_acl_access_data('.git/acl')</code></pre>
</div>
</div>
<div class="paragraph">
<p>Diğer önemli fark, değiştirilen dosyaların bir listesini nasıl elde ettiğinizdir.
Sunucu tarafı yöntemi, katkı günlüğüne bakar ama bu noktada katkı henüz kaydedilmemiş olduğundan, dosya listenizi izlem alanından almanız gerekir.</p>
</div>
<div class="paragraph">
<p>şunun yerine:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">files_modified = `git log -1 --name-only --pretty=format:'' #{ref}`</code></pre>
</div>
</div>
<div class="paragraph">
<p>bunu kullanmalısınız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">files_modified = `git diff-index --cached --name-only HEAD`</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu ikisi aradaki yegane farklılıklardır, bunlar dışında, betik aynı şekilde çalışır.
Bir diğer önemli not: sizden yerel makinenizde çalışırken veya uzak makineye iterken aynı kullanıcı adıyla çalışmanız beklenir.
Bu ikisi farklıysa, <code>$user</code> değişkenini manuel olarak ayarlamanız gerekir.</p>
</div>
<div class="paragraph">
<p>Burada yapabileceğimiz başka bir şey, kullanıcının ileri-sarmasız (non-fast-forwarded) referanslar itmemesini sağlamaktır.
ileri-sarmasız bir referans almak için, zaten ittiğiniz bir katkıyı tekrar düzenlemek veya aynı uzak dal üzerine farklı bir yerel dalı itmek zorundasınız.</p>
</div>
<div class="paragraph">
<p>Otomatik olarak, sunucunun zaten bu politikayı uygulamak için <code>receive.denyDeletes</code> ve <code>receive.denyNonFastForwards</code> ile yapılandırıldığını varsayıyoruz, bu yüzden yakalamaya çalışabileceğiniz tek kaza, zaten itilmiş katkıları yeniden temellendirilmesidir.</p>
</div>
<div class="paragraph">
<p>İşte bu durumu kontrol eden bir yeniden temellendirme öncesi betiği örneği:
Yeniden yazacağınız tüm katkıların bir listesini alır ve bunların herhangi birinin, herhangi bir uzak referansta var olup olmadığını kontrol eder.
Bir uzak referanstan ulaşılabilir birini görürse, yeniden temellendirme işlemini iptal eder.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#!/usr/bin/env ruby

base_branch = ARGV[0]
if ARGV[1]
  topic_branch = ARGV[1]
else
  topic_branch = "HEAD"
end

target_shas = `git rev-list #{base_branch}..#{topic_branch}`.split("\n")
remote_refs = `git branch -r`.split("\n").map { |r| r.strip }

target_shas.each do |sha|
  remote_refs.each do |remote_ref|
    shas_pushed = `git rev-list ^#{sha}^@ refs/remotes/#{remote_ref}`
    if shas_pushed.split("\n").include?(sha)
      puts "[POLICY] Commit #{sha} has already been pushed to #{remote_ref}"
      exit 1
    end
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu betik, <a href="{{< relurl "book/tr/v2/ch00/_revision_selection" >}}">Düzeltme Seçimi</a> bölümünde ele alınmayan bir sözdizimi kullanır.
Zaten yukarı itilmiş katkıları almak için şunu çalıştırarak bir liste alabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">`git rev-list ^#{sha}^@ refs/remotes/#{remote_ref}`</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>SHA^@</code> sözdizimi, bu katkının tüm öncellerinde çözülür.
Ulaşılabilir herhangi bir katkı arıyorsunuz ve bu katkı, itmeye çalıştığınız SHA-1’lerin herhangi birinin herhangi bir öncelinden ulaşılamadığı anlamına gelir. Yani ileri-sarma (fast-forward)'dır.</p>
</div>
<div class="paragraph">
<p>Bu yaklaşımın başlıca dezavantajı çok yavaş olabilmesi ve genellikle gereksiz olmasıdır. Zorla itme (forced push) işlemi yapmazsanız, sunucu sizi uyaracak ve itmeyi kabul etmeyecektir.
Ancak, bu ilginç bir egzersizdir ve teorik olarak daha sonra geri dönüp düzeltmeniz gerekebilecek bir yeniden temellendirme işleminden kaçınmanıza yardımcı olabilir.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>