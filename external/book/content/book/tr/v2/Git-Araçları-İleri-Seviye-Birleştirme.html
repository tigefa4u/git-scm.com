---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: tr
  chapter:
    title: Git Araçları
    number: 7
  section:
    title: İleri Seviye Birleştirme
    number: 8
    cs_number: '7.8'
    previous: book/tr/v2/Git-Araçları-Reset-Komutunun-Gizemleri
    next: book/tr/v2/Git-Araçları-Rerere
title: Git - İleri Seviye Birleştirme
url: "/book/tr/v2/Git-Araçları-İleri-Seviye-Birleştirme.html"
---
<h2 id="_advanced_merging">İleri Seviye Birleştirme</h2>
<div class="paragraph">
<p>Git’te birleştirme genellikle çok kolaydır.
Git, başka bir dalı bir çok defa birleştirmeyi kolaylaştırdığı için; ufak çakışmaları sık sık çözerek, çok uzun ömürlü dallarınızı bile sürekli güncel tutabilir ve böylece en sonda devasa tek bir çakışmayla karşılaşmazsınız.</p>
</div>
<div class="paragraph">
<p>Ancak, bazen zorlu çatışmalar ortaya çıkabilir.
Diğer bazı sürüm kontrol sistemlerinin aksine, Git birleştirme çakışması çözümünde "aşırı akıllı" olmaya çalışmaz.
Git’in felsefesi, birleştirme çözümünün net olduğunu belirlemede akıllı olmaktır. Ancak bir çakışma varsa, onu otomatik olarak çözmeye çalışmak konusunda akıllı davranmaz.
Bu nedenle, hızla ayrılan iki dalı birleştirmek için çok uzun süre beklerseniz, bazı sorunlarla karşılaşabilirsiniz.</p>
</div>
<div class="paragraph">
<p>Bu bölümde, bu sorunların neler olabileceğini ve Git’in size bu daha zorlu durumlarla başa çıkmada yardımcı olmak için hangi araçları sunduğunu ele alacağız.
Ayrıca, yapabileceğiniz farklı, standart olmayan birleştirmelerin bazılarını ele alacak ve yaptığınız birleştirmelerden nasıl geri adım atılacağını göreceğiz.</p>
</div>
<div class="sect3">
<h3 id="_birleştirme_çakışmaları">Birleştirme Çakışmaları</h3>
<div class="paragraph">
<p>Çok karmaşık çatışmalar için bazı temel adımları <a href="{{< relurl "book/tr/v2/ch00/_basic_merge_conflicts" >}}">Birleştirme Çakışması (merge conflict)</a> bölümünde ele almış olsak da, Git daha karmaşık çatışmaları çözmenize ve bunlarla daha iyi başa çıkmanıza yardımcı olmak için birkaç araç sağlar.</p>
</div>
<div class="paragraph">
<p>Öncelikle, mümkünse, çatışma olabilecek birleştirmeyi yapmadan önce çalışma dizininizin temiz olduğundan emin olmaya çalışın.
Geliştirmeye devam ettiğiniz bir çalışmanız varsa, bunu geçici bir dalda katkılayın veya <code>stash</code> ile saklayın.
Bu burada denediğiniz <strong>herhangi bir şeyi</strong> geri almanızı sağlar.
Birleştirmeyi yaparken çalışma dizininizde kaydedilmemiş değişiklikleriniz varsa, verdiğimiz ipuçlarından bazıları bu çalışmayı korumanıza yardımcı olabilir.</p>
</div>
<div class="paragraph">
<p>Şimdi çok basit bir örnek üzerinden ilerleyelim.
<em>hello world</em> yazısını yazdıran çok basit bir Ruby dosyamız var.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
  puts 'hello world'
end

hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Repomuzda, <code>whitespace</code> adında yeni bir dal oluşturuyoruz ve tüm Unix satır sonlarını DOS satır sonlarına çevirerek yolumuza devam ediyoruz. Esasında dosyanın her satırını sadece boşluklarla değiştirmiş olduk.
Ardından da ``hello world`` satırını ``hello mundo`` olarak değiştiriyoruz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b whitespace
Switched to a new branch 'whitespace'

$ unix2dos hello.rb
unix2dos: converting file hello.rb to DOS format ...
$ git commit -am 'converted hello.rb to DOS'
[whitespace 3270f76] converted hello.rb to DOS
 1 file changed, 7 insertions(+), 7 deletions(-)

$ vim hello.rb
$ git diff -b
diff --git a/hello.rb b/hello.rb
index ac51efd..e85207e 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,7 @@
 #! /usr/bin/env ruby

 def hello
-  puts 'hello world'
+  puts 'hello mundo'^M
 end

 hello()

$ git commit -am 'hello mundo change'
[whitespace 6d338d2] hello mundo change
 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Şimdi <code>master</code> dalımıza geçiyoruz ve fonksiyon için bazı dokümentasyon belgeleri ekliyoruz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
Switched to branch 'master'

$ vim hello.rb
$ git diff
diff --git a/hello.rb b/hello.rb
index ac51efd..36c06c8 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello world'
 end

$ git commit -am 'document the function'
[master bec6336] document the function
 1 file changed, 1 insertion(+)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Şimdi <code>whitespace</code> dalını birleştirmeyi deneriz ve boşluk değişiklikleri nedeniyle çatışma alırız.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge whitespace
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="sect4">
<h4 id="_abort_merge">Birleştirmeyi İptal</h4>
<div class="paragraph">
<p>Şimdi birkaç seçeneğimiz var.
Öncelikle, bu durumdan nasıl çıkacağımızı ele alalım.
Belki de çatışmaları beklemiyordunuz ve şu anda durumla uğraşmak istemiyorsunuz; bu durumda <code>git merge --abort</code> komutu ile birleştirmeyi hemen iptal edebilirsiniz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status -sb
## master
UU hello.rb

$ git merge --abort

$ git status -sb
## master</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>git merge --abort</code> seçeneği, birleştirmeyi çalıştırmadan önceki durumunuza geri çevirmeye çalışır.
Bu işlemi mükemmel bir şekilde yapamayabileceğiz tek durum, çalışma dizinizde birleştirmeyi çalıştırdığınızda kaydedilmemiş veya katkılanmamış değişiklikleriniz olmasıdır. Aksi takdirde sorunsuz çalışması beklenir.</p>
</div>
<div class="paragraph">
<p>Eğer bir sebeple sıfırdan başlamak istiyorsanız, <code>git reset --hard HEAD</code> komutunu da çalıştırabilir ve reponun en son katkı işlenmiş durumuna geri dönebilirsiniz.
Unutmayın ki, katkılanmamış çalışmalarınız kaybolur, bu yüzden değişikliklerinizden hiçbirini birini istemediğinizden emin olun.</p>
</div>
</div>
<div class="sect4">
<h4 id="_boşlukları_whitespace_yoksayma">Boşlukları (Whitespace) Yoksayma</h4>
<div class="paragraph">
<p>Bu özel senaryoda, çakışmalar boşluklarla ilgilidir.
Örnek basit olduğundan bunu biliyoruz, ancak gerçek durumlarda da çakışmayı incelediğinizde bu oldukça kolay anlaşılır. Çünkü her satır bir taraftan kaldırılır ve diğer tarafta yeniden eklenir.
Varsayılan olarak, Git tüm bu satırları değişmiş olarak görür, bu yüzden dosyaları birleştiremez.</p>
</div>
<div class="paragraph">
<p>Ancak varsayılan birleştirme stratejisi argümanlar alabilir ve bunlardan birkaçı boşluk değişikliklerini doğru şekilde yok saymayla ilgilidir.
Birleştirmede çok sayıda boşluk sorunu olduğunu görürseniz, doğrudan birleştirmeyi iptal edip <code>-Xignore-all-space</code> veya <code>-Xignore-space-change</code> ile tekrarlayabilirsiniz.
İlk seçenek, satırları karşılaştırırken boşlukları <strong>tamamen</strong> yoksayar; ikincisi ise bir veya daha fazla boşluk karakteri dizilerini eşit kabul eder.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge -Xignore-space-change whitespace
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu örnekte, gerçek dosya değişiklikleri çatışmıyordu. Dolayısıyla boşluk değişikliklerini yoksaydığımızda, her şey sorunsuz bir şekilde birleşir.</p>
</div>
<div class="paragraph">
<p>Ekip üyelerinizden birinin ara sıra her şeyi (boşluklardan sekme karakterlerine veya tersi yönde) yeniden biçimlendirmek gibi bir karakteri varsa, bu özellik gerçekten hayat kurtarıcıdır.</p>
</div>
</div>
<div class="sect4">
<h4 id="_manual_remerge">Manuel Olarak Yeniden Birleştirme</h4>
<div class="paragraph">
<p>Git boşluk ön işlemesini oldukça iyi bir şekilde ele alsa da, Git’in otomatik olarak halledemediği ancak betikle düzeltilebilecek diğer türde değişiklikler olabilir.
Örnek olması açısından, Git’in boşluk değişikliğini halledemediğini ve bunu kendimizin düzeltmesi gerektiğini varsayalım.</p>
</div>
<div class="paragraph">
<p>Aslında yapmamız gereken şey, birleştirmeye çalıştığımız dosyayı, birleştirmeden önce bir <code>dos2unix</code> programından geçirmektir.
Peki, bunu nasıl yapabiliriz?</p>
</div>
<div class="paragraph">
<p>Öncelikle, çakışma durumuna geliyoruz.
Sonra, dosyanın kendi sürümümüzün, onların (birleştirmek istediğimiz dalın) sürümünün ve ortak sürümün (her iki tarafın da dallandığı yerden) kopyalarını almak istiyoruz.
Daha sonra, onların tarafını veya kendi tarafımızı düzeltip sadece bu tek dosya için birleştirmeyi tekrar denemek istiyoruz.</p>
</div>
<div class="paragraph">
<p>Üç dosya sürümünü almak aslında oldukça kolaydır.
Git, bu sürümlerin hepsini izlemde <code>stages</code> altında, her birini kendiyle ilişkilendirilmiş numaralara sahip olmak üzede saklar.
1: ortak öncel, 2: sizin sürümünüz, ve 3: birleştirmeyi yaptığınız sürüm olan <code>MERGE_HEAD</code> 'den gelir.</p>
</div>
<div class="paragraph">
<p>Çakışan dosyanın her bir sürümünü <code>git show</code> komutunu ve özel bir sözdizimini kullanarak çıkarabilirsiniz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show :1:hello.rb &gt; hello.common.rb
$ git show :2:hello.rb &gt; hello.ours.rb
$ git show :3:hello.rb &gt; hello.theirs.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Daha detaylı bir şekilde ilerlemek isterseniz, <code>ls-files -u</code> tesisat komutunu kullanarak bu dosyaların her biri için Git bloblarının gerçek SHA-1’lerini alabilirsiniz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git ls-files -u
100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1	hello.rb
100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2	hello.rb
100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3	hello.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>:1:hello.rb</code>, bu blobun SHA-1’ini aramak için kullanılan bir kısaltmadır.</p>
</div>
<div class="paragraph">
<p>Artık çalışma dizinimizde her üç izlem’in de içeriğine sahip olduğumuza göre, boşluk sorununu çözmek için onların tarafını elle düzeltebilir ve az bilinen <code>git merge-file</code> komutunu kullanarak dosyayı yeniden birleştirebiliriz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ dos2unix hello.theirs.rb
dos2unix: converting file hello.theirs.rb to Unix format ...

$ git merge-file -p \
    hello.ours.rb hello.common.rb hello.theirs.rb &gt; hello.rb

$ git diff -b
diff --cc hello.rb
index 36c06c8,e85207e..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,8 -1,7 +1,8 @@@
  #! /usr/bin/env ruby

 +# prints out a greeting
  def hello
-   puts 'hello world'
+   puts 'hello mundo'
  end

  hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu noktada dosyayı güzel bir şekilde birleştirdik.
Aslında bu, boşluk değişikliklerini doğrudan yoksaymak yerine, gerçekte onları birleştirme öncesinde düzelttiği için <code>ignore-space-change</code> seçeneğinden daha iyi çalışır.
<code>ignore-space-change</code> birleştirmesinde, DOS satır sonlarına sahip olan satırlar biraz kafa karıştırıcıdır.</p>
</div>
<div class="paragraph">
<p>Bu katkıyı işlemeden önce, son bir kontrol amacıyla, gerçekte hangi tarafın hangi değişiklikleri yaptığını görmek isterseniz; katkılamak üzere çalışma dizinizde olup birleştirme sonucu olarak katkılayacağınız çalışmayı bu izlemlerdekilerle kıyaslamak için <code>git diff</code> komutunu kullanabilirsiniz.
Şimdi hepsini deneyelim.</p>
</div>
<div class="paragraph">
<p>Sonucunuzu birleştirmeden önce dalınızdaki son durumuyla karşılaştırmak, diğer bir deyişle birleştirmenin ne tür değişiklikler getirdiğini görmek için <code>git diff --ours</code> komutunu çalıştırabilirsiniz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --ours
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index 36c06c8..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -2,7 +2,7 @@

 # prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu şekilde, dalımızda olup biteni, bu dosyaya bu birleştirmeyle tanıttığımız şeyin, o tek satırı değiştirmek olduğunu kolaylıkla görebiliriz.</p>
</div>
<div class="paragraph">
<p>Birleştirmenin sonucunun, onların tarafındakinden nasıl farklı olduğunu görmek istiyorsak, <code>git diff --theirs</code> komutunu çalıştırabiliriz.
Bu ve aşağıdaki örnekte, boşlukları çıkarmak için ‘-b’ kullanmamız gerekiyor çünkü onu temizlenmiş <em>hello.theirs.rb</em> dosyamızla değil, Git’tekiyle karşılaştırıyoruz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --theirs -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index e85207e..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello mundo'
 end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Son olarak, dosyanın her iki taraftan da nasıl değiştiğini <code>git diff --base</code> ile görebilirsiniz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --base -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index ac51efd..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,8 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu noktada, manuel birleştirmeyi yapmak için oluşturduğumuz, ancak artık ihtiyaç duymadığımız ek dosyaları temizlemek için <code>git clean</code> komutunu kullanabiliriz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clean -f
Removing hello.common.rb
Removing hello.ours.rb
Removing hello.theirs.rb</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_checking_out_conflicts">Çakışmaları Kontrol Etme</h4>
<div class="paragraph">
<p>Belki bu aşamada bir nedenle çözümden memnun değilizdir. Ya da belki bir veya her iki tarafı manuel olarak düzenlemek çok da iyi çalışmamıştır ve daha fazla bağlam gerekmektedir.</p>
</div>
<div class="paragraph">
<p>Örneği biraz değiştirelim.
Bu örnekte, her birinde birkaç katkı olan iki uzun ömürlü dalımız var, ancak birleştirildiğinde meşru bir içerik çakışması oluşturuyorlar.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --graph --oneline --decorate --all
* f1270f7 (HEAD, master) update README
* 9af9d3b add a README
* 694971d update phrase to hola world
| * e3eb223 (mundo) add more tests
| * 7cff591 add testing script
| * c3ffff1 changed text to hello mundo
|/
* b7dcc89 initial hello world code</code></pre>
</div>
</div>
<div class="paragraph">
<p>Şimdi, yalnızca <code>master</code> dalında bulunan üç benzersiz katkımız var ve diğer üçü de <code>mundo</code> dalında bulunuyor.
<code>mundo</code> dalını birleştirmeye çalışırsak, bir çakışma alırız.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Çakışmanın ne olduğunu görmek istiyoruz.
Dosyayı açarsak, şuna benzer bir şey göreceğiz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
  puts 'hola world'
=======
  puts 'hello mundo'
&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo
end

hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Her iki tarafın da bu dosyaya içerik eklemiş, ancak bazı katkılar bu çakışmaya sebep olan dosyayı değiştirmiştir.</p>
</div>
<div class="paragraph">
<p>Şimdi, bu çatışmayı nasıl düzelteceğiniz tam olarak açık değilse, kullanabileceğiniz birkaç aracı keşfedelim.
Belki de bu çatışmayı nasıl çözeceğiniz tam olarak belli değil ve daha fazla bağlama ihtiyacınız var.</p>
</div>
<div class="paragraph">
<p>Yararlı bir araç, <code>git checkout</code> komutuna eklenen <code>--conflict</code> seçeneğidir.
Bu komut dosyayı yeniden kontrol eder ve çakışma işaretlerini değiştirir.
İşaretleri sıfırlamak ve yeniden çözmeyi denemek istiyorsanız, bu faydalı olabilir.</p>
</div>
<div class="paragraph">
<p><code>--conflict</code> seçeneğine <code>diff3</code> veya <code>merge</code> (varsayılan) değerlerinden herhangi birini ekleyebilirsiniz.
Eğer <code>diff3</code> 'ü eklerseniz, Git biraz farklı bir çatışma işareti versiyonu kullanır; size sadece <code>ours</code> (bizimki) ve <code>theirs</code> (onlarınki) versiyonlarını değil, aynı zamanda daha fazla bağlam için <code>base</code> versiyonunu da içerir.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout --conflict=diff3 hello.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bunu çalıştırdıktan sonra, dosya şuna benzer olacaktır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; ours
  puts 'hola world'
||||||| base
  puts 'hello world'
=======
  puts 'hello mundo'
&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs
end

hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Eğer bu formatı begendiyseniz, gelecekteki birleştirme çakışmalarında varsayılan olarak ayarlamak için <code>merge.conflictstyle</code> ayarını <code>diff3</code> olarak değiştirebilirsiniz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global merge.conflictstyle diff3</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>git checkout</code> komutu ayrıca <code>--ours</code> ve <code>--theirs</code> seçeneklerini alabilir, bu da bir tarafı seçmek veya diğerini tamamen birleştirmeden önce seçmenin çok hızlı bir yoludur.</p>
</div>
<div class="paragraph">
<p>Bu, özellikle sadece bir tarafı seçmek istediğiniz ikili (binary) dosya çatışmaları veya başka bir dalda belirli dosyaları birleştirmek istediğiniz durumlar için kullanışlı olabilir; birleştirmeyi yapabilir ve ardından katkıyı işlemeden önce belirli dosyaları bir taraftan veya diğerinden seçebilirsiniz.</p>
</div>
</div>
<div class="sect4">
<h4 id="_merge_log">Merge Günlüğü</h4>
<div class="paragraph">
<p>Git birleştirme çatışmalarını çözerken yararlı bir başka araç da <code>git log</code> komutudur.
Bu komut çatışmalara katkıda bulunan faktörleri anlamanıza yardımcı olabilir.
Bazen iki geliştirme hattının aynı kod bölgesine dokunmasının nedenlerini hatırlamak için, biraz geçmişi gözden geçirmek gerçekten yardımcı olabilir.</p>
</div>
<div class="paragraph">
<p>Bu birleştirmeye dahil olan her iki dalın da içerdiği benzersiz tüm katkıların tam bir listesini almak için, <a href="{{< relurl "book/tr/v2/ch00/_triple_dot" >}}">Üçlü Nokta (…​)</a> sözdizimini kullanabiliriz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --left-right HEAD...MERGE_HEAD
&lt; f1270f7 update README
&lt; 9af9d3b add a README
&lt; 694971d update phrase to hola world
&gt; e3eb223 add more tests
&gt; 7cff591 add testing script
&gt; c3ffff1 changed text to hello mundo</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu, her katkının hangi geliştirme hattında olduğuyla birlikte, sürece dahil olan toplam altı katkının güzel bir listesidir.</p>
</div>
<div class="paragraph">
<p>Ancak, bunu çok daha spesifik bir bağlama sahip olması için biraz daha basitleştirebiliriz.
<code>git log</code> komutuna <code>--merge</code> seçeneğini eklersek, çakışmada olan bir dosyayı değiştiren katkıları gösterecektir.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --left-right --merge
&lt; 694971d update phrase to hola world
&gt; c3ffff1 changed text to hello mundo</code></pre>
</div>
</div>
<div class="paragraph">
<p>Eğer <code>-p</code> seçeneği ile çalıştırırsanız, çakışmaya neden olan dosyalara ilişkin farklılıkları alırsınız.
Bu, bir şeyin neden çakıştığını anlamanıza ve daha akıllıca nasıl çözeceğinize dair ihtiyacınız olan bağlamı hızlı bir şekilde sağlamak için <strong>gerçekten</strong> faydalı olabilir.</p>
</div>
</div>
<div class="sect4">
<h4 id="_birleşik_fark_formatı">Birleşik Fark Formatı</h4>
<div class="paragraph">
<p>Git, başarılı olan her birleştirmeyi izleme alır; bu nedenle çakışma durumunda <code>git diff</code> komutunu çalıştırdığınızda sadece hala çakışma durumunda olanları alırsınız.
Bu, çözmeniz gerekenleri görmek için faydalı olabilir.</p>
</div>
<div class="paragraph">
<p>Birleştirme çakışmasının hemen ardından <code>git diff</code> komutunu çalıştırdığınızda, size benzersiz bir formatta bir fark çıktısı verecektir.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,11 @@@
  #! /usr/bin/env ruby

  def hello
++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
 +  puts 'hola world'
++=======
+   puts 'hello mundo'
++&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo
  end

  hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu format ``Birleşik Fark`` olarak adlandırılır ve her satırın yanında iki sütun veriye sahiptir.
İlk sütun, bu satırın ``ours`` (bizim) dalı ve çalışma dizininizdeki dosya arasında farklı olup olmadığını (eklenmiş veya kaldırılmış olarak) gösterir ve ikinci sütun aynı şeyi ``theirs`` (onların) dalı ve çalışma dizininizdeki kopya arasında yapar.</p>
</div>
<div class="paragraph">
<p>Bu örnekte <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> ve <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> satırlarının çalışma kopyasında olduğunu ancak birleştirmenin her iki tarafında da olmadığını görebilirsiniz.
Birleştirme aracı bunları nelerin eklenip çıkarıldığını anlamamız için yerleştirdiğinden mantıklıdır, ancak bunları kaldırmamız beklenir.</p>
</div>
<div class="paragraph">
<p>Çatışmayı çözer ve <code>git diff</code> komutunu yeniden çalıştırırsak, aynı şeyi göreceğiz, ancak bu sefer biraz daha kullanışlıdır.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ vim hello.rb
$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu, ``hola world`` 'un tarafımızda olduğunu ancak çalışma kopyasında olmadığını, ``hello mundo`` 'nun onların arafında olduğunu ancak çalışma kopyasında olmadığını ve son olarak ``hola mundo`` 'nun her iki tarafta da olmadığını ancak şimdi çalışma kopyasında olduğunu gösterir.
Bu, çözümü katkı olarak işlemeden önce bir gözden geçirmek açısından faydalı olabilir.</p>
</div>
<div class="paragraph">
<p>Ayrıca, birleştirmenin nasıl çözüldüğünü sonradan görmek için herhangi bir birleştirmenin <code>git log</code> çıktısından da yararlanabilirsiniz.
Git, bir birleştirme katkısı üzerine <code>git show</code> komutunu çalıştırdığınızda veya bir <code>git log -p</code> komutuna (varsayılan olarak yalnızca birleştirme katkısı olmayan yamaları gösterir) <code>--cc</code> seçeneği eklediğinizde karşınıza bu formatı çıkarır.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --cc -p -1
commit 14f41939956d80b9e17bb8721354c33f8d5b5a79
Merge: f1270f7 e3eb223
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Sep 19 18:14:49 2014 +0200

    Merge branch 'mundo'

    Conflicts:
        hello.rb

diff --cc hello.rb
index 0399cd5,59727f0..e1d0799
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_undoing_merges">Birleştirmeyi Geri Almak</h3>
<div class="paragraph">
<p>Artık bir birleştirme katkısı oluşturmayı nasıl yapacağınızı bildiğinize göre, muhtemelen bazen kazara kullanacaksınız.
Git ile çalışmanın harika yanlarından biri, hata yapmanın sorun olmadığıdır, çünkü onları düzeltmek mümkündür (ve birçok durumda kolaydır).</p>
</div>
<div class="paragraph">
<p>Birleştirme komutları da istisna değildir.
Diyelim ki bir konu dalında çalışmaya başladınız, bunu yanlışlıkla <code>master</code> dalına birleştirdiniz ve şimdi katkı geçmişiniz şöyle görünüyor:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/undomerge-start.png" >}}" alt="Kazara birleştirme katkısı.">
</div>
<div class="title">Görsel 137. Kazara birleştirme katkısı</div>
</div>
<div class="paragraph">
<p>Bu sorunu çözmek için istediğiniz sonuca bağlı olarak iki farklı yaklaşım bulunmaktadır.</p>
</div>
<div class="sect4">
<h4 id="_referansları_düzeltmek">Referansları Düzeltmek</h4>
<div class="paragraph">
<p>Eğer istenmeyen birleştirme katkısı yalnızca yerel repoda varsa; en kolay ve en iyi çözüm, dalları istediğiniz yere işaret edecek şekilde taşımaktır.
Çoğu durumda, yanlış <code>git merge</code> işleminden sonra <code>git reset --hard HEAD~</code> komutunu takip ederseniz, bu, dal işaretçilerini aşağıdaki gibi sıfırlayacaktır:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/undomerge-reset.png" >}}" alt="`git reset --hard HEAD~` sonrası geçmiş.">
</div>
<div class="title">Görsel 138. <code>git reset --hard HEAD~</code> sonrası geçmiş</div>
</div>
<div class="paragraph">
<p>Bir önceki konumuzda <code>reset</code> komutunu ele aldık (<code>&lt;&lt;_git_reset&gt;&gt;</code>), bu yüzden burada neler olup bittiğini anlamak çok zor olmamalı.
Hemen hatırlatalım: <code>reset --hard</code> genellikle üç adımdan oluşur:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Dalın HEAD’inin işaret ettiği yeri taşı.
Bu durumda, <code>master</code> 'ı birleştirme katkısından önceki konuma (<code>C6</code>) taşımak istiyoruz.</p>
</li>
<li>
<p>İndeksi HEAD’e benzet.</p>
</li>
<li>
<p>Çalışma dizinini indekse benzet.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Bu yaklaşımın dezavantajı, geçmişi yeniden yazmasıdır ve bu, paylaşılan bir repoda sorun olabilir.
Neler olabileceğine dair daha fazla bilgi için <a href="{{< relurl "book/tr/v2/ch00/_rebase_peril" >}}">Yeniden Temellemenin Riskleri</a> bölümüne göz atabilirsiniz; kısaca, yeniden yazdığınız katkıları kullanan başkaları da varsa, <code>reset</code> 'ten kaçınmanız gerekebilir.
Bu yaklaşım, birleştirmenin ardından başka bir katkı oluşturulduğu durumlarda da çalışmaz; işaretçileri taşımak bu değişiklikleri kaybetmeye yol açar.</p>
</div>
</div>
<div class="sect4">
<h4 id="_reverse_commit">Katkıyı Geri Alma</h4>
<div class="paragraph">
<p>Eğer dal işaretçilerini taşımak sizin işinizi görmeyecekse, Git size mevcut bir katkıdan kaynaklanan tüm değişiklikleri geri alacak yeni bir katkı işleme seçeneği sunar.
Git, bu işlemi <code>revert</code> (geri alma) olarak adlandırır, ve bu senaryoda, onu şu şekilde çağırırsınız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git revert -m 1 HEAD
[master b1d8379] Revert "Merge branch 'topic'"</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>-m 1</code> bayrağı, hangi öncelin <code>mainline</code> (ana hat) olduğunu ve korunması gerektiğini belirtir.
<code>HEAD</code> 'e birleştirme çağrısında bulunduğunuzda (<code>git merge topic</code>), yeni katkı iki öncele sahiptir: birinci öncel <code>HEAD</code> (<code>C6</code>) ve ikinci öncel birleştirilen dalın ucudur (<code>C4</code>).
Burada, ikinci öncelin (<code>C4</code>) birleştirmesiyle gelen tüm değişiklikleri geri almak ama birinci öncelin (<code>C6</code>) tüm içeriğini de korumak istiyoruz.</p>
</div>
<div class="paragraph">
<p>Geri alma katkısı sonrasında geçmişimiz şöyle görünür:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/undomerge-revert.png" >}}" alt="`git revert -m 1` sonrası geçmiş.">
</div>
<div class="title">Görsel 139. <code>git revert -m 1</code> sonrası geçmiş</div>
</div>
<div class="paragraph">
<p>Yeni katkı olan <code>^M</code>, tam olarak <code>C6</code> ile aynı içeriğe sahiptir. Bu yüzden buradan itibaren, birleştirilmemiş katkıların halâ <code>HEAD</code> 'in geçmişinde bulunması dışında, sanki birleştirme hiç olmamış gibidir.
<code>topic</code> 'i tekrar <code>master</code> 'a birleştirmeye çalışırsanız Git’in kafası karışır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge topic
Already up-to-date.</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>topic</code> 'te <code>master</code> 'dan ulaşılamayan bir şey yoktur.
Daha fenası, <code>topic</code> 'e iş ekler ve tekrar birleştirirseniz, Git <em>geri alınan birleştirmeden</em> sonraki değişiklikleri getirecektir:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/undomerge-revert2.png" >}}" alt="Kötü birleştirilmiş geçmiş.">
</div>
<div class="title">Görsel 140. Kötü birleştirilmiş geçmiş</div>
</div>
<div class="paragraph">
<p>Bu durumda en iyi çözüm, özgün birleştirmeyi geri alıp (çünkü şimdi geri alınan değişiklikleri getirmek istiyorsunuz), <strong>ardından</strong> yeni bir birleştirme katkısı oluşturmaktır:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git revert ^M
[master 09f0126] Revert "Revert "Merge branch 'topic'""
$ git merge topic</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/undomerge-revert3.png" >}}" alt="Geri alınan bir birleştirmeyi yeniden birleştirdikten sonra geçmiş.">
</div>
<div class="title">Görsel 141. Geri alınan bir birleştirmeyi yeniden birleştirdikten sonra geçmiş:</div>
</div>
<div class="paragraph">
<p>Bu örnekte, <code>M</code> ve <code>^M</code> birbirini iptal eder.
<code>^^M</code> katkısı, <code>C3</code> ve <code>C4</code> 'ten gelen değişiklikleri etkin bir şekilde birleştirirken, <code>C8</code> de, <code>C7`den gelen değişiklikleri birleştirir; böylece `topic</code> tamamen birleştirilmiş olur.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_diğer_birleştirme_tipleri">Diğer Birleştirme Tipleri</h3>
<div class="paragraph">
<p>Şimdiye kadar iki dalın normal birleştirilmesini ele aldık, bunlar genellikle birleştirmenin "özyinelemeli" (recursive) stratejisiyle ele alınır.
Ancak, dalları birleştirmenin başka yolları da vardır.
Hızlı bir şekilde birkaçını ele alalım.</p>
</div>
<div class="sect4">
<h4 id="_bizim_ours_veya_onların_theirs_tercihi">Bizim (ours) veya onların (theirs) tercihi</h4>
<div class="paragraph">
<p>Öncelikle, normal "özyinelemeli" birleştirme moduyla yapabileceğimiz başka bir yararlı işlev daha var.
Zaten bir <code>-X</code> ile iletilen <code>ignore-all-space</code> ve <code>ignore-space-change</code> seçeneklerini gördük, ancak Git’e bir çakışma gördüğünde belli bir tarafı tercih etmesini söyleyebiliriz.</p>
</div>
<div class="paragraph">
<p>Varsayılan olarak, Git birleştirilmekte olan iki dal arasında bir çakışma gördüğünde; kodunuza birleştirme çakışma işaretçilerini ekler, dosyayı çakışmış olarak işaretler ve sizin çakışmayı çözmenize izin verir.
Eğer manuel olarak çözmenize gerek kalmadan, Git’in  belli bir tarafı seçerek çakışmayı otomatik olarak çözmesini tercih ederseniz; <code>merge</code> komutuna <code>-Xours</code> veya <code>-Xtheirs</code> bayraklarını ekleyebilirsiniz.</p>
</div>
<div class="paragraph">
<p>Eğer Git bunu görürse, çakışma işaretçilerini eklemeyecektir.
Birleştirilebilir tüm farkları ise birleştirir.
İkili (binary) dosyalar da dahil, çakışan tüm farklarda ise, tamamen belirttiğiniz tarafları seçer.</p>
</div>
<div class="paragraph">
<p>Eğer önceki "hello world" örneğimize geri dönersek, kendi dalımıza birleştirmenin çatışmalara neden olduğunu görebiliriz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved 'hello.rb' using previous resolution.
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ancak <code>-Xours</code> veya <code>-Xtheirs</code> ile çalıştırırsak, bu işaretçileri eklemeyecektir.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge -Xours mundo
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 test.sh  | 2 ++
 2 files changed, 3 insertions(+), 1 deletion(-)
 create mode 100644 test.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu durumda, dosyada bir tarafta ``hello mundo`` ve diğer tarafta ``hola world`` olan çatışma işaretçilerini almak yerine, sadece ``hola world`` 'ü seçecektir.
Ancak, bu dalda diğer çakışmayan tüm değişiklikler başarıyla birleştirilir.</p>
</div>
<div class="paragraph">
<p>Bu seçenek ayrıca önceki gördüğümüz <code>git merge-file</code> komutuna da geçirilebilir, örneğin, bireysel dosya birleştirmeleri için <code>git merge-file --ours</code> şeklinde.</p>
</div>
<div class="paragraph">
<p>Eğer bunun gibi bir şey yapmak istiyorsanız ve Git’in diğer taraftaki değişiklikleri bile birleştirmeye çalışmasını istemiyorsanız, daha katı bir seçenek olan <code>ours</code> birleştirme <em>stratejisi</em> vardır.
Bu, <code>ours</code> özyinelemeli birleştirme <em>seçeneğinden</em> farklıdır.</p>
</div>
<div class="paragraph">
<p>Bununla aslında sahte bir birleştirme yapılacaktır.
Birleştirmeye çalıştığınız dala bile bakmadan, her iki dalı da öncel kabul ederek yeni bir birleştirme katkısı kaydedecektir.
Sadece birleştirmenin sonucunu, mevcut dalınızdaki kodun tamamı olarak kaydeder.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge -s ours mundo
Merge made by the 'ours' strategy.
$ git diff HEAD HEAD~
$</code></pre>
</div>
</div>
<div class="paragraph">
<p>Görebileceğiniz gibi, bulunduğumuz dal ile birleştirmenin sonucu arasında herhangi bir fark yoktur.</p>
</div>
<div class="paragraph">
<p>Birleştirme yaparken bunu, Git’i bir dalın zaten birleştirilmiş olduğu şeklinde kandırmak için kullanabilirsiniz.
Örneğin, bir <code>release</code> dalından yeniden dallandınız, bu dalda bazı çalışmalar yaptınız ve bu işleri bir noktada <code>master</code> dalınıza geri birleştirmek istiyorsunuz.
Ama bu arada, <code>master</code> üzerindeki bazı hata düzeltmelerinin <code>release</code> dalına alınması gerekiyor.
Hata düzeltme (bugfix) dalını <code>release</code> dalına birleştirebilir ve aynı dalı <code>master</code> dalınıza da <code>merge -s ours</code> ile (<code>bugfix</code> dalı zaten orada olmasına rağmen) birleştirebilirsiniz. Böylece daha sonra <code>release</code> dalını tekrar birleştirdiğinizde <code>bugfix</code> yüzünden çakışmalar olmaz.</p>
</div>
</div>
<div class="sect4">
<h4 id="_subtree_merge">Alt Ağaç Birleştirme</h4>
<div class="paragraph">
<p>Alt ağaç birleştirme fikri, iki projeniz olduğunda, bu projelerden birinin diğerinin alt dizinine eşlendiği anlamına gelir.
Bir alt ağaç birleştirmesi belirttiğinizde, Git genellikle birinin diğerinin bir alt ağacı olduğunu ve uygun şekilde birleştirmesi gerektiğini anlayacak kadar akıllıdır.</p>
</div>
<div class="paragraph">
<p>Bu bölümde, mevcut bir projeye ayrı bir proje eklemeyi ve ardından ikincisinin kodunu birincisinin bir alt dizinine birleştirmeyi inceleyeceğiz.</p>
</div>
<div class="paragraph">
<p>İlk olarak, Rack uygulamasını projemize ekleyeceğiz.
Rack projesini kendi projemize bir uzak referans olarak ekleyeceğiz ve sonra onun kendi dalına geçeceğiz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add rack_remote https://github.com/rack/rack
$ git fetch rack_remote --no-tags
warning: no common commits
remote: Counting objects: 3184, done.
remote: Compressing objects: 100% (1465/1465), done.
remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.
Resolving deltas: 100% (1952/1952), done.
From https://github.com/rack/rack
 * [new branch]      build      -&gt; rack_remote/build
 * [new branch]      master     -&gt; rack_remote/master
 * [new branch]      rack-0.4   -&gt; rack_remote/rack-0.4
 * [new branch]      rack-0.9   -&gt; rack_remote/rack-0.9
$ git checkout -b rack_branch rack_remote/master
Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.
Switched to a new branch "rack_branch"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Şimdi <code>master</code> dalında kendi projemize ve <code>rack_branch</code> dalında Rack projesinin köküne sahibiz.
Önce birini, sonra diğerini kontrol ederseniz, farklı proje köklerine sahip olduklarını görebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ls
AUTHORS         KNOWN-ISSUES   Rakefile      contrib         lib
COPYING         README         bin           example         test
$ git checkout master
Switched to branch "master"
$ ls
README</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu konsept biraz garip gelebilir.
Bir repodaki tüm dalların aslında aynı projenin dalları olması gerekmez.
Nadiren faydalı olduğu için bu pek yaygın değildir, ancak dalların tamamen farklı tarihçeler içermesini sağlamak aslında kolaydır.</p>
</div>
<div class="paragraph">
<p>Burada, Rack projesini <code>master</code> projemize bir alt dizin olarak eklemek istiyoruz.
Bunu <code>git read-tree</code> komutuyla yapabiliriz.
<code>read-tree</code> ve arkadaşları hakkında daha fazla bilgiyi <a href="{{< relurl "book/tr/v2/ch00/ch10-git-internals" >}}">Dahili Git Ögeleri</a> bölümünde öğreneceksiniz; ancak şimdilik, bir dalın kök ağacını mevcut izlem alanınıza ve çalışma dizinize okuduğunu bilmeniz yeterlidir.
Şimdi <code>master</code> dalınıza geri döndük ve ana projemizin <code>master</code> dalına <code>rack_branch</code> dalını <code>rack</code> alt dizinine çekiyoruz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git read-tree --prefix=rack/ -u rack_branch</code></pre>
</div>
</div>
<div class="paragraph">
<p>Katkıyı işledikten sonra, tüm Rack dosyalarının o alt dizin altında olduğu görünür (sanki onları bir sıkıştırılmış dosyadan kopyalamışız gibi).
İlginç olan, bir dalın değişikliklerini bir diğerine oldukça kolay bir şekilde birleştirebilme yeteneğidir.
Yani, Rack projesi güncellendiğinde, o dala geçip değişiklikleri alabiliriz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout rack_branch
$ git pull</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ardından, bu değişiklikleri kendi <code>master</code> dalımıza birleştirebiliriz.
Değişiklikleri almak ve katkı mesajını önceden yenilemek için <code>--squash</code> seçeneğini, ayrıca özyinelemeli birleştirme stratejisinin <code>-Xsubtree</code> seçeneğini kullanın. (Özyinelemeli strateji burada varsayılan olduğundan, netleştirmek için dahil ediyoruz.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
$ git merge --squash -s recursive -Xsubtree=rack rack_branch
Squash commit -- not updating HEAD
Automatic merge went well; stopped before committing as requested</code></pre>
</div>
</div>
<div class="paragraph">
<p>Rack projesindeki tüm değişiklikler birleştirilmiş ve yerel olarak katkılanmaya hazır durumdadır.
Ayrıca, tam tersini de yapabilirsiniz - kendi <code>master</code> dalınızın <code>rack</code> alt dizininde değişiklikler yapın ve daha sonra bunları proje bakıcılarına veya üst akıma göndermek için sonradan <code>rack_branch</code> dalınıza birleştirin.</p>
</div>
<div class="paragraph">
<p>Bu bize, alt modüller kullanmadan alt modül iş akışı kullanmaya oldukça benzeyen bir yöntem sunar (ki alt modülleri <a href="{{< relurl "book/tr/v2/ch00/_git_submodules" >}}">Alt Modüller</a> bölümünde ele alacağız).
İlgili diğer projelerin dallarını repomuzda tutabilir ve zaman zaman alt ağaç birleştirmesi yaparak bunları kendi projemize dahil edebiliriz.
Bu, mesela tüm kodların tek bir yerde katkılanmış olması gibi bazı açılardan güzel olabilir.
Ancak, diğer bazı dezavantajlara sahiptir! Örneğin, biraz daha karmaşıktır, değişiklikleri yeniden entegre etmek zordur veya yanlışlıkla bir dalı ilgisiz bir repoya itmek daha kolaydır.</p>
</div>
<div class="paragraph">
<p>Biraz garip olan başka bir şey de, (mesela onları birleştirmeniz gerekip gerekmediğini görmek için) <code>rack</code> alt dizininde neye sahip olduğunuz ile <code>rack_branch</code> dalındaki kod arasındaki farkı görmek istediğinizde normal <code>diff</code> komutunu kullanamıyor olmanızdır.
Bunun yerine, karşılaştırmak istediğiniz dal ile <code>git diff-tree</code> komutunu çalıştırmalısınız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff-tree -p rack_branch</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or, to compare what is in your <code>rack</code> subdirectory with what the <code>master</code> branch on the server was the last time you fetched, you can run</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff-tree -p rack_remote/master</code></pre>
</div>
</div>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>