---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: tr
  chapter:
    title: Git Dalları
    number: 3
  section:
    title: Yeniden Temelleme (rebase)
    number: 6
    cs_number: '3.6'
    previous: book/tr/v2/Git-Dalları-Uzak-Dallar
    next: book/tr/v2/Git-Dalları-Özet
title: Git - Yeniden Temelleme (rebase)
url: "/book/tr/v2/Git-Dalları-Yeniden-Temelleme-rebase.html"
---
<h2 id="_rebasing">Yeniden Temelleme (rebase)</h2>
<div class="paragraph">
<p>
Git’te, bir dalın değişikliklerini diğerine birleştirmenin iki ana yolu vardır: <code>merge</code> (birleştirme) ve <code>rebase</code> (yeniden temelleme). Bu bölümde, yeniden temellemenin ne olduğunu, nasıl yapıldığını, neden oldukça etkili bir araç olduğunu ve hangi durumlarda kullanmak istemeyeceğinizi öğreneceksiniz.</p>
</div>
<div class="sect3">
<h3 id="_kısaca_yeniden_temelleme">Kısaca Yeniden Temelleme</h3>
<div class="paragraph">
<p>Eğer önceki örneğe, <a href="{{< relurl "book/tr/v2/ch00/_basic_merging" >}}">Birleştirme</a> başlıklı bölüme geri dönerseniz, işinizi dallandırdığınızı ve iki farklı dalda katkı işlediğinizi görebilirsiniz.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/basic-rebase-1.png" >}}" alt="Basit bir ayrışma geçmişi.">
</div>
<div class="title">Görsel 35. Basit bir ayrışma geçmişi</div>
</div>
<div class="paragraph">
<p>Dalları birleştirmenin en kolay yolu, zaten ele aldığımız gibi <code>merge</code> komutudur.
Bu komut, iki dalın (<code>C3</code> ve <code>C4</code>) ve bunların en son ortak öncelinin (<code>C2</code>) son pozlarını üçyönlü birleştirerek, yeni bir poz (ve katkı) oluşturur.</p>
</div>
<div id="rebasing-merging-example" class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/basic-rebase-2.png" >}}" alt="Ayrık çalışma geçmişini birleştirmek.">
</div>
<div class="title">Görsel 36. Ayrık çalışma geçmişini birleştirmek</div>
</div>
<div class="paragraph">
<p>Ancak, başka bir yol daha vardır: <code>C4</code> ile tanıtılan değişikliğin yamasını alabilir ve bunu <code>C3</code> 'ün üzerine yeniden uygulayabilirsiniz.
Git’te buna <em>yeniden temelleme</em> (rebasing) denir.
<code>rebase</code> komutu ile bir dalda işlenmiş tüm değişiklikleri alabilir ve bunları farklı bir dala aktararak bir temel olarak kullanabilirsiniz.</p>
</div>
<div class="paragraph">
<p>Bu örnekte, <code>experiment</code> dalına geçer ve ardından onu şu şekilde <code>master</code> dalına aktarabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu işlem, iki dalın (üzerinde bulunduğunuz dal ve yeniden temellediğiniz dal) ortak önceline gitmesiyle başlar.
Ardından, üzerinde bulunduğunuz dalın her katkısının getirdiği farkı alır ve bu farkları geçici dosyalara kaydeder.
Mevcut dalı, üzerine yeniden temelleme yaptığınız dalın katkıları ile aynı katkıya sıfırlar ve son olarak her değişikliği sırayla uygular.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/basic-rebase-3.png" >}}" alt="`C4` 'teki değişikliği `C3` üzerine temelleme.">
</div>
<div class="title">Görsel 37. <code>C4</code> 'teki değişikliği <code>C3</code> üzerine temelleme</div>
</div>
<div class="paragraph">
<p>Bu noktada, <code>master</code> dalına geri dönebilir ve bir ileri-sarma birleştirmesi (fast-forward merge) yapabilirsiniz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
$ git merge experiment</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/basic-rebase-4.png" >}}" alt="Master dalına ileri-sarma.">
</div>
<div class="title">Görsel 38. Master dalına ileri-sarma</div>
</div>
<div class="paragraph">
<p>Şu anda, <code>C4'</code> tarafından işaret edilen poz, <a href="{{< relurl "book/tr/v2/ch00/rebasing-merging-example" >}}">the merge example</a> örneğinde <code>C5</code> tarafından işaret edilen poz ile tam olarak aynıdır.
Birleştirme çıktısında fark yoktur, ancak yeniden temelleme daha temiz bir geçmiş sunar.
Eğer <code>git log</code> komutuyla temellenmiş bir dalın günlüğünü incelerseniz, doğrusal bir geçmiş görürsünüz.
Başlangıçta eşzamanlı gerçekleşmiş olsa bile, tüm işin sırayla gerçekleştiği izlenimini verir.</p>
</div>
<div class="paragraph">
<p>Çoğu zaman bunu, katkılarınızın temiz bir şekilde bir uzak dala uygulanmasını sağlamak için yaparsınız, belki de bir süre üzerinde çalıştığınız ancak sürdürmediğiniz bir projede.
Bu durumda, işinizi bir dalda yapar ve yamalarınızı ana projeye göndermeye hazır olduğunuzda işinizi <code>origin/master</code> üzerine yeniden temellersiniz.
Bu şekilde, bakım yapan kişinin herhangi bir birleştirme çalışması yapmasına gerek kalmaz - sadece bir ileri-sarma veya temiz bir uygulama yapması yeterlidir.</p>
</div>
<div class="paragraph">
<p>Unutmayın ki, bu işlem sonunda elde ettiğiniz poz, ister bir yeniden temelleme işlemi için alınmış son temelleme katkısı, isterse birleştirme işlemi sonrası elde ettiğiniz son birleştirme katkısı olsun, aynı pozdur - farklı olan sadece tarihtir.
"Yeniden Temelleme" değişiklikleri tanımlandıkları sırayla bir iş çizgisinden başka bir iş çizgisine aktarırken, "birleşim" uç noktaları alır ve bunları birleştirir.</p>
</div>
</div>
<div class="sect3">
<h3 id="_daha_detaylıca_yeniden_temelleme">Daha Detaylıca Yeniden Temelleme</h3>
<div class="paragraph">
<p>Yeniden temelleme işlemi için hedef aldığınız dal dışında bir dala da temellemenizi uygulayabilirsiniz.
Mesela <a href="{{< relurl "book/tr/v2/ch00/rbdiag_e" >}}">Bir tematik daldan ayrılan başka bir tematik dalın geçmişi</a> şeklindeki bir tarihçeyi ele alalım:
Projeye sunucu tarafı işlevselliği eklemek için <code>server</code> adında tematik bir dal oluşturdunuz ve bir katkı işlediniz.
Ardından, istemci tarafındaki değişiklikleri yapmak için bu daldan ayrılıp <code>client</code> dalında birkaç katkı işlediniz.
Son olarak, sunucu dalına geri dönüp birkaç katkı daha işlediniz.</p>
</div>
<div id="rbdiag_e" class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/interesting-rebase-1.png" >}}" alt="Bir tematik daldan ayrılan başka bir tematik dalın geçmişi.">
</div>
<div class="title">Görsel 39. Bir tematik daldan ayrılan başka bir tematik dalın geçmişi</div>
</div>
<div class="paragraph">
<p>Diyelim ki, bir sürüm için kullanıcı tarafındaki değişiklikleri ana dalınıza birleştirmeye karar verdiniz, ancak sunucu tarafındaki değişiklikleri daha fazla test edilene kadar bekletmek istiyorsunuz.
Bu durumda, sunucu tarafında olmayıp (<code>C8</code> and <code>C9</code>) kullanıcı tarafında olan değişiklikleri alabilir ve onları <code>git rebase</code> komutunun <code>--onto</code> seçeneğini kullanarak <code>master</code> dalınıza yeniden temelleyebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rebase --onto master server client</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu temel olarak şunu ifade eder: "<code>client</code> dalını al, bu dalın <code>server</code> dalından ayrıldığından bu yana yapılan yamaları belirle ve bu yamaları <code>client</code> dalında, sanki doğrudan <code>master</code> dalından temellenmiş gibi yeniden temelle."
Biraz karmaşık gibi görünebilir, ancak sonuç oldukça etkileyicidir.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/interesting-rebase-2.png" >}}" alt="Tematik bir daldan yeni bir tematik dala yeniden temelleme.">
</div>
<div class="title">Görsel 40. Tematik bir daldan yeni bir tematik dala yeniden temelleme</div>
</div>
<div class="paragraph">
<p>Artık <code>master</code> dalınızı ileri sarabilirsiniz (bkz. <a href="{{< relurl "book/tr/v2/ch00/rbdiag_g" >}}"><code>master</code> dalını <code>client</code> dalındaki değişiklikleri içerecek şekilde ileri sarmak</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
$ git merge client</code></pre>
</div>
</div>
<div id="rbdiag_g" class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/interesting-rebase-3.png" >}}" alt="`master` dalını `client` dalındaki değişiklikleri içerecek şekilde ileri sarmak.">
</div>
<div class="title">Görsel 41. <code>master</code> dalını <code>client</code> dalındaki değişiklikleri içerecek şekilde ileri sarmak</div>
</div>
<div class="paragraph">
<p>Diyelim ki sunucu dalını da eklemeye karar verdiniz.
<code>git rebase &lt;temel-dalı&gt; &lt;tema-dalı&gt;</code> komutunu çalıştırarak, öncesinde dalınızı değiştirmeden, sunucu dalını <code>master</code> dalına tekrar temelleyebilirsiniz.
Bu komut, ilgili tema dalına (burada <code>server</code>) geçiş yapar ve onu ana dal üzerine (burada <code>master</code>) yeniden temeller.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rebase master server</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu, <a href="{{< relurl "book/tr/v2/ch00/rbdiag_h" >}}"><code>server</code> dalını <code>master</code> dalının üzerine yeniden temelleme</a> diyagramında gösterildiği gibi <code>server</code> çalışmanızı <code>master</code> çalışmanızın üzerine yeniden temeller.</p>
</div>
<div id="rbdiag_h" class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/interesting-rebase-4.png" >}}" alt="`server` dalını `master` dalının üzerine yeniden temelleme.">
</div>
<div class="title">Görsel 42. <code>server</code> dalını <code>master</code> dalının üzerine yeniden temelleme</div>
</div>
<div class="paragraph">
<p>Ardından, ana dalınıza (<code>master</code>) ileri sarabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
$ git merge server</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tüm çalışmalar birleştirildiği için artık <code>client</code> ve <code>server</code> dallarını silebilirsiniz, çünkü bu sürecin tüm geçmişi zaten <a href="{{< relurl "book/tr/v2/ch00/rbdiag_i" >}}">Nihai katkı geçmişi</a> şeklinde görünecektir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch -d client
$ git branch -d server</code></pre>
</div>
</div>
<div id="rbdiag_i" class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/interesting-rebase-5.png" >}}" alt="Nihai katkı geçmişi.">
</div>
<div class="title">Görsel 43. Nihai katkı geçmişi</div>
</div>
</div>
<div class="sect3">
<h3 id="_rebase_peril">Yeniden Temellemenin Riskleri</h3>
<div class="paragraph">
<p>
Yeniden temelleme getirdiği kolaylıkların yanında malesef bazı dezavantajları da içerir.
Bu riskleri tek cümlede özetlemek mümkündür:</p>
</div>
<div class="paragraph">
<p><strong>Repo dışında var olan ve üzerine çalışılmış olabilecek katkıları yeniden temellemeyin.</strong></p>
</div>
<div class="paragraph">
<p>Eğer bu kılavuzu takip ederseniz, sorun yaşamazsınız.
Ama anlatacağımız yönergelere uymazsanız, insanlar sizi sevmeyecek; dostlarınız ve aileniz tarafından hor görüleceksiniz.</p>
</div>
<div class="paragraph">
<p>Birşeyleri yeniden temellediğinizde, mevcut katkıları terk ediyor ve benzer ancak farklı olan yeni katkılar oluşturuyorsunuz.
Eğer katkılarınızı bir yere iterseniz ve başkaları bunları çekip), üzerine çalışma yaparsa, ve daha sonra bu katkıları <code>git rebase</code> ile değiştirip tekrar iterseniz, çalışma arkadaşlarınız kendi çalışmalarını tekrar birleştirmek zorunda kalacak ve onların çalışmalarını kendi projenize çekmeye çalıştığınızda bir karışıklık ortaya çıkacaktır.</p>
</div>
<div class="paragraph">
<p>Herkese açık bir şekilde yayımladığınız çalışmayı yeniden temellemenin nasıl sorunlara yol açabileceğine dair bir örneğe bakalım.
Merkezi bir sunucudan bir repo kopyaladığınızı ve ardından biraz çalışma yaptığınızı düşünelim.
katkı geçmişiniz şu şekilde görünüyor:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/perils-of-rebasing-1.png" >}}" alt="Bir repo kopyala ve üzerine bazı çalışmalar temelle.">
</div>
<div class="title">Görsel 44. Bir repo kopyala ve üzerine bazı çalışmalar temelle</div>
</div>
<div class="paragraph">
<p>Şimdi, başka biri birleştirme içeren bazı çalışmalar yapar ve bu çalışmayı merkezi sunucuya iter.
Siz bunu çeker ve yeni uzak dalı kendi çalışmanıza birleştirirsiniz, geçmişiniz şöyle görünebilir:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/perils-of-rebasing-2.png" >}}" alt="Daha fazla katkı getir ve onları kendi çalışmana birleştir.">
</div>
<div class="title">Görsel 45. Daha fazla katkı getir ve onları kendi çalışmana birleştir</div>
</div>
<div class="paragraph">
<p>Ardından, birleştirilmiş çalışmayı iten kişi, bunun yerine, geriye gidip çalışmaya yeniden temellemeye karar verir.
Bunun için <code>git push --force</code> kullanarak sunucudaki geçmişin üzerine yazar.
Siz de bu sunucudan çekerseniz, yeni katkıları getirirsiniz.</p>
</div>
<div id="_pre_merge_rebase_work" class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/perils-of-rebasing-3.png" >}}" alt="Birisi çalışmanıza temellediğiniz katkıları terkedip, yeniden temellenmiş katkıları iter.">
</div>
<div class="title">Görsel 46. Birisi çalışmanıza temellediğiniz katkıları terkedip, yeniden temellenmiş katkıları iter</div>
</div>
<div class="paragraph">
<p>Şimdi her ikiniz de çıkmazdasınız.
Eğer bir <code>git pull</code> yaparsanız, her iki geçmiş çizgisini de içeren birleştirme katkısı oluşturursunuz ve repo şu şekilde görünecektir:</p>
</div>
<div id="_merge_rebase_work" class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/perils-of-rebasing-4.png" >}}" alt="Aynı çalışmayı tekrar yeni bir birleştirme katkısına dahil edersiniz.">
</div>
<div class="title">Görsel 47. Aynı çalışmayı tekrar yeni bir birleştirme katkısına dahil edersiniz</div>
</div>
<div class="paragraph">
<p>Eğer geçmişiniz bu şekilde göründüğünde bir <code>git log</code> komutu çalıştırırsanız; aynı yazar, tarih ve mesajı taşıyan iki katkı göreceksiniz ki bu da kafa karıştırıcı olacaktır.
Dahası, eğer bu geçmişi tekrar sunucuya iterseniz, tüm bu yeniden temellenmiş katkıları merkezi sunucuya tekrar eklemiş olursunuz ki bu insanların kafasını daha da karıştırabilir.
Diğer geliştiricinin (en başta yeniden temelleme yaptığı için), <code>C4</code> ve <code>C6</code>'nın geçmişte olmasını istemediğini varsayabiliriz.</p>
</div>
</div>
<div class="sect3">
<h3 id="_rebase_rebase">Yeniden Temelleme Yaparken Dikkat Edilmesi Gerekenler</h3>
<div class="paragraph">
<p>Eğer kendinizi böyle bir durumda bulunursanız, Git size yardımcı olabilecek bazı ek özellikler sunar.
Eğer takımınızdaki birisi, yeniden temellediğiniz bir işin üzerine yazan değişiklikleri zorla iterse (force push), karşılaşacağınız gerçek sorun hangi kodun size ait olduğu ve hangisinin üzerine yeniden yazılan olduğunu bulmaktır.</p>
</div>
<div class="paragraph">
<p>Git, katkının SHA-1 sağlamasına ek olarak, yalnızca katkı ile tanıtılan yamaya dayalı bir sağlama da hesaplar.
Buna ``patch-id`` denir.</p>
</div>
<div class="paragraph">
<p>Eğer üzerine yeniden yazılan işi çekerseniz ve bu işi meslektaşınızın yeni katkıları üzerine yeniden temellerseniz; Git genellikle sizin çalışmanızın hangisi olduğunu başarılı bir şekilde bulabilir ve bunları yeni dalın üzerine uygulayabilir.</p>
</div>
<div class="paragraph">
<p>Örneğin, önceki senaryoda, <a href="{{< relurl "book/tr/v2/ch00/_pre_merge_rebase_work" >}}">Birisi çalışmanıza temellediğiniz katkıları terkedip, yeniden temellenmiş katkıları iter</a> noktasındayken birleştirme yerine <code>git rebase teamone/master</code> komutunu çalıştırırsak, Git şunları yapacaktır:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Dalımıza özgü işleri belirle (C2, C3, C4, C6, C7)</p>
</li>
<li>
<p>Hangilerinin birleştirme katkısı olmadığını belirle (C2, C3, C4)</p>
</li>
<li>
<p>Hangilerinin hedef dalda üzerine yeniden yazılmadığını belirle (C4, C4' ile aynı yama olduğu için sadece C2 ve C3)</p>
</li>
<li>
<p>Tüm bu katkıları <code>teamone/master</code>'ın üstüne uygula</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Bu durumda, <a href="{{< relurl "book/tr/v2/ch00/_merge_rebase_work" >}}">Aynı çalışmayı tekrar yeni bir birleştirme katkısına dahil edersiniz</a> görüntüsündeki sonuç yerine, daha ziyade <a href="{{< relurl "book/tr/v2/ch00/_rebase_rebase_work" >}}">Zorla itilmiş yeniden temelleme (force-push rebase) üzerine temelleme</a> benzeri bir sonuç elde ederiz.</p>
</div>
<div id="_rebase_rebase_work" class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/perils-of-rebasing-5.png" >}}" alt="Zorla itilmiş yeniden temelleme üzerine temelleme">
</div>
<div class="title">Görsel 48. Zorla itilmiş yeniden temelleme (force-push rebase) üzerine temelleme</div>
</div>
<div class="paragraph">
<p>Bu sadece meslektaşınızın yaptığı C4 ve C4' katkılarının neredeyse tamamen aynı yama olması durumunda çalışır.
Aksi takdirde, yeniden temelleme bunun bir kopya olduğunu anlayamaz ve başka bir C4 benzeri yama ekler (değişiklikler zaten en azından bir dereceye kadar mevcut olacağı için, bu muhtemelen düzgün bir şekilde uygulanamaz).</p>
</div>
<div class="paragraph">
<p>Bunu normal bir <code>git pull</code> yerine <code>git pull --rebase</code> komutunu çalıştırarak daha da basitleştirebilirsiniz.
Veya bu durumda bir <code>git fetch</code> ve ardından <code>git rebase teamone/master</code> komutu kullanarak manuel olarak da gerçekleştirebilirsiniz.</p>
</div>
<div class="paragraph">
<p>Eğer <code>git pull</code> kullanıyorsanız ve <code>--rebase</code> varsayılan olsun istiyorsanız, <code>git config --global pull.rebase true</code> gibi bir komutla <code>pull.rebase</code> yapılandırmasını ayarlayabilirsiniz.</p>
</div>
<div class="paragraph">
<p>Eğer sadece kendi bilgisayarınızdan hiç ayrılmamış katkıları yeniden temelliyorsanız, sorun yaşamazsınız.
Eğer itilmiş ancak kimsenin bunlardan temellemediği katkıları yeniden temelliyorsanız, yine sorun yaşamazsınız.
Ancak eğer zaten herkese açık bir şekilde itilmiş ve birileri bu katkılardan temelleme yapmışsa, o zaman sıkıntılı bir durumla karşılaşabilir ve takım arkadaşlarınızın tepkisini çekebilirsiniz.</p>
</div>
<div class="paragraph">
<p>Eğer siz veya bir meslektaşınız bunu gerekli görürse, bu sıkıntıyı biraz daha basitleştirmeye çalışmak için, herkesin <code>git pull --rebase</code> komutunu çalıştırmayı bildiğinden emin olun.</p>
</div>
</div>
<div class="sect3">
<h3 id="_yeniden_temelleme_ve_birleştirme">Yeniden Temelleme ve Birleştirme</h3>
<div class="paragraph">
<p>
Yeniden temelleme ve birleştirmeyi öğrendiğinize göre hangisinin daha iyi olduğunu merak ediyor olabilirsiniz.
Bunu yanıtlayabilmek için biraz geriye gitmek ve geçmişin ne anlama geldiğini konuşmak gerekiyor.</p>
</div>
<div class="paragraph">
<p>Bu konudaki bir bakış açısı, repo katkı geçmişinin <strong>aslında nelerin gerçekleştiğinin bir kaydı</strong> olduğudur.
Bu oynanmaması gereken, çok değerli ve tarihi bir belgedir.
Bu açıdan bakıldığında, katkı geçmişini değiştirmek neredeyse şirktir.
Çünkü tarihi tahrif ederek, gerçekte neler olduğu hakkında <em>yalan</em> söylemiş olursunuz.
Yani karışık bir dizi birleştirme katkısı varsa ne olmuş ki?
İşte öyle olduysa bile repo bunu gelecek nesiller için korumalıdır.</p>
</div>
<div class="paragraph">
<p>Karşıt bakış açısı, katkı geçmişinin <strong>projenizin nasıl yapıldığını anlatan bir hikaye</strong> olduğudur.
Bir kitabın ilk taslağını yayımlamazsınız ve yazılımınızı nasıl sürdüreceğiniz konusundaki kılavuz, dikkatli bir düzenlemeyi hak eder.
Bu görüştekiler "yeniden temelleme" ve "dal filtreleme" gibi araçları kullanarak hikayeyi gelecekteki okuyucular için en iyi şekilde anlatan kişilerdir.</p>
</div>
<div class="paragraph">
<p>Şimdi, birleştirmenin mi yoksa yeniden temellemenin mi daha iyi olduğu sorusuna gelince: bunun o kadar da basit bir soru olmadığını anladığınızı ümidediyorum.
Git geçmişinizle ilgili birçok şey yapmanıza izin veren güçlü bir araçtır, ancak her ekip ve her proje de farklıdır.
Her iki işlemin de nasıl çalıştığını bildiğinize göre, hangisinin sizin özel durumunuz için en iyi olduğuna siz karar vereceksiniz.</p>
</div>
<div class="paragraph">
<p>Genel olarak, her iki yaklaşımdan da en iyi şekilde faydalanmanın yolu, henüz paylaşmadığınız yerel değişiklikleri itmeden önce yeniden temelleme yaparak geçmişi temizlemektir, ancak herhangi bir sunucuya ittiğiniz bir şeyi asla yeniden temelleme yapmamaktır.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>