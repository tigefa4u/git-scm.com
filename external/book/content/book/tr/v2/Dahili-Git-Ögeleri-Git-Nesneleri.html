---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: tr
  chapter:
    title: Dahili Git Ögeleri
    number: 10
  section:
    title: Git Nesneleri
    number: 2
    cs_number: '10.2'
    previous: book/tr/v2/Dahili-Git-Ögeleri-Tesisat-ve-Döşeme-Plumbing-ve-Porcelain
    next: book/tr/v2/Dahili-Git-Ögeleri-Git-Referansları
title: Git - Git Nesneleri
url: "/book/tr/v2/Dahili-Git-Ögeleri-Git-Nesneleri.html"
---
<h2 id="_objects">Git Nesneleri</h2>
<div class="paragraph">
<p>Git, içeriğe dayalı bir dosya sistemidir.
İyi, güzel de bu ne anlama geliyor?
Bu, Git’in temelinde basit bir anahtar-değer veri reposunun bulunduğu anlamına gelir.
Bu ise Git reposuna her türlü içeriği ekleyebileceğiniz ve Git’in size daha sonra bu içeriği almak için kullanabileceğiniz benzersiz bir anahtar vereceği anlamına gelir.</p>
</div>
<div class="paragraph">
<p>Görselleştirmek adına: bir veri alıp, onu <code>.git/objects</code> dizinine (nesne veritabanı) saklayacak ve bu veri nesnesine işaret eden benzersiz anahtarı size geri verecek olan <code>git hash-object</code> tesisat komutuna bir bakalım.</p>
</div>
<div class="paragraph">
<p>Öncelikle, yeni bir Git reposu başlatın ve (tahmin edilebilir bir şekilde) <code>objects</code> dizininde hiçbir şey olmadığından emin olun:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git init test
Initialized empty Git repository in /tmp/test/.git/
$ cd test
$ find .git/objects
.git/objects
.git/objects/info
.git/objects/pack
$ find .git/objects -type f</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git <code>objects</code> dizinini başlattı ve içinde <code>pack</code> ve <code>info</code> alt dizinlerini oluşturdu, ancak henüz düzenli dosyalar bulunmamaktadır.
Şimdi, <code>git hash-object</code> kullanarak yeni bir veri nesnesi oluşturun ve bu nesneyi yeni Git veritabanınıza manuel olarak kaydedin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 'test content' | git hash-object -w --stdin
d670460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre>
</div>
</div>
<div class="paragraph">
<p>En basit haliyle <code>git hash-object</code>, verdiğiniz içeriği alır ve bu içeriği Git veritabanınızda depolamak için kullanılacak benzersiz anahtarı size verir.
<code>-w</code> seçeneği komuta yalnızca anahtarı döndürmek yerine bu nesneyi veritabanına yazmasını söyler.
Son olarak <code>--stdin</code> seçeneği ,<code>git hash-object</code> 'in işlenecek içeriği stdin’den almasını sağlar; aksi takdirde komut, kullanılacak içeriği içeren komutun sonundaki bir dosya adı argümanı beklerdi.</p>
</div>
<div class="paragraph">
<p>Yukarıdaki komutun çıktısı 40 karakterlik bir kontrol toplamı özeti olacaktır.
Bu SHA-1 özeti, birazdan öğreneceğiniz üzere, depoladığınız içeriğin bir başlık ile birlikte kontrol toplamıdır.
Şimdi Git’in verilerinizi nasıl sakladığını görebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ find .git/objects -type f
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Yeniden <code>objects</code> dizinini inceleyerseniz, artık bu yeni içerik için bir dosya içerdiğini görebilirsiniz.
Git, içeriği başlangıçta bu şekilde depolar; içeriğin SHA-1 sağlama toplamı ve başlığıyla adlandırılan, içerik parçası başına tek bir dosya olarak.
Alt dizin, SHA-1’in ilk 2 karakteriyle adlandırılır ve dosya adı kalan 38 karakterdir.</p>
</div>
<div class="paragraph">
<p>Nesne veritabanınızda içerik olduğunda, bu içeriği <code>git cat-file</code> komutu ile inceleyebilirsiniz.
Bu komut, Git nesnelerini incelemek için bir tür İsviçre çakısı gibidir.
<code>cat-file</code> komutuna <code>-p</code> geçirmek, komutun önce içeriğin türünü belirlemesini ve ardından uygun şekilde görüntülemesini sağlar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
test content</code></pre>
</div>
</div>
<div class="paragraph">
<p>Şimdi, içerik ekleyebilir ve tekrar çıkarabilirsiniz.
Bu işlemi dosyalardaki içerikle de yapabilirsiniz.
Örneğin, bir dosyada basit bir sürüm kontrolü yapabilirsiniz.
İlk olarak, yeni bir dosya oluşturun ve içeriğini veritabanınıza kaydedin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 'version 1' &gt; test.txt
$ git hash-object -w test.txt
83baae61804e65cc73a7201a7252750c76066a30</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sonra, dosyaya yeni bir içerik yazın ve yeniden kaydedin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 'version 2' &gt; test.txt
$ git hash-object -w test.txt
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</code></pre>
</div>
</div>
<div class="paragraph">
<p>Artık nesne veritabanınız bu yeni dosyanın her iki sürümünü de içeriyor (oraya kaydettiğiniz ilk içeriği de):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ find .git/objects -type f
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Şimde, <code>test.txt</code> dosyasının yerel kopyasını silebilir ve ardından Git’i kullanarak, nesne veritabanından oraya kaydettiğiniz ilk sürümü geri alabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 &gt; test.txt
$ cat test.txt
version 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>ya da ikinci sürümü:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a &gt; test.txt
$ cat test.txt
version 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ancak dosyanın her sürümü için SHA-1 anahtarını hatırlamak pratik değildir; ek olarak, sisteminizde dosya adını değil, yalnızca içeriği saklıyorsunuz.
Bu nesne türüne <em>blob</em> denir.
Herhangi bir nesnenin Git’teki SHA-1 anahtarını verildiğinde, <code>git cat-file -t</code> komutuyla Git’ten size bu nesnenin türünü söylemesini isteyebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
blob</code></pre>
</div>
</div>
<div class="sect3">
<h3 id="_tree_objects">Ağaç (tree) Nesneleri</h3>
<div class="paragraph">
<p>İnceleyeceğimiz sıradaki Git nesne türü sadece dosya adını saklama sorununu çözmekle kalmayıp, aynı zamanda bir grup dosyayı bir arada saklamanıza izin veren <em>tree</em>'dir (ağaç).
Git içeriği UNIX dosya sistemi gibi bir şekilde saklar, ancak biraz daha basitleştirilmiştir.
Tüm içerikler ağaç ve blob (damla) nesneleri olarak saklanır, ağaçlar UNIX dizin girişlerine, bloblar ise aşağı yukarı inode’lara veya dosya içeriklerine karşılık gelir. Tek bir ağaç nesnesi, her biri bir blob veya alt ağacın SHA-1 özeti olan ve ilişkili mod, tür ve dosya adı olan bir veya daha fazla girişi içerir.
Örneğin, bir projedeki en son ağaç şöyle görünebilir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -p master^{tree}
100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README
100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile
040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>master^{tree}</code> sözdizimi, <code>master</code> dalındaki son katkının işaret ettiği ağaç nesnesini belirtir.
<code>lib</code> alt dizininin bir blob olmadığını, ancak başka bir ağaca işaret ettiğini fark edin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0
100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Not</div>
</td>
<td class="content">
<div class="paragraph">
<p>Hangi shell kullandığınıza bağlı olarak, <code>master^{tree}</code> sözdizimini kullanırken hatalarla karşılaşabilirsiniz.</p>
</div>
<div class="paragraph">
<p>Windows’taki CMD’de, <code>^</code> kaçınma karakteri olarak kullanıldığından, bundan sakınmak için iki kez kullanmalısınız: <code>git cat-file -p master^^{tree}</code>.
PowerShell kullanırken, {} karakterlerini içeren parametrelerin, parametrenin yanlış ayrıştırılmasını önlemek için alıntılanması gerekir: <code>git cat-file -p 'master^{tree}'</code>.</p>
</div>
<div class="paragraph">
<p>Eğer ZSH kullanıyorsanız, <code>^</code> karakteri globbing için kullanıldığı için tüm ifadeyi tırnak içine almanız gerekir: <code>git cat-file -p "master^{tree}"</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Kavramsal olarak Git’in depoladığı veriler şuna benzer:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/data-model-1.png" >}}" alt="Git veri modelinin basit versiyonu.">
</div>
<div class="title">Görsel 148. Git veri modelinin basit versiyonu.</div>
</div>
<div class="paragraph">
<p>Kendi ağacınızı oldukça kolay bir şekilde oluşturabilirsiniz.
Git normalde izlem alanınızın veya indeksinizin durumunu alarak ve bir dizi ağaç nesnesi yazarak bir ağaç oluşturur.
Dolayısıyla, bir ağaç nesnesi oluşturmak için önce bazı dosyaları izlem alanına almanız gerekir.
Tek girişli bir dizin (<code>test.txt</code> dosyanızın ilk sürümü) oluşturmak için tesisat komutu <code>git update-index</code> kullanabilirsiniz.
Bu komutu daha önceki <code>test.txt</code> dosyasının önceki sürümünü, yapay olarak yeni bir izlem alanına eklemek için kullanırsınız.
Dosya henüz izlem alanınızda bulunmadığından (<code>test.txt</code> dosyanızın henüz bir izlem alanı dahi yoktur) <code>--add</code> seçeneğini ve eklediğiniz dosya dizininizde değil de veritabanınızda olduğundan <code>--cacheinfo</code> seçeneğini geçirmeniz gerekir.
Ardından da modu, SHA-1’i ve dosya adını belirtirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git update-index --add --cacheinfo 100644 \
  83baae61804e65cc73a7201a7252750c76066a30 test.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu durumda, <code>100644</code> modunu belirtiyorsunuz, bu da normal bir dosya olduğunu gösterir.
Diğer seçenekler arasında, yürütülebilir bir dosya olduğunu gösteren <code>100755</code>; ve sembolik bir bağlantıyı belirten <code>120000</code> bulunmaktadır.
Modlar normal UNIX modlarından alınmıştır ancak çok daha esnektir: bu üç mod, Git’teki dosyalar (bloblar) için geçerli olan tek modlardır (ancak dizinler ve alt modüller için başka modlar kullanılır).</p>
</div>
<div class="paragraph">
<p>Şimdi, izlem alanını bir ağaç nesnesine yazmak için <code>git write-tree</code> kullanabilirsiniz.
Eğer bu ağaç henüz mevcut değilse, bu komutu çağırmak için <code>-w</code> seçeneğine gerek yoktur. Bu komut indeksin durumundan otomatik olarak bir ağaç nesnesi oluşturur:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git write-tree
d8329fc1cc938780ffdd9f94e0d364e0ea74f579
$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579
100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>Yukarıda gördüğünüz aynı <code>git cat-file</code> komutunu kullanarak bunun bir ağaç nesnesi olduğunu da doğrulayabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579
tree</code></pre>
</div>
</div>
<div class="paragraph">
<p>Şimdi, <code>test.txt</code>'nin ikinci sürümü ve yeni bir dosya ile yeni bir ağaç oluşturacaksınız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 'new file' &gt; new.txt
$ git update-index --add --cacheinfo 100644 \
  1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt
$ git update-index --add new.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>İzlem alanınız artık <code>test.txt</code> 'nin yeni sürümüne ve <code>new.txt</code> adlı yeni bir dosyaya sahip.
Bu ağacı yazın (izlem alanının durumunu veya dizinini bir ağaç nesnesine kaydederek) ve nasıl göründüğüne bakın:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git write-tree
0155eb4229851634a0f03eb265b69f5a2d56f341
$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bu ağaçta hem dosya girişleri bulunduğunu hem de <code>test.txt</code> SHA-1’inin daha önceki "versiyon 2" SHA-1 olduğuna dikkat edin (<code>1f7a7a</code>).
Sırf eğlencesine, ilk ağacı bu ağacın bir alt dizini olarak ekleyeceksiniz.
<code>git read-tree</code> çağırarak ağaçları izlem alanınıza okutabilirsiniz.
Bu durumda, bu komutla <code>--prefix</code> seçeneğini kullanarak mevcut bir ağacı izlem alanınıza bir alt ağaç olarak okutabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579
$ git write-tree
3c4e9cd789d88d8d89c1073707c3585e41b0e614
$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614
040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>Eğer yazdığınız yeni ağaçtan bir çalışma dizini oluşturursanız, üst düzeydeki iki dosyayı ve <code>bak</code> adında bir alt dizini alırsınız ve bu alt dizin, <code>test.txt</code> dosyasının ilk sürümünü içerir.
Git’in bu yapılar için içerdiği veriyi şöyle düşünebilirsiniz:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/data-model-2.png" >}}" alt="Mevcut Git verilerinizin içerik yapısı.">
</div>
<div class="title">Görsel 149. Mevcut Git verilerinizin içerik yapısı.</div>
</div>
</div>
<div class="sect3">
<h3 id="_git_commit_objects">katkı Nesnesi</h3>
<div class="paragraph">
<p>Yukarıdakilerin hepsini yaptıysanız, şimdi takip etmek istediğiniz proje pozlarını temsil eden üç ağacınız var, ancak daha önceki sorun hala mevcut: pozları hatırlamak için üç SHA-1 değerini de hatırlamanız gerekir.
Ayrıca, pozları kimin, ne zaman ve neden kaydettiği hakkında hiçbir bilginiz yok.
Bu, katkı nesnesinin sizin için sakladığı temel bilgidir.</p>
</div>
<div class="paragraph">
<p>Bir katkı nesnesi oluşturmak için <code>commit-tree</code> çağırırsınız, ardından tek bir ağaç SHA-1’i ve varsa hangi katkı nesnelerinin doğrudan ondan önce geldiğini belirtirsiniz.
İlk yazdığınız ağaçla başlayın:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 'first commit' | git commit-tree d8329f
fdf4fc3344e67ab068f836878b6c4951e3b15f3d</code></pre>
</div>
</div>
<div class="paragraph">
<p>Farklı oluşturma zamanı ve yazar verisi bulunduğundan farklı bir karmaya sahip olacaksınız.
Bu bölümdeki diğer yerlerde, kendi kontrol toplamalarınızla katkı ve etiket karma değerlerini değiştirin.
Şimdi yeni katkı nesnenizi <code>git cat-file</code> ile inceleyebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -p fdf4fc3
tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579
author Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700
committer Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700

first commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bir katkı nesnesinin formatı basittir: o anki projenin pozu için en üst düzey ağacı belirtir; varsa üst katkılar (yukarıdaki katkı nesnesinin herhangi bir üstü yoktur); yazar/katkılayan bilgisi (ki bu, <code>user.name</code> ve <code>user.email</code> yapılandırma ayarlarınızı ve bir zaman damgasını kullanır); bir boş satır ve ardından katkı mesajı.</p>
</div>
<div class="paragraph">
<p>Sonraki adımda, her biri doğrudan önündeki katkıyı referans alan iki katkı nesnesini yazacaksınız:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 'second commit' | git commit-tree 0155eb -p fdf4fc3
cac0cab538b970a37ea1e769cbbde608743bc96d
$ echo 'third commit'  | git commit-tree 3c4e9c -p cac0cab
1a410efbd13591db07496601ebc7a059dd55cfe9</code></pre>
</div>
</div>
<div class="paragraph">
<p>Her üç katkı nesnesi de oluşturduğunuz üç poz ağacından birine işaret eder.
İlginç bir şekilde, şimdi gerçek bir Git geçmişiniz var ve bunu son katkı SHA-1’i üzerinde çalıştırarak <code>git log</code> komutu ile görebilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --stat 1a410e
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:15:24 2009 -0700

	third commit

 bak/test.txt | 1 +
 1 file changed, 1 insertion(+)

commit cac0cab538b970a37ea1e769cbbde608743bc96d
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:14:29 2009 -0700

	second commit

 new.txt  | 1 +
 test.txt | 2 +-
 2 files changed, 2 insertions(+), 1 deletion(-)

commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:09:34 2009 -0700

    first commit

 test.txt | 1 +
 1 file changed, 1 insertion(+)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Harika.
Sadece arayüz komutlarını kullanmadan bir Git geçmişini oluşturmak için düşük seviyeli işlemleri gerçekleştirdiniz.
Bu, aslında <code>git add</code> ve <code>git commit</code> komutlarını çalıştırdığınızda Git’in yaptığı şeydir (değişen dosyalar için bloblar saklar, indeksi günceller, ağaçları yazarak ve önceki katkıları referans alan katkı nesneleri yazarak üst düzey ağaçları ve onlardan hemen önce gelen katkıları referanslar).
Bu üç ana Git nesnesi - blob, ağaç ve katkı - başlangıçta <code>.git/objects</code> dizininizde ayrı dosyalar olarak saklanır.
İşte örnek dizindeki tüm nesneler, sakladıkları verilere açıklama eklenmiş şekilde:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ find .git/objects -type f
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tüm içsel işaretçileri takip ederseniz, yaklaşık şunun gibi bir nesne grafiği elde edersiniz:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/tr/v2/images/data-model-3.png" >}}" alt="Git dizininizdeki ulaşılabilir tüm nesneler.">
</div>
<div class="title">Görsel 150. Git dizininizdeki ulaşılabilir tüm nesneler.</div>
</div>
</div>
<div class="sect3">
<h3 id="_nesne_depolama">Nesne Depolama</h3>
<div class="paragraph">
<p>Önceki bölümde, Git nesne veritabanınıza her katkıladığınız nesneyle bir başlık depolandığını belirttik.
Git’in nesnelerini nasıl sakladığına bir göz atalım.
Bir blob nesnesini (bu durumda, "what is up, doc?" dizesi) etkileşimli olarak Ruby betik dili içinde nasıl saklayacağınızı göreceksiniz.</p>
</div>
<div class="paragraph">
<p>Etkileşimli Ruby modunu <code>irb</code> komutu ile başlatabilirsiniz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ irb
&gt;&gt; content = "what is up, doc?"
=&gt; "what is up, doc?"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git öncelikle bir başlık oluşturur, bu başlık nesnenin türünü belirleyen kısmı içerir (burada bir blob).
Bu başlık kısmına, Git içeriğin bayt cinsinden boyutunu belirten bir boşluk ekler ve son olarak bir null (geçersiz) baytı ekler:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">&gt;&gt; header = "blob #{content.length}\0"
=&gt; "blob 16\u0000"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git başlık ve orijinal içeriği birleştirir ve ardından bu yeni içeriğin SHA-1 karmasını hesaplar.
Ruby’de bir dizenin SHA-1 değerini hesaplayabilirsiniz, bunun için SHA1 digest kütüphanesini <code>require</code> komutu ile içe aktarmanız ve ardından <code>Digest::SHA1.hexdigest()</code> ile dizeyi kullanmanız gerekir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">&gt;&gt; store = header + content
=&gt; "blob 16\u0000what is up, doc?"
&gt;&gt; require 'digest/sha1'
=&gt; true
&gt;&gt; sha1 = Digest::SHA1.hexdigest(store)
=&gt; "bd9dbf5aae1a3862dd1526723246b20206e5fc37"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hadi bunu <code>git hash-object</code> çıktısı ile karşılaştıralım.
Burada <code>echo -n</code> kullanarak girişe yeni bir satır eklenmesini önleyeceğiz.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo -n "what is up, doc?" | git hash-object --stdin
bd9dbf5aae1a3862dd1526723246b20206e5fc37</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git yeni içeriği zlib ile sıkıştırır, bu işlemi Ruby’de zlib kütüphanesi ile yapabilirsiniz.
İlk olarak, kütüphaneyi içe aktarmanız ve ardından içeriği <code>Zlib::Deflate.deflate()</code> üzerinde çalıştırmanız gerekir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">&gt;&gt; require 'zlib'
=&gt; true
&gt;&gt; zlib_content = Zlib::Deflate.deflate(store)
=&gt; "x\x9CK\xCA\xC9OR04c(\xCFH,Q\xC8,V(-\xD0QH\xC9O\xB6\a\x00_\x1C\a\x9D"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Son olarak, zlib ile sıkıştırılmış içeriğinizi diske bir nesne olarak yazacaksınız.
Yazmak istediğiniz nesnenin yolunu belirleyeceksiniz (SHA-1 değerinin ilk iki karakteri alt dizin adı olacak ve son 38 karakter ise o dizin içindeki dosya adı olacak).
Eğer mevcut değilse, <code>FileUtils.mkdir_p()</code> işlevini kullanarak Ruby’de alt dizini oluşturabilirsiniz.
Ardından, <code>File.open()</code> ile dosyayı açın ve elde edilen dosya tanesi üzerinde <code>write()</code> çağrısı ile önceden zlib ile sıkıştırılmış içeriği dosyaya yazın:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">&gt;&gt; path = '.git/objects/' + sha1[0,2] + '/' + sha1[2,38]
=&gt; ".git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37"
&gt;&gt; require 'fileutils'
=&gt; true
&gt;&gt; FileUtils.mkdir_p(File.dirname(path))
=&gt; ".git/objects/bd"
&gt;&gt; File.open(path, 'w') { |f| f.write zlib_content }
=&gt; 32</code></pre>
</div>
</div>
<div class="paragraph">
<p>Gelin, <code>git cat-file</code> kullanarak nesnenin içeriğini kontrol edelim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">---
$ git cat-file -p bd9dbf5aae1a3862dd1526723246b20206e5fc37
what is up, doc?
---</code></pre>
</div>
</div>
<div class="paragraph">
<p>İşte bu kadar! Geçerli bir Git blob nesnesi oluşturdunuz.</p>
</div>
<div class="paragraph">
<p>Tüm Git nesneleri farklı türlerle olsa dahi (başlık blob dizesi yerine, katkı veya ağaç ile başlayacaktır) aynı şekilde depolanır.
Ayrıca, blob içeriği neredeyse her şey olabilirken, katkı ve ağaç içeriği çok belirli bir formata sahiptir.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>