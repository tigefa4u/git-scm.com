---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: de
  chapter:
    title: Verteiltes Git
    number: 5
  section:
    title: An einem Projekt mitwirken
    number: 2
    cs_number: '5.2'
    previous: book/de/v2/Verteiltes-Git-Verteilter-Arbeitsablauf
    next: book/de/v2/Verteiltes-Git-Ein-Projekt-verwalten
title: Git - An einem Projekt mitwirken
---
<h2 id="_contributing_project">An einem Projekt mitwirken</h2>
<div class="paragraph">
<p>
Die größte Schwierigkeit bei der Beschreibung, wie man an einem Projekt mitwirkt, sind die zahlreichen Varianten, wie man das tun könnte.
Da Git sehr flexibel ist, können die Beteiligten auf viele Arten zusammenarbeiten. Es ist nicht einfach zu beschreiben, wie du dazu beitragen solltest, da jedes Projekt ein wenig anders ist.
Einige der wichtigen Unbekannten sind die Anzahl der aktiven Mitwirkenden, der ausgewählte Arbeitsablauf, deine Zugriffsberechtigung und möglicherweise auch die Methode, wie externe Beiträge verwaltet werden sollen.</p>
</div>
<div class="paragraph">
<p>Die erste Unbekannte ist die Anzahl der aktiven Mitwirkenden – wie viele Benutzer tragen aktiv Quelltext zu diesem Projekt bei und wie oft?
In vielen Fällen hast du zwei oder drei Entwickler mit ein paar Commits pro Tag oder möglicherweise weniger für etwas schlummernde Projekte.
Bei größeren Unternehmen oder Projekten kann die Anzahl der Entwickler in die Tausende gehen, wobei jeden Tag Hunderte oder Tausende von Commits getätigt werden können.
Das ist deshalb von Bedeutung, da du mit einer wachsenden Anzahl von Entwicklern auch sicherstellen musst, dass sich der Code problemlos anwenden lässt und leicht zusammengeführt werden kann.
Von dir übermittelte Änderungen können durch Arbeiten, die während deiner Arbeit oder während deiner Änderungen genehmigt oder eingearbeitet wurden, veraltet sein oder nicht mehr funktionieren.
Wie kannst du deinen Quelltext konsistent auf dem neuesten Stand halten und dafür sorgen, dass deine Commits gültig sind?</p>
</div>
<div class="paragraph">
<p>Die nächste Unbekannte ist der für das Projekt verwendete Arbeitsablauf.
Ist er zentralisiert, wobei jeder Entwickler den gleichen Schreibzugriff auf die Hauptentwicklungslinie hat?
Verfügt das Projekt über einen Betreuer oder Integrationsmanager, der alle Patches überprüft?
Sind alle Patches von Fachleuten geprüft und genehmigt?
Bist du selbst in diesen Prozess involviert?
Ist ein Leutnant System vorhanden und musst du deine Arbeit zuerst bei diesen einreichen?</p>
</div>
<div class="paragraph">
<p>Die nächste Unbekannte ist deine Zugriffsberechtigung.
Der erforderliche Arbeitsablauf, um zu einem Projekt beizutragen, unterscheidet sich erheblich, wenn du Schreibzugriff auf das Projekt hast, als wenn du diesen nicht hast.
Wenn du keinen Schreibzugriff hast, in welcher Reihenfolge erfolgt die Annahme von beigetragener Arbeit?
Gibt es überhaupt eine Richtlinie?
Wie umfangreich sind die Änderungen, die du jeweils beisteuerst?
Wie oft trägst du etwas bei?</p>
</div>
<div class="paragraph">
<p>All diese Fragen können sich darauf auswirken, wie du effektiv zu einem Projekt beitragen und welche Arbeitsabläufe bevorzugt oder überhaupt für sie verfügbar sind.
Wir werden jeden dieser Aspekte in einer Reihe von Anwendungsfällen behandeln, wobei wir mit simplen Beispielen anfangen und später komplexere Szenarios besprechen. Du solltest in der Lage sein, anhand dieser Beispiele die spezifischen Arbeitsabläufe zu erstellen, die du in der Praxis benötigst.</p>
</div>
<div class="sect3">
<h3 id="_commit_guidelines">Richtlinien zur Zusammenführung (engl. Commits)</h3>
<div class="paragraph">
<p>Bevor wir uns mit den spezifischen Anwendungsfällen befassen, findest du hier einen kurzen Hinweis zu Commit-Nachrichten.
Ein guter Leitfaden zum Erstellen von Commits und das Befolgen desselben, erleichtert die Arbeit mit Git und die Zusammenarbeit mit anderen erheblich.
Das Git-Projekt selber enthält ein Dokument, in dem einige nützliche Tipps zum Erstellen von Commits für die Übermittlung von Patches aufgeführt sind. Du findest diese Tipps im Git-Quellcode in der Datei <code>Documentation/SubmittingPatches</code>.</p>
</div>
<div class="paragraph">
<p>
Deine Einsendungen sollten keine Leerzeichenfehler enthalten.
Git bietet eine einfache Möglichkeit, dies zu überprüfen. Führe vor dem Commit <code>git diff --check</code> aus, um mögliche Leerzeichenfehler zu identifizieren und diese aufzulisten.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/git-diff-check.png" >}}" alt="Ausgabe von `git diff --check`">
</div>
<div class="title">Abbildung 56. Ausgabe von <code>git diff --check</code>
</div>
</div>
<div class="paragraph">
<p>Wenn du diesen Befehl vor einem Commit ausführst, kannst du feststellen, ob Leerzeichen Probleme auftreten, die andere Entwickler stören könnten.</p>
</div>
<div class="paragraph">
<p>Als Nächstes, versuchst du, aus jedem Commit einen logisch getrennten Satz von Änderungen zu machen.
Versuche deine Änderungen leicht verständlich zu machen. Arbeiten nicht ein ganzes Wochenende an fünf verschiedenen Features und übermittel all diese Änderungen in einem massiven Commit am Montag.
Auch wenn du am Wochenende keine Commits durchführst, nutze am Montag die Staging-Area, um deine Änderungen aufzuteilen in wenigstens einen Commit für jeden Teilaspekt mit jeweils einer sinnvollen Nachricht.
Wenn einige der Änderungen dieselbe Datei modifizieren, benutze die Anweisung <code>git add --patch</code>, um Dateien partiell zur Staging-Area hinzuzufügen (detailliert dargestellt im Abschnitt <a href="{{< relurl "book/de/v2/ch00/_interactive_staging" >}}">Interaktives Stagen</a>).
Der Schnappschuss vom Projekt am Ende des Branches ist der Selbe, ob du einen oder fünf Commits durchgeführt hast, solange nur all die Änderungen irgendwann hinzugefügt werden. Versuche also, die Dinge für deine Entwicklerkollegen zu vereinfachen, die deine Änderungen begutachten müssen.</p>
</div>
<div class="paragraph">
<p>Dieser Ansatz macht es außerdem einfacher, einen Satz von Änderungen zu entfernen oder rückgängig zu machen, falls das später nötig sein sollte.
<a href="{{< relurl "book/de/v2/ch00/_rewriting_history" >}}">Den Verlauf umschreiben</a> beschreibt eine Reihe nützlicher Git-Tricks zum Umschreiben des Verlaufs oder um interaktiv Dateien zur Staging-Area hinzuzufügen. Verwende diese Werkzeuge, um einen sauberen und leicht verständlichen Verlauf aufzubauen, bevor du deine Arbeit jemand anderem schickst.</p>
</div>
<div class="paragraph">
<p>Als letztes darf die Commit-Nachricht nicht vergessen werden.
Macht man es sich zur Gewohnheit, qualitativ hochwertige Commit-Nachrichten zu erstellen, erleichtert dies die Verwendung und die Zusammenarbeit mit Git erheblich.
In der Regel sollte deine Nachrichten mit einer einzelnen Zeile beginnen, die nicht länger als 50 Zeichen ist. Diese sollte deine Änderungen kurz und bündig beschreiben. Darauf folgen eine leere Zeile und eine ausführliche Erläuterung.
Für das Git-Projekt ist es erforderlich, dass die ausführliche Erläuterung deine Motivation für die Änderung enthält. Außerdem sollte das Ergebnis deiner Implementierung mit dem vorherigen Verhalten des Projekts gegenüber gestellt werden. Dies ist eine gute Richtlinie, an die man sich halten sollte.
Es empfiehlt sich außerdem, die Gegenwartsform des Imperativs in diesen Nachrichten zu benutzen. Mit anderen Worten, verwende Anweisungen. Anstatt „Ich habe Test hinzugefügt für“ oder „Tests hinzufügend für“ benutze „Füge Tests hinzu für“.
Hier ist eine Vorlage, die du nutzen kannst. Wir haben sie leicht angepasst. Das Original findest du hier: <a href="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html" target="_blank" rel="noopener">E-Mail-Vorlage, die ursprünglich von Tim Pope geschrieben wurde</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">Kurzfassung der Änderung (50 Zeichen oder weniger)

Gegebenenfalls ausführlicher, erläuternder Text. Pro Zeile etwa 72
Zeichen. In einigen Kontexten wird die erste Zeile wie der Betreff einer
E-Mail gehandelt und der Rest des Textes als Textkörper. Die Leerzeile,
welche die Zusammenfassung vom Text trennt ist von entscheidender Bedeutung
(es sei denn, du lässt den Textkörper ganz weg). Werkzeuge wie rebase
können Fehler machen, wenn du diese Leerzeile nicht einhältst.

Schreiben deine Commit Nachrichten im Imperativ: "Fix bug" und nicht
"Fixed bug" oder "Fixes bug". Diese Konvention stimmt mit Commit-Nachrichten
überein, die von Befehlen wie git merge und git revert generiert werden.

Weitere Absätze folgen nach Leerzeilen.

- Aufzählungszeichen sind auch in Ordnung

- In der Regel wird für das Aufzählungszeichen ein Bindestrich oder ein Sternchen verwendet, gefolgt von einem Leerzeichen.
  Zwischen den einzelnen Aufzählungen werden Leerzeilen eingefügt. Diese Konventionen variieren jedoch.

      Verwende einen hängenden Einzug</code></pre>
</div>
</div>
<div class="paragraph">
<p>Wenn alle deine Commit-Nachrichten diesem Modell folgen, wird es für dich und die Entwickler, mit denen du zusammenarbeitest, viel einfacher sein.
Das Git-Projekt selber enthält gut formatierte Commit-Nachrichten. Versuche, <code>git log --no-merges</code> auszuführen, um zu sehen, wie ein gut formatierter Commit-Verlauf des Projekts aussieht.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Anmerkung</div>
</td>
<td class="content">
<div class="title">Tue das, was wir sagen und nicht das, was wir tun.</div>
<div class="paragraph">
<p>Der Kürze halber haben viele der Beispiele in diesem Buch keine gut formatierten Commit-Nachrichten. Stattdessen verwenden wir einfach die Option <code>-m</code>, um <code>git commit</code> auszuführen.</p>
</div>
<div class="paragraph">
<p>Kurz gesagt, tue es wie wir es sagen und nicht wie wir es tun.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h3 id="_private_team">Kleines, privates Team</h3>
<div class="paragraph">
<p>
Das einfachste Setup, auf das du wahrscheinlich stoßen wirst, ist ein privates Projekt mit einem oder zwei anderen Entwicklern.
Privat bedeutet in diesem Zusammenhang „closed source“ – es ist für die Außenwelt nicht öffentlich zugänglich.
Du und die anderen Entwickler haben alle Schreibzugriff (Push-Zugriff) auf das Repository.</p>
</div>
<div class="paragraph">
<p>In dieser Umgebung kannst du einem Arbeitsablauf folgen, der dem ähnelt, den du mit Subversion oder einem anderen zentralisierten System ausführen würdest.
Du hast immer noch die Vorteile von Dingen wie Offline-Commit und ein wesentlich einfacheres Verzweigungs- (engl.branching) und Zusammenführungsmodel (engl. merging), aber der Arbeitsablauf kann sehr ähnlich sein. Hauptunterschied ist, dass das Zusammenführen eher auf der Client-Seite stattfindet als auf dem Server beim Durchführen eines Commits.
Mal sehen, wie es aussehen könnte, wenn zwei Entwickler beginnen, mit einem gemeinsam genutzten Repository zusammenzuarbeiten.
Der erste Entwickler, John, klont das Repository, nimmt eine Änderung vor und commitet es lokal.
Die Protokollnachrichten wurden in diesen Beispielen durch <code>…​</code> ersetzt, um sie etwas zu verkürzen.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console"># John's Machine
$ git clone john@githost:simplegit.git
Cloning into 'simplegit'...
...
$ cd simplegit/
$ vim lib/simplegit.rb
$ git commit -am 'Remove invalid default value'
[master 738ee87] Remove invalid default value
 1 files changed, 1 insertions(+), 1 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Die zweite Entwicklerin, Jessica, tut dasselbe — sie klont das Repository, ändert etwas und führt einen Commit durch.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console"># Jessica's Machine
$ git clone jessica@githost:simplegit.git
Cloning into 'simplegit'...
...
$ cd simplegit/
$ vim TODO
$ git commit -am 'Add reset task'
[master fbff5bc] Add reset task
 1 files changed, 1 insertions(+), 0 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nun lädt Jessica ihre Änderungen auf den Server hoch. Das funktioniert problemlos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console"># Jessica's Machine
$ git push origin master
...
To jessica@githost:simplegit.git
   1edee6b..fbff5bc  master -&gt; master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Die letzte Zeile der obigen Ausgabe zeigt eine nützliche Rückmeldung der Push Operation.
Das Grundformat ist <code>&lt;oldref&gt; .. &lt;newref&gt; fromref → toref</code>, wobei <code>oldref</code> die alte Referenz bedeutet, <code>newref</code> die neue Referenz bedeutet, <code>fromref</code> der Name der lokalen Referenz ist, die übertragen wird, und <code>toref</code> ist der Name der entfernten Referenz, die aktualisiert werden soll.
Eine ähnliche Ausgabe findst du weiter unten in den Diskussionen. Wenn du also ein grundlegendes Verständnis der Bedeutung dieser Angaben hast, dann kannst du die verschiedenen Zustände der Repositorys besser verstehen.
Weitere Informationen dazu findest du in der Dokumentation für <a href="https://git-scm.com/docs/git-push" target="_blank" rel="noopener">git-push</a>.</p>
</div>
<div class="paragraph">
<p>Wenn wir mit diesem Beispiel fortfahren, nimmt John einige Änderungen vor, schreibt sie in sein lokales Repository und versucht, sie auf den gleichen Server zu übertragen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console"># John's Machine
$ git push origin master
To john@githost:simplegit.git
 ! [rejected]        master -&gt; master (non-fast forward)
error: failed to push some refs to 'john@githost:simplegit.git'</code></pre>
</div>
</div>
<div class="paragraph">
<p>John ist es nicht gestattet, seine Änderungen hochzuladen, weil Jessica vorher <em>ihre</em> hochgeladen hat.
Dies ist wichtig zu verstehen, wenn du an Subversion gewöhnt bist. Wie du sicherlich bemerkt hast, haben die beiden Entwickler nicht dieselbe Datei bearbeitet.
Obwohl Subversion eine solche Zusammenführung automatisch auf dem Server durchführt, wenn verschiedene Dateien bearbeitet werden, musst du bei Git die Commits <em>zuerst</em> lokal zusammenführen.
Mit anderen Worten, John muss zuerst Jessicas Änderungen abrufen und in seinem lokalen Repository zusammenführen, bevor ihm das Hochladen gestattet wird.</p>
</div>
<div class="paragraph">
<p>Als ersten Schritt holt John, Jessicas Änderungen (dies holt nur Jessicas Änderungen, diese werden noch nicht mit Johns Änderungen zusammengeführt):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git fetch origin
...
From john@githost:simplegit
 + 049d078...fbff5bc master     -&gt; origin/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Zu diesem Zeitpunkt sieht Johns lokales Repository ungefähr so aus:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/small-team-1.png" >}}" alt="Johns abzweigender Verlauf">
</div>
<div class="title">Abbildung 57. Johns abzweigender Verlauf</div>
</div>
<div class="paragraph">
<p>Jetzt kann John, Jessicas abgeholte Änderungen, zu seinen eigenen lokalen Änderungen zusammenführen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge origin/master
Merge made by the 'recursive' strategy.
 TODO |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Wenn diese lokale Zusammenführung reibungslos verläuft, sieht der aktualisierte Verlauf von John nun folgendermaßen aus:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/small-team-2.png" >}}" alt="Johns Repository nach der Zusammenführung `origin/master`">
</div>
<div class="title">Abbildung 58. Johns Repository nach der Zusammenführung <code>origin/master</code>
</div>
</div>
<div class="paragraph">
<p>Zu diesem Zeitpunkt möchte John möglicherweise diesen neuen Code testen, um sicherzustellen, dass sich keine der Arbeiten von Jessica auf seine auswirkt. Wenn alles in Ordnung ist, kann er die neu zusammengeführten Änderungen schließlich auf den Server übertragen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git push origin master
...
To john@githost:simplegit.git
   fbff5bc..72bbc59  master -&gt; master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Am Ende sieht Johns Commit-Verlauf so aus:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/small-team-3.png" >}}" alt="Johns Verlauf nach Hochladen auf den `origin` Server">
</div>
<div class="title">Abbildung 59. Johns Verlauf nach Hochladen auf den <code>origin</code> Server</div>
</div>
<div class="paragraph">
<p>In der Zwischenzeit hat Jessica einen neuen Branch mit dem Namen <code>issue54</code> erstellt und drei Commits auf diesem Branch vorgenommen.
Sie hat Johns Änderungen noch nicht abgerufen, daher sieht ihr Commit-Verlauf folgendermaßen aus:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/small-team-4.png" >}}" alt="Jessicas Featurebranch">
</div>
<div class="title">Abbildung 60. Jessicas Featurebranch</div>
</div>
<div class="paragraph">
<p>Nun erfährt Jessica, dass John einige neue Arbeiten auf den Server geschoben hat und sie möchte sich diese ansehen. Sie kann alle neuen Inhalte von dem Server abrufen über die sie noch nicht verfügt:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console"># Jessica's Machine
$ git fetch origin
...
From jessica@githost:simplegit
   fbff5bc..72bbc59  master     -&gt; origin/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dies zieht die Arbeit herunter (Pull), die John in der Zwischenzeit hochgeladen hat.
Jessicas Verlauf sieht jetzt so aus:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/small-team-5.png" >}}" alt="Jessicas Verlauf nach dem Abholen von Johns Änderungen">
</div>
<div class="title">Abbildung 61. Jessicas Verlauf nach dem Abholen von Johns Änderungen</div>
</div>
<div class="paragraph">
<p>Jessica denkt, dass ihr Feature Branch nun fertig ist. Sie möchte jedoch wissen, welchen Teil von Johns abgerufenen Arbeiten sie in ihre Arbeit einbinden muss, damit sie hochladen kann.
Sie führt <code>git log</code> aus, um das herauszufinden:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --no-merges issue54..origin/master
commit 738ee872852dfaa9d6634e0dea7a324040193016
Author: John Smith &lt;jsmith@example.com&gt;
Date:   Fri May 29 16:01:27 2009 -0700

   Remove invalid default value</code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Syntax <code>issue54..origin/master</code> ist ein Logfilter, der Git anweist, nur die Commits anzuzeigen, die sich im letzterem Branch befinden (in diesem Fall <code>origin/master</code>) und nicht im ersten Branch (in diesem Fall <code>issue54</code>).
Wir werden diese Syntax in <a href="{{< relurl "book/de/v2/ch00/_commit_ranges" >}}">Commit-Bereiche</a> genauer erläutern.</p>
</div>
<div class="paragraph">
<p>Aus der obigen Ausgabe können wir sehen, dass es einen einzigen Commit gibt, den John gemacht hat, welchen Jessica nicht in ihre lokale Arbeit eingebunden hat.
Wenn sie <code>origin/master</code> zusammenführt, ist dies der einzige Commit, der ihre lokale Arbeit verändert.</p>
</div>
<div class="paragraph">
<p>Jetzt kann Jessica ihre Arbeit in ihrem <code>master</code> Branch zusammenführen, Johns Arbeit (<code>origin/master</code>) in ihrem <code>master</code> Branch zusammenführen und dann wieder auf den Server hochladen.</p>
</div>
<div class="paragraph">
<p>Als erstes wechselt Jessica (nachdem sie alle Änderungen in ihrem FeatureBranch <code>issue54</code> commitet hat) zurück zu ihrem <code>master</code> Branch, um diese Integration vorzubereiten:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
Switched to branch 'master'
Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jessica kann entweder <code>origin/master</code> oder <code>issue54</code> mit ihrem lokalem <code>master</code> zusammenführen – beide sind ihrem <code>master</code> vorgelagert. Daher spielt die Reihenfolge keine Rolle.
Der finale Schnappschuss sollte unabhängig von der gewählten Reihenfolge identisch sein. Nur der Verlauf wird anders sein.
Sie beschließt, zuerst den Branch <code>issue54</code> zusammenzuführen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge issue54
Updating fbff5bc..4af4298
Fast forward
 README           |    1 +
 lib/simplegit.rb |    6 +++++-
 2 files changed, 6 insertions(+), 1 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Es treten keine Probleme auf. Wie du siehst, handelte es sich um eine einfache Schnellvorlauf Zusammenführung (engl. Fast-Forward).
Jessica schließt nun den lokalen Zusammenführungsprozess ab, indem sie Johns zuvor abgerufene Arbeit zusammenführt, die sich im Branch <code>origin/master</code> befindet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge origin/master
Auto-merging lib/simplegit.rb
Merge made by the 'recursive' strategy.
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alles kann sauber zusammengeführt werden. Jessicas Verlauf sieht nun so aus:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/small-team-6.png" >}}" alt="Jessicas Verlauf nach Zusammenführung mit Johns Änderungen">
</div>
<div class="title">Abbildung 62. Jessicas Verlauf nach Zusammenführung mit Johns Änderungen</div>
</div>
<div class="paragraph">
<p>Jetzt ist <code>origin/master</code> über Jessicas <code>master</code> Branch erreichbar, sodass sie erfolgreich pushen kann (vorausgesetzt, John hat in der Zwischenzeit keine weiteren Änderungen hochgeladen):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git push origin master
...
To jessica@githost:simplegit.git
   72bbc59..8059c15  master -&gt; master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jeder Entwickler hat einige Commits durchgeführt und die Arbeit des jeweils anderen erfolgreich zusammengeführt.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/small-team-7.png" >}}" alt="Jessicas Verlauf nach hochladen aller Änderungen auf den Server">
</div>
<div class="title">Abbildung 63. Jessicas Verlauf nach hochladen aller Änderungen auf den Server</div>
</div>
<div class="paragraph">
<p>Das ist einer der einfachsten Arbeitsabläufe.
Du arbeitest eine Weile (in der Regel in einem Feature Branch) und führst diese Arbeiten in deinem Branch <code>master</code> zusammen, sobald sie für die Integration bereit sind.
Wenn du diese Arbeit teilen möchtest, rufst du deinen <code>master</code> von <code>origin/master</code> ab und führst ihn zusammen, falls er sich geändert hat. Anschließend pushst du ihn in den <code>master</code> Branch auf dem Server.
Die allgemeine Reihenfolge sieht in etwa so aus:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/small-team-flow.png" >}}" alt="Allgemeine Abfolge von Ereignissen für einen einfachen Arbeitsablauf mit mehreren Entwicklern">
</div>
<div class="title">Abbildung 64. Allgemeine Abfolge von Ereignissen für einen einfachen Arbeitsablauf mit mehreren Entwicklern</div>
</div>
</div>
<div class="sect3">
<h3 id="_geführtes_privates_team">Geführtes, privates Team</h3>
<div class="paragraph">
<p>
In diesem Szenario sehen wir uns die Rollen der Mitwirkenden in einem größeren, geschlossenen Team an.
Du lernst, wie Du in einer Umgebung arbeitest, in der kleine Gruppen an der Entwicklung einzelner Funktionen zusammenarbeiten. Anschließend werden diese teambasierten Beiträge von einem anderen Beteiligten integriert.</p>
</div>
<div class="paragraph">
<p>Nehmen wir an, John und Jessica arbeiten gemeinsam an einem Feature (nennen wir dieses <code>FeatureA</code>), während Jessica und Josie, eine dritte Entwicklerin, an einem zweiten Feature arbeiten (sagen wir <code>FeatureB</code>).
In diesem Fall verwendet das Unternehmen einen Arbeitsablauf mit Integrationsmanager. Bei diesem kann die Arbeit der einzelnen Gruppen nur von bestimmten Beteiligten integriert werden. Der Master-Branch des Haupt Repositorys kann nur von diesen Beteiligten aktualisiert werden kann.
In diesem Szenario werden alle Arbeiten in teambasierten Branches ausgeführt und später vom Integrationsmanager zusammengeführt.</p>
</div>
<div class="paragraph">
<p>Folgen wir Jessicas Arbeitsablauf, während sie an ihren beiden Features tätig ist und parallel mit zwei verschiedenen Entwicklern in dieser Umgebung arbeitet.
Wir nehmen an, sie hat ihr Repository bereits geklont. Zuerst beschließt sie an <code>featureA</code> zu arbeiten.
Sie erstellt einen neuen Branch für das Feature und führt dort einige Änderungen aus:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console"># Jessica's Machine
$ git checkout -b featureA
Switched to a new branch 'featureA'
$ vim lib/simplegit.rb
$ git commit -am 'Add limit to log function'
[featureA 3300904] Add limit to log function
 1 files changed, 1 insertions(+), 1 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Zu diesem Zeitpunkt muss sie ihre Arbeit mit John teilen, also lädt sie ihre <code>featureA</code> Branch Commits auf den Server hoch.
Jessica hat keinen Push-Zugriff auf den <code>master</code> Branch, nur die Integrationsmanager haben das. Sie muss daher auf einen anderen Branch hochladen, um mit John zusammenzuarbeiten:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git push -u origin featureA
...
To jessica@githost:simplegit.git
 * [new branch]      featureA -&gt; featureA</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jessica schickt John eine E-Mail, um ihm mitzuteilen, dass sie einige Arbeiten in einen Branch mit dem Namen <code>featureA</code> hochgeladen hat. Er kann sie sich jetzt ansehen.
Während sie auf Rückmeldung von John wartet, beschließt Jessica, mit Josie an <code>featureB</code> zu arbeiten.
Zunächst startet sie einen neuen Feature-Branch, der auf dem <code>master</code> Branch des Servers basiert:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console"># Jessica's Machine
$ git fetch origin
$ git checkout -b featureB origin/master
Switched to a new branch 'featureB'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jetzt macht Jessica ein paar Commits auf dem Branch <code>featureB</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ vim lib/simplegit.rb
$ git commit -am 'Make ls-tree function recursive'
[featureB e5b0fdc] Make ls-tree function recursive
 1 files changed, 1 insertions(+), 1 deletions(-)
$ vim lib/simplegit.rb
$ git commit -am 'Add ls-files'
[featureB 8512791] Add ls-files
 1 files changed, 5 insertions(+), 0 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jessicas Repository sieht nun folgendermaßen aus:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/managed-team-1.png" >}}" alt="Jessicas initialer Commit Verlauf">
</div>
<div class="title">Abbildung 65. Jessicas initialer Commit Verlauf</div>
</div>
<div class="paragraph">
<p>Sie ist bereit, ihre Arbeit hochzuladen, erhält jedoch eine E-Mail von Josie, dass ein Branch mit einigen anfänglichen <code>featureB</code> Aufgaben bereits als <code>featureBee</code> Branch auf den Server übertragen wurde.
Jessica muss diese Änderungen mit ihren eigenen zusammenführen, bevor sie ihre Arbeit auf den Server übertragen kann.
Jessica holt sich zuerst Josies Änderungen mit <code>git fetch</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git fetch origin
...
From jessica@githost:simplegit
 * [new branch]      featureBee -&gt; origin/featureBee</code></pre>
</div>
</div>
<div class="paragraph">
<p>Angenommen Jessica befindet sich noch in ihrem ausgecheckten <code>featureB</code> Branch. Dann kann sie nun Josies Arbeit mit <code>git merge</code> in diesen Branch zusammenführen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge origin/featureBee
Auto-merging lib/simplegit.rb
Merge made by the 'recursive' strategy.
 lib/simplegit.rb |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nun möchte Jessica die gesamte zusammengeführte Arbeit an <code>featureB</code> zurück auf den Server übertragen. Jedoch möchte sie nicht einfach ihren eigenen Branch <code>featureB</code> übertragen.
Da Josie bereits einen Upstream Branch <code>featureBee</code> gestartet hat, möchte Jessica auf diesen Branch hochladen, was sie auch folgendermaßen tut:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git push -u origin featureB:featureBee
...
To jessica@githost:simplegit.git
   fba9af8..cd685d1  featureB -&gt; featureBee</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dies wird als <em>refspec</em> bezeichnet.
Unter <a href="{{< relurl "book/de/v2/ch00/_refspec" >}}">Die Referenzspezifikation (engl. Refspec)</a> findest du eine detailliertere Beschreibung der Git-Refspecs und der verschiedenen Möglichkeiten, die du damit hast.
Beachte auch die <code>-u</code> Option. Dies ist die Abkürzung für <code>--set-upstream</code>, mit der die Branches so konfiguriert werden, dass sie später leichter gepusht und gepullt werden können.</p>
</div>
<div class="paragraph">
<p>Als nächstes erhält Jessica eine E-Mail von John, der ihr mitteilt, dass er einige Änderungen am Branch <code>featureA</code> vorgenommen hat, an dem sie zusammenarbeiten. Er bittet Jessica, sie sich anzusehen.
Wieder führt Jessica ein einfaches <code>git fetch</code> durch, um <em>alle</em> neue Inhalte vom Server abzurufen, einschließlich (natürlich) Johns neuester Arbeit:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git fetch origin
...
From jessica@githost:simplegit
   3300904..aad881d  featureA   -&gt; origin/featureA</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jessica kann sich Johns neue Arbeit ansehen, indem sie den Inhalt des neu abgerufenen Branches <code>featureA</code> mit ihrer lokalen Kopie desselben Branches vergleicht:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log featureA..origin/featureA
commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
Author: John Smith &lt;jsmith@example.com&gt;
Date:   Fri May 29 19:57:33 2009 -0700

    Increase log output to 30 from 25</code></pre>
</div>
</div>
<div class="paragraph">
<p>Wenn ihr Johns neue Arbeit gefällt, kann sie sie mit ihrem lokalen Branch <code>featureA</code> zusammenführen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout featureA
Switched to branch 'featureA'
$ git merge origin/featureA
Updating 3300904..aad881d
Fast forward
 lib/simplegit.rb |   10 +++++++++-
1 files changed, 9 insertions(+), 1 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Schließlich möchte Jessica noch ein paar geringfügige Änderungen an dem gesamten, zusammengeführten Inhalt vornehmen. Sie kann diese Änderungen vornehmen, indem sie in ihren lokalen Branch <code>featureA</code> comittet und das Endergebnis zurück auf den Server überträgt (pusht):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git commit -am 'Add small tweak to merged content'
[featureA 774b3ed] Add small tweak to merged content
 1 files changed, 1 insertions(+), 1 deletions(-)
$ git push
...
To jessica@githost:simplegit.git
   3300904..774b3ed  featureA -&gt; featureA</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jessicas commit Verlauf sieht nun in etwa so aus:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/managed-team-2.png" >}}" alt="Jessicas Verlauf nach committen auf einem Feature Branch">
</div>
<div class="title">Abbildung 66. Jessicas Verlauf nach committen auf einem Feature Branch</div>
</div>
<div class="paragraph">
<p>Irgendwann informieren Jessica, Josie und John die Integratoren, dass die Branches <code>featureA</code> und <code>featureBee</code> auf dem Server für die Integration in die Hauptlinie bereit sind.
Nachdem die Integratoren diese Branches in der Hauptlinie zusammengeführt haben, holt ein Abruf den neuen Zusammenführungs-Commit ab, sodass der Verlauf wie folgt aussieht:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/managed-team-3.png" >}}" alt="Jessicas Verlauf nach Zusammenführung ihrer beiden Featurebranches">
</div>
<div class="title">Abbildung 67. Jessicas Verlauf nach Zusammenführung ihrer beiden Featurebranches</div>
</div>
<div class="paragraph">
<p>Viele Teams wechseln zu Git, da sie parallel arbeiten können und die verschiedenen Entwicklungslinien zu einem späteren Zeitpunkt zusammengeführt werden können.
Ein großer Vorteil von Git besteht darin, dass man in kleinen Untergruppen eines Teams über entfernte Branches zusammenarbeiten kann, ohne notwendigerweise das gesamte Team zu involvieren oder zu behindern.
Die Vorgehensweise dieses Arbeitsablaufes, sieht in etwa so aus:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/managed-team-flow.png" >}}" alt="Grundlegende Vorgehensweise bei einem geführten Team">
</div>
<div class="title">Abbildung 68. Grundlegende Vorgehensweise bei einem geführten Team</div>
</div>
</div>
<div class="sect3">
<h3 id="_public_project">Verteiltes, öffentliches Projekt</h3>
<div class="paragraph">
<p>
An öffentlichen Projekten mitzuwirken ist ein wenig anders.
Da du nicht die Berechtigung hast, Branches im Projekt direkt zu aktualisieren, musst du deine Arbeit auf andere Weise an die Projektbetreuer weiterleiten.
In diesem ersten Beispiel wird beschrieben, wie du auf Git Hosts, die einfaches „Forking“ unterstützen, via „Forking“ mitwirken kannst.
Viele Hosting-Sites unterstützen dies (einschließlich GitHub, BitBucket, repo.or.cz und andere) und viele Projektbetreuer erwarten diese Art der Mitarbeit.
Der nächste Abschnitt befasst sich mit Projekten, die bereitgestellte Patches bevorzugt per E-Mail akzeptieren.</p>
</div>
<div class="paragraph">
<p>Zunächst möchtest du wahrscheinlich das Hauptrepository klonen, einen Branch für den Patch oder die Patch Serien erstellen, die du beisteuern möchtest, und dort deine Arbeit erledigen.
Der Prozess sieht im Grunde so aus:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone &lt;url&gt;
$ cd project
$ git checkout -b featureA
  ... work ...
$ git commit
  ... work ...
$ git commit</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Anmerkung</div>
</td>
<td class="content">
<div class="paragraph">
<p>Du kannst <code>rebase -i</code> verwenden, um deine Arbeit auf ein einzelnen Commit zu reduzieren. Du kannst auch die Änderungen in den Commits neu anordnen, damit der Betreuer den Patch einfacher überprüfen kann – siehe <a href="{{< relurl "book/de/v2/ch00/_rewriting_history" >}}">Den Verlauf umschreiben</a> für weitere Informationen zum interaktiven Rebasing.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Wenn deine Arbeit am Branch abgeschlossen ist und du bereit bist, sie an die Betreuer weiterzuleiten, wechsel zur ursprünglichen Projektseite. Dort klickst du auf die Schaltfläche <code>Fork</code>, um deinen eigenen schreibbaren Fork des Projekts zu erstellen.
Anschließend musst du diese Repository-URL als neue Remote-Adresse deines lokalen Repositorys hinzufügen. Nennen wir es in diesem Beispiel <code>myfork</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add myfork &lt;url&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Anschließend musst du deine neue Arbeit in dieses Repository hochladen.
Es ist am einfachsten, den Branch, an dem du arbeitest, in dein geforktes Repository hochzuladen, anstatt diese Arbeit in deinem ´master´-Branch zusammenzuführen und diesen hochzuladen.
Der Grund dafür ist, dass du deinen <code>master</code> Branch nicht zurücksetzen musst, wenn deine Arbeit nicht akzeptiert bzw. nur teilweise übernommen (cherry-pick) wurde (die Git-Operation zum <code>cherry-pick</code> wird ausführlicher in <a href="{{< relurl "book/de/v2/ch00/_rebase_cherry_pick" >}}">Rebasing und Cherry-Picking Workflows</a> behandelt).
Wenn die Betreuer deine Arbeit per <code>merge</code>, <code>rebase</code> oder <code>cherry-pick</code> übernehmen, erhältst du deine Arbeit sowieso zurück, wenn du aus dem Repository der Betreuer pullst.</p>
</div>
<div class="paragraph">
<p>Auf jedem Fall kannst du deine Arbeit hochladen mit:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git push -u myfork featureA</code></pre>
</div>
</div>
<div class="paragraph">
<p>
Sobald deine Arbeit an deinem Fork des Repositorys hochgeladen wurde, musst du den Betreuern des ursprünglichen Projekts mitteilen, dass es Änderungen gibt, die sie zusammenführen möchten.
Dies wird oft als <em>Pull Request</em> bezeichnet. Du generierst eine solche Anfrage entweder über die Website – GitHub hat einen eigenen „Pull-Request-Mechanismus“, den wir in <a href="{{< relurl "book/de/v2/ch00/ch06-github" >}}">GitHub</a> behandeln werden, oder du kannst den Befehl <code>git request-pull</code> ausführen und die nachfolgende Ausgabe manuell per E-Mail an den Projektbetreuer senden.</p>
</div>
<div class="paragraph">
<p>Der Befehl <code>git request-pull</code> verwendet den Basis Branch, in den dein Feature Branch abgelegt werden soll. Außerdem wird die Git-Repository-URL angegeben aus dem er gezogen werden soll. Er erstellt damit eine Zusammenfassung aller Änderungen, um deren Übernahme du bittest.
Wenn bspw. Jessica an John eine Pull Request senden möchte und sie zwei Commits für den gerade hochgeladenen Featurebranch ausgeführt hat, kann sie folgendes ausführen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git request-pull origin/master myfork
The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
Jessica Smith (1):
        Create new function

are available in the git repository at:

  https://githost/simplegit.git featureA

Jessica Smith (2):
      Add limit to log function
      Increase log output to 30 from 25

 lib/simplegit.rb |   10 +++++++++-
 1 files changed, 9 insertions(+), 1 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Diese Ausgabe kann an den Betreuer gesendet werden. Sie teilt ihm mit, von wo die Arbeit gebranched wurde, fasst die Commits zusammen und gibt an, von wo die neue Arbeit abgerufen werden soll.</p>
</div>
<div class="paragraph">
<p>Bei einem Projekt, für das du nicht der Betreuer bist, ist es im Allgemeinen einfacher, einen Branch wie <code>master</code> zu haben, der immer <code>origin/master</code> folgt. Deine Arbeit kannst du dann in Feature Branches erledigen, die du einfach verwerfen kannst, wenn deine Änderungen abgelehnt werden.
Durch das Isolieren von Änderungen in Feature Branches wird es für dich auch einfacher, deine Arbeit neu zu strukturieren. Falls sich das Haupt-Repositorys in der Zwischenzeit weiter entwickelt hat und deine Commits nicht mehr sauber angewendet werden können.
Wenn du beispielsweise ein zweites Feature an das Projekt senden möchtest, arbeitest du nicht weiter an dem Branch, den du gerade hochgeladen hast. Beginne erneut im <code>master</code> Branch des Haupt-Repositorys:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b featureB origin/master
  ... work ...
$ git commit
$ git push myfork featureB
$ git request-pull origin/master myfork
  ... email generated request pull to maintainer ...
$ git fetch origin</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jetzt ist jedes deiner Features in einer Art Silo enthalten, ähnlich wie bei einer Patch-Warteschlange. Dieses kannst du umarbeiten, zurücksetzen oder ändern, ohne dass die Features sich gegenseitig stören oder voneinander abhängig sind.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/public-small-1.png" >}}" alt="Initialer Commit Verlauf mit `featureB` Änderungen">
</div>
<div class="title">Abbildung 69. Initialer Commit Verlauf mit <code>featureB</code> Änderungen</div>
</div>
<div class="paragraph">
<p>Nehmen wir an, der Projektbetreuer hat eine Reihe weiterer Patches übernommen und deinen ersten Branch einfließen lassen, der jedoch nicht mehr ordnungsgemäß zusammengeführt werden kann.
In diesem Fall kannst du versuchen, diesen Branch auf `origin/master' zu reorganisieren, die Konflikte für den Betreuer zu lösen und deine Änderungen erneut zu übermitteln:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout featureA
$ git rebase origin/master
$ git push -f myfork featureA</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dadurch wird dein Verlauf so umgeschrieben, sodass er jetzt folgendermaßen aussieht <a href="{{< relurl "book/de/v2/ch00/psp_b" >}}">Commit Verlauf nach <code>featureA</code> Änderungen</a>.</p>
</div>
<div id="psp_b" class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/public-small-2.png" >}}" alt="Commit Verlauf nach `featureA` Änderungen">
</div>
<div class="title">Abbildung 70. Commit Verlauf nach <code>featureA</code> Änderungen</div>
</div>
<div class="paragraph">
<p>Da du den Branch reorganisiert hast, musst du das <code>-f</code> für deinen Push-Befehl angeben, um den <code>featureA</code> Branch auf dem Server mit einen Commit ersetzen zu können, der nicht vom gegenwärtig letzten Commit des entfernten Branches abstammt.
Eine Alternative wäre, diese neue Arbeit in einen anderen Branch auf dem Server hochzuladen (beispielsweise als <code>featureAv2</code>).</p>
</div>
<div class="paragraph">
<p>Schauen wir uns ein weiteres mögliches Szenario an: Der Betreuer hat sich die Arbeit in deinem zweiten Branch angesehen und mag dein Konzept, möchte aber, dass du ein Implementierungsdetail änderst.
Du nutzt diese Gelegenheit, um deine Änderungen zu verschieben, damit diese auf dem aktuellen <code>master</code> Branch des Projektes basieren.
Du startest einen neuen Branch, der auf den aktuellen Branch <code>origin/master</code> basiert und fasst die Änderungen an <code>featureB</code> dort zusammen. Dabei löst du etwaige Konflikte, machst die Implementierungsänderungen und lädst diese Arbeiten als neuen Branch hoch:</p>
</div>
<div class="paragraph">
<p></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b featureBv2 origin/master
$ git merge --squash featureB
  ... change implementation ...
$ git commit
$ git push myfork featureBv2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mit der Option <code>--squash</code> wird die gesamte Arbeit an dem zusammengeführten Branch in einen Änderungssatz komprimiert. Dadurch wird ein Repository-Status erzeugt, als ob eine echter Commit stattgefunden hätte, ohne dass tatsächlich ein Merge-Commit durchgeführt wurde.
Dies bedeutet, dass dein zukünftiger Commit nur einen übergeordneten Vorgänger hat. Das erlaubt dir alle Änderungen aus einem anderen Branch einzuführen und weitere Änderungen vorzunehmen, bevor du den neuen Commit aufnimmst.
Auch die Option <code>--no-commit</code> kann nützlich sein, um den Merge-Commit im Falle des Standard-Merge-Prozesses zu verzögern.</p>
</div>
<div class="paragraph">
<p>Nun kannst du den Betreuer darüber informieren, dass du die angeforderten Änderungen vorgenommen hast und dass du diese Änderungen in deinem Branch <code>featureBv2</code> findest.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/public-small-3.png" >}}" alt="Commit Verlauf nach getaner `featureBv2` Arbeit">
</div>
<div class="title">Abbildung 71. Commit Verlauf nach getaner <code>featureBv2</code> Arbeit</div>
</div>
</div>
<div class="sect3">
<h3 id="_project_over_email">Öffentliche Projekte via Email</h3>
<div class="paragraph">
<p>
Viele Projekte haben fest definierte Prozesse, um Änderungen entgegenzunehmen. Du musst die spezifischen Regeln dieser Projekte kennen, da sie sich oft unterscheiden.
Da es viele alte und große Projekte gibt, die Änderungen über eine Entwickler-Mailingliste akzeptieren, werden wir jetzt solch ein Beispiel durchgehen.</p>
</div>
<div class="paragraph">
<p>Der Workflow ähnelt dem vorherigen Anwendungsfall: Du erstellst Feature Branches für jede Patch Serie, an der du arbeitest.
Der Unterschied besteht darin, wie du diese Änderungen an das Projekt sendest.
Anstatt das Projekt zu forken und auf dein eigenes geforktes Repository hochzuladen, generierst du E-Mail-Versionen jeder Commit-Serie und sendest diese per E-Mail an die Entwickler-Mailingliste:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b topicA
  ... work ...
$ git commit
  ... work ...
$ git commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>
Jetzt hast du zwei Commits, die du an die Mailingliste senden kannst.
Du verwendest <code>git format-patch</code>, um die mbox-formatierten Dateien zu generieren, die du anschließend per E-Mail an die Mailingliste sendest. Dabei wird jeder Commit in eine E-Mail-Nachricht umgewandelt. Die erste Zeile der Commit-Nachricht wird als Betreff verwendet. Der Rest der Commit-Nachricht plus den Patch, den der Commit einführt wird als Mail-Körper verwendet.
Der Vorteil daran ist, dass durch das Anwenden eines Patches aus einer mit <code>format-patch</code> erstellten E-Mail alle Commit-Informationen ordnungsgemäß erhalten bleiben.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git format-patch -M origin/master
0001-add-limit-to-log-function.patch
0002-increase-log-output-to-30-from-25.patch</code></pre>
</div>
</div>
<div class="paragraph">
<p>Der Befehl <code>format-patch</code> gibt die Namen der von ihm erstellten Patch-Dateien aus.
Die <code>-M</code> Option weist Git an, nach Umbenennungen zu suchen.
Die Dateien sehen am Ende folgendermaßen aus:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat 0001-add-limit-to-log-function.patch
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith &lt;jessica@example.com&gt;
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] Add limit to log function

Limit log functionality to the first 20

---
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 76f47bc..f9815f1 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -14,7 +14,7 @@ class SimpleGit
   end

   def log(treeish = 'master')
-    command("git log #{treeish}")
+    command("git log -n 20 #{treeish}")
   end

   def ls_tree(treeish = 'master')
--
2.1.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Du kannst diese Patch-Dateien auch bearbeiten, um weitere Informationen für die E-Mail-Liste hinzuzufügen, die nicht in der Commit-Nachricht angezeigt werden sollen.
Wenn du Text zwischen der Zeile <code>---</code> und dem Beginn des Patches (der Zeile <code>diff --git</code>) einfügst, können die Entwickler diesen Text lesen. Der Inhalt wird jedoch vom Patch-Vorgang ignoriert.</p>
</div>
<div class="paragraph">
<p>Um dies nun per E-Mail an eine Mailingliste zu senden, kannst du die Datei entweder an eine Mail anhängen oder über ein Befehlszeilenprogramm direkt versenden.
Das Einfügen von Text führt häufig zu Formatierungsproblemen, insbesondere bei „intelligenten“ Clients, bei denen Zeilenumbrüche und andere Leerzeichen nicht ordnungsgemäß beibehalten werden.
Glücklicherweise bietet Git ein Tool, mit dem du ordnungsgemäß formatierte Patches über IMAP senden kannst, was einfacher für dich sein könnte.
Wir zeigen dir, wie du einen Patch über Google Mail sendest. Dies ist der E-Mail-Agent, mit dem wir uns am besten auskennen. Detaillierte Anweisungen für eine Reihe von anderen Mail-Programmen findest du am Ende der oben genannten Datei <code>Documentation/SubmittingPatches</code> im Git-Quellcode.</p>
</div>
<div class="paragraph">
<p>
Zuerst musst du den Abschnitt imap in deiner <code>~/.gitconfig</code> Datei einrichten.
Du kannst jeden Wert separat mit einer Reihe von <code>git config</code> Befehlen festlegen oder manuell hinzufügen. Am Ende sollte deine Konfigurationsdatei ungefähr so aussehen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">[imap]
  folder = "[Gmail]/Entwürfe"
  host = imaps://imap.gmail.com
  user = user@gmail.com
  pass = YX]8g76G_2^sFbd
  port = 993
  sslverify = false</code></pre>
</div>
</div>
<div class="paragraph">
<p>Wenn dein IMAP-Server kein SSL verwendet, sind die letzten beiden Zeilen wahrscheinlich nicht erforderlich. Der Hostwert lautet dann <code>imap://</code> anstelle von <code>imaps://</code>.
Wenn dies eingerichtet ist, kannst du <code>git imap-send</code> verwenden, um die Patch-Reihe im Ordner <code>Entwürfe</code> des angegebenen IMAP-Servers abzulegen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat *.patch |git imap-send
Resolving imap.gmail.com... ok
Connecting to [74.125.142.109]:993... ok
Logging in...
sending 2 messages
100% (2/2) done</code></pre>
</div>
</div>
<div class="paragraph">
<p>Zu diesem Zeitpunkt solltest du in der Lage sein, in deinem Entwurfsordner zu wechseln und dort das Feld An der generierten Email in die Mailinglist-Adresse zu ändern, an die du den Patch senden willst. Möglicherweise willst du auch den Betreuer oder die Person in Kopie nehmen, die für diesen Abschnitt verantwortlich ist. Anschließend kannst du die Mail versenden.</p>
</div>
<div class="paragraph">
<p>Du kannst die Patches auch über einen SMTP-Server senden.
Wie zuvor kannst du jeden Wert separat mit einer Reihe von <code>git config</code> Befehlen festlegen oder manuell im Abschnitt sendemail in deiner <code>~/.gitconfig</code> Datei hinzufügen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">[sendemail]
  smtpencryption = tls
  smtpserver = smtp.gmail.com
  smtpuser = user@gmail.com
  smtpserverport = 587</code></pre>
</div>
</div>
<div class="paragraph">
<p>Danach kannst du deine Patches mit <code>git send-email</code> versenden:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git send-email *.patch
0001-add-limit-to-log-function.patch
0002-increase-log-output-to-30-from-25.patch
Who should the emails appear to be from? [Jessica Smith &lt;jessica@example.com&gt;]
Emails will be sent from: Jessica Smith &lt;jessica@example.com&gt;
Who should the emails be sent to? jessica@example.com
Message-ID to be used as In-Reply-To for the first email? y</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git gibt anschließend für jeden Patch, den du versendest, eine Reihe von Protokollinformationen aus, die in etwa so aussehen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">(mbox) Adding cc: Jessica Smith &lt;jessica@example.com&gt; from
  \line 'From: Jessica Smith &lt;jessica@example.com&gt;'
OK. Log says:
Sendmail: /usr/sbin/sendmail -i jessica@example.com
From: Jessica Smith &lt;jessica@example.com&gt;
To: jessica@example.com
Subject: [PATCH 1/2] Add limit to log function
Date: Sat, 30 May 2009 13:29:15 -0700
Message-Id: &lt;1243715356-61726-1-git-send-email-jessica@example.com&gt;
X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
In-Reply-To: &lt;y&gt;
References: &lt;y&gt;

Result: OK</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Hinweis</div>
</td>
<td class="content">
<div class="paragraph">
<p>Weitere Informationen zum Konfigurieren deines Systems und deiner E-Mail-Adresse, weitere Tipps und Tricks sowie eine Sandbox zum Senden eines Test-Patches per E-Mail findest du unter <a href="https://git-send-email.io" target="_blank" rel="noopener">git-send-email.io</a>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h3 id="_zusammenfassung_6">Zusammenfassung</h3>
<div class="paragraph">
<p>In diesem Abschnitt haben wir mehrere Workflows behandelt und über die Unterschiede zwischen der Arbeit an an Closed-Source-Projekten in einem kleinen Teams und der Mitarbeit an einem großen öffentlichen Projekt gesprochen.
Du musst vor dem Committen nach White-Space-Fehlern suchen und kannst großartige Commit-Beschreibungen hinzufügen.
Du hast gelernt, wie du Patches formatieren und per E-Mail an eine Entwickler-Mailingliste senden kannst.
Der Umgang mit Merges wurde auch im Zusammenhang mit den verschiedenen Arbeitsabläufen behandelt.
Du bist jetzt gut vorbereitet, an jedem Projekt mitzuarbeiten.</p>
</div>
<div class="paragraph">
<p>Als Nächstes erfährst du, wie du auf der anderen Seite arbeitest: als Verwalter (Maintainer) eines Git-Projektes.
Du lernst, wie man als wohlwollender Diktator oder Integrationsmanager korrekt arbeitet.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>