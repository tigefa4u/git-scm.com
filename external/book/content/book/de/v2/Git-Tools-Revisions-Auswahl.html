---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: de
  chapter:
    title: Git Tools
    number: 7
  section:
    title: Revisions-Auswahl
    number: 1
    cs_number: '7.1'
    previous: book/de/v2/GitHub-Zusammenfassung
    next: book/de/v2/Git-Tools-Interaktives-Stagen
title: Git - Revisions-Auswahl
---
<p>Inzwischen hast du die meisten der gängigen Befehle und Workflows kennen gelernt. Du benötigst sie, um ein Git-Repository für deine Quellcode-Kontrolle zu verwalten oder zu pflegen.
Du hast die grundlegenden Aufgaben des Tracking und Committens von Dateien gelernt und du hast die Leistungsfähigkeit der Staging-Area und Branching- und Merging-Funktionen mit Feature-Branches genutzt.</p><p>Jetzt wirst du eine Reihe von anderen nützlichen Git-Funktionen entdecken. Du wirst diese nicht unbedingt im Alltag einsetzen müssen, aber vielleicht irgendwann einmal benötigen.</p>
<h2 id="_revision_selection">Revisions-Auswahl</h2>
<div class="paragraph">
<p>Es gibt eine Reihe von Wegen um auf einen einzelnen Commit, einen Satz von Commits oder einen Bereich von Commits zu verweisen.
Nicht alle sind offensichtlich, aber es ist nützlich sie zu kennen.</p>
</div>
<div class="sect3">
<h3 id="_einzelne_revisionsstände">Einzelne Revisionsstände</h3>
<div class="paragraph">
<p>Du kannst dich natürlich auf jeden einzelnen Commit mit seinem vollen, 40-stelligen SHA-1-Hash beziehen, aber es gibt auch benutzerfreundlichere Möglichkeiten, sich auf Commits zu beziehen.
Dieses Kapitel beschreibt die verschiedenen Möglichkeiten, wie du auf jeden Commit verweisen kannst.</p>
</div>
</div>
<div class="sect3">
<h3 id="_kurz_sha_1">Kurz-SHA-1</h3>
<div class="paragraph">
<p>Git ist intelligent genug, um herauszufinden, auf welchen Commit du dich beziehst, wenn du die ersten paar Zeichen des SHA-1-Hash angibst, solange dieser Teil-Hash mindestens vier Zeichen lang und eindeutig ist. D.h. kein anderes Objekt in der Objektdatenbank darf einen Hash haben, der mit dem gleichen Präfix beginnt.</p>
</div>
<div class="paragraph">
<p>Wenn du z.B. einen bestimmten Commit untersuchen möchtest, kannst du den Befehl <code>git log</code> ausführen, um den Commit zu finden:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log
commit 734713bc047d87bf7eac9674765ae793478c50d3
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Jan 2 18:32:33 2009 -0800

    Fix refs handling, add gc auto, update tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'

commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 14:58:32 2008 -0800

    Add some blame and merge stuff</code></pre>
</div>
</div>
<div class="paragraph">
<p>Angenommen, du bist an dem Commit interessiert, dessen Hash mit <code>1c002dd…​</code> beginnt.
Du kannst den Commit mit einer der folgenden Varianten von <code>git show</code> überprüfen (vorausgesetzt, die verkürzten Hash-Versionen sind eindeutig):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b
$ git show 1c002dd4b536e7479f
$ git show 1c002d</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git kann eine eindeutige Abkürzung für deine SHA-1-Hashs ermitteln.
Wenn du <code>--abbrev-commit</code> mit dem Befehl <code>git log</code> nutzt, verwendet die Ausgabe kürzere und eindeutige Hast-Werte. Standardmäßig werden sieben Zeichen verwendet. Diese werden jedoch bei Bedarf länger, um die Eindeutigkeit des SHA-1-Hashs zu gewährleisten:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --abbrev-commit --pretty=oneline
ca82a6d Change the version number
085bb3b Remove unnecessary test code
a11bef0 Initial commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>In der Regel sind acht bis zehn Zeichen mehr als genug, um innerhalb eines Projekts eindeutig zu sein.
Zum Beispiel hat der Linux-Kernel (ein ziemlich großes Projekt) seit Februar 2019 über 875.000 Commits und fast sieben Millionen Objekte in seiner Objektdatenbank, wobei keine zwei Objekte vorhanden sind, deren SHA-1s in den ersten 12 Zeichen identisch sind.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Anmerkung</div>
</td>
<td class="content">
<div class="title">Eine kurze Anmerkung zu SHA-1</div>
<div class="paragraph">
<p>Viele Leute machen sich zu einem bestimmten Zeitpunkt Sorgen, dass sie zufällig zwei verschiedene Objekte in ihrem Repository haben könnten, die den gleichen SHA-1-Wert haben.
Was dann?</p>
</div>
<div class="paragraph">
<p>Wenn du ein Objekt, das auf den gleichen SHA-1-Wert wie ein vorhergehendes <em>unterschiedliches</em> Objekt in deinem Repository hasht, committest, wird Git das vorhergehende Objekt bereits in deiner Git-Datenbank sehen und davon ausgehen, dass es bereits geschrieben wurde und es einfach wiederverwenden.
Wenn du versuchst, dieses Objekt irgendwann wieder auszuchecken, erhältst du immer die Daten des ersten Objekts.</p>
</div>
<div class="paragraph">
<p>Du solltest dir jedoch bewusst sein, wie unwahrscheinlich dieses Szenario ist.
Der SHA-1 Hashwert beträgt 20 Bytes oder 160 Bit.
Die Anzahl der zufällig gehashten Objekte, die benötigt werden, um eine 50%ige Wahrscheinlichkeit einer einzelnen Kollision zu erreichen, beträgt etwa 2<sup>80</sup> (Die Formel zur Bestimmung der Kollisionswahrscheinlichkeit ist <code>p = (n(n-1)/2) * (1/2^160)</code>).
2<sup>80</sup> sind 1.2 x 10<sup>24</sup> oder 1 Million Milliarden Milliarden.
Das ist das 1.200-fache der Anzahl der Sandkörner auf der Erde.</p>
</div>
<div class="paragraph">
<p>Hier ist ein Beispiel, um dir eine Vorstellung davon zu geben, was nötig wäre, um eine SHA-1-Kollision zu erhalten.
Wenn alle 6,5 Milliarden Menschen auf der Erde programmierten würden und jeder jede Sekunde soviel Code produzieren würde, die der Menge des gesamten Verlaufs des Linux-Kernels entspräche (6,5 Millionen Git-Objekte) und dann alles in ein riesiges Git-Repository geschoben wird, dann würde es etwa 2 Jahre dauern, bis dieses Repository genügend Objekte enthielte, um eine 50%ige Wahrscheinlichkeit einer einzelnen SHA-1-Objektkollision zu erzielen.
Somit ist eine organische SHA-1-Kollision unwahrscheinlicher, als wenn jedes Mitglied deines Programmierer-Teams in der gleichen Nacht von Wölfen angegriffen und auf eine andere Art in der selben Nacht getötet würde.</p>
</div>
<div class="paragraph">
<p>Wenn du Rechenleistung im Wert von mehreren Tausend US-Dollar dafür bereitstellst, könntest du zwei Dateien mit demselben Hash künstlich generieren, wie im Februar 2017 unter <a href="https://shattered.io/" class="bare" target="_blank" rel="noopener">https://shattered.io/</a> nachgewiesen wurde.
Git geht dazu über, SHA256 als Standard-Hashing-Algorithmus zu verwenden, der gegenüber Kollisionsangriffen wesentlich widerstandsfähiger ist und Code beinhaltet, um diesen Angriff abzuschwächen (obwohl er nicht vollständig beseitigt werden kann).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h3 id="_branch_references">Branch Referenzen</h3>
<div class="paragraph">
<p>Eine unkomplizierte Methode, auf einen bestimmten Commit zu verweisen, ist, wenn es sich um den Commit am Ende eines Branches handelt. In diesem Fall kannst du einfach den Branch-Namen in jedem Git-Befehl verwenden, der eine Referenz auf einen Commit erwartet.
Wenn du beispielsweise das letzte Commit-Objekt in einem Branch untersuchen möchtest, sind die folgenden Befehle gleichwertig, vorausgesetzt, der Branch <code>topic1</code> zeigt auf den Commit <code>ca82a6d…​.</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show ca82a6dff817ec66f44342007202690a93763949
$ git show topic1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Wenn du sehen willst, auf welchen spezifischen SHA-1 ein Branch zeigt, oder wenn du sehen willst, worauf sich die folgenden Beispiele in Bezug auf SHA-1s verkürzen, kannst du ein Git Basis-Befehl (engl. plumbing tool) mit dem Namen <code>rev-parse</code> verwenden.
Du kannst in <a href="{{< relurl "book/de/v2/ch00/ch10-git-internals" >}}">Git Interna</a> weitere Details über Basisbefehl-Tools nachlesen. Der Befehlt <code>rev-parse</code> ist eine Low-Level-Befehl und ist normalerweise nicht für den täglichen Einsatz notwendig.
Allerdings kann es gelegentlich hilfreich sein, wenn man herausfinden muss, was eigentlich passiert ist.
So kannst du <code>rev-parse</code> auf deinem Branch ausführen.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rev-parse topic1
ca82a6dff817ec66f44342007202690a93763949</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_git_reflog">RefLog Kurzformen</h3>
<div class="paragraph">
<p>Eine der Dinge, die Git im Hintergrund macht, während du arbeitest, ist einen „Reflog“ aufzuzeichnen – ein Protokoll darüber, wo sich deine HEAD- und Branch-Referenzen in den letzten Monaten befunden haben.</p>
</div>
<div class="paragraph">
<p>Du kannst dein Reflog sehen, indem du <code>git reflog</code> benutzt:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git reflog
734713b HEAD@{0}: commit: Fix refs handling, add gc auto, update tests
d921970 HEAD@{1}: merge phedders/rdocs: Merge made by the 'recursive' strategy.
1c002dd HEAD@{2}: commit: Add some blame and merge stuff
1c36188 HEAD@{3}: rebase -i (squash): updating HEAD
95df984 HEAD@{4}: commit: # This is a combination of two commits.
1c36188 HEAD@{5}: rebase -i (squash): updating HEAD
7e05da5 HEAD@{6}: rebase -i (pick): updating HEAD</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jedes Mal, wenn das Ende deines Branch aus irgendeinem Grund aktualisiert wird, speichert Git diese Informationen für dich in dieser temporären Historie.
Du kannst deine Reflog-Daten auch verwenden, um auf ältere Commits zu verweisen.
Wenn du beispielsweise den fünft-letzten Wert des HEADs deines Repositorys sehen möchtest, kannst du den Verweis <code>@{5}</code> benutzen, damit du diese Reflog-Ausgabe erhältst:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show HEAD@{5}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Du kannst diese Syntax auch verwenden, um zu sehen, wo sich ein Branch vor einer bestimmten Zeit befand.
Um zum Beispiel zu sehen, wo dein <code>master</code> Branch gestern war, kannst du folgendes eingeben:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show master@{yesterday}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Das würde dir zeigen, wo das Ende deines <code>master</code> Branchs gestern war.
Diese Technik funktioniert nur für Daten, die sich noch in deinem Reflog befinden. Daher kannst du sie nicht verwenden, um nach Commits zu suchen, die älter als ein paar Monate sind.</p>
</div>
<div class="paragraph">
<p>Um die Reflog-Informationen so zu formatieren, wie die Ausgabe von <code>git log</code>, kannst du <code>git log -g</code> aufrufen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -g master
commit 734713bc047d87bf7eac9674765ae793478c50d3
Reflog: master@{0} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: commit: Fix refs handling, add gc auto, update tests
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Jan 2 18:32:33 2009 -0800

    Fix refs handling, add gc auto, update tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Reflog: master@{1} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: merge phedders/rdocs: Merge made by recursive.
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Es ist jedoch wichtig festzuhalten, dass die Reflog-Informationen ausschließlich lokale Informationen sind – es ist nur ein Protokoll dessen, was <em>du</em> in <em>deinem</em> Repository getan hast.
Diese Referenzen sind nicht die gleichen wie auf einer anderen Kopie des Repositorys. Gleich nachdem du ein Repository geklont hast, hast du ein leeres Reflog, da noch keine Aktivität in deinem lokalen Repository stattgefunden hat.
Wenn du <code>git show HEAD@{2.months.ago}</code> ausführst, wird dir der passende Commit nur angezeigt, wenn du das Projekt vor mindestens zwei Monaten geklont haben. Wenn du es aber erst vor kurzem geklont hast, siehst du nur deinen ersten lokalen Commit.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Hinweis</div>
</td>
<td class="content">
<div class="title">Betrachte das Reflog als die Shell-Historie von Git.</div>
<div class="paragraph">
<p>Wenn du UNIX- oder Linux-Kenntnisse hast, kannst du dir das Reflog als die Git-Version der Shell-Historie vorstellen. Diese zeigt jedoch wie bei der Shell-Historie nur die Daten für deine „Sitzung“, die mit niemand anderem etwas zu tun hat, der am gleichen Client arbeiten könnte.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Anmerkung</div>
</td>
<td class="content">
<div class="title">Klammern in PowerShell maskieren</div>
<div class="paragraph">
<p>Bei Verwendung von PowerShell sind geschweifte Klammern wie <code>{</code> und <code>}</code> Sonderzeichen und müssen maskiert werden.
Du kannst sie mit einem Backtick ` maskieren oder die Commit-Referenz in Anführungszeichen setzen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show HEAD@{0}     # wird nicht funktionieren
$ git show HEAD@`{0`}   # OK
$ git show "HEAD@{0}"   # OK</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h3 id="_abstammung_der_referenzen">Abstammung der Referenzen</h3>
<div class="paragraph">
<p>Die andere Methode, um einen Commit anzugeben, ist über seine Abstammung.
Wenn du ein <code>^</code> (Zirkumflex) am Ende einer Referenz anhängt, löst Git es auf, um das Eltern (engl. parent) Element dieses Commits anzusprechen.
Angenommen, du schaust auf den Verlauf deines Projekts:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --pretty=format:'%h %s' --graph
* 734713b Fix refs handling, add gc auto, update tests
*   d921970 Merge commit 'phedders/rdocs'
|\
| * 35cfb2b Some rdoc changes
* | 1c002dd Add some blame and merge stuff
|/
* 1c36188 Ignore *.gem
* 9b29157 Add open3_detach to gemspec file list</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dann könntest du den vorherigen Commit sehen, indem du <code>HEAD^</code> angibst, das das „Elternteil von HEAD“  bedeutet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show HEAD^
commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Anmerkung</div>
</td>
<td class="content">
<div class="title">Den Zirkumflex (^) in Windows umgehen</div>
<div class="paragraph">
<p>In der Eingabeaufforderung von Windows (<code>cmd.exe</code>) ist <code>^</code> ein Sonderzeichen und muss anders behandelt werden.
Du kannst es entweder verdoppeln oder die Commit-Referenz in Anführungszeichen setzen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show HEAD^     # wird in Windows NICHT funktionieren
$ git show HEAD^^    # OK
$ git show "HEAD^"   # OK</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Du kannst auch eine Zahl nach dem <code>^</code> angeben, um den gewünschten Elternteil zu identifizieren. So bedeutet beispielsweise <code>d921970^2</code> den „zweiten Elternteil von d921970“.
Diese Syntax ist nur für Merge-Commits nützlich, die mehr als einen Elternteil haben – der <em>erste</em> Elternteil eines Merge-Commits stammt aus dem Branch, in dem du beim Mergen warst (in der Regel <code>master</code>). Der <em>zweite</em> Elternteil eines Merge-Commits stammt aus dem Branch, der zusammengeführt wurde (z.B. <code>topic</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show d921970^
commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 14:58:32 2008 -0800

    Add some blame and merge stuff

$ git show d921970^2
commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548
Author: Paul Hedderly &lt;paul+git@mjr.org&gt;
Date:   Wed Dec 10 22:22:03 2008 +0000

    Some rdoc changes</code></pre>
</div>
</div>
<div class="paragraph">
<p>Die andere wichtige Abstammungsangabe ist die <code>~</code> (Tilde).
Sie bezieht sich auch auf den ersten Elternteil, so dass <code>HEAD~</code> und <code>HEAD^</code> gleichbedeutend sind.
Der Unterschied wird deutlich, wenn du eine Zahl angibst.
<code>HEAD~2</code> meint den „ersten Elternteil des ersten Elternteils“ oder „den Großelternteil“ – er passiert den ersten Elternteil so oft wie du angegeben hast.
In der zuvor aufgelisteten Historie wäre z. B. <code>HEAD~3</code> folgendes gewesen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show HEAD~3
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;
Date:   Fri Nov 7 13:47:59 2008 -0500

    Ignore *.gem</code></pre>
</div>
</div>
<div class="paragraph">
<p>Das kann auch als <code>HEAD~~~</code> geschrieben werden. Auch hier handelt es sich um den ersten Elternteil des ersten Elternteils des ersten Elternteils:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show HEAD~~~
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;
Date:   Fri Nov 7 13:47:59 2008 -0500

    Ignore *.gem</code></pre>
</div>
</div>
<div class="paragraph">
<p>Du kannst diese Syntax auch kombinieren – so kannst du den zweiten Elternteil der vorhergehenden Referenz (vorausgesetzt, es handelt sich um einen Merge Commit) erhalten, indem du <code>HEAD~3^2</code> verwendest, und so weiter.</p>
</div>
</div>
<div class="sect3">
<h3 id="_commit_ranges">Commit-Bereiche</h3>
<div class="paragraph">
<p>Nachdem du jetzt einzelne Commits angeben kannst, möchten wir dir zeigen, wie du einen Bereich von Commits festlegen kannst.
Besonders nützlich ist das für die Verwaltung deines Branches. Bei vielen Branches kannst du mit Hilfe von Bereichs(engl. Range)-Spezifikationen Fragen beantworten wie: „Welche Arbeit ist in diesem Branch, die ich noch nicht mit meiner Haupt-Branch zusammengeführt habe?“</p>
</div>
<div class="sect4">
<h4 id="_doppelter_punkt">Doppelter Punkt</h4>
<div class="paragraph">
<p>Die gebräuchlichste Bereichsspezifikation ist die Doppelte-Punkt-Syntax.
Hiermit wird Git im Wesentlichen aufgefordert, eine Reihe von Commits aufzulösen, die von einem bestimmten Commit erreichbar sind, aber von einem anderen nicht.
Angenommen, du hast eine Commit-Historie, die wie <a href="{{< relurl "book/de/v2/ch00/double_dot" >}}">Beispiel – Verlauf zur Bereichsauswahl</a> aussieht.</p>
</div>
<div id="double_dot" class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/double-dot.png" >}}" alt="Beispiel – Verlauf zur Bereichsauswahl">
</div>
<div class="title">Abbildung 136. Beispiel – Verlauf zur Bereichsauswahl</div>
</div>
<div class="paragraph">
<p>Angenommen, du willst nun wissen, was sich in deinem Branch <code>experiment</code> befindet, das noch nicht mit deinem Branch <code>master</code> gemerged wurde.
Du kannst Git fragen, ob es dir ein Log der Commits mit <code>master..experiment</code> anzeigen kann – d.h. „alle Commits, die von experiment aus erreichbar sind, von master aus aber nicht“.
Um die Kürze und Übersichtlichkeit dieser Beispiele zu erhalten, werden die Buchstaben der Commit-Objekte aus der Abbildung anstelle der eigentlichen Protokollausgabe verwendet, in der Reihenfolge, in der sie angezeigt werden:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log master..experiment
D
C</code></pre>
</div>
</div>
<div class="paragraph">
<p>Wenn du das Gegenteil sehen wollen – alle Commits in <code>master</code>, die nicht in <code>experiment</code> sind – dann kannst du die Branch-Namen umkehren.
<code>experiment..master</code> zeigt dir alles in <code>master</code>, was von <code>experiment</code> nicht erreichbar ist:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log experiment..master
F
E</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dieses Vorgehen ist praktisch, wenn du den Branch <code>experiment</code> auf dem aktuellen Stand halten und eine Vorschau darauf erhalten möchtest, was du gerade mergen willst.
Eine weitere häufige Anwendung dieser Syntax besteht darin, zu überprüfen, was du auf einen Remote pushen möchtest:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log origin/master..HEAD</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dieser Befehl zeigt dir alle Commits in deinem aktuellen Branch an, die sich nicht im Branch <code>master</code> auf deinem Remote <code>origin</code> befinden.
Wenn du ein <code>git push</code> ausführst und dein aktueller Branch trackt <code>origin/master</code>, dann sind die Commits, die mit <code>git log origin/master..HEAD</code> aufgelistet werden, die Commits, die an den Server übertragen werden.
Du kannst auch eine Seite der Syntax weglassen, so dass Git <code>HEAD</code> auf der fehlenden Seite annimmt.
Zum Beispiel kannst du die gleichen Ergebnisse wie im vorherigen Beispiel erhalten, indem du <code>git log origin/master..</code> angibst. Git ersetzt in diesem Fall`HEAD`, wenn eine Seite fehlt.</p>
</div>
</div>
<div class="sect4">
<h4 id="_mehrere_punkte">Mehrere Punkte</h4>
<div class="paragraph">
<p>Die Doppelte-Punkt-Syntax ist als Kurzform nützlich, aber möglicherweise möchtest du mehr als zwei Branches angeben, um deinen Revisions-Stand anzuzeigen. So könntest du beispielsweise feststellen, welche Commits in einem oder mehreren Branches vorhanden sind aber sich nicht in dem Branch befinden, in dem du dich gerade aufhältst.
Git ermöglicht dir dies mit dem Zeichen <code>^</code> oder dem Zusatz <code>--not</code> vor einer Referenz, von der du keinen Commits sehen möchtest.
Die folgenden drei Befehle sind daher vergleichbar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log refA..refB
$ git log ^refA refB
$ git log refB --not refA</code></pre>
</div>
</div>
<div class="paragraph">
<p>Das ist auch deshalb interessant, weil du mit dieser Syntax mehr als zwei Referenzen in deiner Abfrage angeben kannst. Das ist mit der Doppelte-Punkt-Syntax (engl. Double-Dot-Syntax) nicht möglich.
Wenn du zum Beispiel alle Commits sehen möchtest, die von <code>refA</code> oder <code>refB</code> aus erreichbar sind, aber nicht von <code>refC</code> aus, kannst du eine der folgenden Optionen verwenden:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log refA refB ^refC
$ git log refA refB --not refC</code></pre>
</div>
</div>
<div class="paragraph">
<p>Das sorgt für ein sehr leistungsfähiges Revisions-Abfragesystem, das dir dabei helfen sollte, festzustellen, was in deinen Branches gerade enthalten ist.</p>
</div>
</div>
<div class="sect4">
<h4 id="_triple_dot">Dreifacher  Punkt</h4>
<div class="paragraph">
<p>Die letzte wichtige Syntax für die Bereichsauswahl ist die Dreifach-Punkt-Syntax (engl. Triple-Dot-Syntax), die alle Commits angibt, die durch <em>eine</em> der beiden Referenzen erreichbar sind, aber nicht durch beide.
Schaue dir dazu die Commit-Historie in <a href="{{< relurl "book/de/v2/ch00/double_dot" >}}">Beispiel – Verlauf zur Bereichsauswahl</a> an.
Wenn du wissen willst, was sich in <code>master</code> oder <code>experiment</code> befindet, aber nicht deren gemeinsamen Referenzen, kannst du diese Funktion ausführen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log master...experiment
F
E
D
C</code></pre>
</div>
</div>
<div class="paragraph">
<p>Auch hier erhältst du eine normale <code>log</code> Ausgabe. Es werden dir jedoch nur die Commit-Informationen für diese vier Commits angezeigt, die in der normalen Reihenfolge der Commit-Daten erscheinen.</p>
</div>
<div class="paragraph">
<p>Ein gängiger Parameter, der hier mit dem <code>log</code> Befehl verwendet werden kann ist <code>--left-right</code>. Er zeigt dir, auf welcher Seite des Bereichs sich der Commit gerade befindet.
Auf diese Weise wird die Ausgabe besser auswertbar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --left-right master...experiment
&lt; F
&lt; E
&gt; D
&gt; C</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mit diesen Tools kannst du Git viel einfacher mitteilen, welche Commits du überprüfen möchtest.</p>
</div>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>