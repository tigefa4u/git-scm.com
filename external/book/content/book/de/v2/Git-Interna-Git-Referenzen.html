---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: de
  chapter:
    title: Git Interna
    number: 10
  section:
    title: Git Referenzen
    number: 3
    cs_number: '10.3'
    previous: book/de/v2/Git-Interna-Git-Objekte
    next: book/de/v2/Git-Interna-Packdateien-engl-Packfiles
title: Git - Git Referenzen
---
<h2 id="_git_refs">Git Referenzen</h2>
<div class="paragraph">
<p>Wenn du den Verlauf deines Repositorys sehen möchtest, der über Commit erreichbar ist, z. B. <code>1a410e</code>, kannst du so etwas wie <code>git log 1a410e</code> ausführen, um diesen Verlauf anzuzeigen. Dennoch musst du sich weiterhin daran erinnern, dass <code>1a410e</code> der Commit ist den du als Ausgangspunkt für diese Historie verwenden möchtest.
Es wäre aber einfacher, wenn du eine Datei hättest, in der du diesen SHA-1-Wert unter einem einfachen Namen speichern kannst, sodass du diesen einfachen Namen anstelle des unformatierten SHA-1-Werts verwenden könntest.</p>
</div>
<div class="paragraph">
<p>In Git werden diese einfachen Namen „Referenzen“ oder „Refs“ genannt. Du findest die Dateien, die diese SHA-1-Werte enthalten, im Verzeichnis <code>.git/refs</code>.
Im aktuellen Projekt enthält dieses Verzeichnis keine Dateien, es enthält eine einfache Struktur:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ find .git/refs
.git/refs
.git/refs/heads
.git/refs/tags
$ find .git/refs -type f</code></pre>
</div>
</div>
<div class="paragraph">
<p>Um eine neue Referenz zu erstellen, die dir hilft, dich zu erinnern, wo sich dein letzter Commit befindet, kannst du einfach folgendes machen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 1a410efbd13591db07496601ebc7a059dd55cfe9 &gt; .git/refs/heads/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jetzt kannst du die soeben erstellte Kopfreferenz anstelle des SHA-1-Werts in deinem Git-Befehlen verwenden:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --pretty=oneline master
1a410efbd13591db07496601ebc7a059dd55cfe9 Third commit
cac0cab538b970a37ea1e769cbbde608743bc96d Second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d First commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Es wird nicht empfohlen, die Referenzdateien direkt zu bearbeiten. Stattdessen bietet Git den sichereren <code>Befehl git update-ref</code>, um dies zu tun, wenn du eine Referenz aktualisieren möchtest:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9</code></pre>
</div>
</div>
<div class="paragraph">
<p>Das ist im Grunde genommen ein Branch in Git: ein einfacher Zeiger oder ein Verweis auf den Kopf einer Arbeitslinie.
So erstellst du eine Verzweigung beim zweiten Commit:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git update-ref refs/heads/test cac0ca</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dein Branch enthält nur Arbeiten von diesem Commit an abwärts:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --pretty=oneline test
cac0cab538b970a37ea1e769cbbde608743bc96d Second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d First commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nun sieht deine Git-Datenbank konzeptionell ungefähr so aus:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/data-model-4.png" >}}" alt="Git-Verzeichnisobjekte mit Branch Head Referenzen">
</div>
<div class="title">Abbildung 176. Git-Verzeichnisobjekte mit Branch Head Referenzen</div>
</div>
<div class="paragraph">
<p>Wenn du Befehle wie <code>git branch &lt;branch&gt;</code> ausführst, führt Git grundsätzlich den Befehl <code>update-ref</code> aus, um den SHA-1 des letzten Commits des Branches, in dem du sich befindest, in die neue Referenz einzufügen, die du erstellen möchtest.</p>
</div>
<div class="sect3">
<h3 id="ref_the_ref">HEAD</h3>
<div class="paragraph">
<p>Die Frage ist nun, wenn du <code>git branch &lt;branch&gt;</code> ausführst, woher kennt Git den SHA-1 des letzten Commits?
Die Antwort ist die HEAD-Datei.</p>
</div>
<div class="paragraph">
<p>Normalerweise ist die HEAD-Datei ein symbolischer Verweis auf den Branch, in dem du dich gerade befindest.
Mit symbolischer Referenz meinen wir, dass sie im Gegensatz zu einer normalen Referenz einen Zeiger auf eine andere Referenz enthält.</p>
</div>
<div class="paragraph">
<p>In einigen seltenen Fällen kann die HEAD-Datei jedoch den SHA-1-Wert eines Git-Objekts enthalten.
Dies geschieht beim Auschecken eines Tags, Commits oder eines Remote-Branches, wodurch dein Repository in den Status <a href="https://git-scm.com/docs/git-checkout#_detached_head" target="_blank" rel="noopener">"detached HEAD"</a> versetzt wird.</p>
</div>
<div class="paragraph">
<p>Wenn du dir die Datei ansiehst, siehst du normalerweise Folgendes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .git/HEAD
ref: refs/heads/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Wenn du <code>git checkout test</code> ausführst, aktualisiert Git die Datei folgendermaßen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .git/HEAD
ref: refs/heads/test</code></pre>
</div>
</div>
<div class="paragraph">
<p>Wenn du <code>git commit</code> ausführst, wird das Commitobjekt erstellt, wobei das übergeordnete Objekt dieses Commitobjekts als der SHA-1-Wert angegeben wird, auf den die Referenz in HEAD verweist.</p>
</div>
<div class="paragraph">
<p>Du kannst diese Datei auch manuell bearbeiten, es gibt jedoch wieder einen sichereren Befehl: <code>git symbolic-ref</code>.
Du kannst den Wert deines HEAD über diesen Befehl lesen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git symbolic-ref HEAD
refs/heads/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Du kannst den Wert von HEAD auch mit demselben Befehl festlegen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git symbolic-ref HEAD refs/heads/test
$ cat .git/HEAD
ref: refs/heads/test</code></pre>
</div>
</div>
<div class="paragraph">
<p>Du kannst keine symbolische Referenz außerhalb des Refs-Stils festlegen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git symbolic-ref HEAD test
fatal: Refusing to point HEAD outside of refs/</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_tags">Tags</h3>
<div class="paragraph">
<p>Wir haben gerade die drei Hauptobjekttypen von Git (<em>blobs</em>, <em>trees</em> und <em>commits</em>) besprochen, aber es gibt einen vierten.
Das <em>tag</em>-Objekt ähnelt stark einem Commitobjekt — es enthält einen Tagger, ein Datum, eine Nachricht und einen Zeiger.
Der Hauptunterschied besteht darin, dass ein Tag-Objekt im Allgemeinen eher auf ein Commit als auf einen Baum verweist.
Es ist wie eine Branchreferenz, aber es bewegt sich nie — es zeigt immer auf den gleichen Commit, gibt ihm aber einen lesbareren Namen.</p>
</div>
<div class="paragraph">
<p>Wie in <a href="{{< relurl "book/de/v2/ch00/ch02-git-basics-chapter" >}}">Git Grundlagen</a> beschrieben, gibt es zwei Arten von Tags: Annotierte- und Leichtgewichtige-Tags.
Du kannst einen leichtgewichtigen Tag erstellen, indem du Folgendes ausführst:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d</code></pre>
</div>
</div>
<div class="paragraph">
<p>Das ist alles, was ein leichtgewichtiges Tag ist — eine Referenz, die sich nie bewegt.
Ein annotiertes Tag ist jedoch komplexer.
Wenn du ein annotiertes Tag erstellst, erstellt Git ein Tag-Objekt und schreibt dann einen Verweis, um darauf zu zeigen, anstatt direkt auf den Commit.
Du kannst dies sehen, indem du ein annotiertes Tag (mit der Option <code>-a</code>) erstellst:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m 'Test tag'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hier ist der Wert für das Objekt SHA-1, das erstellt wurde:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .git/refs/tags/v1.1
9585191f37f7b0fb9444f35a9bf50de191beadc2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Führe nun <code>git cat-file -p</code> für diesen SHA-1-Wert aus:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2
object 1a410efbd13591db07496601ebc7a059dd55cfe9
type commit
tag v1.1
tagger Scott Chacon &lt;schacon@gmail.com&gt; Sat May 23 16:48:58 2009 -0700

Test tag</code></pre>
</div>
</div>
<div class="paragraph">
<p>Du kannst sehen, dass der Objekteintrag auf den Commit SHA-1-Wert verweist, den du getagged hast.
Beachte auch, dass es nicht auf ein Commit verweisen muss. Du kannst jedes Git-Objekt taggen.
Beispielsweise hat der Betreuer im Git-Quellcode seinen öffentlichen GPG-Schlüssel als Blob-Objekt hinzugefügt und dann mit Tags versehen.
Du kannst den öffentlichen Schlüssel anzeigen, indem du diesen in einem Klon des Git-Repositorys ausführst:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file blob junio-gpg-pub</code></pre>
</div>
</div>
<div class="paragraph">
<p>Das Linux-Kernel-Repository verfügt auch über ein Tag-Objekt, das nicht auf Commits verweist. Das erste erstellte Tag verweist auf den ursprünglichen Baum des Imports des Quellcodes.</p>
</div>
</div>
<div class="sect3">
<h3 id="_remotes">Remotes</h3>
<div class="paragraph">
<p>Der dritte Referenztyp, den du siehst, ist eine Remotereferenz.
Wenn du ein Remote hinzufügst und darauf pushst, speichert Git den Wert, den du zuletzt an diesen Remote gesendet hast, für jeden Branch im Verzeichnis <code>refs/remotes</code>.
Zum Beispiel kannst du eine Remote mit dem Namen <code>origin</code> hinzufügen und deinen <code>master</code> -Branch darauf pushen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add origin git@github.com:schacon/simplegit-progit.git
$ git push origin master
Counting objects: 11, done.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (7/7), 716 bytes, done.
Total 7 (delta 2), reused 4 (delta 1)
To git@github.com:schacon/simplegit-progit.git
  a11bef0..ca82a6d  master -&gt; master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Anschließend kannst du in der Datei <code>refs/remotes/origin/master</code> sehen, in welchen <code>master</code> Branch auf dem <code>origin</code> Remote du das letzte Mal mit dem Server kommuniziert hast:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .git/refs/remotes/origin/master
ca82a6dff817ec66f44342007202690a93763949</code></pre>
</div>
</div>
<div class="paragraph">
<p>Remote Referenzen unterscheiden sich von Branches (<code>refs/heads</code> Referenzen) hauptsächlich darin, dass sie als schreibgeschützt gelten.
Du kannst <code>git checkout</code> darauf ausführen, aber HEAD wird nicht symbolisch darauf referenzieren, so dass du es niemals mit einem <code>commit</code> Befehl aktualisieren kannst.
Git verwaltet sie als Lesezeichen für den letzten bekannten Status, in dem sich diese Branches auf diesen Servern befinden.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>