---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: de
  chapter:
    title: Git Branching
    number: 3
  section:
    title: Remote-Branches
    number: 5
    cs_number: '3.5'
    previous: book/de/v2/Git-Branching-Branching-Workflows
    next: book/de/v2/Git-Branching-Rebasing
title: Git - Remote-Branches
---
<h2 id="_remote_branches">Remote-Branches</h2>
<div class="paragraph">
<p>
Remote-Referenzen sind Referenzen (Zeiger) in deinem Remote-Repositorys, einschließlich Branches, Tags usw.
Du kannst eine vollständige, ausführliche Liste von Remote-Referenzen bekommen, wenn du die Anweisungen <code>git ls-remote &lt;remote&gt;</code> oder <code>git remote show &lt;remote&gt;</code> für Remote-Branches ausführst, sowie auch für weitere Informationen.
Der gängigerer Ansatz ist jedoch die Nutzung von Remote-Tracking-Branches.</p>
</div>
<div class="paragraph">
<p>Remote-Tracking-Branches sind Referenzen auf den Zustand von Remote-Branches.
Sie sind lokale Referenzen, die du nicht manuell ändern kannst. Sie werden automatisch für dich geändert, sobald du irgendeine Netzwerkkommunikation durchführst.
Betrachte sie als Lesezeichen, die daran erinnern, wo die Branches in deinem Remote-Repositorys das letzte Mal standen, als du dich mit ihnen verbunden hast.</p>
</div>
<div class="paragraph">
<p>Remote-Tracking-Branch-Namen haben die Form <code>&lt;remote&gt;/&lt;branch&gt;</code>.
Wenn du beispielsweise wissen möchtest, wie der Branch <code>master</code> in deinem Repository <code>origin</code> ausgesehen hat, als du zuletzt Kontakt mit ihm hattest, dann würdest du den Branch <code>origin/master</code> überprüfen.
Wenn du mit einem Mitstreiter an einem Problem gearbeitet hast und dieser bereits einen <code>iss53</code> Branch hochgeladen (gepusht) hat, besitzt du möglicherweise deinen eigenen lokalen <code>iss53</code> Branch. Der Branch auf dem Server würde jedoch vom Remote-Tracking-Branch <code>origin/iss53</code> dargestellt werden.</p>
</div>
<div class="paragraph">
<p>Das kann ein wenig verwirrend sein, lass uns also ein Beispiel betrachten.
Angenommen, du hast in deinem Netzwerk einen Git-Server mit der Adresse <code>git.ourcompany.com</code>.
Wenn du von diesem klonst, erhält der Server von der Git-Anweisung <code>clone</code> automatisch den Namen <code>origin</code>, lädt all seine Daten herunter, erstellt einen Zeiger auf dem <code>master</code> Branch zeigt und benennt ihn lokal <code>origin/master</code>.
Git gibt dir auch deinen eigenen lokalen <code>master</code> Branch mit der gleichen Ausgangsposition wie der <code>origin/master</code> Branch, damit du einen Punkt hast, wo du mit deiner Arbeit beginnen kannst.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Anmerkung</div>
</td>
<td class="content">
<div class="title">„origin“ ist nichts Besonderes</div>
<div class="paragraph">
<p>Genau wie der Branch-Name „master“ in Git keine besondere Bedeutung hat, hat auch „origin“ keine besondere Bedeutung.
Während „master“ die Standardbezeichnung für den Anfangsbranch ist, wenn du die Anweisung <code>git init</code> ausführst, was der einzige Grund dafür ist, warum er so weit verbreitet ist, wird „origin“ als Standardbezeichnung für ein entferntes Repository vergeben, wenn du die Anweisung <code>git clone</code> ausführst.
Wenn du stattdessen die Anweisung <code>git clone -o booyah</code> ausführen, erhältst du <code>booyah/master</code> als Standard-Remote-Branch.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/remote-branches-1.png" >}}" alt="Entfernte und lokale Repositorys nach dem Klonen">
</div>
<div class="title">Abbildung 30. Entfernte und lokale Repositorys nach dem Klonen</div>
</div>
<div class="paragraph">
<p>Wenn du ein wenig an deinem lokalen <code>master</code> Branch arbeitest und in der Zwischenzeit jemand anderes etwas zu <code>git.ourcompany.com</code> hochlädt und damit dessen <code>master</code> Branch aktualisiert, dann bewegen sich eure Verläufe unterschiedlich vorwärts.
Solange du keinen Kontakt mit deinem <code>origin</code> Server aufnimmst, bewegt sich dein <code>origin/master</code> Zeiger nicht.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/remote-branches-2.png" >}}" alt="Lokale und entfernte Änderungen können auseinanderlaufen">
</div>
<div class="title">Abbildung 31. Lokale und entfernte Änderungen können Auseinanderlaufen</div>
</div>
<div class="paragraph">
<p>Um deine Arbeit mit einem bestimmten Remote zu synchronisieren, führst du den Befehl <code>git fetch &lt;remote&gt;</code> aus (in unserem Fall <code>git fetch origin</code>).
Der Befehl sucht, welcher Server „origin“ ist (in diesem Fall <code>git.ourcompany.com</code>), holt alle Daten, die du noch nicht hast, und aktualisierst deine lokale Datenbank, indem er deinen <code>origin/master</code> Zeiger auf seine neue, aktuellere Position bewegt.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/remote-branches-3.png" >}}" alt="`git fetch` aktualisiert deine Remote-Tracking-Branches">
</div>
<div class="title">Abbildung 32. <code>git fetch</code> aktualisiert deine Remote-Tracking-Branches</div>
</div>
<div class="paragraph">
<p>Um den Umgang mit mehreren Remote-Servern zu veranschaulichen und um zu sehen, wie Remote-Branches bei diesen Remote-Projekten aussehen, nehmen wir an, dass du einen weiteren internen Git-Server hast, welcher von einem deiner Sprint-Teams nur zur Entwicklung genutzt wird.
Diesen Server erreichen wir unter <code>git.team1.ourcompany.com</code>.
Du kannst ihn zu dem Projekt, an dem du gegenwärtig arbeitest, als neuen Remote-Server hinzufügen, indem du die Anweisung <code>git remote add</code> ausführst, wie wir bereits in Kapitel 2 <a href="{{< relurl "book/de/v2/ch00/ch02-git-basics-chapter" >}}">Git Grundlagen</a> behandelt haben.
Wir nennen diesen Remote-Server <code>teamone</code>, was die Kurzbezeichnung für die gesamte URL sein wird.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/remote-branches-4.png" >}}" alt="Hinzufügen eines weiteren Remote-Servers">
</div>
<div class="title">Abbildung 33. Hinzufügen eines weiteren Remote-Servers</div>
</div>
<div class="paragraph">
<p>Jetzt kannst du mit der Anweisung <code>git fetch teamone</code> alles vom Server holen, was du noch nicht hast.
Da auf diesem Server nur eine Teilmenge der Daten ist, die sich genau jetzt auf deinem <code>origin</code> Server befinden, holt Git keine Daten ab, aber es erstellt einen Remote-Branch <code>teamone/master</code> so, dass er auf den Commit zeigt, den <code>teamone</code> als seinen <code>master</code> Branch hat.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/remote-branches-5.png" >}}" alt="Remote-Tracking-Branch für `teamone/master`">
</div>
<div class="title">Abbildung 34. Remote-Tracking-Branch für <code>teamone/master</code>
</div>
</div>
<div class="sect3">
<h3 id="_pushing_branches">Pushing/Hochladen</h3>
<div class="paragraph">
<p>
Wenn du einen Branch mit der Welt teilen möchtest, musst du ihn auf einen Remote-Server hochladen, auf dem du Schreibrechte besitzt.
Deine lokalen Branches, auf die du schreibst, werden nicht automatisch mit den Remotes synchronisiert – Du musst die Branches, die du freigeben möchtest, explizit pushen.
Auf diese Weise kannst du private Branches, die du nicht veröffentlichen willst, zum Arbeiten benutzen und nur die Feature-Branches pushen, an denen du mitarbeiten willst.</p>
</div>
<div class="paragraph">
<p>Wenn du einen Branch namens <code>serverfix</code> besitzt, an dem du mit anderen arbeiten möchtest, dann kannst du diesen auf dieselbe Weise Hochladen wie deinen ersten Branch.
Führe die Anweisung <code>git push &lt;remote&gt; &lt;branch&gt;</code> aus:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git push origin serverfix
Counting objects: 24, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (15/15), done.
Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.
Total 24 (delta 2), reused 0 (delta 0)
To https://github.com/schacon/simplegit
 * [new branch]      serverfix -&gt; serverfix</code></pre>
</div>
</div>
<div class="paragraph">
<p>Das ist eine Art Abkürzung.
Git erweitert den Branch-Namen <code>serverfix</code> automatisch zu <code>refs/heads/serverfix:refs/heads/serverfix</code>, was soviel bedeutet wie „Nimm meinen lokalen Branch <code>serverfix</code> und aktualisiere damit den <code>serverfix</code> Branch auf meinem Remote-Server“.
Wir werden den Teil <code>refs/heads/</code> in Kapitel 10 <a href="{{< relurl "book/de/v2/ch00/ch10-git-internals" >}}">Git Interna</a> noch näher beleuchten, du kannst ihn aber in der Regel auslassen.
Du kannst auch die Anweisung <code>git push origin serverfix:serverfix</code> ausführen, was das Gleiche bewirkt – es bedeutet „Nimm meinen <code>serverfix</code> und mach ihn zum <code>serverfix</code> des Remote-Servers“.
Du kannst dieses Format auch benutzen, um einen lokalen Branch in einen Remote-Branch mit anderem Namen zu pushen.
Wenn du nicht willst, dass er auf dem Remote als <code>serverfix</code> bezeichnet wird, kannst du stattdessen <code>git push origin serverfix:awesomebranch</code> ausführen, um deinen lokalen <code>serverfix</code> Branch auf den <code>awesomebranch</code> Branch im Remote-Projekt zu pushen.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Anmerkung</div>
</td>
<td class="content">
<div class="title">Geb dein Passwort nicht jedes Mal neu ein</div>
<div class="paragraph">
<p>Wenn du eine HTTPS-URL zum Übertragen verwendest, fragt der Git-Server nach deinem Benutzernamen und Passwort zur Authentifizierung.
Standardmäßig wirst du auf dem Terminal nach diesen Informationen gefragt, damit der Server erkennen kann, ob du pushen darfst.</p>
</div>
<div class="paragraph">
<p>Wenn du es nicht jedes Mal eingeben willst, wenn du etwas hochlädst, dann kannst du einen „credential cache“ einstellen.
Am einfachsten ist es, die Informationen nur für einige Minuten im Speicher zu behalten, was du einfach mit der Anweisung <code>git config --global credential.helper cache</code> bewerkstelligen kannst.</p>
</div>
<div class="paragraph">
<p>Weitere Informationen zu den verschiedenen verfügbaren „credential cache“ Optionen findest du in Kapitel 7 <a href="{{< relurl "book/de/v2/ch00/_credential_caching" >}}">Caching von Anmeldeinformationen</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Das nächste Mal, wenn einer deiner Mitstreiter Daten vom Server abholt, wird er eine Referenz auf die Server-Version des Branches <code>serverfix</code> unter dem Remote-Branch <code>origin/serverfix</code> erhalten:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git fetch origin
remote: Counting objects: 7, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://github.com/schacon/simplegit
 * [new branch]      serverfix    -&gt; origin/serverfix</code></pre>
</div>
</div>
<div class="paragraph">
<p>Es ist wichtig zu beachten, dass du bei einem Abruf, der neue Remote-Tracking-Branches abruft, nicht automatisch über lokale, bearbeitbare Kopien davon verfügst.
Mit anderen Worten, in diesem Fall hast du keinen neuen Branch <code>serverfix</code> – Du hast nur einen Zeiger <code>origin/serverfix</code>, den du nicht ändern kannst.</p>
</div>
<div class="paragraph">
<p>Um diese Änderungen in deinem gegenwärtigen Arbeitsbranch einfließen zu lassen, kannst du die Anweisung <code>git merge origin/serverfix</code> ausführen.
Wenn du deinen eigenen <code>serverfix</code> Branch haben willst, an dem du arbeiten kannst, kannst du ihn von deinem Remote-Tracking-Branch ableiten (engl. base):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b serverfix origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Das erstellt dir einen lokalen Branch, an dem du arbeiten kannst, und der dort beginnt, wo <code>origin/serverfix</code> derzeit steht.</p>
</div>
</div>
<div class="sect3">
<h3 id="_tracking_branches">Tracking-Branches</h3>
<div class="paragraph">
<p>
Das Auschecken eines lokalen Branches von einem Remote-Branch erzeugt automatisch einen sogenannten „Tracking-Branch“ (oder manchmal einen „Upstream-Branch“).
Tracking-Branches sind lokale Branches, die eine direkte Beziehung zu einem Remote-Branch haben.
Wenn du dich auf einem Tracking-Branch befindest und <code>git pull</code> eingibst, weiß Git automatisch, von welchem Server Daten abzuholen sind und in welchen Branch diese einfließen sollen.</p>
</div>
<div class="paragraph">
<p>Wenn du ein Repository klonst, wird automatisch ein <code>master</code> Branch erzeugt, welcher <code>origin/master</code> trackt.
Du kannst jedoch auch andere Tracking-Branches erzeugen, wenn du wünschst – welche die Branches auf anderen Remotes folgen.
Der einfachste Fall ist das Beispiel, dass du gerade gesehen hast, die Ausführung der Anweisung <code>git checkout -b &lt;branch&gt; &lt;remotename&gt;/&lt;branch&gt;</code>.
Das ist eine übliche Operation, für die Git die Kurzform <code>--track</code> bereitstellt:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout --track origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'</code></pre>
</div>
</div>
<div class="paragraph">
<p>In der Tat ist dies so weit verbreitet, dass es sogar eine Abkürzung für diese Abkürzung gibt.
Wenn der Branch-Name, den du zum Auschecken verwenden möchtest (a), nicht existiert und (b) genau mit einem Namen auf nur einem Remote übereinstimmt, erstellt Git einen Tracking-Branch für dich:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Um einen lokalen Branch mit einem anderen Namen als den entfernten Branch einzurichten, kannst du die erste Version mit einem anderen lokalen Branch-Namen verwenden:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b sf origin/serverfix
Branch sf set up to track remote branch serverfix from origin.
Switched to a new branch 'sf'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nun wird dein lokaler Branch <code>sf</code> automatisch von <code>origin/serverfix</code> pullen.</p>
</div>
<div class="paragraph">
<p>Wenn du bereits über einen lokalen Branch verfügst und ihn auf einen Remote-Branch festlegen möchtest, den du gerade gepullt hast, oder auf den von dir gefolgten Upstream-Branch ändern möchtest, kannst du die Option <code>-u</code> oder <code>--set-upstream-to</code> für <code>git branch</code> verwenden, um es jederzeit festzulegen.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch -u origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Anmerkung</div>
</td>
<td class="content">
<div class="title">Upstream-Kürzel</div>
<div class="paragraph">
<p>Wenn du einen Tracking-Branch eingerichtet hast, kannst du auf seinen Upstream-Branch mit der Kurzform <code>@{upstream}</code> oder <code>@{u}</code> verweisen.
Wenn du also auf dem <code>master</code> Branch bist und er <code>origin/master</code> folgt, kannst du, so etwas wie <code>git merge @{u}</code> anstelle von <code>git merge origin/master</code> verwenden.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Wenn du die Tracking-Branches sehen willst, die du eingerichtet hast, kannst du die Anweisung <code>git branch</code> zusammen mit der Option <code>-vv</code> ausführen.
Das listet deine lokalen Branches zusammen mit weiteren Informationen auf, einschließlich was jeder Branch trackt und ob dein lokaler Branch voraus oder zurück liegt, oder auch beides.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch -vv
  iss53     7e424c3 [origin/iss53: ahead 2] Add forgotten brackets
  master    1ae2a45 [origin/master] Deploy index fix
* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] This should do it
  testing   5ea463a Try something new</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hier können wir also sehen, dass unser <code>iss53</code> Branch den Branch <code>origin/iss53</code> folgt und die Information „ahead 2“ bedeutet, dass wir zwei lokale Commits haben, welche noch nicht auf den Server hochgeladen wurden.
Wir können außerdem sehen, dass unser <code>master</code> Branch <code>origin/master</code> folgt und auf den neuesten Stand ist.
Als nächstes sehen wir, dass unser <code>serverfix</code> Branch den Branch <code>server-fix-good</code> auf unserem Server <code>teamone</code> folgt. „ahead 3, behind 1“ bedeutet, dass es einen Commit auf dem Server gibt, den wir noch nicht gemerged haben, und drei lokale Commits existieren, die wir noch nicht gepusht haben.
Zum Schluss können wir sehen, dass unser <code>testing</code> Branch gar keinen Remote-Branch folgt.</p>
</div>
<div class="paragraph">
<p>Es ist wichtig zu beachten, dass diese Zahlen den Zustand zu dem Zeitpunkt beschreiben, als du zum letzten Mal Daten vom Server abgeholt hast.
Diese Anweisung greift nicht auf die Server zu, sie liefert nur die Informationen, welche beim letzten Server-Kontakt lokal zwischengespeichert wurden.
Wenn du gänzlich aktuelle Zahlen von „ahead“ und „behind“ willst, dann musst du, kurz bevor du die Anweisung ausführst, von all deinen Remote-Servern Daten abholen (fetch).
Du kannst das so machen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git fetch --all; git branch -vv</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_pullingherunterladen">Pulling/Herunterladen</h3>
<div class="paragraph">
<p>
Die Anweisung <code>git fetch</code> holt alle Änderungen auf dem Server ab, die du zurzeit noch nicht hast. In deinem Arbeitsverzeichnis wird sie jedoch überhaupt nichts verändern.
Sie wird einfach die Daten für dich holen und dir das Zusammenführen überlassen.
Es gibt jedoch die Anweisung <code>git pull</code>, welche im Grunde genommen ein <code>git fetch</code> ist, dem in den meisten Fällen augenblicklich ein <code>git merge</code> folgt.
Wenn du einen Tracking-Branch eingerichtet hast, wie im letzten Abschnitt gezeigt, indem du ihn explizit setzt oder indem du ihn mit den Befehlen <code>clone</code> oder <code>checkout</code> für dich hast erstellen lassen, dann sucht <code>git pull</code> nach dem Server und dem getrackten Branch. Git macht ein fetch vom Server und versucht dann diesen remote branch zu mergen.</p>
</div>
<div class="paragraph">
<p>Generell ist es besser, einfach explizit die Anweisungen <code>git fetch</code> und <code>git merge</code> zu benutzen, da die Magie der Anweisung <code>git pull</code> häufig verwirrend sein kann.</p>
</div>
</div>
<div class="sect3">
<h3 id="_delete_branches">Remote-Branches entfernen</h3>
<div class="paragraph">
<p>
Stellen wir uns vor, du bist mit deinem Remote-Branch fertig. Du und deine Kollegen sind fertig mit einer neuen Funktion und haben sie in den Branch <code>master</code> des Remote-Servers (oder in welchem Branch auch immer sich dein stabiler Code befindet) einfließen lassen.
Du kannst einen Remote-Branch löschen, indem du die Anweisung <code>git push</code> zusammen mit der Option <code>--delete</code> ausführst.
Wenn du deinen <code>serverfix</code> Branch vom Server löschen willst, führst du folgende Anweisung aus:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git push origin --delete serverfix
To https://github.com/schacon/simplegit
 - [deleted]         serverfix</code></pre>
</div>
</div>
<div class="paragraph">
<p>Im Grunde genommen ist alles, was das bewirkt, dass der Zeiger vom Server entfernt wird.
Der Git-Server bewahrt die Daten dort in der Regel eine Weile auf, bis eine Speicherbereinigung läuft. Wenn sie also versehentlich gelöscht wurden, ist es oft einfach, sie wiederherzustellen.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>