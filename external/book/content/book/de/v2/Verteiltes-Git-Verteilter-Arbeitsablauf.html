---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: de
  chapter:
    title: Verteiltes Git
    number: 5
  section:
    title: Verteilter Arbeitsablauf
    number: 1
    cs_number: '5.1'
    previous: book/de/v2/Git-auf-dem-Server-Zusammenfassung
    next: book/de/v2/Verteiltes-Git-An-einem-Projekt-mitwirken
title: Git - Verteilter Arbeitsablauf
---
<p>
Nachdem du ein entferntes Git-Repository eingerichtet hast, in dem alle Entwickler ihren Code teilen können, und du mit den grundlegenden Git-Befehlen in einem lokalen Arbeitsablauf vertraut bist, wirst du einige der verteilten Arbeitsabläufe verwenden, die Git dir ermöglicht.</p><p>In diesem Kapitel erfährst du, wie du mit Git in einer verteilten Umgebung als Mitwirkender (engl. Contributor) und Integrator arbeitest. Das heißt, du lernst, wie du Quelltext erfolgreich zu einem Projekt beisteuern und es dir und dem Projektbetreuer so einfach wie möglich machst. Außerdem lernst du, wie du ein Projekt erfolgreich verwaltest, in dem mehrere Entwicklern Inhalte beisteuern.</p>
<h2 id="_verteilter_arbeitsablauf">Verteilter Arbeitsablauf</h2>
<div class="paragraph">
<p>
Im Gegensatz zu CVCSs (Centralized Version Control Systems – Zentrale Versionsverwaltungs Systeme) kannst du dank der verteilten Struktur von Git die Zusammenarbeit von Entwicklern in Projekten wesentlich flexibler gestalten.
In zentralisierten Systemen ist jeder Entwickler ein gleichwertiger Netzknoten, der mehr oder weniger gleichermaßen mit einem zentralen System arbeitet.
In Git ist jedoch jeder Entwickler potentiell beides – sowohl Netzknoten als auch zentrales System. Das heißt, jeder Entwickler kann sowohl Code für andere Repositorys bereitstellen als auch ein öffentliches Repository verwalten, auf dem andere ihre Arbeit aufbauen und zu dem sie beitragen können.
Dies bietet eine Fülle von möglichen Arbeitsabläufen (engl. Workflows) für dein Projekt und/oder deinem Team, sodass wir einige gängige Paradigmen behandeln, welche die Vorteile dieser Flexibilität nutzen.
Wir werden auf die Stärken und möglichen Schwächen der einzelnen Entwürfe eingehen. Du kannst einen einzelnen davon auswählen, um ihn zu nutzen, oder du kannst die Funktionalitäten von allen miteinander kombinieren.</p>
</div>
<div class="sect3">
<h3 id="_zentralisierter_arbeitsablauf">Zentralisierter Arbeitsablauf</h3>
<div class="paragraph">
<p>
In zentralisierten Systemen gibt es im Allgemeinen ein einziges Modell für die Zusammenarbeit – den zentralisierten Arbeitsablauf.
Ein zentraler Hub oder <em>Repository</em> kann Quelltext akzeptieren und alle Beteiligten synchronisieren ihre Arbeit damit.
Eine Reihe von Entwicklern sind Netzknoten – Nutzer dieses Hubs – und synchronisieren ihre Arbeit mit diesem einen, zentralen Punkt.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/centralized_workflow.png" >}}" alt="Zentralisierter Arbeitsablauf">
</div>
<div class="title">Abbildung 53. Zentralisierter Arbeitsablauf</div>
</div>
<div class="paragraph">
<p>Dies bedeutet, wenn zwei Entwickler ein Repository vom Hub klonen und beide Änderungen vornehmen, kann der erste Entwickler seine Änderungen problemlos zurückspielen (pushen).
Der zweite Entwickler muss jedoch die Arbeit des ersten Entwicklers bei sich einfließen lassen (mergen), bevor seine Änderungen aufgenommen werden können, damit die Änderungen des ersten Entwicklers nicht überschrieben werden.
Dieses Konzept ist in Git genauso wahr wie in Subversion (oder ein anderes beliebiges CVCS), und dieses Konzept funktioniert in Git wunderbar.</p>
</div>
<div class="paragraph">
<p>Wenn du bereits mit einem zentralisierten Arbeitsablauf in deinem Unternehmen oder Team vertraut bist, kannst du diesen Ablauf problemlos mit Git weiterverwenden.
Richte einfach ein einziges Repository ein und gewähre allen Mitgliedern deines Teams Schreib-Zugriff (push). Git lässt nicht zu, dass Benutzer ihre Änderungen gegenseitig überschreiben.</p>
</div>
<div class="paragraph">
<p>Sagen wir, John und Jessica fangen beide zur gleichen Zeit mit ihrer Arbeit an.
John beendet seine Änderung und lädt diese zum Server hoch.
Dann versucht Jessica, ihre Änderungen hochzuladen, aber der Server lehnt sie ab.
Ihr wird gesagt, dass sie versucht, Änderungen „non-fast-forward“ zu pushen, und dass sie dies erst tun kann, wenn sie die bestehenden Änderungen abgeholt und mit ihrer lokalen Kopie zusammengeführt hat.
Dieser Workflow ist für viele Menschen sehr ansprechend, weil er ein bewährtes Modell ist, mit dem viele bereits bekannt und vertraut sind.</p>
</div>
<div class="paragraph">
<p>Diese Vorgehensweise ist nicht auf kleine Teams beschränkt.
Mit dem Verzweigungs-Modell (Branching-Modell) von Git ist es Hunderten von Entwicklern möglich, ein einzelnes Projekt über Dutzende von Branches gleichzeitig erfolgreich zu bearbeiten.</p>
</div>
</div>
<div class="sect3">
<h3 id="_integration_manager">Arbeitsablauf mit Integrationsmanager</h3>
<div class="paragraph">
<p>
Da du in Git über mehrere Remote-Repositorys verfügen kannst, ist ein Workflow möglich, bei dem jeder Entwickler Schreibzugriff auf sein eigenes, öffentliches Repository und Lesezugriff auf die Repositorys aller anderen Entwickler hat.
Dieses Szenario enthält häufig ein zentrales Repository, das das „offizielle“ Projekt darstellt.
Um zu diesem Projekt beizutragen, erstellst du deinen eigenen öffentlichen Klon des Projekts und lädst deine Änderungen dort hoch.
Anschließend kannst du eine Anfrage an den Betreuer des Hauptprojekts senden, um deine Änderungen zu übernehmen (Pull Request).
Der Betreuer kann dann dein Repository als Remote hinzufügen, deine Änderungen lokal testen, diese in seinem Branch einfließen lassen und in sein öffentliches Repository hochladen.
Der Prozess funktioniert wie folgt (siehe <a href="{{< relurl "book/de/v2/ch00/wfdiag_b" >}}">Arbeitsablauf mit Integrationsmanager</a>):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Die Projekt Betreuer laden Arbeit in ihr eigenes, öffentlichen Repository hoch.</p>
</li>
<li>
<p>Ein Mitwirkender klont dieses Repository und nimmt Änderungen vor.</p>
</li>
<li>
<p>Der Mitwirkende lädt diese in sein eigenes öffentliches Repository hoch.</p>
</li>
<li>
<p>Der Mitwirkende sendet dem Betreuer eine E-Mail mit der Aufforderung, die Änderungen zu übernehmen (Pull Request).</p>
</li>
<li>
<p>Der Betreuer fügt das Repository des Mitwirkenden als Remote hinzu und führt die Änderungen lokal zusammen.</p>
</li>
<li>
<p>Der Betreuer lädt die zusammengeführten Änderungen in das Haupt-Repository hoch.</p>
</li>
</ol>
</div>
<div id="wfdiag_b" class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/integration-manager.png" >}}" alt="Arbeitsablauf mit Integrationsmanager">
</div>
<div class="title">Abbildung 54. Arbeitsablauf mit Integrationsmanager</div>
</div>
<div class="paragraph">
<p>
Dies ist ein sehr häufiger Workflow mit Hub-basierten Tools wie GitHub oder GitLab, bei dem es einfach ist, ein Projekt zu „forken“ und eigene Änderungen in deinen Fork hochzuladen, damit jeder sie sehen kann.
Einer der Hauptvorteile dieses Ansatzes besteht darin, dass du weiterarbeiten kannst und der Verwalter des Haupt-Repositorys deine Änderungen jederzeit übernehmen kann.
Die Mitwirkenden müssen nicht warten, bis das Projekt deine Änderungen übernommen hat – jede Partei kann in ihrem eigenen Tempo arbeiten.</p>
</div>
</div>
<div class="sect3">
<h3 id="_arbeitsablauf_mit_diktator_und_leutnants">Arbeitsablauf mit Diktator und Leutnants</h3>
<div class="paragraph">
<p>
Dies ist eine Variante eines Workflows mit vielen Repositorys.
Sie wird im Allgemeinen von großen Projekten mit Hunderten von Mitstreitern verwendet. Ein berühmtes Beispiel ist der Linux-Kernel.
Verschiedene Integrationsmanager sind für bestimmte Teile des Repositorys verantwortlich. Sie heißen <em>Leutnants</em>.
Alle Leutnants haben einen Integrationsmanager, der als der wohlwollende Diktator (benevolent dictator) bezeichnet wird.
Der wohlwollende Diktator pusht von seinem Verzeichnis in ein Referenz-Repository, aus dem alle Beteiligten ihre eigenen Repositorys aktualisieren müssen.
Dieser Prozess funktioniert wie folgt (siehe <a href="{{< relurl "book/de/v2/ch00/wfdiag_c" >}}">Arbeitsablauf mit wohlwollendem Diktator</a>):</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Entwickler arbeiten regelmäßig an ihrem Featurebranch und reorganisieren (rebasen) ihre Arbeit auf <code>master</code>.
Der <code>master</code> Branch ist der des Referenz-Repositorys, in das der Diktator pusht.</p>
</li>
<li>
<p>Die Leutnants mergen die Featurebranches der Entwickler in ihrem <code>master</code> Branch.</p>
</li>
<li>
<p>Der Diktator führt die <code>master</code> Branches der Leutnants in den Branch <code>master</code> des Diktators zusammen.</p>
</li>
<li>
<p>Schließlich pusht der Diktator diesen <code>master</code> Branch in das Referenz-Repository, damit die anderen Entwickler darauf einen Rebase durchführen können.</p>
</li>
</ol>
</div>
<div id="wfdiag_c" class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/benevolent-dictator.png" >}}" alt="Arbeitsablauf mit wohlwollendem Diktator">
</div>
<div class="title">Abbildung 55. Arbeitsablauf mit wohlwollendem Diktator</div>
</div>
<div class="paragraph">
<p>Diese Art von Arbeitsablauf ist nicht weit verbreitet, kann jedoch in sehr großen Projekten oder in sehr hierarchischen Umgebungen hilfreich sein.
Dies ermöglicht dem Projektleiter (dem Diktator), einen Großteil der Arbeit zu delegieren und große Teilbereiche von Quelltext an mehreren Stellen zu sammeln, bevor diese integriert werden.</p>
</div>
</div>
<div class="sect3">
<h3 id="_patterns_for_managing_source_code_branches">Methoden zur Verwaltung von Quellcode-Branches</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Anmerkung</div>
</td>
<td class="content">
<div class="paragraph">
<p>Martin Fowler hat den Leitfaden „Patterns for Managing Source Code Branches“ (Methoden zur Verwaltung von Quellcode-Branches) erstellt.
Dieser Leitfaden deckt alle gängigen Git-Workflows ab und erklärt, wie und wann sie eingesetzt werden sollten.
Es gibt auch einen Abschnitt, in dem hohe und niedrige Integrationsfrequenzen verglichen werden.</p>
</div>
<div class="paragraph">
<p><a href="https://martinfowler.com/articles/branching-patterns.html" class="bare" target="_blank" rel="noopener">https://martinfowler.com/articles/branching-patterns.html</a></p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h3 id="_zusammenfassung_5">Zusammenfassung</h3>
<div class="paragraph">
<p>Dies sind einige häufig verwendete Workflows, die mit einem verteilten System wie Git möglich sind. Allerdings sind auch viele Variationen möglich, um deinen eigenen Arbeitsabläufen gerecht zu werden.
Jetzt, da du (hoffentlich) bestimmen kannst, welche Kombination von Arbeitsabläufen bei dir funktionieren würde, werden wir einige spezifischere Beispiele davon betrachten, wie man die Hauptaufgaben durchführen kann, welche die unterschiedliche Abläufe ausmachen.
Im nächsten Abschnitt erfährst du etwas über gängige Formen der Mitarbeit an einem Projekt.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>