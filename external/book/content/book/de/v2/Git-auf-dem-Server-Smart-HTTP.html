---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: de
  chapter:
    title: Git auf dem Server
    number: 4
  section:
    title: Smart HTTP
    number: 6
    cs_number: '4.6'
    previous: book/de/v2/Git-auf-dem-Server-Git-Daemon
    next: book/de/v2/Git-auf-dem-Server-GitWeb
title: Git - Smart HTTP
---
<h2 id="_smart_http_2">Smart HTTP</h2>
<div class="paragraph">
<p>
Wir haben jetzt authentifizierten Zugriff über SSH und nicht authentifizierten Zugriff über <code>git://</code>, aber es gibt auch ein Protokoll, das beides gleichzeitig kann.
Die Einrichtung von Smart HTTP ist im Grunde genommen nur die Aktivierung eines CGI-Skripts, das zusammen mit Git namens <code>git-http-backend</code> auf dem Server bereitgestellt wird.
Dieses CGI liest den Pfad und die Header, die von einem <code>git fetch</code> oder <code>git push</code> an eine HTTP-URL gesendet werden, und bestimmt, ob der Client über HTTP kommunizieren kann (was für jeden Client ab Version 1.6.6 gilt).
Wenn das CGI sieht, dass der Client intelligent ist, kommuniziert es intelligent mit ihm; andernfalls fällt es auf das dumme Verhalten zurück (also ist es rückwärtskompatibel für Lesezugriffe mit älteren Clients).</p>
</div>
<div class="paragraph">
<p>Lass uns durch ein sehr einfaches Setup gehen.
Wir werden Apache als CGI-Server verwenden.
Wenn du kein Apache-Setup hast, kannst du dies auf einem Linux-System, wie nachfolgend beschrieben einrichten:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ sudo apt-get install apache2 apache2-utils
$ a2enmod cgi alias env</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dadurch werden auch die Module <code>mod_cgi</code>, <code>mod_alias</code>, und <code>mod_env</code> aktiviert, die alle benötigt werden, damit das Ganze ordnungsgemäß funktioniert.</p>
</div>
<div class="paragraph">
<p>Du solltest auch die Unix-Benutzergruppe im Verzeichnis <code>/srv/git</code> auf <code>www-data</code> setzen, damit dein Webserver auf die Repositorys lesend und schreibend zugreifen kann. Die Apache-Instanz, auf der das CGI-Skript läuft, wird standardmäßig unter dieser Benutzer laufen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ chgrp -R www-data /srv/git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Als nächstes müssen wir der Apache-Konfiguration einige Dinge hinzufügen, um das <code>git-http-backend</code> als Handler für alles, was im`/git` Pfad dein Webservers liegt, auszuführen.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">SetEnv GIT_PROJECT_ROOT /srv/git
SetEnv GIT_HTTP_EXPORT_ALL
ScriptAlias /git/ /usr/lib/git-core/git-http-backend/</code></pre>
</div>
</div>
<div class="paragraph">
<p>Wenn du die Umgebungsvariable <code>GIT_HTTP_EXPORT_ALL</code> nicht setzt, wird Git unauthentifizierten Clients nur die Repositorys, die die Datei <code>git-daemon-export-ok</code> enthalten, zur Verfügung stellen. Das Verhalten ist dann wie beim Git-Daemon.</p>
</div>
<div class="paragraph">
<p>Abschließend konfigurierst du Apache so, dass er Anfragen an das <code>git-http-backend</code> zulassen soll, um Schreibvorgänge zu authentifiziert. Dazu kannst du folgenden Code nutzen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">&lt;Files "git-http-backend"&gt;
    AuthType Basic
    AuthName "Git Access"
    AuthUserFile /srv/git/.htpasswd
    Require expr !(%{QUERY_STRING} -strmatch '*service=git-receive-pack*' || %{REQUEST_URI} =~ m#/git-receive-pack$#)
    Require valid-user
&lt;/Files&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dazu musst du eine <code>.htpasswd</code> Datei erstellen, die die Passwörter aller gültigen Benutzer enthält.
Hier ein Beispiel für das Hinzufügen eines Benutzers „schacon“:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ htpasswd -c /srv/git/.htpasswd schacon</code></pre>
</div>
</div>
<div class="paragraph">
<p>Es gibt unzählige Möglichkeiten, Benutzer mit Apache zu authentifizieren.
Du musst eine von ihnen auswählen und implementieren.
Dies ist ein einfaches Beispiel. Du wirst dies wahrscheinlich über SSL konfigurieren wollen, damit auch alle Daten verschlüsselt werden.</p>
</div>
<div class="paragraph">
<p>Wir wollen nicht zu weit in das Konzept der Apache-Konfigurationsspezifikationen eindringen, da du möglicherweise einen anderen Server verwendst oder andere Authentifizierungsanforderungen hast.
Die Idee ist, dass Git mit einem CGI mit dem Namen <code>git-http-backend</code> daherkommt, das beim Senden und Empfangen von Daten die Kommunikation über HTTP aushandelt.
Es implementiert selbst keine Authentifizierung, aber diese kann über den Webservers gesteuert werden.
Du kannst das mit fast jedem CGI-fähigen Webserver tun. Am besten wählst du denjenigen, den du am besten kennst.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Anmerkung</div>
</td>
<td class="content">
<div class="paragraph">
<p>Weitere Informationen zur Konfiguration der Authentifizierung in Apache findest du in den Apache-Dokumenten unter: <a href="https://httpd.apache.org/docs/current/howto/auth.html" class="bare" target="_blank" rel="noopener">https://httpd.apache.org/docs/current/howto/auth.html</a></p>
</div>
</td>
</tr>
</table>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>