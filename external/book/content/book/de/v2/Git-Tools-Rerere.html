---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: de
  chapter:
    title: Git Tools
    number: 7
  section:
    title: Rerere
    number: 9
    cs_number: '7.9'
    previous: book/de/v2/Git-Tools-Fortgeschrittenes-Merging
    next: book/de/v2/Git-Tools-Debuggen-mit-Git
title: Git - Rerere
---
<h2 id="ref_rerere">Rerere</h2>
<div class="paragraph">
<p>Der Befehl <code>git rerere</code> ist eine eher versteckte Funktion.
Der Name steht für „reuse recorded resolution“ (dt. „gespeicherte Ergebnisse wiederverwenden“). Der Name bedeutet, dass du Git auffordern kannst sich zu erinnern, wie du einen bestimmten Konflikt in der Vergangenheit gelöst hast. Wenn Git das nächste Mal den gleichen Konflikt sieht, kann es ihn automatisch lösen.</p>
</div>
<div class="paragraph">
<p>Es gibt eine Reihe von Szenarien, in denen diese Funktionalität wirklich nützlich sein kann.
Eines der Beispiele, das in der Dokumentation erwähnt wird, ist sicher zu stellen, dass ein langlebiger Feature-Branch am Ende sauber gemerged wird. Dabei willst du jedoch nicht, dass eine Menge zwischenzeitlicher Merge-Commits deine Commit-Historie durcheinander bringt.
Wenn <code>rerere</code> aktiviert ist, kannst du ab und zu einen Merge starten, die Konflikte lösen und dann den Merge-Prozess stoppen.
Falls du das kontinuierlich tust, sollte der finale Merge recht unkompliziert sein, denn <code>rerere</code> kann alles für dich automatisch erledigen.</p>
</div>
<div class="paragraph">
<p>Dieselbe Vorgehensweise kann angewendet werden, wenn du einen Branch rebased, damit du dich nicht jedes Mal mit denselben Konflikten beim Rebase auseinandersetzen musst.
Oder wenn du einen Branch, den du schon gemerged und eine Reihe von Konflikten behoben hast dich dann jedoch ein Rebase entscheidest. Dann musst du wahrscheinlich nicht alle Konflikte nochmal lösen.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Eine weitere Einsatzmöglichkeit von `rerere` ist, wenn man eine Reihe sich fortentwickelnden Feature-Branches gelegentlich zu einem testbarem Head zusammenfügt, so wie es das Git-Projekt oft selbst praktiziert.
Wenn die Tests fehlschlagen, kannst du die Merges rückgängig machen und sie ohne den fehlerhaften Feature-Branch, erneut starten, ohne die Konflikte erneut auflösen zu müssen.</pre>
</div>
</div>
<div class="paragraph">
<p>Um die Funktion <code>rerere</code> zu aktivieren, musst du nur die folgende Config-Einstellung verwenden:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global rerere.enabled true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Du kannst sie auch einschalten, indem du das Verzeichnis <code>.git/rr-cache</code> in einem konkreten Repository erstellst. Die Konfigurationseinstellung ist allerdings eindeutiger und aktiviert diese Funktion global.</p>
</div>
<div class="paragraph">
<p>Sehen wir uns nun ein einfaches Beispiel an, das unserem vorherigen ähnlich ist.
Nehmen wir an, wir haben eine Datei namens <code>hello.rb</code>, die so aussieht:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
  puts 'hello world'
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>In dem einen Branch ändern wir das Wort „hello“ in „hola“, in dem anderen Branch ändern wir „world“ in „mundo“, wie gehabt.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/rerere1.png" >}}" alt="Zwei Branches ändern die selbe Stelle unterschiedlich">
</div>
<div class="title">Abbildung 160. Zwei Branches ändern die selbe Stelle unterschiedlich</div>
</div>
<div class="paragraph">
<p>Wenn wir beiden Branches mergen, bekommen wir einen Merge-Konflikt:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge i18n-world
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Recorded preimage for 'hello.rb'
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Beachte die neue Zeile <code>Recorded preimage for FILE</code>.
Der Rest sollte genauso wie bei ein normaler Merge-Konflikt aussehen.
An dieser Stelle kann <code>rerere</code> uns ein paar Dinge sagen.
Normalerweise kannst du an diesem Punkt <code>git status</code> ausführen, um alle Konflikte zu sehen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
# On branch master
# Unmerged paths:
#   (use "git reset HEAD &lt;file&gt;..." to unstage)
#   (use "git add &lt;file&gt;..." to mark resolution)
#
#	both modified:      hello.rb
#</code></pre>
</div>
</div>
<div class="paragraph">
<p>Allerdings wird dir <code>git rerere</code> auch mitteilen, was es im Pre-Merge Status mit <code>git rerere status</code> aufgezeichnet hat:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rerere status
hello.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ein <code>git rerere diff</code> zeigt den aktuellen Status der Lösung – womit du angefangen hast und welche Lösung du gefunden hast.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rerere diff
--- a/hello.rb
+++ b/hello.rb
@@ -1,11 +1,11 @@
 #! /usr/bin/env ruby

 def hello
-&lt;&lt;&lt;&lt;&lt;&lt;&lt;
-  puts 'hello mundo'
-=======
+&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
   puts 'hola world'
-&gt;&gt;&gt;&gt;&gt;&gt;&gt;
+=======
+  puts 'hello mundo'
+&gt;&gt;&gt;&gt;&gt;&gt;&gt; i18n-world
 end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Außerdem (und das hat nicht wirklich etwas mit <code>rerere</code> zu tun) kannst du <code>git ls-files -u</code> verwenden, um dir die in Konflikt stehenden Dateien anzusehen (inklusive der vorherigen, linken und rechten Version):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git ls-files -u
100644 39804c942a9c1f2c03dc7c5ebcd7f3e3a6b97519 1	hello.rb
100644 a440db6e8d1fd76ad438a49025a9ad9ce746f581 2	hello.rb
100644 54336ba847c3758ab604876419607e9443848474 3	hello.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jetzt kannst du es einfach zu <code>puts 'hola mundo'</code> auflösen. Dann kannst du noch einmal <code>git rerere diff</code> starten, um zu sehen, woran rerere sich erinnern wird:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rerere diff
--- a/hello.rb
+++ b/hello.rb
@@ -1,11 +1,7 @@
 #! /usr/bin/env ruby

 def hello
-&lt;&lt;&lt;&lt;&lt;&lt;&lt;
-  puts 'hello mundo'
-=======
-  puts 'hola world'
-&gt;&gt;&gt;&gt;&gt;&gt;&gt;
+  puts 'hola mundo'
 end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Das heißt im Grunde genommen: wenn Git in einer <code>hello.rb</code> Datei, die „hello mundo“ auf der einen Seite und „hola world“ auf der anderen Seite enthält, einen Konflikt erkennt und ihn zu „hola mundo“ auflöst.</p>
</div>
<div class="paragraph">
<p>Jetzt können wir ihn als gelöst markieren und committen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add hello.rb
$ git commit
Recorded resolution for 'hello.rb'.
[master 68e16e5] Merge branch 'i18n'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Du kannst sehen, dass es die „Lösung für DATEI gespeichert hat“ (Recorded resolution for FILE).</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/rerere2.png" >}}" alt="Aufgezeichnete Auflösung für FILE">
</div>
<div class="title">Abbildung 161. Aufgezeichnete Auflösung für FILE</div>
</div>
<div class="paragraph">
<p>Machen wir jetzt diesen Merge rückgängig und legen ihn stattdessen dann auf unseren Branch <code>master</code>.
Wir können unseren Branch zurücksetzen, indem wir <code>git reset</code> anwenden, wie wir es in <a href="{{< relurl "book/de/v2/ch00/_git_reset" >}}">Reset entzaubert</a> beschrieben haben.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git reset --hard HEAD^
HEAD is now at ad63f15 i18n the hello</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unser Merge wurde rückgängig gemacht.
Lass uns jetzt den Feature-Branch rebasen.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout i18n-world
Switched to branch 'i18n-world'

$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: i18n one word
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved 'hello.rb' using previous resolution.
Failed to merge in the changes.
Patch failed at 0001 i18n one word</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nun haben wir den erwarteten Merge-Konflikt, aber schaue dir die Zeile <code>Resolved FILE using previous resolution</code> an.
Wenn wir die Datei betrachten, sehen wir, dass der Konflikt bereits gelöst ist. Es gibt keine Marker für den Merge-Konflikt in der Datei.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
  puts 'hola mundo'
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Zudem wird dir <code>git diff</code> zeigen, wie es erneut automatisch gelöst wurde:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --cc hello.rb
index a440db6,54336ba..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/de/v2/images/rerere3.png" >}}" alt="Automatisch aufgelöster merge Konflikt" width="der eine vorherige Auflösung nutzt">
</div>
<div class="title">Abbildung 162. Automatisch aufgelöster merge Konflikt, der eine vorherige Auflösung nutzt</div>
</div>
<div class="paragraph">
<p>Du kannst den Status der Konfliktdatei auch mit <code>git checkout</code> wiederherstellen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout --conflict=merge hello.rb
$ cat hello.rb
#! /usr/bin/env ruby

def hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; ours
  puts 'hola world'
=======
  puts 'hello mundo'
&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ein Beispiel dafür haben wir in <a href="{{< relurl "book/de/v2/ch00/_advanced_merging" >}}">Fortgeschrittenes Merging</a> kennengelernt.
Vorerst sollten wir das Problem dadurch lösen, dass wir <code>git rerere</code> noch einmal starten:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rerere
Resolved 'hello.rb' using previous resolution.
$ cat hello.rb
#! /usr/bin/env ruby

def hello
  puts 'hola mundo'
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Wir haben die Datei automatisch mit der mit <code>rerere</code> zwischengespeicherten Lösung erneut gelöst.
Du kannst es nun hinzufügen und den Rebase fortsetzen, um ihn fertigzustellen.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add hello.rb
$ git rebase --continue
Applying: i18n one word</code></pre>
</div>
</div>
<div class="paragraph">
<p>Wenn du also viele Re-Merges machst oder einen Topic-Branch mit deinem Branch <code>master</code> aktuell halten willst, ohne dass eine Unmenge von Merges durchgeführt werden sollen. Oder wenn du häufig einen Rebase machst, solltest du <code>rerere</code> aktivieren, um dir das Leben ein wenig leichter zu machen.</p>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>