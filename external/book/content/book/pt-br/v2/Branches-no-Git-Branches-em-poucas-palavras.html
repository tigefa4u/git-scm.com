---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: pt-br
  chapter:
    title: Branches no Git
    number: 3
  section:
    title: Branches em poucas palavras
    number: 1
    cs_number: '3.1'
    previous: book/pt-br/v2/Fundamentos-de-Git-Sumário
    next: book/pt-br/v2/Branches-no-Git-O-básico-de-Ramificação-Branch-e-Mesclagem-Merge
title: Git - Branches em poucas palavras
---
<p>
Quase todo Sistema de Controle de Versionamento tem alguma forma de suporte a ramificações (Branches).
Ramificação significa que você diverge da linha principal de desenvolvimento e continua a trabalhar sem alterar essa linha principal.
Em muitas ferramentas versionamento, este é um processo um tanto difícil, geralmente exigindo que você crie uma nova cópia do diretório do código-fonte, o que pode demorar muito em projetos maiores.</p><p>Algumas pessoas se referem ao modelo de ramificação do Git como seu “recurso matador” e certamente diferencia o Git na comunidade de sistemas de versionamento.
Por que isso é tão especial?
A forma como o Git cria branches é incrivelmente leve, tornando as operações de ramificação quase instantâneas, alternando entre os branches geralmente com a mesma rapidez.
Ao contrário de muitos outros sistemas, o Git incentiva fluxos de trabalho que se ramificam e se fundem com frequência, até mesmo várias vezes ao dia.
Compreender e dominar esse recurso oferece uma ferramenta poderosa e única e pode mudar totalmente a maneira como você desenvolve.</p>
<h2 id="r_git_branches_overview">Branches em poucas palavras</h2>
<div class="paragraph">
<p>Para realmente entender como o Git trabalha com Branches, precisamos dar um passo atrás e examinar como o Git armazena seus dados.</p>
</div>
<div class="paragraph">
<p>Como você deve se lembrar de &lt;&lt; ch01-introdução &gt;&gt;, o Git não armazena dados como uma série de mudanças ou diferenças, mas sim como uma série de snapshots (instantâneos de um momento) .</p>
</div>
<div class="paragraph">
<p>Quando você faz um commit, o Git armazena um objeto de commit que contém um ponteiro para o snapshot do conteúdo que você testou.
Este objeto também contém o nome do autor e o e-mail, a mensagem que você digitou e ponteiros para o commit ou commits que vieram antes desse commit (seu pai ou pais): sem pai para o commit inicial, um pai para um commit normal, e vários pais para um commit que resulta de uma fusão de dois ou mais branches.</p>
</div>
<div class="paragraph">
<p>Para verificar isso, vamos assumir que você tem um diretório contendo três arquivos, e você seleciona todos eles e efetua o commit.
Ele Prepara os arquivos e calcula uma verificação para cada um (o hash SHA-1 que mencionamos em &lt;&lt; ch01-introdução &gt;&gt;), armazena essa versão do arquivo no repositório Git (Git se refere a eles como blobs), e adiciona esse hash de verificação à área de preparação (staging area):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add README test.rb LICENSE
$ git commit -m 'The initial commit of my project'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quando você faz um commit executando <code>git commit</code>, o Git verifica cada subdiretório (neste caso, apenas o diretório raiz do projeto) e armazena esses objetos no repositório do Git.
O Git então cria um objeto de commit que possui os metadados e um ponteiro para a raiz do projeto para que ele possa recriar aquele snapshots quando necessário.
</p>
</div>
<div class="paragraph">
<p>Seu repositório Git agora contém cinco objetos: um blob para o conteúdo de cada um dos seus três arquivos, uma árvore que lista o conteúdo do diretório e especifica quais nomes de arquivo são armazenados e quais seus blobs e um commit com o ponteiro para essa árvore e todos os metadados de commit.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/pt-br/v2/images/commit-and-tree.png" >}}" alt="A commit and its tree.">
</div>
<div class="title">Figure 9. Um commit e sua árvore</div>
</div>
<div class="paragraph">
<p>Se você fizer algumas mudanças e confirmar novamente, o próximo commit armazena um ponteiro para o commit que veio imediatamente antes dele.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/pt-br/v2/images/commits-and-parents.png" >}}" alt="Commits and their parents.">
</div>
<div class="title">Figure 10. Commits e seus pais</div>
</div>
<div class="paragraph">
<p>Um branch no Git é simplesmente um ponteiro móvel para um desses commits.
O nome do branch padrão no Git é <code>master</code>.
Conforme você começa a fazer commits, você recebe um branch <code>master</code> que aponta para o último commit que você fez.
Cada vez que você faz um novo commit, ele avança automaticamente.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>O branch ‘` master '’ no Git não é um branch especial. 
É exatamente como qualquer outra ramificação.
A única razão pela qual quase todo repositório tem um é que o comando <code>git init</code> o cria por padrão e a maioria das pessoas não se preocupa em alterá-lo.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/pt-br/v2/images/branch-and-history.png" >}}" alt="A branch and its commit history.">
</div>
<div class="title">Figure 11. Um branch e seu histórico de commits</div>
</div>
<div class="sect3">
<h3 id="r_create_new_branch">Criando um Novo Branch</h3>
<div class="paragraph">
<p>
O que acontece se você criar um novo branch?
Bem, fazer isso cria um novo ponteiro para você mover.
Digamos que você crie um novo branch chamado: testing.
Você faz isso com o comando <code>git branch</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch testing</code></pre>
</div>
</div>
<div class="paragraph">
<p>Isso cria um novo ponteiro para o mesmo commit em que você está atualmente.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/pt-br/v2/images/two-branches.png" >}}" alt="Two branches pointing into the same series of commits.">
</div>
<div class="title">Figure 12. Duas branches apontando para a mesma série de commits</div>
</div>
<div class="paragraph">
<p>Como o Git sabe em qual branch você está atualmente?
Ele mantém um ponteiro especial chamado <code>HEAD</code>.
Note que isso é muito diferente do conceito de <code>HEAD</code> em outros sistemas de versionamento com os quais você pode estar acostumado, como Subversion ou CVS.
No Git, isso é um ponteiro para o branch local em que você está.
Neste caso, você ainda está em <code>master</code>.
O comando <code>git branch</code> apenas <em>criou</em> um novo branch - ele não mudou para aquele branch.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/pt-br/v2/images/head-to-master.png" >}}" alt="HEAD pointing to a branch.">
</div>
<div class="title">Figure 13. HEAD apontando para um branch</div>
</div>
<div class="paragraph">
<p>Você pode ver isso facilmente executando um simples comando <code>git log</code> que mostra para onde os ponteiros do branch estão apontando.
Esta opção é chamada de <code>--decorate</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --decorate
f30ab (HEAD -&gt; master, testing) add feature #32 - ability to add new formats to the central interface
34ac2 Fixed bug #1328 - stack overflow under certain conditions
98ca9 The initial commit of my project</code></pre>
</div>
</div>
<div class="paragraph">
<p>Você pode ver os branches ‘` master <em>’ e `` testing '</em> que estão bem ali ao lado do commit <code>f30ab</code>.</p>
</div>
</div>
<div class="sect3">
<h3 id="r_switching_branches">Alternando entre Branches</h3>
<div class="paragraph">
<p>
Para mudar para um branch existente, você executa o comando <code>git checkout</code>.
Vamos mudar para o novo branch <code>testing</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout testing</code></pre>
</div>
</div>
<div class="paragraph">
<p>Isso move o <code>HEAD</code> e o aponta para o branch` testing`.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/pt-br/v2/images/head-to-testing.png" >}}" alt="HEAD points to the current branch.">
</div>
<div class="title">Figure 14. HEAD aponta para o branch atual</div>
</div>
<div class="paragraph">
<p>O que isso significa?
Bem, vamos fazer outro commit:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ vim test.rb
$ git commit -a -m 'made a change'</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/pt-br/v2/images/advance-testing.png" >}}" alt="The HEAD branch moves forward when a commit is made.">
</div>
<div class="title">Figure 15. O branch do HEAD avança quando um commit é feito</div>
</div>
<div class="paragraph">
<p>Isso é interessante, porque agora seu branch <code>testing</code> avançou, mas seu branch` master` ainda aponta para o commit em que você estava quando executou <code>git checkout</code> para alternar entre os branches.
Vamos voltar para o branch <code>master</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/pt-br/v2/images/checkout-master.png" >}}" alt="HEAD moves when you checkout.">
</div>
<div class="title">Figure 16. O HEAD se move quando você faz o checkout</div>
</div>
<div class="paragraph">
<p>Esse comando fez duas coisas.
Ele moveu o ponteiro HEAD de volta para apontar para o branch <code>master</code>, e reverteu os arquivos em seu diretório de trabalho de volta para o snapshots para o qual` master` aponta.
Isso também significa que as alterações feitas a partir deste ponto irão divergir de uma versão mais antiga do projeto.
Essencialmente, ele retrocede o trabalho que você fez em seu branch <code>testing</code> para que você possa ir em uma direção diferente.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">A troca de branches muda os arquivos em seu diretório de trabalho</div>
<div class="paragraph">
<p>É importante notar que quando você muda de branches no Git, os arquivos em seu diretório de trabalho mudam.
Se você mudar para um branch mais antigo, seu diretório de trabalho será revertido para se parecer com a última vez que você fez commit naquele branch.
Se o Git não puder fazer, ele não permitirá que você faça a troca.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Vamos fazer algumas mudanças e confirmar novamente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ vim test.rb
$ git commit -a -m 'made other changes'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Agora o histórico do seu projeto divergiu (consulte <a href="{{< relurl "book/pt-br/v2/ch00/rdivergent_history" >}}">Histórico de diferenças</a>).
Você criou e mudou para um branch, fez algum trabalho nele e, em seguida, voltou para o seu branch principal e fez outro trabalho.
Ambas as mudanças são isoladas em branches separados: você pode alternar entre os branches e mesclá-los quando estiver pronto.
E você fez tudo isso com comandos simples <code>branch</code>,` checkout` e <code>commit</code>.</p>
</div>
<div id="rdivergent_history" class="imageblock">
<div class="content">
<img src="{{< relurl "book/pt-br/v2/images/advance-master.png" >}}" alt="Divergent history.">
</div>
<div class="title">Figure 17. Histórico de diferenças</div>
</div>
<div class="paragraph">
<p>Você também pode ver isso facilmente com o comando <code>git log</code>.
Se você executar <code>git log --oneline --decorate --graph --all</code>, ele mostrará o histórico de seus commits, exibindo onde estão seus ponteiros de branch e como seu histórico divergiu.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --decorate --graph --all
* c2b9e (HEAD, master) made other changes
| * 87ab2 (testing) made a change
|/
* f30ab add feature #32 - ability to add new formats to the
* 34ac2 fixed bug #1328 - stack overflow under certain conditions
* 98ca9 initial commit of my project</code></pre>
</div>
</div>
<div class="paragraph">
<p>Como um branch no Git é na verdade um arquivo simples que contém a verificação SHA-1 de 40 caracteres do commit para o qual ele aponta, branches são fáceis para criar e destruir.
Criar um novo branch é tão rápido e simples quanto escrever 41 bytes em um arquivo (40 caracteres e uma nova linha).</p>
</div>
<div class="paragraph">
<p>Isso está em nítido contraste com a forma como as ferramentas de Versionamento mais antigas se ramificam, o que envolve a cópia de todos os arquivos do projeto em um segundo diretório.
Isso pode levar vários segundos ou até minutos, dependendo do tamanho do projeto, enquanto no Git o processo é sempre instantâneo.
Além disso, como estamos gravando os pais quando fazemos o commit, encontrar uma base adequada para a mesclagem é feito automaticamente para nós e geralmente é muito fácil de fazer.
Esses recursos ajudam a incentivar os desenvolvedores a criar e usar branches com frequência.</p>
</div>
<div class="paragraph">
<p>Vamos ver por que você deve fazer isso.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>