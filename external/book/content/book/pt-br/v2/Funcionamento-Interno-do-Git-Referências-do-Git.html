---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: pt-br
  chapter:
    title: Funcionamento Interno do Git
    number: 10
  section:
    title: Referências do Git
    number: 3
    cs_number: '10.3'
    previous: book/pt-br/v2/Funcionamento-Interno-do-Git-Objetos-do-Git
    next: book/pt-br/v2/Funcionamento-Interno-do-Git-Packfiles
title: Git - Referências do Git
url: "/book/pt-br/v2/Funcionamento-Interno-do-Git-Referências-do-Git.html"
---
<h2 id="r_git_refs">Referências do Git</h2>
<div class="paragraph">
<p>Você pode executar algo como <code>git log 1a410e</code> para ver todo o seu histórico, mas você ainda precisa lembrar que <code>1a410e</code> é o último <em>commit</em> para poder caminhar nesse histórico para encontrar todos esses objetos.
Você precisa de um arquivo em que você possa armazenar o valor do SHA-1 com um simples nome para que você possa usar essa referência em vez do valor de um SHA-1 puro.</p>
</div>
<div class="paragraph">
<p>No Git, chamamos isso de “referências” (<em>references</em>) ou “refs”; você pode encontrar os arquivos que contém os valores SHA-1 no diretório <code>.git/refs</code>.
No projeto atual, este diretório não contém nenhum arquivo, mas contém uma simples estrutura:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ find .git/refs
.git/refs
.git/refs/heads
.git/refs/tags
$ find .git/refs -type f</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para criar uma nova referência que irá te ajudar a lembrar onde está seu último <em>commit</em>, você pode tecnicamente fazer algo tão simples quanto isto:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo "1a410efbd13591db07496601ebc7a059dd55cfe9" &gt; .git/refs/heads/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Agora, você pode usar a referência <em>head</em> que você acabou de criar em vez do valor SHA-1 nos seus comandos Git:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --pretty=oneline master
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nós não encorajamos você a editar diretamente arquivos de referência.
O Git provê um comando mais seguro para fazer isso se você quiser atualizar uma referência, chamado <code>update-ref</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9</code></pre>
</div>
</div>
<div class="paragraph">
<p>Isto é o que uma <em>branch</em> é basicamente: uma simples referência para a cabeça de uma linha de trabalho.
Para criar uma <em>branch</em> no segundo <em>commit</em>, você pode fazer isto:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git update-ref refs/heads/test cac0ca</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sua <em>branch</em> irá conter apenas o trabalho a partir desse <em>commit</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --pretty=oneline test
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Agora, seu banco de dados do Git conceitualmente aparenta ser algo assim:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/pt-br/v2/images/data-model-4.png" >}}" alt="Objetos do diretório Git com todas as referências _head_ incluídas.">
</div>
<div class="title">Figure 151. Git directory objects with branch head references included.</div>
</div>
<div class="paragraph">
<p>Quando você executa comandos como <code>git branch (nome da branch)</code>, o Git basicamente executa esse comando <code>update-ref</code> para adicionar o SHA-1 do último <em>commit</em> da <em>branch</em> que você está em qualquer nova referência que você quer criar.</p>
</div>
<div class="sect3">
<h3 id="r_the_head">A HEAD</h3>
<div class="paragraph">
<p>A questão agora é, quando você executa <code>git branch (nome da branch)</code>, como o Git sabe o SHA-1 do último <em>commit</em>?
A resposta é o arquivo HEAD.</p>
</div>
<div class="paragraph">
<p>O arquivo HEAD é uma referência simbólica para a <em>branch</em> que você está no momento.
Queremos dizer por referência simbólica que, ao contrário de uma referência normal, em geral ela não contém um valor de um SHA-1, mas um ponteiro para outra referência.
Se você olhar para o arquivo, normalmente você verá algo como isto:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .git/HEAD
ref: refs/heads/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Se você executar <code>git checkout test</code>, o Git atualizará o arquivo de forma que ele ficará assim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .git/HEAD
ref: refs/heads/test</code></pre>
</div>
</div>
<div class="paragraph">
<p>Quando você executa <code>git commit</code>, ele cria um objeto <em>commit</em>, especificando como pai desse objeto <em>commit</em> o valor do SHA-1 que a referência contida em HEAD aponta.</p>
</div>
<div class="paragraph">
<p>Você pode alterar manualmente esse arquivo mas, novamente, um comando mais seguro existe para fazer isso: <code>symbolic-ref</code>.
Você pode ler esse arquivo de sua HEAD através deste comando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git symbolic-ref HEAD
refs/heads/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Você também pode definir o valor de HEAD:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git symbolic-ref HEAD refs/heads/test
$ cat .git/HEAD
ref: refs/heads/test</code></pre>
</div>
</div>
<div class="paragraph">
<p>Você não pode definir o valor de uma referência simbólica fora do estilo <em>refs</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git symbolic-ref HEAD test
fatal: Refusing to point HEAD outside of refs/</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_tags">Tags</h3>
<div class="paragraph">
<p>Nós acabamos de falar sobre os três principais tipos de objetos, mas existe também um quarto.
O objeto <em>tag</em> é bem parecido com um objeto <em>commit</em>, ele contém um <em>tagger</em>, a data, a mensagem, e uma referência.
A principal diferença é que um objeto <em>tag</em> geralmente aponta para um <em>commit</em> em vez de uma <em>tree</em>.
Ele é bem parecido com uma referência do tipo <em>branch</em>, mas ele nunca se move - ele sempre aponta para o mesmo <em>commit</em> mas dá a ele um nome mais amigável.</p>
</div>
<div class="paragraph">
<p>Como discutimos em <a href="{{< relurl "book/pt-br/v2/ch00/ch02-git-basics" >}}">[ch02-git-basics]</a>, exitem dois tipos de <em>tags</em>: anotada e leve.
Você pode criar uma <em>tag</em> leve executando algo assim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d</code></pre>
</div>
</div>
<div class="paragraph">
<p>Isso é tudo que uma <em>tag</em> leve é - uma referência que nunca se move.
Entretanto, uma <em>tag</em> anotada é mais complexa.
Se você criar uma <em>tag</em> anotada, o Git cria um objeto <em>tag</em> e então escreve uma referência que aponta para ele em vez de apontar diretamente para o <em>commit</em>.
Você pode ver isso criando uma <em>tag</em> anotada (<code>-a</code> especifica que é uma <em>tag</em> anotada):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m 'test tag'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aqui está o valor SHA-1 do objeto que foi criado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .git/refs/tags/v1.1
9585191f37f7b0fb9444f35a9bf50de191beadc2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Agora, execute o comando <code>cat-file</code> no valor SHA-1:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2
object 1a410efbd13591db07496601ebc7a059dd55cfe9
type commit
tag v1.1
tagger Scott Chacon &lt;schacon@gmail.com&gt; Sat May 23 16:48:58 2009 -0700

test tag</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note que o item <code>object</code> aponta ao SHA-1 do <em>commit</em> que você criou a <em>tag</em>.
Note também que ele não precisa apontar para um <em>commit</em>; você pode adicionar qualquer objeto do Git.
No código-fonte do Git, por exemplo, o mantenedor adicionou sua chave GPG pública como um objeto <em>blob</em> e então criou uma <em>tag</em> para ele.
Você pode ver a chave pública executando isto em um clone do repositório do Git:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file blob junio-gpg-pub</code></pre>
</div>
</div>
<div class="paragraph">
<p>O repositório do kernel Linux também tem um objeto <em>tag</em> que não aponta para um <em>commit</em>: a primeira tag criada aponta para a <em>tree</em> inicial da importação do código-fonte.</p>
</div>
</div>
<div class="sect3">
<h3 id="_remotes">Remotes</h3>
<div class="paragraph">
<p>O terceiro tipo de referência que você verá é o <em>remote</em> (remoto).
Se você adicionar um <em>remote</em> e fizer um <em>push</em> para ele, o Git armazenará o valor que você fez o <em>push</em> para ele para cada <em>branch</em> no diretório <code>refs/remotes</code>.
Por exemplo, você pode adicionar um <em>remote</em> chamado <code>origin</code> e fazer o <em>push</em> da sua <code>master</code> para ele:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add origin git@github.com:schacon/simplegit-progit.git
$ git push origin master
Counting objects: 11, done.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (7/7), 716 bytes, done.
Total 7 (delta 2), reused 4 (delta 1)
To git@github.com:schacon/simplegit-progit.git
  a11bef0..ca82a6d  master -&gt; master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Então, você pode ver onde a branch <code>master</code> no <em>remote</em> <code>origin</code> estava na última vez que você se comunicou com o servidor, olhando o arquivo <code>refs/remotes/origin/master</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .git/refs/remotes/origin/master
ca82a6dff817ec66f44342007202690a93763949</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>Remotes</em> se diferenciam de <em>branches</em> (referências em <code>refs/heads</code>) principalmente pelo fato de normalmente serem somente-leitura.
Você pode executar <code>git checkout</code> para um <em>remote</em>, mas o Git não irá apotar a HEAD para um, então você nunca irá atualizá-la com um commando <code>commit</code>.
O Git gerencia elas como marcadores para a último estado conhecido de onde essas branches estavam nos servidores.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>