---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: ko
  chapter:
    title: 분산 환경에서의 Git
    number: 5
  section:
    title: 프로젝트에 기여하기
    number: 2
    cs_number: '5.2'
    previous: book/ko/v2/분산-환경에서의-Git-분산-환경에서의-워크플로
    next: book/ko/v2/분산-환경에서의-Git-프로젝트-관리하기
title: Git - 프로젝트에 기여하기
url: "/book/ko/v2/분산-환경에서의-Git-프로젝트에-기여하기.html"
---
<h2 id="_contributing_project">프로젝트에 기여하기</h2>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>프로젝트에 기여하는 방식을 설명하는데 가장 어려운 점은 그 방식이 매우 다양하다는 점이다.
Git이 워낙 유연하게 설계됐기 때문에 사람들은 여러 가지 방식으로 사용할 수 있다. 게다가 프로젝트마다 환경이 달라서 프로젝트에 기여하는 방식을 쉽게 설명하기란 정말 어렵다.
기여하는 방식에 영향을 끼치는 몇 가지 변수가 있다. 활발히 기여하는 개발자의 수가 얼마인지, 선택한 워크플로가 무엇인지, 각 개발자에게 접근 권한을 어떻게 부여했는지, 외부에서도 기여할 수 있는지 등이 변수다.</p>
</div>
<div class="paragraph">
<p>첫 번째로 살펴볼 변수는 활발히 활동하는 개발자의 수이다. 얼마나 많은 개발자가 얼마나 자주 코드를 쏟아 내는가 하는 점이 활발한 개발자의 기준이다.
대부분 둘, 셋 정도의 개발자가 하루에 몇 번 커밋을 하고 활발하지 않은 프로젝트는 더 띄엄띄엄할 것이다.
하지만, 아주 큰 프로젝트는 수백, 수천 명의 개발자가 하루에도 수십, 수백 개의 커밋을 만들어 낸다.
개발자가 많으면 많을수록 코드를 깔끔하게 적용하거나 Merge 하기 어려워진다.
어떤 커밋은 다른 개발자가 이미 기여한 것으로 불필요해지기도 하고 때론 서로 충돌이 일어난다.
어떻게 해야 코드를 최신으로 유지하면서 원하는 대로 수정할 수 있을까?</p>
</div>
<div class="paragraph">
<p>두 번째 변수는 프로젝트에서 선택한 워크플로다.
개발자 모두가 메인 저장소에 쓰기 권한을 갖는 중앙집중형 방식인가?
프로젝트에 모든 Patch를 검사하고 통합하는 관리자가 따로 있는가?
모든 수정사항을 개발자끼리 검토하고 승인하는가?
자신이 그저 돕는게 아니라 어떤 책임을 맡고 있는지?
중간 관리자가 있어서 그들에게 먼저 알려야 하는가?</p>
</div>
<div class="paragraph">
<p>세 번째 변수는 접근 권한이다.
'프로젝트에 쓰기 권한이 있어서 직접 쓸 수 있는가? 아니면 읽기만 가능한가?'에 따라서 프로젝트에 기여하는 방식이 매우 달라진다.
쓰기 권한이 없다면 어떻게 수정 사항을 프로젝트에 반영할 수 있을까?
수정사항을 적용하는 정책이 프로젝트에 있는가?
얼마나 많은 시간을 프로젝트에 할애하는가?
얼마나 자주 기여하는가?</p>
</div>
<div class="paragraph">
<p>이런 질문에 따라 프로젝트에 기여하는 방법과 워크플로가 달라진다.
간단한 것부터 복잡한 것까지 예제를 통해 각 상황을 살펴보면 실제 프로젝트에 필요한 워크플로를 선택하는 데 도움이 될 것이다.</p>
</div>
<div class="sect3">
<h3 id="_commit_guidelines">커밋 가이드라인</h3>
<div class="paragraph">
<p>다른 것보다 먼저 커밋 메시지에 대한 주의사항을 알아보자.
커밋 메시지를 잘 작성하는 가이드라인을 알아두면 다른 개발자와 함께 일하는 데 도움이 많이 된다.
Git 프로젝트에 보면 커밋 메시지를 작성하는데 참고할 만한 좋은 팁이 많다. Git 프로젝트의 <code>Documentation/SubmittingPatches</code> 문서를 참고하자.</p>
</div>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>무엇보다도 먼저 공백문자를 깨끗하게 정리하고 커밋해야 한다.
Git은 공백문자를 검사해볼 수 있는 간단한 명령을 제공한다. 커밋을 하기 전에 <code>git diff --check</code> 명령으로 공백문자에 대한 오류를 확인할 수 있다.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ko/v2/images/git-diff-check.png" >}}" alt="`git diff --check` 의 결과.">
</div>
<div class="title">그림 57. <code>git diff --check</code> 의 결과.</div>
</div>
<div class="paragraph">
<p>커밋을 하기 전에 공백문자에 대해 검사를 하면 공백으로 불필요하게 커밋되는 것을 막고 이런 커밋으로 인해 불필요하게 다른 개발자들이 신경 쓰는 일을 방지할 수 있다.</p>
</div>
<div class="paragraph">
<p>그리고 각 커밋은 논리적으로 구분되는 Changeset이다.
최대한 수정사항을 한 주제로 요약할 수 있어야 하고 여러 가지 이슈에 대한 수정사항을 하나의 커밋에 담지 않아야 한다.
여러 가지 이슈를 한꺼번에 수정했다고 하더라도 Staging Area를 이용하여 한 커밋에 이슈 하나만 담기도록 한다. 작업 내용을 분할하고, 각 커밋마다 적절한 메시지를 작성한다.
같은 파일의 다른 부분을 수정하는 경우에는 <code>git add -patch</code> 명령을 써서 한 부분씩 나누어 Staging Area에 저장해야 한다(관련 내용은 <a href="{{< relurl "book/ko/v2/ch00/_interactive_staging" >}}">대화형 명령</a> 에서 다룬다).
결과적으로 최종 프로젝트의 모습은 한 번에 커밋을 하든 다섯 번에 나누어 커밋을 하든 똑같다.</p>
</div>
<div class="paragraph">
<p>하지만, 여러 번 나누어 커밋하는 것이 다른 동료가 수정한 부분을 확인할 때나 각 커밋의 시점으로 복원해서 검토할 때 이해하기 훨씬 쉽다.
<a href="{{< relurl "book/ko/v2/ch00/_rewriting_history" >}}">히스토리 단장하기</a> 에서 이미 저장된 커밋을 다시 수정하거나 파일을 단계적으로 Staging Area에 저장하는 방법을 살펴본다. 다양한 도구를 이용해서 간단하고 이해하기 쉬운 커밋을 쌓아가야 한다.</p>
</div>
<div class="paragraph">
<p>마지막으로 명심해야 할 점은 커밋 메시지 자체다.
좋은 커밋 메시지를 작성하는 습관은 Git을 사용하는 데 도움이 많이 된다.
일반적으로 커밋 메시지를 작성할 때 사용하는 규칙이 있다. 메시지의 첫 라인에 50자가 넘지 않는 아주 간략한 메시지를 적어 해당 커밋을 요약한다. 다음 한 라인은 비우고 그다음 라인부터 커밋을 자세히 설명한다.
예를 들어 Git 개발 프로젝트에서는 개발 동기와 구현 상황의 제약 조건이나 상황 등을 자세하게 요구한다. 이런 점은 따를 만한 좋은 가이드라인이다.
그리고 현재형 표현을 사용하는 것이 좋다.
명령문으로 시작하는 것도 좋은 방법이다.
예를 들어 “I added tests for (테스트를 추가함)” 보다는 “Add tests for (테스트 추가)” 와 같은 메시지를 작성한다.
아래 내용은 <a href="http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">Tim Pope가 작성한 커밋 메시지의 템플릿</a>이다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">영문 50글자 이하의 간략한 수정 요약

자세한 설명. 영문 72글자 이상이 되면
라인 바꿈을 하고 이어지는 내용을 작성한다.
특정 상황에서는 첫 번째 라인이 이메일
메시지의 제목이 되고 나머지는 메일
내용이 된다. 빈 라인은 본문과 요약을
구별해주기에 중요하다(본문 전체를 생략하지 않는 한).

이어지는 내용도 한 라인 띄우고 쓴다.

  - 목록 표시도 사용할 수 있다.

  - 보통 '-' 나 '*' 표시를 사용해서 목록을 표현하고
    표시 앞에 공백 하나, 각 목록 사이에는 빈 라인
    하나를 넣는데, 이건 상황에 따라 다르다.</code></pre>
</div>
</div>
<div class="paragraph">
<p>메시지를 이렇게 작성하면 함께 일하는 사람은 물론이고 자신에게도 매우 유용하다.
Git 개발 프로젝트에는 잘 쓰인 커밋 메시지가 많으므로 프로젝트를 내려받아서 <code>git log --no-merges</code> 명령으로 꼭 살펴보기를 권한다.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">노트</div>
</td>
<td class="content">
<div class="title">책 처럼 하지말고, 시키는 대로 하기.</div>
<div class="paragraph">
<p>시간 관계상, 이 책에서 설명하는 예제의 커밋 메시지는 위와 같이 아주 멋지게 쓰지 않았다. <code>git commit</code> 명령에서 <code>-m</code> 옵션을 사용하여 간단하게 적는다.</p>
</div>
<div class="paragraph">
<p>하지만! 저자처럼 하지 말고 시키는 대로 하는 것이 좋다.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h3 id="_private_team">비공개 소규모 팀</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>두세 명으로 이루어진 비공개 프로젝트가 가장 간단한 프로젝트일 것이다.
“비공개” 라고 함은 소스코드가 공개되지 않은 것을 말하는 것이지 외부에서 접근할 수 없는 것을 말하지 않는다.
모든 개발자는 공유하는 저장소에 쓰기 권한이 있어야 한다.</p>
</div>
<div class="paragraph">
<p>이런 환경에서는 보통 Subversion 같은 중앙집중형 버전 관리 시스템에서 사용하던 방식을 사용한다.
물론 Git이 가진 오프라인 커밋 기능이나 브랜치 Merge 기능을 이용하긴 하지만 크게 다르지 않다. 가장 큰 차이점은 서버가 아닌 클라이언트 쪽에서 Merge 한다는 점이다.
두 개발자가 저장소를 공유하는 시나리오를 살펴보자.
개발자인 John은 저장소를 Clone 하고 파일을 수정하고 나서 로컬에 커밋한다
(예제에서 Git이 출력하는 메시지 중 일부는 <code>…​</code> 으로 줄이고 생략했다).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console"># John's Machine
$ git clone john@githost:simplegit.git
Cloning into 'simplegit'...
...
$ cd simplegit/
$ vim lib/simplegit.rb
$ git commit -am 'remove invalid default value'
[master 738ee87] remove invalid default value
 1 files changed, 1 insertions(+), 1 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>개발자인 Jessica도 저장소를 Clone 하고 나서 파일을 하나 새로 추가하고 커밋한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console"># Jessica's Machine
$ git clone jessica@githost:simplegit.git
Cloning into 'simplegit'...
...
$ cd simplegit/
$ vim TODO
$ git commit -am 'add reset task'
[master fbff5bc] add reset task
 1 files changed, 1 insertions(+), 0 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jessica는 서버에 커밋을 Push 한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console"># Jessica's Machine
$ git push origin master
...
To jessica@githost:simplegit.git
   1edee6b..fbff5bc  master -&gt; master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Push 명령을 실행하고 난 결과 중 가장 마지막 줄은 유용한 정보를 보여주고 있다.
마지막 줄의 기본적인 형태는 <code>&lt;oldref&gt;..&lt;newref&gt; fromref → toref</code> 이다. <code>oldref</code> 는 이전 레퍼런스를, <code>newref</code> 는 새 레퍼런스를, <code>fromref</code> 는 Push 명령에서 사용한 로컬 레퍼런스의 이름을, <code>toref</code> 는 Push로 업데이트한 리모트 레퍼런스를 나타낸다.
이어지는 내용에서 지금과 비슷한 Push 명령 출력 결과는 여러번 등장한다. 이 출력 메시지의 내용을 이해하고 있으면 다양한 상태에서 정확하게 어떤일이 벌어지는가를 좀 더 쉽게 이해할 수 있다.
자세한 내용을 좀 더 살펴보려면 Git 문서 <a href="https://git-scm.com/docs/git-push">git-push</a>를 참고한다.</p>
</div>
<div class="paragraph">
<p>다시 예제 내용으로 돌아오면, John도 내용을 변경하고 커밋을 만든 후 서버로 커밋을 Push 하려고 한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console"># John's Machine
$ git push origin master
To john@githost:simplegit.git
 ! [rejected]        master -&gt; master (non-fast forward)
error: failed to push some refs to 'john@githost:simplegit.git'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jessica의 Push한 내용으로 인해, John의 커밋은 서버에서 거절된다.
Subversion을 사용했던 사람은 이 부분을 이해하는 것이 중요하다.
같은 파일을 수정한 것도 아닌데 왜 Push가 거절되는 걸까? Subversion에서는 서로 다른 파일을 수정하는 이런 Merge 작업은 자동으로 서버가 처리한다. 하지만 Git은 로컬에서 먼저 <em>Merge</em> 해야 한다.
다시 말해 John은 Push 하기 전에 Jessica가 수정한 커밋을 Fetch 하고 Merge 해야 한다는 말이다.</p>
</div>
<div class="paragraph">
<p>이를 위해 우선 John은 Jessica의 작업 내용을 아래와 같이 Fetch 한다(아래 명령은 Jessica의 작업 내용을 내려받긴 하지만 Merge 까지 하지는 않는 작업이다).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git fetch origin
...
From john@githost:simplegit
 + 049d078...fbff5bc master     -&gt; origin/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Fetch 하고 나면 John의 로컬 저장소는 아래와 같이 된다.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ko/v2/images/small-team-1.png" >}}" alt="Fetch 하고 난 John의 저장소.">
</div>
<div class="title">그림 58. Fetch 하고 난 John의 저장소.</div>
</div>
<div class="paragraph">
<p>이제 John은 Fetch하여 가져 온 Jessica의 작업 내용을 Merge 할 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge origin/master
Merge made by the 'recursive' strategy.
 TODO |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Merge가 잘 이루어지면 John의 브랜치는 아래와 같은 상태가 된다.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ko/v2/images/small-team-2.png" >}}" alt="`origin/master` 브랜치를 Merge 하고 난 후 John의 저장소.">
</div>
<div class="title">그림 59. <code>origin/master</code> 브랜치를 Merge 하고 난 후 John의 저장소.</div>
</div>
<div class="paragraph">
<p>John은 Merge 하고 나서 자신이 작업한 코드가 제대로 동작하는지 확인한다. 그 후에 공유하는 저장소에 Push 한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git push origin master
...
To john@githost:simplegit.git
   fbff5bc..72bbc59  master -&gt; master</code></pre>
</div>
</div>
<div class="paragraph">
<p>이제 John의 저장소는 아래와 같이 되었다.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ko/v2/images/small-team-3.png" >}}" alt="Push 하고 난 후 John의 저장소.">
</div>
<div class="title">그림 60. Push 하고 난 후 John의 저장소.</div>
</div>
<div class="paragraph">
<p>동시에 Jessica는 토픽 브랜치를 하나 만든다. issue54 브랜치를 만들고 세 번에 걸쳐서 커밋한다.
아직 John의 커밋을 Fetch 하지 않은 상황이기 때문에 아래와 같은 상황이 된다.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ko/v2/images/small-team-4.png" >}}" alt="Jessica의 토픽 브랜치.">
</div>
<div class="title">그림 61. Jessica의 토픽 브랜치.</div>
</div>
<div class="paragraph">
<p>Jessica는 John이 새로 Push했다는 것을 알게 되어 하던 작업을 멈추고 John의 작업 내용을 살펴보려고 한다. 하지만 아직 Jessica는 John의 변경사항을 가지고 있지 않은 상태이다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console"># Jessica's Machine
$ git fetch origin
...
From jessica@githost:simplegit
   fbff5bc..72bbc59  master     -&gt; origin/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>위 명령으로 John이 Push 한 커밋을 모두 내려받는다.
그러면 Jessica의 저장소는 아래와 같은 상태가 된다.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ko/v2/images/small-team-5.png" >}}" alt="John의 커밋을 Fetch 한 후 Jessica의 저장소.">
</div>
<div class="title">그림 62. John의 커밋을 Fetch 한 후 Jessica의 저장소.</div>
</div>
<div class="paragraph">
<p>이제 <code>orgin/master</code> 와 Merge 할 차례다.
Jessica는 토픽 브랜치에서의 작업을 마치고 어떤 내용이 Merge 되는지 <code>git log</code> 명령으로 확인한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --no-merges issue54..origin/master
commit 738ee872852dfaa9d6634e0dea7a324040193016
Author: John Smith &lt;jsmith@example.com&gt;
Date:   Fri May 29 16:01:27 2009 -0700

   remove invalid default value</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>issue54..origin/master</code> 문법은 히스토리를 검색할 때 뒤의 브랜치(<code>origin/master</code>)에 속한 커밋 중 앞의 브랜치(<code>issue54</code>)에 속하지 않은 커밋을 검색하는 문법이다.
자세한 내용은 <a href="{{< relurl "book/ko/v2/ch00/_commit_ranges" >}}">범위로 커밋 가리키기</a>에서 다룬다.</p>
</div>
<div class="paragraph">
<p>앞의 명령에 따라 히스토리를 검색한 결과 John이 생성하고 Jessica가 Merge 하지 않은 커밋을 하나 찾았다.
<code>origin/master</code> 브랜치를 Merge 하게 되면 검색된 커밋 하나가 로컬 작업에 Merge 될 것이다.</p>
</div>
<div class="paragraph">
<p>Merge 할 내용을 확인한 Jessica는 자신이 작업한 내용과 John이 Push 한 작업(<code>origin/master</code>)을 <code>master</code> 브랜치에 Merge 하고 Push 한다.</p>
</div>
<div class="paragraph">
<p><code>issue54</code> 토픽 브랜치에 쌓은 모든 내용을 합치려면, 우선 <code>master</code> 브랜치를 Checkout 해야 한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
Switched to branch 'master'
Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>origin/master</code>, <code>issue54</code> 모두 Upstream 브랜치이기 때문에 둘 중에 무엇을 먼저 Merge 하든 상관이 없다.
물론 어떤 것을 먼저 Merge 하느냐에 따라 히스토리 순서는 달라지지만, 최종 결과는 똑같다.
Jessica는 먼저 <code>issue54</code> 브랜치를 Merge 한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge issue54
Updating fbff5bc..4af4298
Fast forward
 README           |    1 +
 lib/simplegit.rb |    6 +++++-
 2 files changed, 6 insertions(+), 1 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>보다시피 Fast-forward Merge 이기 때문에 명령 실행 결과는 별 문제가 없다.
<code>origin/master</code> 에 쌓여있던 John의 작업 내용을 다음과 같이 실행하여 Jessica는 Merge 작업을 완료할 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge origin/master
Auto-merging lib/simplegit.rb
Merge made by the 'recursive' strategy.
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>위와 같이 Merge가 잘 되면 그림 아래와 같은 상태가 된다.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ko/v2/images/small-team-6.png" >}}" alt="John의 커밋을 Merge 후 Jessica의 저장소.">
</div>
<div class="title">그림 63. John의 커밋을 Merge 후 Jessica의 저장소.</div>
</div>
<div class="paragraph">
<p><code>origin/master</code> 브랜치가 Jessica의 <code>master</code> 브랜치로 나아갈(reachable) 수 있기 때문에 Push는 성공한다(물론 John이 그 사이에 Push 하지 않았다면).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git push origin master
...
To jessica@githost:simplegit.git
   72bbc59..8059c15  master -&gt; master</code></pre>
</div>
</div>
<div class="paragraph">
<p>두 개발자의 커밋을 성공적으로 Merge 하고 나면 결과는 아래와 같다.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ko/v2/images/small-team-7.png" >}}" alt="Jessica가 서버로 Push 하고 난 후의 저장소.">
</div>
<div class="title">그림 64. Jessica가 서버로 Push 하고 난 후의 저장소.</div>
</div>
<div class="paragraph">
<p>매우 간단한 상황의 예제를 살펴보았다.
토픽 브랜치에서 수정하고 로컬의 <code>master</code> 브랜치에 Merge 한다.
작업한 내용을 프로젝트의 공유 저장소에 Push 하고자 할 때는 우선 <code>origin/master</code> 브랜치를 Fetch 하고 Merge 한다. 그리고 나서 Merge 한 결과를 다시 서버로 Push 한다.
이런 워크플로가 일반적이며 아래와 같이 나타낼 수 있다.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ko/v2/images/small-team-flow.png" >}}" alt="여러 개발자가 Git을 사용하는 워크플로.">
</div>
<div class="title">그림 65. 여러 개발자가 Git을 사용하는 워크플로.</div>
</div>
</div>
<div class="sect3">
<h3 id="_비공개_대규모_팀">비공개 대규모 팀</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>이제 비공개 대규모 팀에서의 역할을 살펴보자.
이런 상황에는 보통 팀을 여러 개로 나눈다. 그래서 각각의 작은 팀이 서로 어떻게 하나로 Merge 하는지를 살펴본다.</p>
</div>
<div class="paragraph">
<p>John과 Jessica는 “featureA” 기능을 함께 작업하게 됐다. Jessica는 Josie와 함께 “featureB” 기능도 작업하고 있다.
이런 상황이라면 회사는 Integration-manager 워크플로를 선택하는 게 좋다. 작은 팀이 수행한 결과물은 Integration-Manager가 Merge 하고 공유 저장소의 <code>master</code> 브랜치를 업데이트한다.
팀마다 브랜치를 하나씩 만들고 Integration-Manager는 그 브랜치를 Pull 해서 Merge 한다.</p>
</div>
<div class="paragraph">
<p>두 팀에 모두 속한 Jessica의 작업 순서를 살펴보자.
우선 Jessica는 저장소를 Clone 하고 <code>featureA</code> 작업을 먼저 한다.
<code>featureA</code> 브랜치를 만들고 수정하고 커밋한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console"># Jessica's Machine
$ git checkout -b featureA
Switched to a new branch 'featureA'
$ vim lib/simplegit.rb
$ git commit -am 'add limit to log function'
[featureA 3300904] add limit to log function
 1 files changed, 1 insertions(+), 1 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>이 수정한 부분을 John과 공유해야 한다. 공유하려면 우선 <code>featureA</code> 브랜치를 서버로 Push 한다.
Integration-Manager만 <code>master</code> 브랜치를 업데이트할 수 있기 때문에 master 브랜치로 Push를 할 수 없고 다른 브랜치로 John과 공유한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git push -u origin featureA
...
To jessica@githost:simplegit.git
 * [new branch]      featureA -&gt; featureA</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jessica는 자신이 한 일을 <code>featureA</code> 라는 브랜치로 Push 했다는 이메일을 John에게 보낸다.
John의 피드백을 기다리는 동안 Jessica는 Josie와 함께 하는 <code>featureB</code> 작업을 하기로 한다.
서버의 <code>master</code> 브랜치를 기반으로 새로운 브랜치를 하나 만든다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console"># Jessica's Machine
$ git fetch origin
$ git checkout -b featureB origin/master
Switched to a new branch 'featureB'</code></pre>
</div>
</div>
<div class="paragraph">
<p>몇 가지 작업을 하고 <code>featureB</code> 브랜치에 커밋한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ vim lib/simplegit.rb
$ git commit -am 'made the ls-tree function recursive'
[featureB e5b0fdc] made the ls-tree function recursive
 1 files changed, 1 insertions(+), 1 deletions(-)
$ vim lib/simplegit.rb
$ git commit -am 'add ls-files'
[featureB 8512791] add ls-files
 1 files changed, 5 insertions(+), 0 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>그럼 Jessica의 저장소는 그림 아래와 같다.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ko/v2/images/managed-team-1.png" >}}" alt="Jessica의 저장소.">
</div>
<div class="title">그림 66. Jessica의 저장소.</div>
</div>
<div class="paragraph">
<p>작업을 마치고 Push 하려고 하는데 Jesie가 이미 “featureB” 작업을 하고 서버에 <code>featureBee</code> 브랜치로 Push 했다는 이메일을 보내왔다.
Jessica는 Jesie의 작업을 먼저 Merge 해야만 Push 할 수 있다.
Merge 하기 위해서 우선 <code>git fetch</code> 로 Fetch 한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git fetch origin
...
From jessica@githost:simplegit
 * [new branch]      featureBee -&gt; origin/featureBee</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jessica가 앞서 Checkout 한 <code>featureB</code> 브랜치에서 작업중일 때, Fetch 해 온 브랜치를 <code>git merge</code> 명령으로 Merge 한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge origin/featureBee
Auto-merging lib/simplegit.rb
Merge made by the 'recursive' strategy.
 lib/simplegit.rb |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>이 시점에서 Jissica는 Merge 한 “featureB” 작업을 서버로 Push 할 때 서버의 <code>featureB</code> 브랜치로 Push하지 않고자 한다.
이미 Josie가 생성한 <code>featureBee</code> 로 작업 내용을 Push 하러면 아래와 같이 실행한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git push -u origin featureB:featureBee
...
To jessica@githost:simplegit.git
   fba9af8..cd685d1  featureB -&gt; featureBee</code></pre>
</div>
</div>
<div class="paragraph">
<p>이것은 <em>refspec</em> 이란 것을 사용하는 것인데
<a href="{{< relurl "book/ko/v2/ch00/_refspec" >}}">Refspec</a> 에서 자세하게 설명한다.
명령에서 사용한 <code>-u</code> 옵션은 <code>--set-upstream</code> 옵션의 짧은 표현인데 브랜치를 추적하도록 설정해서 이후 Push 나 Pull 할 때 좀 더 편하게 사용할 수 있다.</p>
</div>
<div class="paragraph">
<p>John이 몇 가지 작업을 하고 나서 <code>featureA</code> 에 Push 했고 확인해 달라는 내용의 이메일을 보내왔다.
Jessica는 John의 작업 내용을 확인하기 위해 다시 한 번 <code>git fetch</code> 로 Push된 작업을 Fetch 한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git fetch origin
...
From jessica@githost:simplegit
   3300904..aad881d  featureA   -&gt; origin/featureA</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jessica의 로컬 <code>featureA</code> 브랜치와 Fetch 해 온 John의 작업내용이 같은 <code>featureA</code> 브랜치 상에서 어떤 것이 업데이트됐는지 <code>git log</code> 명령으로 확인한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log featureA..origin/featureA
commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
Author: John Smith &lt;jsmith@example.com&gt;
Date:   Fri May 29 19:57:33 2009 -0700

    changed log output to 30 from 25</code></pre>
</div>
</div>
<div class="paragraph">
<p>확인을 마치면 로컬의 <code>featureA</code> 브랜치로 John의 작업 내용을 다음과 같이 Merge 한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout featureA
Switched to branch 'featureA'
$ git merge origin/featureA
Updating 3300904..aad881d
Fast forward
 lib/simplegit.rb |   10 +++++++++-
1 files changed, 9 insertions(+), 1 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jessica는 일부 수정하고, <code>featureA</code> 브랜치에 커밋하고, 수정한 내용을 다시 서버로 Push 한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git commit -am 'small tweak'
[featureA 774b3ed] small tweak
 1 files changed, 1 insertions(+), 1 deletions(-)
$ git push
...
To jessica@githost:simplegit.git
   3300904..774b3ed  featureA -&gt; featureA</code></pre>
</div>
</div>
<div class="paragraph">
<p>위와 같은 작업을 마치고 나면 Jessica의 저장소는 아래와 같은 모습이 된다.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ko/v2/images/managed-team-2.png" >}}" alt="마지막 Push 하고 난 후의 Jessica의 저장소.">
</div>
<div class="title">그림 67. 마지막 Push 하고 난 후의 Jessica의 저장소.</div>
</div>
<div class="paragraph">
<p>그럼 <code>featureA</code> 와 <code>featureBee</code> 브랜치가 프로젝트의 메인 브랜치로 Merge 할 준비가 되었다고 Integration-Manager에게 알려준다.
Integration-Manager가 두 브랜치를 모두 Merge 하고 난 후에 메인 브랜치를 Fetch 하면 아래와 같은 모양이 된다.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ko/v2/images/managed-team-3.png" >}}" alt="두 브랜치가 메인 브랜치에 Merge 된 후의 저장소.">
</div>
<div class="title">그림 68. 두 브랜치가 메인 브랜치에 Merge 된 후의 저장소.</div>
</div>
<div class="paragraph">
<p>수많은 팀의 작업을 동시에 진행하고 나중에 Merge 하는 기능을 사용하려고 다른 버전 관리 시스템에서 Git으로 바꾸는 조직들이 많아지고 있다.
팀은 자신의 브랜치로 작업하지만, 메인 브랜치에 영향을 끼치지 않는다는 점이 Git의 장점이다.
아래는 이런 워크플로를 나타내고 있다.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ko/v2/images/managed-team-flow.png" >}}" alt="Managed 팀의 워크플로.">
</div>
<div class="title">그림 69. Managed 팀의 워크플로.</div>
</div>
</div>
<div class="sect3">
<h3 id="_public_project">공개 프로젝트 Fork</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>비공개 팀을 운영하는 것과 공개 팀을 운영하는 것은 약간 다르다.
공개 팀을 운영할 때는 모든 개발자가 프로젝트의 공유 저장소에 직접적으로 쓰기 권한을 가지지는 않는다. 그래서 프로젝트의 관리자는 몇 가지 일을 더 해줘야 한다.
Fork를 지원하는 Git 호스팅에서 Fork를 통해 프로젝트에 기여하는 법을 예제를 통해 살펴본다.
Git 호스팅 사이트(GitHub, BitBucket, repo.or.cz 등) 대부분은 Fork 기능을 지원하며 프로젝트 관리자는 보통 Fork 하는 것으로 프로젝트를 운영한다.
다른 방식으로 이메일과 Patch를 사용하는 방식도 있는데 뒤이어 살펴본다.</p>
</div>
<div class="paragraph">
<p>우선 처음 할 일은 메인 저장소를 Clone 하는 것이다. 그리고 나서 토픽 브랜치를 만들고 일정 부분 기여한다.
그 순서는 아래와 같다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone &lt;url&gt;
$ cd project
$ git checkout -b featureA
  ... work ...
$ git commit
  ... work ...
$ git commit</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">노트</div>
</td>
<td class="content">
<div class="paragraph">
<p><code>rebase -i</code> 명령을 사용하면 여러 커밋을 하나의 커밋으로 합치거나 프로젝트의 관리자가 수정사항을 쉽게 이해하도록 커밋을 정리할 수 있다. <a href="{{< relurl "book/ko/v2/ch00/_rewriting_history" >}}">히스토리 단장하기</a> 에서 대화식으로 Rebase 하는 방법을 살펴본다.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>일단 프로젝트의 웹사이트로 가서 “Fork” 버튼을 누르면 원래 프로젝트 저장소에서 갈라져 나온, 쓰기 권한이 있는 저장소가 하나 만들어진다. 그러면 로컬에서 수정한 커밋을 원래 저장소에 Push 할 수 있다.
그 저장소를 로컬 저장소의 리모트 저장소로 등록한다. 예를 들어 <code>myfork</code> 로 등록한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add myfork &lt;url&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>자 이제 등록한 리모트 저장소에 Push 한다.
작업하던 것을 로컬 저장소의 <code>master</code> 브랜치에 Merge 한 후 Push 하는 것보다 리모트 브랜치에 바로 Push를 하는 방식이 훨씬 간단하다.
이렇게 하는 이유는 관리자가 토픽 브랜치를 프로젝트에 포함시키고 싶지 않을 때 토픽 브랜치를 Merge 하기 이전 상태로 <code>master</code> 브랜치를 되돌릴 필요가 없기 때문이다. (<code>cherry-pick</code> 명령은 <a href="{{< relurl "book/ko/v2/ch00/_rebase_cherry_pick" >}}">Rebase와 Cherry-Pick 워크플로</a> 에서 자세히 다룬다).
관리자가 토픽 브랜치를 Merge 하든 Rebase 하든 Cherry-Pick 하든지 간에 결국 다시 관리자의 저장소를 Pull 할 때는 토픽 브랜치의 내용이 들어 있을 것이다.</p>
</div>
<div class="paragraph">
<p>어떤 경우라도 다음과 같이 작업 내용을 Push 할 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git push -u myfork featureA</code></pre>
</div>
</div>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Fork 한 저장소에 Push 하고 나면 프로젝트 관리자에게 이 내용을 알려야 한다.
이것을 <em>Pull Request</em> 라고 한다. Git 호스팅 사이트에서 관리자에게 보낼 메시지를 생성하거나 <code>git request-pull</code> 명령으로 이메일을 수동으로 만들 수 있다. GitHub의 “Pull Request” 버튼은 자동으로 메시지를 만들어 주는데 관련 내용은 <a href="{{< relurl "book/ko/v2/ch00/ch06-github" >}}">GitHub</a> 에서 살펴볼 수 있다.</p>
</div>
<div class="paragraph">
<p><code>git request-pull</code> 명령은 아규먼트를 두 개 입력받는다. 첫 번째 아규먼트는 작업한 토픽 브랜치의 Base 브랜치이다. 두 번째는 토픽 브랜치가 위치한 저장소 URL인데 위에서 등록한 리모트 저장소 이름을 적을 수 있다. 이 명령은 토픽 브랜치 수정사항을 요약한 내용을 결과로 보여준다.
예를 들어 Jessica가 John에게 Pull 요청을 보내는 상황을 살펴보자. Jessica는 토픽 브랜치에 두 번 커밋을 하고 Fork 한 저장소에 Push 했다. 그리고 아래와 같이 실행한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git request-pull origin/master myfork
The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
Jessica Smith (1):
        added a new function

are available in the git repository at:

  git://githost/simplegit.git featureA

Jessica Smith (2):
      add limit to log function
      change log output to 30 from 25

 lib/simplegit.rb |   10 +++++++++-
 1 files changed, 9 insertions(+), 1 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>관리자에게 이 내용을 보낸다. 이 내용에는 토픽 브랜치가 어느 시점에 갈라져 나온 것인지, 어떤 커밋이 있는지, Pull 하려면 어떤 저장소에 접근해야 하는지에 대한 내용이 들어 있다.</p>
</div>
<div class="paragraph">
<p>프로젝트 관리자가 아니라고 해도 보통 <code>origin/master</code> 를 추적하는 <code>master</code> 브랜치는 가지고 있다. 그래도 토픽 브랜치를 만들고 일을 하면 관리자가 수정 내용을 거부할 때 쉽게 버릴 수 있다.
토픽 브랜치를 만들어서 주제별로 독립적으로 일을 하는 동안에도 주 저장소의 <code>master</code> 브랜치는 계속 수정된다. 하지만 주 저장소의 브랜치의 최근 커밋 이후로 Rebase 하면 깨끗하게 Merge 할 수 있다.
그리고 다른 주제의 일을 하려고 할 때는 앞서 Push 한 토픽 브랜치에서 시작하지 말고 주 저장소의 <code>master</code> 브랜치로부터 만들어야 한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b featureB origin/master
  ... work ...
$ git commit
$ git push myfork featureB
$ git request-pull origin/master myfork
  ... email generated request pull to maintainer ...
$ git fetch origin</code></pre>
</div>
</div>
<div class="paragraph">
<p>각 토픽은 일종의 실험실이라고 할 수 있다. 각 토픽은 서로 방해하지 않고 독립적으로 수정하고 Rebase 할 수 있다.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ko/v2/images/public-small-1.png" >}}" alt="featureB 수정작업이 끝난 직후 저장소의 모습.">
</div>
<div class="title">그림 70. featureB 수정작업이 끝난 직후 저장소의 모습.</div>
</div>
<div class="paragraph">
<p>프로젝트 관리자가 사람들의 수정 사항을 Merge 하고 나서 Jessica의 브랜치를 Merge 하려고 할 때 충돌이 날 수도 있다.
그러면 Jessica가 자신의 브랜치를 <code>origin/master</code> 에 Rebase 해서 충돌을 해결하고 다시 Pull Request을 보낸다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout featureA
$ git rebase origin/master
$ git push -f myfork featureA</code></pre>
</div>
</div>
<div class="paragraph">
<p>위 명령들을 실행하고 나면 히스토리는 아래와 같아진다.</p>
</div>
<div id="psp_b" class="imageblock">
<div class="content">
<img src="{{< relurl "book/ko/v2/images/public-small-2.png" >}}" alt="FeatureA에 대한 Rebase가 적용된 후의 모습.">
</div>
<div class="title">그림 71. FeatureA에 대한 Rebase가 적용된 후의 모습.</div>
</div>
<div class="paragraph">
<p>브랜치를 Rebase 해 버렸기 때문에 Push 할 때 <code>-f</code> 옵션을 주고 강제로 기존 서버에 있던 <code>featureA</code> 브랜치의 내용을 덮어 써야 한다.
아니면 새로운 브랜치를(예를 들어 <code>featureAv2</code>) 서버에 Push 해도 된다.</p>
</div>
<div class="paragraph">
<p>또 다른 시나리오를 하나 더 살펴보자. 프로젝트 관리자는 <code>featureB</code> 브랜치의 내용은 좋지만, 상세 구현은 다르게 하고 싶다. 관리자는 <code>featureB</code> 담당자에게 상세 구현을 다르게 해달라고 요청한다.
<code>featureB</code> 담당자는 하는 김에 <code>featureB</code> 브랜치를 프로젝트의 최신 <code>master</code> 브랜치 기반으로 옮긴다.
먼저 <code>origin/master</code> 브랜치에서 <code>featureBv2</code> 브랜치를 새로 하나 만들고, <code>featureB</code> 의 커밋들을 모두 Squash 해서 Merge 하고, 만약 충돌이 나면 해결하고, 상세 구현을 수정하고, 새 브랜치를 Push 한다.</p>
</div>
<div class="paragraph">
<p></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b featureBv2 origin/master
$ git merge --squash featureB
  ... change implementation ...
$ git commit
$ git push myfork featureBv2</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>--squash</code> 옵션은 현재 브랜치에 Merge 할 때 해당 브랜치의 커밋을 모두 커밋 하나로 합쳐서 Merge 한다. 이 때 Merge 커밋은 만들지 않는다.
다른 브랜치에서 수정한 사항을 전부 가져오는 것은 똑같다. 하지만 새로 만들어지는 커밋은 부모가 하나이고 커밋을 기록하기 전에 좀 더 수정할 기회도 있다.
다른 브랜치에서 수정한 사항을 전부 가져오면서 그전에 추가적으로 수정할 게 있으면 수정하고 Merge 할 수 있다. 게다가 새로 만들어지는 커밋은 부모가 하나다.
<code>--no-commit</code> 옵션을 추가하면 커밋을 합쳐 놓고 자동으로 커밋하지 않는다.</p>
</div>
<div class="paragraph">
<p>수정을 마치면 관리자에게 <code>featureBv2</code> 브랜치를 확인해 보라고 메시지를 보낸다.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ko/v2/images/public-small-3.png" >}}" alt="featureBv2 브랜치를 커밋한 이후 저장소 모습.">
</div>
<div class="title">그림 72. featureBv2 브랜치를 커밋한 이후 저장소 모습.</div>
</div>
</div>
<div class="sect3">
<h3 id="_project_over_email">대규모 공개 프로젝트와 이메일을 통한 관리</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>대규모 프로젝트는 보통 수정사항이나 Patch를 수용하는 자신만의 규칙을 마련해놓고 있다. 프로젝트마다 규칙은 서로 다를 수 있으므로 각 프로젝트의 규칙을 미리 알아둘 필요가 있다.
오래된 대규모 프로젝트는 대부분 메일링리스트를 통해서 Patch를 받아들이는데 예제를 통해 살펴본다.</p>
</div>
<div class="paragraph">
<p>토픽 브랜치를 만들어 수정하는 작업은 앞서 살펴본 바와 거의 비슷하지만,
Patch를 제출하는 방식이 다르다.
프로젝트를 Fork 하여 Push 하는 것이 아니라 커밋 내용을 메일로 만들어 개발자 메일링리스트에 제출한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b topicA
  ... work ...
$ git commit
  ... work ...
$ git commit</code></pre>
</div>
</div>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>커밋을 두 번 하고 메일링리스트에 보내 보자.
<code>git format-patch</code> 명령으로 메일링리스트에 보낼 mbox 형식의 파일을 생성한다. 각 커밋은 하나씩 이메일 메시지로 생성되는데 커밋 메시지의 첫 번째 라인이 제목이 되고 Merge 메시지 내용과 Patch 자체가 메일 메시지의 본문이 된다.
이 방식은 수신한 이메일에 들어 있는 Patch를 바로 적용할 수 있어서 좋다. 메일 속에는 커밋의 모든 내용이 포함된다. 메일에 포함된 Patch를 적용하는 것은 다음 절에서 살펴본다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git format-patch -M origin/master
0001-add-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>format-patch</code> 명령을 실행하면 생성한 파일 이름을 보여준다.
<code>-M</code> 옵션은 이름이 변경된 파일이 있는지 살펴보라는 옵션이다.
각 파일의 내용은 아래와 같다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat 0001-add-limit-to-log-function.patch
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith &lt;jessica@example.com&gt;
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20

---
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 76f47bc..f9815f1 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -14,7 +14,7 @@ class SimpleGit
   end

   def log(treeish = 'master')
-    command("git log #{treeish}")
+    command("git log -n 20 #{treeish}")
   end

   def ls_tree(treeish = 'master')
--
2.1.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>메일링리스트에 이메일을 보내기 전에 각 Patch 파일을 손으로 고칠 수 있다.
<code>---</code> 라인과 Patch가 시작되는 라인(<code>diff --git</code> 로 시작하는 라인) 사이에 내용을 추가하면 다른 개발자는 읽을 수 있지만, 나중에 Patch에 적용되지는 않는다.</p>
</div>
<div class="paragraph">
<p>특정 메일 프로그램을 사용하거나 이메일을 보내는 명령어로 메일링리스트에 보낼 수 있다.
붙여 넣기로 위의 내용이 그대로 들어가지 않는 메일 프로그램도 있다. 사용자 편의를 위해 공백이나 라인 바꿈 문자 등을 넣어 주는 메일 프로그램은 원본 그대로 들어가지 않는다.
다행히 Git에는 Patch 메일을 그대로 보낼 수 있는 도구가 있다. IMAP 프로토콜로 보낸다.
저자가 사용하는 방법으로 Gmail을 사용하여 Patch 메일을 전송하는 방법을 살펴보자. 추가로 Git 프로젝트의 <code>Documentation/SubmittingPatches</code> 문서의 마지막 부분을 살펴보면 다양한 메일 프로그램으로 메일을 보내는 방법을 설명한다.</p>
</div>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>메일을 보내려면 먼저 <code>~/.gitconfig</code> 파일에서 이메일 부분 설정한다.
<code>git config</code> 명령으로 추가할 수도 있고 직접 파일을 열어서 추가할 수도 있다. 아무튼, 아래와 같이 설정을 한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">[imap]
  folder = "[Gmail]/Drafts"
  host = imaps://imap.gmail.com
  user = user@gmail.com
  pass = YX]8g76G_2^sFbd
  port = 993
  sslverify = false</code></pre>
</div>
</div>
<div class="paragraph">
<p>IMAP 서버가 SSL을 사용하지 않으면 마지막 두 라인은 필요 없고 host에서 <code>imaps://</code> 대신 <code>imap://</code> 로 한다.
이렇게 설정하면 <code>git imap-send</code> 명령으로 Patch 파일을 IMAP 서버의 Draft 폴더에 이메일로 보낼 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat *.patch |git imap-send
Resolving imap.gmail.com... ok
Connecting to [74.125.142.109]:993... ok
Logging in...
sending 2 messages
100% (2/2) done</code></pre>
</div>
</div>
<div class="paragraph">
<p>이후 Gmail의 Draft 폴더로 가서 To 부분을 메일링리스트의 주소로 변경하고 CC 부분에 해당 메일을 참고해야 하는 관리자나 개발자의 메일 주소를 적고 실제로 전송한다.</p>
</div>
<div class="paragraph">
<p>SMTP 서버를 이용해서 Patch를 보낼 수도 있다.
먼저 SMTP 서버를 설정해야 한다. <code>git config</code> 명령으로 하나씩 설정할 수도 있지만 아래와 같이 <code>~/.gitconfig</code> 파일의 sendemail 섹션을 손으로 직접 고쳐도 된다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ini" data-lang="ini">[sendemail]
  smtpencryption = tls
  smtpserver = smtp.gmail.com
  smtpuser = user@gmail.com
  smtpserverport = 587</code></pre>
</div>
</div>
<div class="paragraph">
<p>이렇게 설정하면 <code>git send-email</code> 명령으로 패치를 보낼 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git send-email *.patch
0001-added-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
Who should the emails appear to be from? [Jessica Smith &lt;jessica@example.com&gt;]
Emails will be sent from: Jessica Smith &lt;jessica@example.com&gt;
Who should the emails be sent to? jessica@example.com
Message-ID to be used as In-Reply-To for the first email? y</code></pre>
</div>
</div>
<div class="paragraph">
<p>명령을 실행하면 아래와 같이 서버로 Patch를 보내는 내용이 화면에 나타난다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">(mbox) Adding cc: Jessica Smith &lt;jessica@example.com&gt; from
  \line 'From: Jessica Smith &lt;jessica@example.com&gt;'
OK. Log says:
Sendmail: /usr/sbin/sendmail -i jessica@example.com
From: Jessica Smith &lt;jessica@example.com&gt;
To: jessica@example.com
Subject: [PATCH 1/2] added limit to log function
Date: Sat, 30 May 2009 13:29:15 -0700
Message-Id: &lt;1243715356-61726-1-git-send-email-jessica@example.com&gt;
X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
In-Reply-To: &lt;y&gt;
References: &lt;y&gt;

Result: OK</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_요약_5">요약</h3>
<div class="paragraph">
<p>이번 절에서는 다양한 워크플로에 따라 Git을 어떻게 사용하는지 살펴보고 그에 필요한 도구들을 설명했다.
다음 절에서는 동전의 뒷면인 프로젝트를 운영하는 방법에 대하여 살펴본다.
즉 친절한 Dictator나 Integration-Manager가 되어 보는 것이다.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>