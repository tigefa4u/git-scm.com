---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: ko
  chapter:
    title: Git의 내부
    number: 10
  section:
    title: Git Refs
    number: 3
    cs_number: '10.3'
    previous: book/ko/v2/Git의-내부-Git-개체
    next: book/ko/v2/Git의-내부-Packfile
title: Git - Git Refs
url: "/book/ko/v2/Git의-내부-Git-Refs.html"
---
<h2 id="_git_refs">Git Refs</h2>
<div class="paragraph">
<p>어떤 커밋 <code>1a410e</code> 이전의 모든 히스토리를 보려면 <code>git log 1a410e</code> 라고 실행하면 히스토리를 볼 수 있지만, 여전히 <code>1a410e</code> 를 기억해야 한다. 이 커밋은 마지막 커밋이기 때문에 히스토리를 따라 모든 개체를 조회할 수 있다.
SHA-1 값을 날로 사용하기보다 쉬운 이름으로 된 포인터가 있으면 그걸 사용하는 게 더 좋다. 외우기 쉬운 이름으로 된 파일에 SHA-1 값을 저장한다.</p>
</div>
<div class="paragraph">
<p>Git에서는 이런 것을 “References” 또는 “Refs” 라고 부른다. 이 SHA-1 값을 저장하는 파일은 <code>.git/refs</code> 디렉토리에 있다.
예제의 프로젝트에는 아직 <code>.git/refs</code> 디렉토리 안에 파일은 없고 디렉토리만 몇 개 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ find .git/refs
.git/refs
.git/refs/heads
.git/refs/tags
$ find .git/refs -type f</code></pre>
</div>
</div>
<div class="paragraph">
<p>Refs가 있으면 커밋을 찾기 쉬워진다. 사실 내부는 아래처럼 단순하다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 1a410efbd13591db07496601ebc7a059dd55cfe9 &gt; .git/refs/heads/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>SHA-1 값 대신에 지금 만든 Refs를 사용할 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --pretty=oneline master
1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Refs 파일을 직접 고치는 것이 좀 못마땅하다. Git에는 좀 더 안전하게 바꿀 수 있는 <code>git update-ref</code> 명령이 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git 브랜치의 역할이 바로 이거다. 브랜치는 어떤 작업 중 마지막 작업을 가리키는 포인터 또는 Refs이다.
간단히 두 번째 커밋을 가리키는 브랜치를 만들어 보자.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git update-ref refs/heads/test cac0ca</code></pre>
</div>
</div>
<div class="paragraph">
<p>브랜치는 직접 가리키는 커밋과 그 커밋으로 따라갈 수 있는 모든 커밋을 포함한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --pretty=oneline test
cac0cab538b970a37ea1e769cbbde608743bc96d second commit
fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>이제 Git 데이터베이스는 아래 그림처럼 보인다.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/ko/v2/images/data-model-4.png" >}}" alt="브랜치 Refs가 추가된 Git 데이터베이스.">
</div>
<div class="title">그림 151. 브랜치 Refs가 추가된 Git 데이터베이스.</div>
</div>
<div class="paragraph">
<p><code>git branch &lt;branch&gt;</code> 명령을 실행하면 Git은 내부적으로 <code>update-ref</code> 명령을 실행한다. 입력받은 브랜치 이름과 현 브랜치의 마지막 커밋의 SHA-1 값을 가져다 <code>update-ref</code> 명령을 실행한다.</p>
</div>
<div class="sect3">
<h3 id="ref_the_ref">HEAD</h3>
<div class="paragraph">
<p><code>git branch &lt;branch&gt;</code> 명령을 실행할 때 Git은 어떻게 마지막 커밋의 SHA-1 값을 아는 걸까?
HEAD 파일은 현 브랜치를 가리키는 간접(symbolic) Refs다.</p>
</div>
<div class="paragraph">
<p>간접 Refs라서 다른 것과 다르다.
이 Refs는 다른 Refs를 가리키는 것이라서 SHA-1 값이 없다.
파일을 열어 보면 아래와 같이 생겼다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .git/HEAD
ref: refs/heads/master</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>git checkout test</code> 를 실행하면 Git은 HEAD 파일을 아래와 같이 바꾼다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .git/HEAD
ref: refs/heads/test</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>git commit</code> 을 실행하면 커밋 개체가 만들어지는데, 지금 HEAD가 가리키고 있던 커밋의 SHA-1 값이 그 커밋 개체의 부모로 사용된다.</p>
</div>
<div class="paragraph">
<p>이 파일도 손으로 직접 편집할 수 있지만 <code>git symbolic-ref</code> 라는 명령어가 있어서 좀 더 안전하게 사용할 수 있다.
이 명령으로 HEAD의 값을 읽을 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git symbolic-ref HEAD
refs/heads/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>HEAD의 값을 변경할 수도 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git symbolic-ref HEAD refs/heads/test
$ cat .git/HEAD
ref: refs/heads/test</code></pre>
</div>
</div>
<div class="paragraph">
<p>refs 형식에 맞지 않으면 수정할 수 없다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git symbolic-ref HEAD test
fatal: Refusing to point HEAD outside of refs/</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_태그">태그</h3>
<div class="paragraph">
<p>중요한 개체 세 가지는 모두 살펴봤고(Blob, Tree, 커밋) 살펴볼 개체가 하나가 남았다.
태그 개체는 커밋 개체랑 매우 비슷하다. 커밋 개체처럼 누가, 언제 태그를 달았는지 태그 메시지는 무엇이고 어떤 커밋을 가리키는지에 대한 정보가 포함된다.
태그 개체는 Tree 개체가 아니라 커밋 개체를 가리키는 것이 그 둘의 차이다.
브랜치처럼 커밋 개체를 가리키지만 옮길 수는 없다. 태그 개체는 늘 그 이름이 뜻하는 커밋만 가리킨다.</p>
</div>
<div class="paragraph">
<p><a href="{{< relurl "book/ko/v2/ch00/ch02-git-basics-chapter" >}}">Git의 기초</a> 에서 배웠듯 태그는 Annotated 태그와 Lightweight 태그 두 종류로 나뉜다.
먼저 아래와 같이 Lightweight 태그를 만들어 보자.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lightwieght 태그는 만들기 쉽다. 브랜치랑 비슷하지만 브랜치처럼 옮길 수는 없다.
이에 비해 Annotated 태그는 좀 더 복잡하다. Annotated 태그를 만들면 Git은 태그 개체를 만들고 거기에 커밋을 가리키는 Refs를 저장한다.
Annotated 태그는 커밋을 직접 가리키지 않고 태그 개체를 가리킨다.
<code>-a</code> 옵션을 주고 Annotated 태그를 만들어 확인해보자.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m 'test tag'</code></pre>
</div>
</div>
<div class="paragraph">
<p>태그 개체의 SHA-1 값을 확인한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .git/refs/tags/v1.1
9585191f37f7b0fb9444f35a9bf50de191beadc2</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>git cat-file -p</code> 명령으로 해당 SHA-1 값의 내용을 조회한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2
object 1a410efbd13591db07496601ebc7a059dd55cfe9
type commit
tag v1.1
tagger Scott Chacon &lt;schacon@gmail.com&gt; Sat May 23 16:48:58 2009 -0700

test tag</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>object</code> 부분에 있는 SHA-1 값이 실제로 태그가 가리키는 커밋이다.
커밋 개체뿐만 아니라 모든 Git 개체에 태그를 달 수 있다.
커밋 개체에 태그를 다는 것이 아니라 Git 개체에 태그를 다는 것이다.
Git을 개발하는 프로젝트에서는 관리자가 자신의 GPG 공개키를 Blob 개체로 추가하고 그 파일에 태그를 달았다.
아래 명령으로 그 공개키를 확인할 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file blob junio-gpg-pub</code></pre>
</div>
</div>
<div class="paragraph">
<p>Linux Kernel 저장소에도 커밋이 아닌 다른 개체를 가리키는 태그 개체가 있다. 그 태그는 저장소에 처음으로 소스 코드를 임포트했을 때 그 첫 Tree 개체를 가리킨다.</p>
</div>
</div>
<div class="sect3">
<h3 id="_리모트">리모트</h3>
<div class="paragraph">
<p>리모트 Refs라는 것도 있다.
리모트를 추가하고 Push 하면 Git은 각 브랜치마다 Push 한 마지막 커밋이 무엇인지 <code>refs/remotes</code> 디렉토리에 저장한다.
예를 들어, <code>origin</code> 이라는 리모트를 추가하고 <code>master</code> 브랜치를 Push 한다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add origin git@github.com:schacon/simplegit-progit.git
$ git push origin master
Counting objects: 11, done.
Compressing objects: 100% (5/5), done.
Writing objects: 100% (7/7), 716 bytes, done.
Total 7 (delta 2), reused 4 (delta 1)
To git@github.com:schacon/simplegit-progit.git
  a11bef0..ca82a6d  master -&gt; master</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>origin</code> 의 <code>master</code> 브랜치에서 서버와 마지막으로 교환한 커밋이 어떤 것인지 <code>refs/remotes/origin/master</code> 파일에서 확인할 수 있다.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .git/refs/remotes/origin/master
ca82a6dff817ec66f44342007202690a93763949</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>refs/heads</code> 에 있는 Refs인 브랜치와 달리 리모트 Refs는 Checkout 할 수 없고 읽기 용도로만 쓸 수 있는 브랜치인 것이다.
이 리모트 Refs는 서버의 브랜치가 가리키는 커밋이 무엇인지 적어둔 일종의 북마크이다.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>