---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: bg
  chapter:
    title: Git инструменти
    number: 5
  section:
    title: Сливане за напреднали
    number: 8
    cs_number: '5.8'
    previous: book/bg/v2/Git-инструменти-Мистерията-на-командата-Reset
    next: book/bg/v2/Git-инструменти-Rerere
title: Git - Сливане за напреднали
url: "/book/bg/v2/Git-инструменти-Сливане-за-напреднали.html"
---
<h2 id="_advanced_merging">Сливане за напреднали</h2>
<div class="paragraph">
<p>Обикновено сливането в Git е лесно.
Понеже Git позволява сливането на друг клон много пъти, това означава, че можете да имате клон с много дълъг живот, да го поддържате обновен докато работите и да решавате своевременно и често малките конфликти, вместо да трябва да се оправяте с един голям конфликт в края на работата си.</p>
</div>
<div class="paragraph">
<p>Обаче, понякога възникват по-проблематични конфликти.
За разлика от други системи за контрол на версиите, Git не се опитва да бъде прекалено умен що се касае до решаването на merge конфликти.
Философията на системата е да е добра в установяването на това дали сливането може да се направи недвусмислено, но ако има конфликт - да не се опитва автоматично да го реши.
По тази причина, ако чакате твърде дълго преди да слеете клонове, които се развиват бързо може да се сблъскате с проблеми.</p>
</div>
<div class="paragraph">
<p>В тази секция ще разгледаме какви биха могли да са някои от тези проблеми и какви инструменти имате на разположение за да се оправите с тях.
Ще разгледаме и някои по-различни, нестандартни типове сливане, които можете да направите, както и ще видим как да отмените сливания.</p>
</div>
<div class="sect3">
<h3 id="_конфликти_при_сливане">Конфликти при сливане</h3>
<div class="paragraph">
<p>Въпреки, че вече видяхме основните стъпки за разрешаване на конфликти в <a href="{{< relurl "book/bg/v2/ch00/_basic_merge_conflicts" >}}">Конфликти при сливане</a>, при по-заплетените такива Git осигурява инструменти, с които да установите какво точно се е случило и как по-добре да се справите с проблема.</p>
</div>
<div class="paragraph">
<p>Преди всичко, ако е възможно, уверете се, че работната ви директория е чиста, преди да опитате сливане, което може да доведе до конфликти.
Ако имате текуща работа, опитайте да я къмитнете във временен клон или да я маскирате (stashing).
Това ви гарантира, че ще можете да отмените <strong>всичко</strong>, което предстои да опитате.
Ако имате незаписани промени в работната директория когато опитате сливане, някои от следващите действия могат да ви помогнат да съхраните тази работа.</p>
</div>
<div class="paragraph">
<p>Нека видим един прост пример.
Имаме кратък Ruby файл, който отпечатва 'hello world'.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
  puts 'hello world'
end

hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>В нашето хранилище, създаваме нов клон наречен <code>whitespace</code> и променяме Unix символите за край на ред в DOS такива ефективно модифицирайки всеки един ред но само с празни символи.
След това сменяме реда “hello world” на “hello mundo”.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b whitespace
Switched to a new branch 'whitespace'

$ unix2dos hello.rb
unix2dos: converting file hello.rb to DOS format ...
$ git commit -am 'Convert hello.rb to DOS'
[whitespace 3270f76] Convert hello.rb to DOS
 1 file changed, 7 insertions(+), 7 deletions(-)

$ vim hello.rb
$ git diff -b
diff --git a/hello.rb b/hello.rb
index ac51efd..e85207e 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,7 @@
 #! /usr/bin/env ruby

 def hello
-  puts 'hello world'
+  puts 'hello mundo'^M
 end

 hello()

$ git commit -am 'Use Spanish instead of English'
[whitespace 6d338d2] Use Spanish instead of English
 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Сега превключаме обратно към <code>master</code> клона и добавяме малко документация за функцията.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
Switched to branch 'master'

$ vim hello.rb
$ git diff
diff --git a/hello.rb b/hello.rb
index ac51efd..36c06c8 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello world'
 end

$ git commit -am 'Add comment documenting the function'
[master bec6336] Add comment documenting the function
 1 file changed, 1 insertion(+)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Опитваме да слеем клона <code>whitespace</code> и изпадаме в конфликтна ситуация заради whitespace промените.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge whitespace
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="sect4">
<h4 id="_abort_merge">Прекъсване на сливане</h4>
<div class="paragraph">
<p>Сега имаме няколко възможности.
Първо, нека видим как да излезем от ситуацията, връщайки се в предишното състояние на хранилището.
Ако не сте очаквали конфликти и не желаете да ги оправяте в момента, можете просто да откажете сливането с <code>git merge --abort</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status -sb
## master
UU hello.rb

$ git merge --abort

$ git status -sb
## master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Командата <code>git merge --abort</code> опитва да върне статуса, в който сте били преди да опитате сливането.
Като казваме опитва, единствените случаи, в които не би успяла е ако имате немаскирани (unstashed) или некъмитнати промени в работната директория. Във всички останали случаи тя ще работи коректно.</p>
</div>
<div class="paragraph">
<p>Ако по някаква причина просто искате да започнете отначало, можете също така да изпълните <code>git reset --hard HEAD</code> и работната ви директория ще бъде върната до последния къмитнат статус.
Помнете, че всяка некъмитната работа ще бъде загубена, така че се уверете, че промените наистина не ви трябват.</p>
</div>
</div>
<div class="sect4">
<h4 id="_игнориране_на_празните_символи">Игнориране на празните символи</h4>
<div class="paragraph">
<p>В този конкретен случай проблемите ни възникваха от празните символи във файла.
Знаем това, защото случаят е прост, но също така ситуацията е лесно откриваема и в реални случаи, когато разглеждаме причината за конфликта, понеже се вижда, че всеки ред е премахнат от едната страна и повторно добавен в другата.
По подразбиране, Git вижда всички тези редове като променени и отказва сливането.</p>
</div>
<div class="paragraph">
<p>Стратегията за сливане по подразбиране също приема аргументи и някои от тях подпомагат игнорирането на празните символи.
Ако виждате, че имате много whitespace проблеми в сливането, можете просто да го откажете и да го опитате отново, този път с аргумента <code>-Xignore-all-space</code> или <code>-Xignore-space-change</code>.
Първата опция игнорира празните символи <strong>изцяло</strong> при сравняването на редовете, докато втората третира последователностите от един или повече празни символи като еквивалентни.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge -Xignore-space-change whitespace
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Сега действителните промени по файла не водят до конфликт и сливането минава чисто.</p>
</div>
<div class="paragraph">
<p>Това може да ви измъкне в ситуации, когато някой член на екипа, любител на преформатирането, внезапно реши да смени интервалите с табулации или обратно.</p>
</div>
</div>
<div class="sect4">
<h4 id="_manual_remerge">Ръчно повторно сливане на файлове</h4>
<div class="paragraph">
<p>Git се оправя добре с обработката на празни символи, но има други типове промени, с които вероятно няма да се оправи сам, но които вие знаете, че можете лесно да коригирате със скрипт.
Например, нека кажем че Git хипотетично не може да обработи whitespace промените и трябва да направим това на ръка.</p>
</div>
<div class="paragraph">
<p>Това, което трябва действително да направим е да прекараме файла през програмата <code>dos2unix</code> преди да опитаме сливането.
Как можем да направим това?</p>
</div>
<div class="paragraph">
<p>Първо, изпадаме в конфликтната ситуация.
След това, искаме да извлечем собствената версия на файла, версията от клона, който сме опитали да слеем, както и общата версия (тази от която двата клона са стартирани).
След това, искаме да поправим или нашата или другата версия и да опитаме отново сливане за само този единичен файл.</p>
</div>
<div class="paragraph">
<p>Извличането на трите версии в действителност е лесно.
Git съхранява всички тях в индекса под формата на “етапи (stages)” като всеки от тях има съответен номер.
Stage 1 е общия файл (common), от който произлизат другите два, stage 2 е вашата версия (ours) и stage 3 е версията от <code>MERGE_HEAD</code>, тоест от клона който опитвате да слеете (“theirs”).</p>
</div>
<div class="paragraph">
<p>Можете да извлечете копие от всяка от тези версии на конфликтния файл с командата <code>git show</code> и специален синтаксис.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show :1:hello.rb &gt; hello.common.rb
$ git show :2:hello.rb &gt; hello.ours.rb
$ git show :3:hello.rb &gt; hello.theirs.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ако искате да видите повече подробности, можете да използвате plumbing командата <code>ls-files -u</code> за да получите действителните SHA-1 стойности за всеки от тези файлове</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git ls-files -u
100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1	hello.rb
100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2	hello.rb
100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3	hello.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Изразът <code>:1:hello.rb</code> е просто съкратен начин да потърсите blob обекта със съответния SHA-1 хеш.</p>
</div>
<div class="paragraph">
<p>След като вече имаме съдържанието на трите версии на файла в работната директория, можем ръчно да поправим whitespace проблема във файла от клона, който опитваме да слеем и след това да опитаме цялото сливане отново с малко позната команда <code>git merge-file</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ dos2unix hello.theirs.rb
dos2unix: converting file hello.theirs.rb to Unix format ...

$ git merge-file -p \
    hello.ours.rb hello.common.rb hello.theirs.rb &gt; hello.rb

$ git diff -b
diff --cc hello.rb
index 36c06c8,e85207e..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,8 -1,7 +1,8 @@@
  #! /usr/bin/env ruby

 +# prints out a greeting
  def hello
-   puts 'hello world'
+   puts 'hello mundo'
  end

  hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>В този момент успешно сляхме файла.
В действителност, това работи по-добре от <code>ignore-space-change</code> аргумента защото реално поправя промените с празните символи преди сливането, вместо просто да ги игнорира.
При <code>ignore-space-change</code> сливането получихме няколко реда с DOS line ending символи, което смесва нещата и не изглежда красиво.</p>
</div>
<div class="paragraph">
<p>Ако преди да завършите къмита искате да получите представа за това какво действително е променено между едната страна или другата, можете да поискате от <code>git diff</code> да сравни намиращото се в работната ви директория (и което ще къмитнете) с всяка от гореописаните три версии.
Нека видим всички сравнения.</p>
</div>
<div class="paragraph">
<p>За да сравните резултата с това, което сте имали във вашия клон преди сливането, с други думи да видите какво е въвело сливането, можете да изпълните <code>git diff --ours</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --ours
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index 36c06c8..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -2,7 +2,7 @@

 # prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Така тук лесно можем да видим, че това което се е случило с този файл в резултат на сливането е промяната на един единствен ред.</p>
</div>
<div class="paragraph">
<p>Ако искаме да видим разликите от сливането с версията от другия клон, изпълняваме <code>git diff --theirs</code>.
В този и следващия пример, използваме флага <code>-b</code> за да изключим празните символи, защото сравняваме с това, което е в Git, а не с почистения <code>hello.theirs.rb</code> файл.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --theirs -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index e85207e..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello mundo'
 end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Накрая, можем да проверим как файлът е бил променен и от двете страни с <code>git diff --base</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --base -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index ac51efd..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,8 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>На този етап можем да използваме <code>git clean</code> за да изтрием допълнителните файлове, които създадохме за да осъществим ръчното сливане, те вече не ни трябват.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clean -f
Removing hello.common.rb
Removing hello.ours.rb
Removing hello.theirs.rb</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_checking_out_conflicts">Извличане на конфликти</h4>
<div class="paragraph">
<p>Стигайки дотук, по някаква причина може да не сме доволни от решението на конфликта или пък ръчната редакция на едната или другата версия все още не работи добре и се нуждаем от повече контекст.</p>
</div>
<div class="paragraph">
<p>Нека променим примера малко.
В този случай, имаме два продължително развиващи се клона с по няколко къмита всеки, опита за сливане на които води до конфликт по съдържание.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --graph --oneline --decorate --all
* f1270f7 (HEAD, master) Update README
* 9af9d3b Create README
* 694971d Update phrase to 'hola world'
| * e3eb223 (mundo) Add more tests
| * 7cff591 Create initial testing script
| * c3ffff1 Change text to 'hello mundo'
|/
* b7dcc89 Initial hello world code</code></pre>
</div>
</div>
<div class="paragraph">
<p>Сега имаме три уникални къмита само в <code>master</code> клона и три други в клона <code>mundo</code>.
Ако опитаме да слееем <code>mundo</code>, получаваме конфликт.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Искаме да видим какъв точно е конфликта.
Ако отворим файла, ще видим нещо такова:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
  puts 'hola world'
=======
  puts 'hello mundo'
&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo
end

hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>И двете страни са добавили съдържание към този файл, но някои от къмитите са го модифицирали в едно и също място, което поражда конфликта.</p>
</div>
<div class="paragraph">
<p>Нека разгледаме няколко инструмента, които биха ни подсказали как е възникнал проблема.
Твърде възможно е да изпаднем в ситуация, в която може би да не е очевидно как точно трябва да го разрешим.
Трябват ни повече контекстни данни.</p>
</div>
<div class="paragraph">
<p>Едно полезно средство е командата <code>git checkout</code> с параметър <code>--conflict</code>.
Това ще извлече файла отново и ще замени merge conflict маркерите.
Това може да е полезно, ако искате да нулирате маркерите и да опитате да разрешите конфликта отново.</p>
</div>
<div class="paragraph">
<p>Можете да подадете на <code>--conflict</code> или <code>diff3</code> или <code>merge</code> (което е по подразбиране).
Ако подадете <code>diff3</code>, Git ще използва малко по-различна версия на маркерите за конфликти и ще ви покаже не само “ours” и “theirs” версиите, но също и “base” версията вътре във файла, за да имате повече информация.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout --conflict=diff3 hello.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Изпълнявайки това, файлът ни вече изглежда така:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; ours
  puts 'hola world'
||||||| base
  puts 'hello world'
=======
  puts 'hello mundo'
&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs
end

hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ако този формат ви харесва, можете да го направите подразбиращ се за бъдещи merge конфликти задавайки стойност <code>diff3</code> за настройката <code>merge.conflictstyle</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global merge.conflictstyle diff3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Командата <code>git checkout</code> също може да приема <code>--ours</code> и <code>--theirs</code> параметри, което може да е наистина бърз начин за избор на едната или другата страна без въобще да сливаме.</p>
</div>
<div class="paragraph">
<p>Това може да е особено полезно за конфликти при двоични файлове, където можете просто да изберете едната страна или когато искате да слеете само определени файлове от друг клон — можете да направите сливането и след това да изберете дадени файлове от едната или другата страна преди къмитването.</p>
</div>
</div>
<div class="sect4">
<h4 id="_merge_log">Дневник на сливанията</h4>
<div class="paragraph">
<p>Друг полезен инструмент при разрешаване на merge конфликти е <code>git log</code>.
Командата може да ви помогне да получите представа за обстоятелствата, при които вие самите бихте могли да сте допринесли за конфликта.
Разглеждането на малко история за да си припомните защо два паралелни работни процеса модифицират едно и също място в кода може да е много полезно понякога.</p>
</div>
<div class="paragraph">
<p>За да получим списък на всички уникални къмити интегрирани в клоновете, които участват в сливането, можем да използваме “triple dot” синтаксиса, за който научихме в <a href="{{< relurl "book/bg/v2/ch00/_triple_dot" >}}">Три точки</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --left-right HEAD...MERGE_HEAD
&lt; f1270f7 Update README
&lt; 9af9d3b Create README
&lt; 694971d Update phrase to 'hola world'
&gt; e3eb223 Add more tests
&gt; 7cff591 Create initial testing script
&gt; c3ffff1 Change text to 'hello mundo'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Това е кратък списък на шестте къмита, които засягат сливането както и от коя линия на разработка идват.</p>
</div>
<div class="paragraph">
<p>Можем да опростим още изхода, така че да получим по-специфичен контекст.
Ако добавим параметъра <code>--merge</code> към <code>git log</code>, ще получим само къмитите от двете страни на сливането, които променят текущо конфликтния файл.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --left-right --merge
&lt; 694971d Update phrase to 'hola world'
&gt; c3ffff1 Change text to 'hello mundo'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ако вместо това изпълните командата с параметър <code>-p</code>, получавате само разликите за файла, маркиран като конфликтен.
Това може да е <strong>наистина</strong> полезно, ако бързо трябва да получите контекста, от който да разберете защо е възникнал даден конфликт и как по-интелигентно да го разрешите.</p>
</div>
</div>
<div class="sect4">
<h4 id="_комбиниран_diff_формат">Комбиниран Diff формат</h4>
<div class="paragraph">
<p>Понеже Git индексира всички успешни резултати от сливанията, когато изпълните <code>git diff</code> докато сте в режим на конфликт, ще получите само това, което е все още в статус на конфликт.
Това може да ви помогне да видите какво все още ви остава да разрешите.</p>
</div>
<div class="paragraph">
<p>Изпълнявайки <code>git diff</code> в такова положение, командата ви дава информация в специфичен diff изходен формат.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,11 @@@
  #! /usr/bin/env ruby

  def hello
++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
 +  puts 'hola world'
++=======
+   puts 'hello mundo'
++&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo
  end

  hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Форматът е познат като “Combined Diff” и ви дава две колони с информация в началото на всеки ред.
Първата колона показва дали редът е различен (добавен или изтрит) между “ours” клона и файла в работната ви директория, а втората колона показва същото но сравнявайки “theirs” клона и копието в работната директория.</p>
</div>
<div class="paragraph">
<p>Така в този пример можем да видим, че редовете <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> и <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> са в работното копие, но не са били в нито едната от страните участващи в сливането.
Това има смисъл, защото сливащият механизъм ги е оставил там за нашия контекст, но ние сме очаквали да ги премахне.</p>
</div>
<div class="paragraph">
<p>Ако разрешим конфликта и изпълним <code>git diff</code> отново, ще видим същото нещо, но малко по-полезно.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ vim hello.rb
$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Резултатът ни показва, че “hola world” е бил в нашия клон, но не е в работното копие, че “hello mundo” е бил в другия клон, но не е в работното копие, и накрая - че “hola mundo” редът не е бил в нито една от страните, но сега е в работното копие.
Това би могло да е от помощ като финален преглед преди да къмитнете решението на конфликта.</p>
</div>
<div class="paragraph">
<p>Същата информация можете да извлечете и от <code>git log</code> за всяко едно сливане, за да видите постфактум как даден проблем е бил разрешен.
Git ще отпечата на екрана даннните в този формат ако изпълните <code>git show</code> за merge къмит или ако добавите аргумента <code>--cc</code> към <code>git log -p</code> (която по подразбиране показва само пачове за non-merge къмити).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --cc -p -1
commit 14f41939956d80b9e17bb8721354c33f8d5b5a79
Merge: f1270f7 e3eb223
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Sep 19 18:14:49 2014 +0200

    Merge branch 'mundo'

    Conflicts:
        hello.rb

diff --cc hello.rb
index 0399cd5,59727f0..e1d0799
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_undoing_merges">Отмяна на сливания</h3>
<div class="paragraph">
<p>След като вече знаете как да създадете сливащ къмит, твърде вероятно е да направите такъв погрешка.
Едно от най-добрите неща в Git е, че системата няма проблем с вашите грешки, понеже е възможно (и в много случаи лесно) да ги поправите.</p>
</div>
<div class="paragraph">
<p>Сливащите къмити не правят изключение.
Да кажем, че сте започнали работа по topic клон, по невнимание сте го сляли в <code>master</code> клона и сега вашата история изглежда така:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/bg/v2/images/undomerge-start.png" >}}" alt="Инцидентен сливащ къмит">
</div>
<div class="title">Фигура 137. Инцидентен сливащ къмит</div>
</div>
<div class="paragraph">
<p>Има два подхода за справяне с проблема, в зависимост от желания резултат.</p>
</div>
<div class="sect4">
<h4 id="_корекция_на_референциите">Корекция на референциите</h4>
<div class="paragraph">
<p>Ако нежеланият къмит съществува само в локалното ви хранилище, най-лесното и добро решение е да преместите клоновете така, че да сочат където искате.
В повечето случаи, ако след погрешната <code>git merge</code> изпълните <code>git reset --hard HEAD~</code>, това ще коригира указателите на клоновете, така че да изглеждат по следния начин:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/bg/v2/images/undomerge-reset.png" >}}" alt="Историята след изпълнение на `git reset --hard HEAD~`">
</div>
<div class="title">Фигура 138. Историята след изпълнение на <code>git reset --hard HEAD~</code>
</div>
</div>
<div class="paragraph">
<p>Разглеждахме вече <code>reset</code> в <a href="{{< relurl "book/bg/v2/ch00/_git_reset" >}}">Мистерията на командата Reset</a>, така че не би следвало да ви е трудно да разберете какво се случва тук.
Като бързо припомняне: <code>reset --hard</code> обикновено работи на три стъпки:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Премества клона, към който сочи HEAD.
В този случай искаме да местим <code>master</code> до позицията, в която е бил преди сливащия къмит (<code>C6</code>).</p>
</li>
<li>
<p>Променя индекса да изглежда като HEAD.</p>
</li>
<li>
<p>Променя работната директория да изглежда като индекса.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Недостатъкът на този подход е, че променя историята, което може да е проблематично при споделени хранилища.
Погледнете <a href="{{< relurl "book/bg/v2/ch00/_rebase_peril" >}}">[_rebase_peril]</a> за повече информация какво би могло да се случи. Накратко, би следвало да избягвате <code>reset</code> ако други хора вече имат къмитите, които ще преработите.
Освен това, този подход няма да работи ако след сливането има направени други къмити. Преместването на указателите ще доведе до загуба на промените от тези къмити.</p>
</div>
</div>
<div class="sect4">
<h4 id="_reverse_commit">Връщане на къмит</h4>
<div class="paragraph">
<p>Ако преместването на указателите на клоновете не работи за вас, Git ви дава възможността да направите нов къмит, който отменя промените на съществуващ такъв.
Git нарича тази операция “revert” и в този специфичен сценарий се прави така:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git revert -m 1 HEAD
[master b1d8379] Revert "Merge branch 'topic'"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Флагът <code>-m 1</code> указва кой родител да се счита за “mainline” и да бъде запазен.
Когато направите сливането в <code>HEAD</code> (<code>git merge topic</code>), новият къмит има два родителя: първият е <code>HEAD</code> (<code>C6</code>) и вторият е върха на клона, който бива сливан (<code>C4</code>).
В този случай, ние искаме да отменим всички промени настъпили в резултат от сливането на родител #2 (<code>C4</code>) и същевременно да запазим съдържанието на родител # 1 (<code>C6</code>).</p>
</div>
<div class="paragraph">
<p>Историята с revert къмита сега изглежда така:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/bg/v2/images/undomerge-revert.png" >}}" alt="Историята след `git revert -m 1`">
</div>
<div class="title">Фигура 139. Историята след <code>git revert -m 1</code>
</div>
</div>
<div class="paragraph">
<p>Новият къмит <code>^M</code> има същото съдържание като <code>C6</code>, така че оттук нататък нещата са такива сякаш сливането въобще не се е случвало с изключение на факта, че сега не-слетите къмити още са в историята на <code>HEAD</code>.
Git ще изпадне в затруднение, ако сега отново се опитате да слеете <code>topic</code> в <code>master</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge topic
Already up-to-date.</code></pre>
</div>
</div>
<div class="paragraph">
<p>В <code>topic</code> сега няма нищо, което да не е вече достъпно през <code>master</code>.
Което е по-лошо, ако сега направите промени в <code>topic</code> и слеете отново, Git ще вземе промените направени <em>след</em> reverted сливането.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/bg/v2/images/undomerge-revert2.png" >}}" alt="Историята след лошо сливане">
</div>
<div class="title">Фигура 140. Историята след лошо сливане</div>
</div>
<div class="paragraph">
<p>Най-добрият начин да заобиколите това е да откажете revert-a на оригиналното сливане, понеже сега искате да върнете отменените промени и <strong>след това</strong> да създадете нов сливащ къмит:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git revert ^M
[master 09f0126] Revert "Revert "Merge branch 'topic'""
$ git merge topic</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/bg/v2/images/undomerge-revert3.png" >}}" alt="История след повторно сливане на reverted merge">
</div>
<div class="title">Фигура 141. История след повторно сливане на reverted merge</div>
</div>
<div class="paragraph">
<p>В този пример, <code>M</code> и <code>^M</code> са отказани.
<code>^^M</code> ефективно слива промените от <code>C3</code> и`C4`, а <code>C8</code> слива промените от <code>C7</code>, така че сега <code>topic</code> е напълно слят.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_други_типове_сливания">Други типове сливания</h3>
<div class="paragraph">
<p>Досега прегледахме нормално сливане между два клона, което обикновено се осъществява с т. нар. “recursive” сливаща стратегия.
Обаче, има и други начини за сливане на клонове.
Нека видим някои от тях набързо.</p>
</div>
<div class="sect4">
<h4 id="_our_или_theirs_преференция">Our или Theirs преференция</h4>
<div class="paragraph">
<p>Преди всичко има още едно полезно нещо, което можем да правим с нормалния “recursive” режим на сливане.
Вече видяхме <code>ignore-all-space</code> и <code>ignore-space-change</code> опциите подавани с <code>-X</code>, но можем също така да кажем на Git да дава предимство на едната или другата страна при сливането, когато установи конфликт.</p>
</div>
<div class="paragraph">
<p>По подразбиране, когато Git види конфликт между два сливащи се клона, ще добави merge conflict маркери в кода и ще маркира файла като конфликтен, очаквайки да го коригирате.
Ако предпочитате Git просто да избере една от двете опции и да игнорира другата, вместо да остави на вас решаването на проблема, можете да подадете на <code>merge</code> параметрите <code>-Xours</code> или <code>-Xtheirs</code>.</p>
</div>
<div class="paragraph">
<p>В такъв случай маркери няма да бъдат добавяни.
Всички промени, които могат да бъдат слети чисто, ще бъдат слети.
При всички промени, които предизвикват конфликт, Git просто ще избере указаната от вас страна, включително за двоичните файлове.</p>
</div>
<div class="paragraph">
<p>Ако се върнем обратно до “hello world” примера, ще видим че сливането в нашия клон предизвиква конфликти.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved 'hello.rb' using previous resolution.
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ако обаче изпълним командата с <code>-Xours</code> или <code>-Xtheirs</code>, конфликти няма.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge -Xours mundo
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 test.sh  | 2 ++
 2 files changed, 3 insertions(+), 1 deletion(-)
 create mode 100644 test.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>В този случай, вместо да слага маркери за конфликт с “hello mundo” от една страна и “hola world” от друга, Git просто ще избере “hola world”.
Но всички останали промени от този клон, които не предизвикват конфликт, ще бъдат успешно слети.</p>
</div>
<div class="paragraph">
<p>Тази опция може да се подаде и на командата <code>git merge-file</code>, която видяхме по-рано изпълнявайки нещо като <code>git merge-file --ours</code> за индивидуални сливания на файлове.</p>
</div>
<div class="paragraph">
<p>Ако искате да направите нещо такова, но да укажете на Git дори да не се опитва да слива промени от другата страна, има още по-рестриктивна опция, известна като “ours” merge <em>стратегия</em>.
Това е различно от “ours” recursive merge <em>опцията</em>.</p>
</div>
<div class="paragraph">
<p>В действителност това ще направи лъжливо сливане.
Процесът ще запише нов сливащ къмит с двата клона като родители, но практически дори и няма да погледне в клона, който сливате.
Резултатът ще е сливане, което просто записва съдържанието на текущия клон.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge -s ours mundo
Merge made by the 'ours' strategy.
$ git diff HEAD HEAD~
$</code></pre>
</div>
</div>
<div class="paragraph">
<p>Може да видите, че няма разлика между клона, в който сме били и резултата от сливането.</p>
</div>
<div class="paragraph">
<p>Често подобен подход може да е полезен, за да прилъжете Git да приема, че клонът е вече слят, когато искате да правите сливане по-късно.
Да кажем, че сте създали клон <code>release</code> и сте свършили някаква работа в него, която по-късно ще искате да слеете в <code>master</code>.
Междувременно се оказва, че в <code>master</code> е направена някаква спешна корекция на грешка и тази промяна трябва да се интегрира в <code>release</code>.</p>
</div>
<div class="paragraph">
<p>Можете да слеете bugfix клона в <code>release</code> и също да направите <code>merge -s ours</code> за същия клон в <code>master</code> клона (въпреки, че поправката е вече вътре). Така, когато по-късно слеете <code>release</code> клона отново, няма да има конфликти от поправката на грешката.</p>
</div>
</div>
<div class="sect4">
<h4 id="_subtree_merge">Subtree сливане</h4>
<div class="paragraph">
<p>Идеята на subtree сливането е че имате два проекта и единия от тях съществува в поддиректория на другия.
Когато укажете subtree сливане, Git често е достатъчно добър да установи, че единия е поддърво на другия и слива съответно.</p>
</div>
<div class="paragraph">
<p>Ще видим пример за добавяне на отделен проект в съществуващ такъв и след това за сливане на код от втория в поддиректория на първия.</p>
</div>
<div class="paragraph">
<p>Първо, ще добавим приложението Rack към нашия проект.
Ще добавим Rack проекта като отдалечена референция в нашия собствен проект и след това ще го извлечем в негов собствен клон:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add rack_remote https://github.com/rack/rack
$ git fetch rack_remote --no-tags
warning: no common commits
remote: Counting objects: 3184, done.
remote: Compressing objects: 100% (1465/1465), done.
remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.
Resolving deltas: 100% (1952/1952), done.
From https://github.com/rack/rack
 * [new branch]      build      -&gt; rack_remote/build
 * [new branch]      master     -&gt; rack_remote/master
 * [new branch]      rack-0.4   -&gt; rack_remote/rack-0.4
 * [new branch]      rack-0.9   -&gt; rack_remote/rack-0.9
$ git checkout -b rack_branch rack_remote/master
Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.
Switched to a new branch "rack_branch"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Сега имаме корена на Rack проекта в нашия клон <code>rack_branch</code> и нашия собствен проект в <code>master</code> клона.
Ако превключите единия и после другия, може да видите, че те имат различни корени:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ls
AUTHORS         KNOWN-ISSUES   Rakefile      contrib         lib
COPYING         README         bin           example         test
$ git checkout master
Switched to branch "master"
$ ls
README</code></pre>
</div>
</div>
<div class="paragraph">
<p>Това е леко странна концепция.
Не е задължително всички клонове във вашето хранилище да са клонове от един и същи проект.
Не е често срещана ситуация, понеже рядко е полезна, но е сравнително лесно да имате клонове съдържащи изцяло различни истории.</p>
</div>
<div class="paragraph">
<p>В този случай, ние искаме да издърпаме Rack проекта в нашия <code>master</code> проект като поддиректория.
Можем да направим това с <code>git read-tree</code>.
Ще научим повече за тази команда и придружаващите я други в <a href="{{< relurl "book/bg/v2/ch00/ch10-git-internals" >}}">Git на ниско ниво</a>, засега просто приемете, че тя прочита главното дърво на един клон в текущия индекс и работна директория.
Току що превключихме към <code>master</code> клона и издърпваме <code>rack_branch</code> клона в поддиректорията <code>rack</code> на нашия <code>master</code> клон за основния ни проект:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git read-tree --prefix=rack/ -u rack_branch</code></pre>
</div>
</div>
<div class="paragraph">
<p>Когато къмитнем, изглежда имаме всички Rack файлове в тази поддиректория — също както ако бяхме копирали директно вътре от архив.
Интересното в случая е, че можем сравнително лесно да сливаме промени от единия клон в другия.
Така, ако Rack проектът бъде обновен, можем да издърпаме upstream промените като превключим към този клон и стартираме издърпването:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout rack_branch
$ git pull</code></pre>
</div>
</div>
<div class="paragraph">
<p>След това, можем да слеем новите промени обратно в нашия <code>master</code> клон.
За да изтеглим промените и да попълним предварително къмит съобщението, използваме <code>--squash</code> опцията, както и <code>-Xsubtree</code> параметъра на recursive merge стратегията.
Рекурсивната стратегия се подразбира тук, но я указваме за яснота.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
$ git merge --squash -s recursive -Xsubtree=rack rack_branch
Squash commit -- not updating HEAD
Automatic merge went well; stopped before committing as requested</code></pre>
</div>
</div>
<div class="paragraph">
<p>Всички промени на Rack проекта са слети и са готови да се къмитнат локално.
Можете да направите и обратното — да направите модификации в <code>rack</code> поддиректорията на <code>master</code> клона и след това да го слеете в <code>rack_branch</code> клона по-късно за да ги изпратите на собствениците на проекта.</p>
</div>
<div class="paragraph">
<p>Това ни дава възможност да следваме работен процес донякъде подобен на submodule без да използваме подмодули (което ще разгледаме в <a href="{{< relurl "book/bg/v2/ch00/_git_submodules" >}}">Подмодули</a>).
В подобен маниер можем да пазим клонове с други свързани проекти в нашето хранилище и да ги интегрираме при необходимост в нашия собствен проект посредством subtree сливане.
В някои аспекти това е хубаво, защото целият код се къмитва на едно място.
От друга страна, един такъв подход си има и недостатъци, защото е малко по-сложен, по-лесно е да се правят грешки при повторна интеграция на промени и също така може по невнимание да се публикува погрешен клон в неподходящо хранилище.</p>
</div>
<div class="paragraph">
<p>Друго неудобство е, че за да получите diff между съдържанията на <code>rack</code> поддиректорията и кода в <code>rack_branch</code> клона (така че да разберете дали се налага да ги сливате) — не можете да използвате нормалната <code>diff</code> команда.
Вместо това, трябва да използвате <code>git diff-tree</code> с клона, който искате да сравнявате:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff-tree -p rack_branch</code></pre>
</div>
</div>
<div class="paragraph">
<p>Или, за да сравните съдържанието на <code>rack</code> поддиректорията със съдържанието на <code>master</code> клона на сървъра последния път когато сте го издърпали, може да изпълните:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff-tree -p rack_remote/master</code></pre>
</div>
</div>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>