---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: bg
  chapter:
    title: GitHub
    number: 4
  section:
    title: Как да сътрудничим в проект
    number: 2
    cs_number: '4.2'
    previous: book/bg/v2/GitHub-Създаване-и-настройка-на-акаунт
    next: book/bg/v2/GitHub-Управление-на-проект
title: Git - Как да сътрудничим в проект
url: "/book/bg/v2/GitHub-Как-да-сътрудничим-в-проект.html"
---
<h2 id="_как_да_сътрудничим_в_проект">Как да сътрудничим в проект</h2>
<div class="paragraph">
<p>След като акаунтът ви е готов, нека погледнем някои полезни особености, които ще са ви от помощ, когато допринасяте към даден проект с ваш код.</p>
</div>
<div class="sect3">
<h3 id="_forking_на_проекти">Forking на проекти</h3>
<div class="paragraph">
<p>
Ако искате да сътрудничите в съществуващ проект, към който нямате push достъп, можете да “fork”-нете (да клонирате) проекта.
Когато направите fork, GitHub ще направи копие на този проект, което е изцяло ваше; то съществува във вашия namespace и вие можете да пишете в него.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Забележка</div>
</td>
<td class="content">
<div class="paragraph">
<p>В исторически план, понятието “fork” се е възприемало и като негативно действие, при което злонамерен потребител взема проект с отворен код и го насочва в друга посока създавайки понякога конкурентен проект и разделяйки участващите в проекта потребители.
В GitHub, “fork” е просто същия проект преместен във вашия namespace, който можете да променяте, начин да дадете вашия принос към оригиналния проект в по-достъпен стил.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>По този начин, собствениците на проектите са освободени от грижата да дават права за писане на потребителите-сътрудници.
Хората просто fork-ват проект, пишат в копието и накрая предлагат своите промени обратно към оригиналното хранилище посредством похват известен като Pull Request, който ще разгледаме по-нататък.
Това създава дискусионна нишка в сайта с възможност за code review, в която собственикът на проекта и допринасящия към него потребител могат да комуникират дотогава, докато собственикът реши, че предложените промени го задоволяват и може да ги слее в оригинала.</p>
</div>
<div class="paragraph">
<p>За да fork-нете проект, отворете страницата на съответното хранилище и натиснете “Fork” бутона в горната дясна част на страницата.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/bg/v2/images/forkbutton.png" >}}" alt="Бутонът “Fork”">
</div>
<div class="title">Фигура 88. Бутонът “Fork”</div>
</div>
<div class="paragraph">
<p>След няколко секунди, ще бъдете прехвърлени към новата страница на проекта, където вече ще имате права за писане.</p>
</div>
</div>
<div class="sect3">
<h3 id="_github_flow">Работния процес в GitHub</h3>
<div class="paragraph">
<p>
GitHub е проектиран да следва специфичен модел за съвместна работа, в който централно място заемат Pull Requests заявките.
Това работи както за малки екипи в единично споделено хранилище, така и в големи разпределени проекти със стотици разработчици и десетки fork-нати копия.
Акцентът е върху <a href="{{< relurl "book/bg/v2/ch00/_topic_branch" >}}">Topic клонове</a> работната последователност, която обсъждаме в <a href="{{< relurl "book/bg/v2/ch00/ch03-git-branching" >}}">Клонове в Git</a>.</p>
</div>
<div class="paragraph">
<p>Ето как работят нещата накратко:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Fork-вате проект.</p>
</li>
<li>
<p>Създавате topic клон базиран на <code>master</code>.</p>
</li>
<li>
<p>Правите няколко къмита за да подобрите проекта.</p>
</li>
<li>
<p>Изпращате този topic клон към вашия GitHub проект, в който можете да пишете.</p>
</li>
<li>
<p>Създавате Pull Request в GitHub.</p>
</li>
<li>
<p>Дискутирате и (ако е необходимо) къмитвате допълнително код.</p>
</li>
<li>
<p>Собственикът на оригиналния проект слива или закрива отворения от вас Pull Request.</p>
</li>
<li>
<p>Синхронизирате обновения master обратно към вашия fork.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>В общи линии, това е Integration Manager похвата за работа, който видяхме в <a href="{{< relurl "book/bg/v2/ch00/_integration_manager" >}}">[_integration_manager]</a>, само че вместо имейл съобщения за дискусия на промените, програмистите използват директно уеб-базираните инструменти в сайта на GitHub.</p>
</div>
<div class="paragraph">
<p>Нека видим това с един реален пример за проект в GitHub.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Подсказка</div>
</td>
<td class="content">
<div class="paragraph">
<p>Можете да ползвате официалния <strong>GitHub CLI</strong> инструмент вместо уеб интерфейса на GitHub за повечето операции.
Инструментът е наличен за Windows, MacOS, и Linux.
Отидете на <a href="https://cli.github.com/" target="_blank" rel="noopener">GitHub CLI homepage</a>, където има инструкции за инсталация и ползването му.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h4 id="_създаване_на_pull_request">Създаване на Pull Request</h4>
<div class="paragraph">
<p>Да кажем, че Tony търси определен код, който да стартира на своя програмируем микроконтролер Arduino и го е открил в GitHub хранилището на адрес <a href="https://github.com/schacon/blink" class="bare">https://github.com/schacon/blink</a>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/bg/v2/images/blink-01-start.png" >}}" alt="Проектът, в който искаме да сътрудничим">
</div>
<div class="title">Фигура 89. Проектът, в който искаме да сътрудничим</div>
</div>
<div class="paragraph">
<p>Кодът е ОК, единственият проблем е, че скоростта на примигване е твърде висока и решаваме да я намалим до веднъж на 3 секунди, вместо всяка секунда.
Така че, нека променим програмата и да изпратим промяната си като предложим тя да бъде интегрирана в главния проект.</p>
</div>
<div class="paragraph">
<p>Първо, натискаме бутона 'Fork', за да си създаден собствено копие на проекта.
Потребителското ни име е “tonychacon”, така че нашето копие на този проект ще е на адрес <code><a href="https://github.com/tonychacon/blink" class="bare">https://github.com/tonychacon/blink</a></code> и там ще можем да пишем.
Ще си го клонираме локално в компютъра, ще създадем topic клон, ще променим необходимото и ще изпратим промените обратно към GitHub.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone https://github.com/tonychacon/blink <b class="conum">(1)</b>
Cloning into 'blink'...

$ cd blink
$ git checkout -b slow-blink <b class="conum">(2)</b>
Switched to a new branch 'slow-blink'

$ sed -i '' 's/1000/3000/' blink.ino (macOS) <b class="conum">(3)</b>
# If you're on a Linux system, do this instead:
# $ sed -i 's/1000/3000/' blink.ino <b class="conum">(3)</b>

$ git diff --word-diff <b class="conum">(4)</b>
diff --git a/blink.ino b/blink.ino
index 15b9911..a6cc5a5 100644
--- a/blink.ino
+++ b/blink.ino
@@ -18,7 +18,7 @@ void setup() {
// the loop routine runs over and over again forever:
void loop() {
  digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
}

$ git commit -a -m 'Change delay to 3 seconds' <b class="conum">(5)</b>
[slow-blink 5ca509d] Change delay to 3 seconds
 1 file changed, 2 insertions(+), 2 deletions(-)

$ git push origin slow-blink <b class="conum">(6)</b>
Username for 'https://github.com': tonychacon
Password for 'https://tonychacon@github.com':
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 340 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
To https://github.com/tonychacon/blink
 * [new branch]      slow-blink -&gt; slow-blink</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Клонираме fork-натото хранилище локално в работния компютър.</p>
</li>
<li>
<p>Създаваме описателен topic клон.</p>
</li>
<li>
<p>Променяме кода както смятаме за добре.</p>
</li>
<li>
<p>Проверяваме дали промяната е наистина добра.</p>
</li>
<li>
<p>Къмитваме промяната в topic клона.</p>
</li>
<li>
<p>Качваме topic клона обратно в нашето GitHub копие на хранилището.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Сега, ако се върнем обратно в сайта с нашето копие, ще видим че GitHub е установил, че сме публикували нов topic клон и ще ни предложи голям зелен бутон с чиято помощ да проверим промените и да създадем Pull Request към оригиналния проект.</p>
</div>
<div class="paragraph">
<p>Можете също така да отворите “Branches” страницата на адрес <code>https://github.com/&lt;user&gt;/&lt;project&gt;/branches</code> за да намерите вашия клон и да създадете Pull Request директно оттам.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/bg/v2/images/blink-02-pr.png" >}}" alt="Pull Request бутон">
</div>
<div class="title">Фигура 90. Pull Request бутон</div>
</div>
<div class="paragraph">
<p>
Ако натиснем бутона, ще видим екран, който ни подканя да въведем заглавие и описание на нашия Pull Request.
Почти винаги това усилие си струва, защото подходящото пояснение ще улесни собственика на проекта да разбере по-лесно целта на вашите промени, дали те са коректни и дали наистина подобряват проекта като цяло.</p>
</div>
<div class="paragraph">
<p>Също така, виждаме списък с къмитите на нашия topic клон, които са “ahead” (напред) в сравнение с <code>master</code> клона (в този случай, само един къмит) и унифициран diff със всички промени, които ще бъдат направени в проекта, ако собственикът му реши да направи сливането.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/bg/v2/images/blink-03-pull-request-open.png" >}}" alt="Страница за създаване на Pull Request">
</div>
<div class="title">Фигура 91. Страница за създаване на Pull Request</div>
</div>
<div class="paragraph">
<p>Когато натиснете бутона 'Create pull request' на този екран, собственикът на оригиналния проект ще получи уведомление, че някой предлага промяна и линк към страница описваща всички промени.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Забележка</div>
</td>
<td class="content">
<div class="paragraph">
<p>Въпреки, че Pull Request заявките обикновено се ползват за публични проекти като този, когато сътрудникът е напълно готов с промените си, те също така често се използват във вътрешни проекти <em>в началото</em> на цикъла по разработка.
Понеже можете да продължавате да променяте и публикувате topic клонове дори и <strong>след</strong> като Pull Request-ът от тях е пуснат, често той се създава много рано в процеса на работа и се използва като средство за постъпково следене на развитието на даден проект от целия екип, вместо да се създава в края на процеса.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h4 id="_анализ_на_pull_request">Анализ на Pull Request</h4>
<div class="paragraph">
<p>В този момент, собственикът на проекта може да погледне промените ви и да ги приеме, да ги отхвърли или да ги коментира.
Нека допуснем, че той харесва идеята ви, но би предпочел времето, в което светлината на платката е изключена, да е малко по-дълго от времето, в което е включена.</p>
</div>
<div class="paragraph">
<p>Докато цялата тази комуникация традиционно би се извършвала по имейл в работните процеси описани в <a href="{{< relurl "book/bg/v2/ch00/ch05-distributed-git" >}}">[ch05-distributed-git]</a>, то в GitHub тя се осъществява онлайн.
Собственикът може да разгледа унифицирания diff и да постави коментар щраквайки директно върху кой да е ред от кода.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/bg/v2/images/blink-04-pr-comment.png" >}}" alt="Коментар в специфичен ред от кода в Pull Request">
</div>
<div class="title">Фигура 92. Коментар в специфичен ред от кода в Pull Request</div>
</div>
<div class="paragraph">
<p>Веднъж след като коментарът бъде направен, човекът отворил Pull Request-та (както и всички други следящи хранилището), ще получат уведомление за това.
Ще видим това по-късно, но в общи линии, ако сме разрешили имейл нотификациите, Tony ще получи електронна поща с нещо подобно:</p>
</div>
<div id="_email_notification" class="imageblock">
<div class="content">
<img src="{{< relurl "book/bg/v2/images/blink-04-email.png" >}}" alt="Email уведомление">
</div>
<div class="title">Фигура 93. Коментарите изпратени като имейл уведомление</div>
</div>
<div class="paragraph">
<p>Също така, всеки може да остави общ коментар по Pull Request.
В <a href="{{< relurl "book/bg/v2/ch00/_pr_discussion" >}}">Страница за дискусии за Pull Request</a> можем да видим пример, в който собственикът на проект коментира както даден ред код, така и да оставя общ коментар в секцията за дискусии.
Можете да видите, че code-коментарите също се показват в дискусията.</p>
</div>
<div id="_pr_discussion" class="imageblock">
<div class="content">
<img src="{{< relurl "book/bg/v2/images/blink-05-general-comment.png" >}}" alt="Страница за дискусии за Pull Request">
</div>
<div class="title">Фигура 94. Страница за дискусии за Pull Request</div>
</div>
<div class="paragraph">
<p>Сега сътрудникът може да види какво трябва да коригира по кода си, за да бъде той приет за сливане.
За щастие, това е доста лесно.
Ако използвахте имейл, можеше да се наложи да съберете наново всичката информация и да я изпратите към мейлинг лист отново и отново. С GitHub обаче, вие просто къмитвате към topic клона, публикувате го в хранилището си и това автоматично обновява Pull Request-a.
В <a href="{{< relurl "book/bg/v2/ch00/_pr_final" >}}">Финален Pull Request</a> можете също така да видите, че старият коментар в кода е свит в обновения Pull Request, тъй като е бил направен за ред, който после е бил променен.</p>
</div>
<div class="paragraph">
<p>Добавянето на къмити към съществуващ Pull Request не изпраща нови нотификации, така че след като Tony е публикувал корекциите си, той решава да остави коментар, за да информира собственика, че е направил исканите промени.</p>
</div>
<div id="_pr_final" class="imageblock">
<div class="content">
<img src="{{< relurl "book/bg/v2/images/blink-06-final.png" >}}" alt="Финален Pull Request">
</div>
<div class="title">Фигура 95. Финален Pull Request</div>
</div>
<div class="paragraph">
<p>Интересно за отбелязване, ако кликнете върху секцията “Files Changed” на този Pull Request, ще получите т. нар. “unified” diff — това са общите сумарни промени, които ще бъдат въведени в главния клон на проекта, ако този topic клон бъде слят.
В смисъла на <code>git diff</code>, това автоматично ви показва <code>git diff master…​&lt;branch&gt;</code> за клона, върху който е базиран този Pull Request.
Вижте <a href="{{< relurl "book/bg/v2/ch00/_what_is_introduced" >}}">Изследване на промените</a> за повече информация за този тип diff.</p>
</div>
<div class="paragraph">
<p>Другото, което ще забележите е, че GitHub проверява дали Pull Request-ът ви може да се слее чисто и ако е така - осигурява бутон да го направите директно на сървъра.
Този бутон се показва само ако имате права за писане в хранилището и ако може да се направи тривиално сливане.
Ако го натиснете, GitHub ще направи “non-fast-forward” сливане, което значи че дори сливането <strong>да би могло</strong> да бъде fast-forward, то все пак ще се създаде merge commit.</p>
</div>
<div class="paragraph">
<p>Ако предпочитате, бихте могли просто да изтеглите клона локално и да го слеете на компютър.
Ако направите това и слеете клона с <code>master</code> клона и след това качите обратно в GitHub, то Pull Request-тът ще бъде автоматично затворен.</p>
</div>
<div class="paragraph">
<p>Това е базисният работен процес, който повечето GitHub проекти следват.
Създават се topic клонове, по тях се отварят Pull Request-и, провежда се дискусия, евентуално се извършват допълнителни корекции и накрая Pull Request-ът или се приема или се затваря.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Забележка</div>
</td>
<td class="content">
<div class="title">Не само Forks</div>
<div class="paragraph">
<p>Важно е да отбележим, че можете да създадете Pull Request между два клона в едно и също хранилище.
Ако работите по дадена функционалност с някой друг колега и двамата имате права за писане в проекта, можете да публикувате topic клон в хранилището и да отворите Pull Request по него към <code>master</code> клона на същия проект. Така бихте могли да инициирате code review и дискусия.
Не е необходимо да правите отделно копие на хранилището.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_pull_requests_за_напреднали">Pull Requests за напреднали</h3>
<div class="paragraph">
<p>След като разгледахме основите на сътрудничеството в GitHub, нека погледнем някои интересни трикове и съвети за Pull Request-ите и как да ги използвате по-ефективно.</p>
</div>
<div class="sect4">
<h4 id="_pull_requests_като_пачове">Pull Requests като пачове</h4>
<div class="paragraph">
<p>Важно е да се разбере, че много проекти в действителност не разглеждат Pull Request-ите като поредици от перфектни пачове, които трябва да се прилагат чисто в определена последователност както примерно се гледа на тях в проектите базирани на комуникация през мейлинг листи.
Повечето GitHub проекти гледат на Pull Request клоновете като на итеративна дискусия около дадена предложена промяна, кулминацията на която е унифицирания diff, който се прилага при сливането.</p>
</div>
<div class="paragraph">
<p>Това е важна разлика, понеже в общия случай промяната се предлага преди кодът да е възприет като перфектен - нещо което се случва далеч по-рядко при мейлинг-лист базираните серии от пачове.
Това позволява контакт със собственика на проекта на много по-ранен етап и съответно достигането до финалното решение на даден проблем е много повече плод на съвместни усилия.
Когато с Pull Request се предложи код и собствениците на проекта или трети страни предложат промяна по него, серията пачове не се излива наново а вместо това се публикуват само разликите под формата на нов къмит в клона като дискусията се премества напред в контекста на вече създадената работа.</p>
</div>
<div class="paragraph">
<p>Ако се върнете малко назад и погледнете отново <a href="{{< relurl "book/bg/v2/ch00/_pr_final" >}}">Финален Pull Request</a>, ще забележите, че сътрудникът не е пребазирал къмита си и не е създавал нов Pull Request.
Вместо това, той е създал няколко нови къмита и ги е публикувал в същия клон. По този начин, ако по-късно във времето се върнете и разгледате отново този Pull Request, ще можете лесно да намерите контекста в който дадените решения са били взети.
Натискането на бутона “Merge” в сайта умишлено създава merge къмит, който сочи към Pull Request-а, така че е лесно да се върнете назад и да изследвате оригиналната дискусия, ако е необходимо.</p>
</div>
</div>
<div class="sect4">
<h4 id="_в_тон_с_upstream_промените">В тон с Upstream промените</h4>
<div class="paragraph">
<p>Ако вашият Pull Request стане неактуален или по друга причина не се слива чисто, вероятно ще искате да го поправите, така че да може да бъде лесно слят от собственика на проекта на по-късен етап.
GitHub ще тества това за вас и ще ви уведомява със съобщение в долната част на екрана на всеки Pull Request дали сливането е тривиално или не.</p>
</div>
<div id="_pr_fail" class="imageblock">
<div class="content">
<img src="{{< relurl "book/bg/v2/images/pr-01-fail.png" >}}" alt="Pull Request, който не се слива чисто">
</div>
<div class="title">Фигура 96. Pull Request, който не се слива чисто</div>
</div>
<div class="paragraph">
<p>Ако видите нещо като <a href="{{< relurl "book/bg/v2/ch00/_pr_fail" >}}">Pull Request, който не се слива чисто</a>, ще трябва да поправите вашия клон, така че да стане отново "зелен" и да не се налага собственикът на проекта да извършва допълнителни дейности.</p>
</div>
<div class="paragraph">
<p>Имате два начина да се оправите в подобни случаи.
Можете или да пребазирате вашия клон върху целевия такъв (нормално <code>master</code> клона на хранилището, което сте fork-нали), или да слеете целевия клон с вашия.</p>
</div>
<div class="paragraph">
<p>Повечето разработчици в GitHub правят второто по същите причини, които разгледахме в предишната глава.
Това, което е важно е историята и финалното сливане, така че пребазирането не ви дава много повече от една идея по-чиста история - а за сметка на това е <strong>много</strong> по-труден и податлив на грешки процес.</p>
</div>
<div class="paragraph">
<p>Ако решите да слеете актуалния целеви клон, така че Pull Request-ът ви да може да се слива, ще добавите оригиналното хранилище като нова отдалечена референция, ще издърпате данните от нея, ще слеете основния ѝ клон във вашия topic клон, ще поправите евентуалните проблеми и накрая ще изпратите промените в същия клон, от който сте създали Pull Request-а.</p>
</div>
<div class="paragraph">
<p>Например, нека кажем, че в “tonychacon” случая, който вече използвахме, оригиналният автор е направил промяна, която ще доведе до конфликт с нашия Pull Request.
Нека следваме тази последователност:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add upstream https://github.com/schacon/blink <b class="conum">(1)</b>

$ git fetch upstream <b class="conum">(2)</b>
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (3/3), done.
Unpacking objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0)
From https://github.com/schacon/blink
 * [new branch]      master     -&gt; upstream/master

$ git merge upstream/master <b class="conum">(3)</b>
Auto-merging blink.ino
CONFLICT (content): Merge conflict in blink.ino
Automatic merge failed; fix conflicts and then commit the result.

$ vim blink.ino <b class="conum">(4)</b>
$ git add blink.ino
$ git commit
[slow-blink 3c8d735] Merge remote-tracking branch 'upstream/master' \
    into slower-blink

$ git push origin slow-blink <b class="conum">(5)</b>
Counting objects: 6, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 682 bytes | 0 bytes/s, done.
Total 6 (delta 2), reused 0 (delta 0)
To https://github.com/tonychacon/blink
   ef4725c..3c8d735  slower-blink -&gt; slow-blink</code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Добавяме оригиналното хранилище като remote с име “upstream”.</p>
</li>
<li>
<p>Издърпваме най-новата работа от това отдалечено хранилище.</p>
</li>
<li>
<p>Сливаме главния клон на това хранилище с нашия topic клон.</p>
</li>
<li>
<p>Оправяме възникналия конфликт.</p>
</li>
<li>
<p>Публикуваме обратно към същия topic клон.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>След като направим това, Pull Request-ът ни автоматично ще бъде обновен и проверен дали се слива безконфликтно.</p>
</div>
<div id="_pr_merge_fix" class="imageblock">
<div class="content">
<img src="{{< relurl "book/bg/v2/images/pr-02-merge-fix.png" >}}" alt="Pull Request-ът сега се слива чисто">
</div>
<div class="title">Фигура 97. Pull Request-ът сега се слива чисто</div>
</div>
<div class="paragraph">
<p>Едно от най-добрите неща в Git е, че можете да правите това непрекъснато.
Ако имате много дълго продължаващ проект, можете спокойно да издърпвате и сливате главния му клон много пъти и само трябва да се справяте с евентуално възникналите конфликти след последното ви сливане, което прави процеса лесно управляем.</p>
</div>
<div class="paragraph">
<p>Ако все пак категорично искате да пребазирате клона, за да го прочистите, със сигурност можете да направите това, но горещо се препоръчва да не се презаписва клон от който има пуснат Pull Request.
Ако други хора вече са го изтеглили и са работили по него, ще се сблъскате с всички проблеми посочени в <a href="{{< relurl "book/bg/v2/ch00/_rebase_peril" >}}">[_rebase_peril]</a>.
Много по-малко болезнено би било да публикувате пребазирания клон като нов такъв в GitHub и да отворите нов Pull Request, който сочи към предишния и след това да закриете стария.</p>
</div>
</div>
<div class="sect4">
<h4 id="_указатели">Указатели</h4>
<div class="paragraph">
<p>Следващият ви въпрос би могъл да е “Как да се обръщам към стар Pull Request?”.
Оказва се, че съществуват голям брой начини да се обръщате към други неща почти навсякъде, където можете да пишете в GitHub.</p>
</div>
<div class="paragraph">
<p>Нека започнем с това как да направим cross-reference към друг Pull Request или Issue.
Към всеки Pull Request или Issue се асоциира номер и тези номера са уникални в рамките на проекта.
Например, не можете да имате Pull Request #3 <em>и</em> Issue \#3.
Ако искате да създадете указател към всеки Pull Request или Issue от кой да е друг такъв, можете просто да въведете <code>\#&lt;num&gt;</code> във всеки ваш коментар или описание.
Можете да бъдете и по-специфични, ако Pull Request-ът се намира някъде другаде; напишете <code>username#&lt;num&gt;</code> ако се обръщате към Issue или Pull Request във fork на хранилището, в което се намирате. Или дори <code>username/repo#&lt;num&gt;</code> за да укажете обект от съвсем друго хранилище.</p>
</div>
<div class="paragraph">
<p>Нека погледнем един пример.
Да приемем, че сте пребазирали клона в предишния пример, създали сте нов Pull Request за него и сега искате да посочите стария Pull Request от новия такъв.
Също така, искаме да укажем връзка към Issue което се намира във fork на хранилището и в заключение - Issue в съвсем различен проект.
Можем да попълним описанието точно както <a href="{{< relurl "book/bg/v2/ch00/_pr_references" >}}">Cross references в Pull Request</a></p>
</div>
<div id="_pr_references" class="imageblock">
<div class="content">
<img src="{{< relurl "book/bg/v2/images/mentions-01-syntax.png" >}}" alt="Cross references в Pull Request">
</div>
<div class="title">Фигура 98. Cross references в Pull Request</div>
</div>
<div class="paragraph">
<p>Когато изпратим този Pull Request, ще видим всичко това рендерирано като на фигурата <a href="{{< relurl "book/bg/v2/ch00/_pr_references_render" >}}">Cross references рендерирани в Pull Request</a>.</p>
</div>
<div id="_pr_references_render" class="imageblock">
<div class="content">
<img src="{{< relurl "book/bg/v2/images/mentions-02-render.png" >}}" alt="Cross references рендерирани в Pull Request">
</div>
<div class="title">Фигура 99. Cross references рендерирани в Pull Request</div>
</div>
<div class="paragraph">
<p>Забележете, как пълният GitHub URL, който поставихме, е съкратен така че да показва само нужното.</p>
</div>
<div class="paragraph">
<p>Ако сега Tony се върне и затвори оригиналния Pull Request, ще можем да видим това отбелязано в новия - GitHub автоматично е създал trackback събитие в Pull Request времевата линия.
Това означава, че всеки който посети този Pull Request и види, че той е затворен, може лесно да направи връзка с този, който го замества.
Линкът ще изглежда по подобен начин като на фигурата <a href="{{< relurl "book/bg/v2/ch00/_pr_closed" >}}">Линк към новия Pull Request в линията на времето на затворен Pull Request</a>.</p>
</div>
<div id="_pr_closed" class="imageblock">
<div class="content">
<img src="{{< relurl "book/bg/v2/images/mentions-03-closed.png" >}}" alt="Линк към новия Pull Request в линията на времето на затворен Pull Request">
</div>
<div class="title">Фигура 100. Линк към новия Pull Request в линията на времето на затворен Pull Request</div>
</div>
<div class="paragraph">
<p>Освен чрез Issue номерата, можете също така да сочите към определен къмит чрез SHA-1 сумата.
Трябва да укажете пълните 40 символа и ако GitHub засече това в коментар, ще бъде създаден линк директно към къмита.
Отново, можете да сочите към къмити във fork-нати хранилища или към такива в други хранилища по същия начин, по който го правехте с Issues.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_markdown_в_github">Markdown в GitHub</h3>
<div class="paragraph">
<p>Линкването към други Issues е само началото на интересните неща, които можете да правите в почти всяка текстова кутия в GitHub.
В описанията на Issue и Pull Request-ите, коментарите, коментарите към кода и в други места, можете да използвате т. нар. “GitHub Flavored Markdown”.
С Markdown езика пишете обикновен текст, който се форматира обогатен, когато се рендерира на страницата.</p>
</div>
<div class="paragraph">
<p>Вижте <a href="{{< relurl "book/bg/v2/ch00/_example_markdown" >}}">GitHub Flavored Markdown по време на писане и рендериран</a> за пример как коментари или текст могат да се пишат и рендерират с Markdown.</p>
</div>
<div id="_example_markdown" class="imageblock">
<div class="content">
<img src="{{< relurl "book/bg/v2/images/markdown-01-example.png" >}}" alt="GitHub Flavored Markdown по време на писане и рендериран">
</div>
<div class="title">Фигура 101. GitHub Flavored Markdown по време на писане и рендериран</div>
</div>
<div class="paragraph">
<p>Версията на Markdown, която ползва GitHub, добавя повече екстри към стандартния Markdown синтаксис, които подпомагат създаването на описателни и ясни инструкции към Pull Request-и или Issues.</p>
</div>
<div class="sect4">
<h4 id="_списъци_със_задачи">Списъци със задачи</h4>
<div class="paragraph">
<p>Една много интересна възможност, специално за ползване с Pull Request-и, е списъкът със задачи (Task List).
По същество това е поредица от чекбоксове, с които да отмятате нещата, които трябва да се свършат.
Поставянето им в Issue или Pull Request обикновено индикира, че искате определени задачки да бъдат свършени преди съответния Pull Request/Issue да се приеме като завършен.</p>
</div>
<div class="paragraph">
<p>Списък се създава така:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">- [X] Write the code
- [ ] Write all the tests
- [ ] Document the code</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ако въведем подобен код в описание за Pull Request или Issue, ще го видим рендериран като <a href="{{< relurl "book/bg/v2/ch00/_eg_task_lists" >}}">Списък задачи рендериран в Markdown коментар.</a>.</p>
</div>
<div id="_eg_task_lists" class="imageblock">
<div class="content">
<img src="{{< relurl "book/bg/v2/images/markdown-02-tasks.png" >}}" alt="Списък задачи рендериран в Markdown коментар">
</div>
<div class="title">Фигура 102. Списък задачи рендериран в Markdown коментар.</div>
</div>
<div class="paragraph">
<p>Това често се ползва в Pull Request-и за да се укажат нещата, които трябва да се свършат в клона код преди Pull Request-а да бъде одобрен за сливане.
Истински готината част е, че можете да натискате чекбоксовете за да обновявате коментара — не е необходимо да редактирате Markdown текста директно за да маркирате задачите като свършени.</p>
</div>
<div class="paragraph">
<p>В допълнение, GitHub ще претърси вашите Pull Request и Issues за списъци със задачи и ще ги покаже като метаданни на страниците им.
Например, ако имате Pull Request със задачи и погледнете overview страницата на всички Pull Request-и, можете да видите до каква степен задачите са изпълнени.
Това позволява на потребителите да разделят Pull Request-ите на подзадачи и помага на другите да проследяват развитието на клона.
Може да видите пример за това в <a href="{{< relurl "book/bg/v2/ch00/_task_list_progress" >}}">Преглед на Task list статуса в списъка от Pull Request-и</a>.</p>
</div>
<div id="_task_list_progress" class="imageblock">
<div class="content">
<img src="{{< relurl "book/bg/v2/images/markdown-03-task-summary.png" >}}" alt="Преглед на Task list статуса в списъка от Pull Request-и">
</div>
<div class="title">Фигура 103. Преглед на Task list статуса в списъка от Pull Request-и</div>
</div>
<div class="paragraph">
<p>Това е особено полезно, когато отворите Pull Request рано във времето и го използвате да за следите как вървят дейностите по имплементация на дадена възможност.</p>
</div>
</div>
<div class="sect4">
<h4 id="_отрязъци_код">Отрязъци код</h4>
<div class="paragraph">
<p>В коментарите можете да добавяте и отрязъци от код.
Това е особено полезно, ако искате да представите нещо, което <em>бихте могли</em> да направите преди в действителност да го имплементирате като къмит в клона.
Често се използва и за добавяне на примерен код за нещо, което не работи или пък за това какво имплементира дадения Pull Request.</p>
</div>
<div class="paragraph">
<p>За да добавите част от код в текста, трябва да го “оградите” в обратни апострофи.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">```java
for(int i=0 ; i &lt; 5 ; i++)
{
   System.out.println("i is : " + i);
}
```</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ако добавите и името на езика за програмиране, както сме го направили в примера с 'java', то GitHub също така ще опита да оцвети синтактично отрязъка код.
В горния пример, рендерираният текст ще изглежда като <a href="{{< relurl "book/bg/v2/ch00/_md_code" >}}">Рендериран програмен код</a></p>
</div>
<div id="_md_code" class="imageblock">
<div class="content">
<img src="{{< relurl "book/bg/v2/images/markdown-04-fenced-code.png" >}}" alt="Рендериран програмен код">
</div>
<div class="title">Фигура 104. Рендериран програмен код</div>
</div>
</div>
<div class="sect4">
<h4 id="_цитати">Цитати</h4>
<div class="paragraph">
<p>Ако искате да отговорите на малка част от дълъг коментар, можете избирателно да го цитирате слагайки символа <code>&gt;</code> преди редовете.
В действителност, това се използва толкова често, че дори съществува клавиатурна комбинация.
Ако селектирате текст в коментар, който искате директно да цитирате и натиснете клавиша <code>r</code>, това ще създаде автоматично желания цитат в текстовото поле.</p>
</div>
<div class="paragraph">
<p>Цитатите изглеждат така:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">&gt; Whether 'tis Nobler in the mind to suffer
&gt; The Slings and Arrows of outrageous Fortune,

How big are these slings and in particular, these arrows?</code></pre>
</div>
</div>
<div class="paragraph">
<p>Веднъж рендериран, коментарът изглежда като <a href="{{< relurl "book/bg/v2/ch00/_md_quote" >}}">Рендериран цитат</a>.</p>
</div>
<div id="_md_quote" class="imageblock">
<div class="content">
<img src="{{< relurl "book/bg/v2/images/markdown-05-quote.png" >}}" alt="Рендериран цитат">
</div>
<div class="title">Фигура 105. Рендериран цитат</div>
</div>
</div>
<div class="sect4">
<h4 id="_emoji">Emoji</h4>
<div class="paragraph">
<p>Накрая, можете също така да използвате и emoji.
В действителност, тази възможност се ползва доста често в коментарите на Issues и Pull Request-ите като дори съществува emoji helper.
Ако пишете коментар и започнете със символа <code>:</code>, то ще се покаже autocompleter за да ви помогне да изберете.</p>
</div>
<div id="_md_emoji_auto" class="imageblock">
<div class="content">
<img src="{{< relurl "book/bg/v2/images/markdown-06-emoji-complete.png" >}}" alt="Emoji autocompleter в действие">
</div>
<div class="title">Фигура 106. Emoji autocompleter в действие</div>
</div>
<div class="paragraph">
<p>Emoji-тата са под формата на <code>:&lt;name&gt;:</code> навсякъде в коментара.
Например, можете да напишете това:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">I :eyes: that :bug: and I :cold_sweat:.

:trophy: for :microscope: it.

:+1: and :sparkles: on this :ship:, it's :fire::poop:!

:clap::tada::panda_face:</code></pre>
</div>
</div>
<div class="paragraph">
<p>И те ще изглеждат рендерирани като <a href="{{< relurl "book/bg/v2/ch00/_md_emoji" >}}">Интензивно ползване на emoji</a>.</p>
</div>
<div id="_md_emoji" class="imageblock">
<div class="content">
<img src="{{< relurl "book/bg/v2/images/markdown-07-emoji.png" >}}" alt="Интензивно ползване на emoji">
</div>
<div class="title">Фигура 107. Интензивно ползване на emoji</div>
</div>
<div class="paragraph">
<p>Не че emoji-тата са нещо толкова полезно, но добавят елемент на забавление и разведряване в среда, в която това иначе е трудно постижимо.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Забележка</div>
</td>
<td class="content">
<div class="paragraph">
<p>Съществуват солиден брой уеб услуги, които осигуряват emoji символи.
Можете да погледнете тук:</p>
</div>
<div class="paragraph">
<p><a href="https://www.webfx.com/tools/emoji-cheat-sheet/" class="bare" target="_blank" rel="noopener">https://www.webfx.com/tools/emoji-cheat-sheet/</a></p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h4 id="_изображения">Изображения</h4>
<div class="paragraph">
<p>Чисто технически, това не е част от GitHub Flavored Markdown, но възможността за лесно вмъкване на картинки е полезна функция в GitHub.
Вместо да добавяте Markdown линкове към изображения, което може да е доста досадно, сайтът позволява да влачите и пускате изображенията директно в текстовите кутии.</p>
</div>
<div id="_md_drag" class="imageblock">
<div class="content">
<img src="{{< relurl "book/bg/v2/images/markdown-08-drag-drop.png" >}}" alt="Вмъквайте изображения директно с Drag and drop">
</div>
<div class="title">Фигура 108. Вмъквайте изображения директно с Drag and drop и автоматично вграждане</div>
</div>
<div class="paragraph">
<p>Ако погледнете <a href="{{< relurl "book/bg/v2/ch00/_md_drag" >}}">Вмъквайте изображения директно с Drag and drop и автоматично вграждане</a>, може да видите малката подсказка “Parsed as Markdown” над текстовата област.
Щракайки върху нея, можете да видите пълен спомагателен списък на всичко, което можете да правите с Markdown в GitHub.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_fetch_and_push_on_different_repositories">Актуализиране на вашето публично GitHub хранилище</h3>
<div class="paragraph">
<p>Веднъж след като fork-нете GitHub хранилище, вашето хранилище (или вашия "fork") съществува независимо от оригинала.
В частност, когато в оригиналното хранилище се появят нови къмити, GitHub ви информира за това със съобщение от рода на:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">This branch is 5 commits behind progit:master.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Но вашето клонирано копие никога няма да бъде автоматично обновено от GitHub - това е нещо, което трябва да направите сами.
За щастие не е трудно.</p>
</div>
<div class="paragraph">
<p>Едната възможност да се направи не изисква конфигурация.
Например, ако сте клонирали от <code><a href="https://github.com/progit/progit2.git" class="bare">https://github.com/progit/progit2.git</a></code>, можете да поддържате <code>master</code> клона актуален така:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master <b class="conum">(1)</b>
$ git pull https://github.com/progit/progit2.git <b class="conum">(2)</b>
$ git push origin master <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Ако сте на друг клон, върнете се към <code>master</code>.</p>
</li>
<li>
<p>Изтеглете промените от <code><a href="https://github.com/progit/progit2.git" class="bare">https://github.com/progit/progit2.git</a></code> и ги слейте в <code>master</code>.</p>
</li>
<li>
<p>Изпратете <code>master</code> клона към <code>origin</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Това работи, но е малко досадно да въвеждате fetch URL-а всеки път.
Може да автоматизирате процеса с малко конфигурация:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add progit https://github.com/progit/progit2.git <b class="conum">(1)</b>
$ git fetch progit <b class="conum">(2)</b>
$ git branch --set-upstream-to=progit/master master <b class="conum">(3)</b>
$ git config --local remote.pushDefault origin <b class="conum">(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Добавяте изходното хранилище и му давате име.
Тук сме избрали то да е <code>progit</code>.</p>
</li>
<li>
<p>Вземате референция към клоновете на progit, по-специално <code>master</code>.</p>
</li>
<li>
<p>Настройвате <code>master</code> клона си да тегли от отдалеченото хранилище <code>progit</code>.</p>
</li>
<li>
<p>Дефинирате <code>origin</code> като подразбиращо се push хранилище.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>След като сте направили това, последователността става много по-проста:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master <b class="conum">(1)</b>
$ git pull <b class="conum">(2)</b>
$ git push <b class="conum">(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<ol>
<li>
<p>Ако сте в друг клон се връщате в <code>master</code>.</p>
</li>
<li>
<p>Изтегляте промените от <code>progit</code> и ги сливате в клона <code>master</code>.</p>
</li>
<li>
<p>Изпращате локалния <code>master</code> клон към <code>origin</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Този подход може да е удобен, но си има и недостатъци
Git с готовност ще свърши тази работа за вас, но няма да ви предупреди ако направите къмит в <code>master</code>, изтеглите от <code>progit</code> и след това публикувате в <code>origin</code> — всички тези операции са напълно валидни при такава ситуация.
Така че, трябва да внимавате никога да не къмитвате директно в <code>master</code>, защото този клон ефективно принадлежи към upstream хранилището.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>