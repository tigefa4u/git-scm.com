---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: bg
  chapter:
    title: Git и други системи
    number: 7
  section:
    title: Миграция към Git
    number: 2
    cs_number: '7.2'
    previous: book/bg/v2/Git-и-други-системи-Git-като-клиент
    next: book/bg/v2/Git-и-други-системи-Обобщение
title: Git - Миграция към Git
url: "/book/bg/v2/Git-и-други-системи-Миграция-към-Git.html"
---
<h2 id="_migrating">Миграция към Git</h2>
<div class="paragraph">
<p>
Ако имате наличен код под друга VCS, но искате да използвате Git, ще трябва да мигрирате проекта по някакъв начин.
Тази секция разглежда някои популярни импортиращи инструменти и показва как да си направите свой собствен потребителски importer.
Ще научим как се импортират данни от няколко от най-големите SCM системи защото те формират болшинството потребители, които мигрират и защото за тях се предлагат висококачествени инструменти.</p>
</div>
<div class="sect3">
<h3 id="_subversion">Subversion</h3>
<div class="paragraph">
<p>

Ако сте прочели секцията за използването на <code>git svn</code>, може да сте ползвали тези инструкции за да направите <code>git svn clone</code> към хранилище, след това да сте спрели да използвате Subversion сървъра, да сте публикували в нов Git сървър и да ползвате него занапред.
Ако искате историята, може да направите това толкова бързо колкото може да теглите от Subversion сървъра (което може да отнеме доста време).</p>
</div>
<div class="paragraph">
<p>Обаче, импортът не е перфектен и понеже може да отнеме време, няма да е лошо да го направите правилно.
Първият проблем е с информацията за автора.
В Subversion, всеки къмитващ автор има акаунт на сървъра, който се записва в къмит информацията.
Примерите в предишната секция показваха <code>schacon</code> в някои позиции, като наприме <code>blame</code> изхода и <code>git svn log</code>.
Ако искате да свържете тази информация с информацията за авторите в Git, ще ви трябва някакъв мапинг между Subversion потребителските акаунти и Git авторите.
Създайте файл <code>users.txt</code>, който прави мапинга така:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>schacon = Scott Chacon &lt;schacon@geemail.com&gt;
selse = Someo Nelse &lt;selse@geemail.com&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>За да получите списък с имената на авторите, които SVN използва:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ svn log --xml --quiet | grep author | sort -u | \
  perl -pe 's/.*&gt;(.*?)&lt;.*/$1 = /'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Това генерира лог изхода в XML формат, след това филтрира само редовете с author данни, премахва повторенията и изчиства XML таговете.
Очевидно това ще работи при налични <code>grep</code>, <code>sort</code>, и <code>perl</code>.
След това, пренасочете този изход във файла <code>users.txt</code>, така че да добавите еквивалентните Git потребителски данни във всеки ред.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Забележка</div>
</td>
<td class="content">
<div class="paragraph">
<p>Ако пробвате това на Windows машина, ще срещнете проблем.
Microsoft предлага няколко добри съвета и примера на адрес <a href="https://docs.microsoft.com/en-us/azure/devops/repos/git/perform-migration-from-svn-to-git" class="bare" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/azure/devops/repos/git/perform-migration-from-svn-to-git</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Може да подадете този файл на командата <code>git svn</code> за да я подпомогнете в по-акуратното мапване на данните за авторите.
Можете също да укажете на <code>git svn</code> да не включва метаданните, които Subversion нормално импортира с флага <code>--no-metadata</code> към командите <code>clone</code> или <code>init</code>.
Метаданните включват <code>git-svn-id</code> вграден във всяко къмит съобщение, което Git ще генерира по време на импорта.
Това може да задръсти вашия Git лог и да го направи по-неясен.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Забележка</div>
</td>
<td class="content">
<div class="paragraph">
<p>Ще имате нужда от метаданните, ако искате да клонирате къмитите направени в Git хранилището обратно в оригиналното SVN такова.
Ако не желаете синхронизацията във вашия commit-лог, може спокойно да пропуснете параметъра <code>--no-metadata</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Така командата <code>import</code> ще изглежда по следния начин:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn clone http://my-project.googlecode.com/svn/ \
      --authors-file=users.txt --no-metadata --prefix "" -s my_project
$ cd my_project</code></pre>
</div>
</div>
<div class="paragraph">
<p>Сега ще имате по-красив Subversion импорт в директорията <code>my_project</code>.
Вместо къмити изглеждащи така:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>commit 37efa680e8473b615de980fa935944215428a35a
Author: schacon &lt;schacon@4c93b258-373f-11de-be05-5f7a86268029&gt;
Date:   Sun May 3 00:12:22 2009 +0000

    fixed install - go to trunk

    git-svn-id: https://my-project.googlecode.com/svn/trunk@94 4c93b258-373f-11de-
    be05-5f7a86268029</code></pre>
</div>
</div>
<div class="paragraph">
<p>те ще се показват като:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>commit 03a8785f44c8ea5cdb0e8834b7c8e6c469be2ff2
Author: Scott Chacon &lt;schacon@geemail.com&gt;
Date:   Sun May 3 00:12:22 2009 +0000

    fixed install - go to trunk</code></pre>
</div>
</div>
<div class="paragraph">
<p>Сега не само полето Author изглежда по-добре, но и <code>git-svn-id</code> информацията няма да се появява.</p>
</div>
<div class="paragraph">
<p>Бихте могли да направите и допълнително почистване след импорта.
Добре би било да махнете странните референции, които <code>git svn</code> настройва.
Първо ще преместите таговете, така че да бъдат реални тагове вместо странни отдалечени референции и след това ще преместите останалите клонове, така че да станат локални.</p>
</div>
<div class="paragraph">
<p>За да превърнете таговете в реални Git тагове, изпълнете:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ for t in $(git for-each-ref --format='%(refname:short)' refs/remotes/tags); do git tag ${t/tags\//} $t &amp;&amp; git branch -D -r $t; done</code></pre>
</div>
</div>
<div class="paragraph">
<p>Това ще вземе референциите представляващи отдалечени клонове и започващи с <code>refs/remotes/tags/</code> и ще ги конвертира в реални олекотени тагове в Git.</p>
</div>
<div class="paragraph">
<p>След това, преместваме останалите референции от <code>refs/remotes</code> като локални клонове:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ for b in $(git for-each-ref --format='%(refname:short)' refs/remotes); do git branch $b refs/remotes/$b &amp;&amp; git branch -D -r $b; done</code></pre>
</div>
</div>
<div class="paragraph">
<p>Може да се случи да видите някои допълнителни клонове със суфикс <code>@xxx</code> (където xxx е число), докато в Subversion виждате само един клон.
Това в действителност е Subversion функция наречена “peg-revisions”, за която Git просто няма синтактичен аналог.
По тази причина <code>git svn</code> просто добавя svn version номера към името на клона точно по същия начин, по който бихте го написали в svn за да адресирате въпросния peg-revision в този клон.
Ако тези peg-revisions не ви интересуват, може просто да ги премахнете:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ for p in $(git for-each-ref --format='%(refname:short)' | grep @); do git branch -D $p; done</code></pre>
</div>
</div>
<div class="paragraph">
<p>Сега всички стари клонове са реални Git клонове и всички стари тагове са реални Git такива.</p>
</div>
<div class="paragraph">
<p>Има още едно последно нещо за коригиране.
За съжаление, <code>git svn</code> създава допълнителен клон с име <code>trunk</code>, който съответства на клона по подразбиране на Subversion, но указателят <code>trunk</code> сочи към същото място, към което и <code>master</code>.
Понеже <code>master</code> е нещото, с което сме свикнали с Git, ето как да премахнете допълнителния клон:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch -d trunk</code></pre>
</div>
</div>
<div class="paragraph">
<p>Последно, добавяме нашия нов Git сървър като remote и публикуваме в него:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add origin git@my-git-server:myrepository.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Понеже искаме всичките ни клонове и тагове да се публикуват, можем да изпълним:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git push origin --all
$ git push origin --tags</code></pre>
</div>
</div>
<div class="paragraph">
<p>Сега всичките клонове и тагове ще са в новия ни Git сървър в резултат на един подреден и изчистен импорт.</p>
</div>
</div>
<div class="sect3">
<h3 id="_mercurial">Mercurial</h3>
<div class="paragraph">
<p>
Mercurial и Git имат подобни модели за представяне на версиите и понеже Git е малко по-гъвкав, конвертирането на хранилище от Mercurial към Git е сравнително лесно чрез инструмента "hg-fast-export", който можете да свалите от:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone https://github.com/frej/fast-export.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Първата стъпка е да се сдобием с пълно копие на хранилището на Mercurial, което ще конвертираме:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ hg clone &lt;remote repo URL&gt; /tmp/hg-repo</code></pre>
</div>
</div>
<div class="paragraph">
<p>Следващата е да създадем author mapping файл.
Mercurial е по-малко рестриктивен от Git по отношение на това какво може да се слага в author полето на changeset-ите, така че това е удобен момент за почистване.
Създаването на списъка отнема една команда в <code>bash</code> шела:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cd /tmp/hg-repo
$ hg log | grep user: | sort | uniq | sed 's/user: *//' &gt; ../authors</code></pre>
</div>
</div>
<div class="paragraph">
<p>Това ще отнеме няколко секунди в зависимост от дължината на историята на проекта, след което файлът <code>/tmp/authors</code> ще изглежда по подобен начин:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>bob
bob@localhost
bob &lt;bob@company.com&gt;
bob jones &lt;bob &lt;AT&gt; company &lt;DOT&gt; com&gt;
Bob Jones &lt;bob@company.com&gt;
Joe Smith &lt;joe@company.com&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>В този конкретен пример, един и същи човек (Bob) е създал changeset-и под четири различни имена, едно от които изглежда коректно и друго, което ще е изцяло невалидно за един Git къмит.
Hg-fast-export ни позволява да коригираме това превръщайки всеки ред в правило: <code>"&lt;input&gt;"="&lt;output&gt;"</code>, мапвайки <code>&lt;input&gt;</code> към <code>&lt;output&gt;</code>.
В стринговете <code>&lt;input&gt;</code> и <code>&lt;output&gt;</code>, са позволени всички escape последователности, които се поддържат от <code>string_escape</code> енкодинга на python.
Ако author mapping файлът не съдържа съответен <code>&lt;input&gt;</code>, този автор ще се изпрати към Git непроменен.
Ако всички потребителски имена изглеждат добре, то въобще няма да се нуждаем от такъв файл.
В този пример искаме файлът ни да изглежда така:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>"bob"="Bob Jones &lt;bob@company.com&gt;"
"bob@localhost"="Bob Jones &lt;bob@company.com&gt;"
"bob &lt;bob@company.com&gt;"="Bob Jones &lt;bob@company.com&gt;"
"bob jones &lt;bob &lt;AT&gt; company &lt;DOT&gt; com&gt;"="Bob Jones &lt;bob@company.com&gt;"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Същият вид мапинг файлове може да се използва за преименуване на клонове и тагове, когато дадено Mercurial име не е позволено за Git.</p>
</div>
<div class="paragraph">
<p>След това е време да създадем новото ни Git хранилище и да пуснем експортиращия скрипт:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git init /tmp/converted
$ cd /tmp/converted
$ /tmp/fast-export/hg-fast-export.sh -r /tmp/hg-repo -A /tmp/authors</code></pre>
</div>
</div>
<div class="paragraph">
<p>Флагът <code>-r</code> инструктира hg-fast-export къде да намери Mercurial хранилището, което ще се конвертира, а <code>-A</code> указва къде е author-mapping файла (съответно за файловете за клонове и тагове се използват флаговете <code>-B</code> и <code>-T</code>).
Скриптът парсва Mercurial changeset-ите и ги конвертира в скрипт за целите на "fast-import" функцията на Git (ще я разгледаме малко по-късно).
Това отнема малко време (но за сметка на това е <em>много</em> по-бързо, в сравнение с времето необходимо, ако трябваше да се прави по мрежата) и изходът е доста подробен:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ /tmp/fast-export/hg-fast-export.sh -r /tmp/hg-repo -A /tmp/authors
Loaded 4 authors
master: Exporting full revision 1/22208 with 13/0/0 added/changed/removed files
master: Exporting simple delta revision 2/22208 with 1/1/0 added/changed/removed files
master: Exporting simple delta revision 3/22208 with 0/1/0 added/changed/removed files
[…]
master: Exporting simple delta revision 22206/22208 with 0/4/0 added/changed/removed files
master: Exporting simple delta revision 22207/22208 with 0/2/0 added/changed/removed files
master: Exporting thorough delta revision 22208/22208 with 3/213/0 added/changed/removed files
Exporting tag [0.4c] at [hg r9] [git :10]
Exporting tag [0.4d] at [hg r16] [git :17]
[…]
Exporting tag [3.1-rc] at [hg r21926] [git :21927]
Exporting tag [3.1] at [hg r21973] [git :21974]
Issued 22315 commands
git-fast-import statistics:
---------------------------------------------------------------------
Alloc'd objects:     120000
Total objects:       115032 (    208171 duplicates                  )
      blobs  :        40504 (    205320 duplicates      26117 deltas of      39602 attempts)
      trees  :        52320 (      2851 duplicates      47467 deltas of      47599 attempts)
      commits:        22208 (         0 duplicates          0 deltas of          0 attempts)
      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)
Total branches:         109 (         2 loads     )
      marks:        1048576 (     22208 unique    )
      atoms:           1952
Memory total:          7860 KiB
       pools:          2235 KiB
     objects:          5625 KiB
---------------------------------------------------------------------
pack_report: getpagesize()            =       4096
pack_report: core.packedGitWindowSize = 1073741824
pack_report: core.packedGitLimit      = 8589934592
pack_report: pack_used_ctr            =      90430
pack_report: pack_mmap_calls          =      46771
pack_report: pack_open_windows        =          1 /          1
pack_report: pack_mapped              =  340852700 /  340852700
---------------------------------------------------------------------

$ git shortlog -sn
   369  Bob Jones
   365  Joe Smith</code></pre>
</div>
</div>
<div class="paragraph">
<p>Това е почти всичко.
Всички Mercurial тагове са конвертирани в Git тагове и Mercurial клоновете и bookmarks обектите са превърнати в съответните Git клонове.
Сега сте готови да публикувате хранилището в сървъра:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add origin git@my-git-server:myrepository.git
$ git push origin --all</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_bazaar">Bazaar</h3>
<div class="paragraph">
<p></p>
</div>
<div class="paragraph">
<p>Bazaar е DVCS инструмент подобен на Git и е сравнително лесно да конвертирате Bazaar хранилище в Git такова.
За целта ви трябва плъгина <code>bzr-fastimport</code>.</p>
</div>
<div class="sect4">
<h4 id="_инсталация_на_bzr_fastimport_плъгина">Инсталация на bzr-fastimport плъгина</h4>
<div class="paragraph">
<p>Процедурата е различна под UNIX операционни системи и Windows.
В първия случай, най-лесният начин е да се инсталира пакета <code>bzr-fastimport</code>, който ще си изтегли и всички необходими допълнителни изисквания.</p>
</div>
<div class="paragraph">
<p>Например, под Debian и дериватите му, може да използвате:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ sudo apt-get install bzr-fastimport</code></pre>
</div>
</div>
<div class="paragraph">
<p>С RHEL варианти командата е:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ sudo yum install bzr-fastimport</code></pre>
</div>
</div>
<div class="paragraph">
<p>При Fedora от версия 22 има нов пакетен мениджър, dnf:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ sudo dnf install bzr-fastimport</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ако пакетът не е наличен, може да го инсталирате като плъгин:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ mkdir --parents ~/.bazaar/plugins     # създава необходимите директории за плъгини
$ cd ~/.bazaar/plugins
$ bzr branch lp:bzr-fastimport fastimport   # импортира fastimport плъгина
$ cd fastimport
$ sudo python setup.py install --record=files.txt   # инсталира плъгина</code></pre>
</div>
</div>
<div class="paragraph">
<p>За да работи този плъгин, ще ви трябва също и <code>fastimport</code> модула за Python.
Може да проверите дали е наличен и, ако трябва да го инсталирате, така:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ python -c "import fastimport"
Traceback (most recent call last):
  File "&lt;string&gt;", line 1, in &lt;module&gt;
ImportError: No module named fastimport
$ pip install fastimport</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ако не е наличен, можете да го изтеглите от <a href="https://pypi.python.org/pypi/fastimport/" class="bare" target="_blank" rel="noopener">https://pypi.python.org/pypi/fastimport/</a>.</p>
</div>
<div class="paragraph">
<p>Под Windows, <code>bzr-fastimport</code> се инсталира автоматично със standalone версията и инсталацията по подразбиране (изберете всички чекбоксове).</p>
</div>
<div class="paragraph">
<p>На този етап начините за импортиране на Bazaar хранилище се различават според това дали имате само един клон или не.</p>
</div>
</div>
<div class="sect4">
<h4 id="_проект_с_единичен_клон">Проект с единичен клон</h4>
<div class="paragraph">
<p>Влезте в директорията, съдържаща Bazaar хранилището и инициализирайте Git хранилище:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cd /path/to/the/bzr/repository
$ git init</code></pre>
</div>
</div>
<div class="paragraph">
<p>След това можете просто да експортирате Bazaar хранилището и да го конвертирате в Git така:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ bzr fast-export --plain . | git fast-import</code></pre>
</div>
</div>
<div class="paragraph">
<p>Според размера на проекта, процесът може да отнеме секунди или няколко минути.</p>
</div>
</div>
<div class="sect4">
<h4 id="_проект_с_главен_клон_и_работен_клон">Проект с главен клон и работен клон</h4>
<div class="paragraph">
<p>Можете също да импортирате Bazaar хранилище съдържащо клонове.
Да кажем, че имате два клона: един главен (myProject.trunk) и един текущ (myProject.work).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ls
myProject.trunk myProject.work</code></pre>
</div>
</div>
<div class="paragraph">
<p>Създайте Git хранилище и влезте в него:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git init git-repo
$ cd git-repo</code></pre>
</div>
</div>
<div class="paragraph">
<p>Изтеглете <code>master</code> клона в Git:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ bzr fast-export --export-marks=../marks.bzr ../myProject.trunk | \
git fast-import --export-marks=../marks.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Направете същото и за работния клон:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ bzr fast-export --marks=../marks.bzr --git-branch=work ../myProject.work | \
git fast-import --import-marks=../marks.git --export-marks=../marks.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Сега <code>git branch</code> показва <code>master</code> и <code>work</code> клонове.
Проверете логовете за да се уверите, че те са изцяло импортирани и махнете файловете <code>marks.bzr</code> и <code>marks.git</code>.</p>
</div>
</div>
<div class="sect4">
<h4 id="_синхронизиране_на_индексната_област">Синхронизиране на индексната област</h4>
<div class="paragraph">
<p>Колкото и клонове да имате и без значение от метода на импортиране, индексната ви област сега не е синхронизирана с <code>HEAD</code>. В случая при импортиране на повече от един клон, то това важи и за работната директория.
Ситуацията се разрешава лесно с командата:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git reset --hard HEAD</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_игнориране_на_файловете_от_bzrignore">Игнориране на файловете от .bzrignore</h4>
<div class="paragraph">
<p>Нека сега да видим каква е ситуацията с игнорирането на файлове.
Първото нещо за правене е да преименуваме <code>.bzrignore</code> в <code>.gitignore</code>.
Ако файлът <code>.bzrignore</code> съдържа един или повече редове започващи с "!!" или "RE:", ще трябва да го коригирате и може би дори да създадете няколко <code>.gitignore</code> файлове с цел да игнорирате точно същото съдържание като Bazaar.</p>
</div>
<div class="paragraph">
<p>Последно ще създадем къмит, който съдържа тези промени за миграцията:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git mv .bzrignore .gitignore
$ # modify .gitignore if needed
$ git commit -am 'Migration from Bazaar to Git'</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_изпращане_на_хранилището_към_сървъра">Изпращане на хранилището към сървъра</h4>
<div class="paragraph">
<p>Сега можем да публикуваме импортираното хранилище в новия му дом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add origin git@my-git-server:mygitrepository.git
$ git push origin --all
$ git push origin --tags</code></pre>
</div>
</div>
<div class="paragraph">
<p>Новото Git хранилище е готово за ползване.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_perforce_import">Perforce</h3>
<div class="paragraph">
<p>
Следващата система, за която ще разгледаме процеса по импортиране на данни, е Perforce.
Както видяхме по-рано, Git и Perforce могат да комуникират по два начина: посредством git-p4 и Perforce Git Fusion.</p>
</div>
<div class="sect4">
<h4 id="_perforce_git_fusion">Perforce Git Fusion</h4>
<div class="paragraph">
<p>Git Fusion прави процеса сравнително безболезнен.
Просто задаваме настройките на проекта, мапинга на потребителите и клоновете в конфигурационен файл (виж <a href="{{< relurl "book/bg/v2/ch00/_p4_git_fusion" >}}">Git Fusion</a>) и клонираме хранилището.
Git Fusion ни изработва резултат подобен на оригинално Git хранилище, което е готово да се публикува на Git сървър.
Можем дори да използваме Perforce като Git хост, ако желаем това.</p>
</div>
</div>
<div class="sect4">
<h4 id="_git_p4">Git-p4</h4>
<div class="paragraph">
<p>Git-p4 може също да работи като имортиращ инструмент.
Като пример, ще импортираме проекта Jam от Perforce публичното депо.
За да настроим клиента си, трябва да експортираме P4PORT environment променливата, така че да сочи към Perforce депото:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ export P4PORT=public.perforce.com:1666</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Забележка</div>
</td>
<td class="content">
<div class="paragraph">
<p>За да продължите примерните инструкции, се нуждаете от достъп до Perforce депо.
Ще използваме публичното такова на адрес public.perforce.com, но може да експериментирате с всяко друго, до което имате достъп.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>
Изпълняваме командата <code>git p4 clone</code> за да импортираме проекта Jam от Perforce сървъра, подавайки ѝ като аргументи депото с пътя до проекта и пътя, в който искаме да го импортираме:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git-p4 clone //guest/perforce_software/jam@all p4import
Importing from //guest/perforce_software/jam@all into p4import
Initialized empty Git repository in /private/tmp/p4import/.git/
Import destination: refs/remotes/p4/master
Importing revision 9957 (100%)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Този проект има само един клон, но ако имаме клонове конфигурирани с branch изгледи (или само множество от директории), може да използваме флага <code>--detect-branches</code> за да инструктираме <code>git p4 clone</code> да импортира всички клонове на проекта.
Вижте <a href="{{< relurl "book/bg/v2/ch00/_git_p4_branches" >}}">Клонове</a> за повече подробности.</p>
</div>
<div class="paragraph">
<p>На този етап сме почти готови.
Ако влезем в директорията <code>p4import</code> и изпълним <code>git log</code>, можем да видим импортираната работа:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -2
commit e5da1c909e5db3036475419f6379f2c73710c4e6
Author: giles &lt;giles@giles@perforce.com&gt;
Date:   Wed Feb 8 03:13:27 2012 -0800

    Correction to line 355; change &lt;/UL&gt; to &lt;/OL&gt;.

    [git-p4: depot-paths = "//public/jam/src/": change = 8068]

commit aa21359a0a135dda85c50a7f7cf249e4f7b8fd98
Author: kwirth &lt;kwirth@perforce.com&gt;
Date:   Tue Jul 7 01:35:51 2009 -0800

    Fix spelling error on Jam doc page (cummulative -&gt; cumulative).

    [git-p4: depot-paths = "//public/jam/src/": change = 7304]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Може да забележите как <code>git-p4</code> е оставила идентификатор във всяко къмит съобщение.
Добре е той да се запази, в случай че по-късно се наложи да се обърнем към Perforce change number-a по някаква причина.
Обаче, ако искаме да махнем идентификатора, сега е времето за това — преди да започнем работа по новото хранилище.

За целта използваме командата <code>git filter-branch</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git filter-branch --msg-filter 'sed -e "/^\[git-p4:/d"'
Rewrite e5da1c909e5db3036475419f6379f2c73710c4e6 (125/125)
Ref 'refs/heads/master' was rewritten</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ако пуснем <code>git log</code>, ще видим как всички SHA-1 чексуми за къмитите са се променили, но <code>git-p4</code> стринговете вече отсъстват от къмит съобщенията:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -2
commit b17341801ed838d97f7800a54a6f9b95750839b7
Author: giles &lt;giles@giles@perforce.com&gt;
Date:   Wed Feb 8 03:13:27 2012 -0800

    Correction to line 355; change &lt;/UL&gt; to &lt;/OL&gt;.

commit 3e68c2e26cd89cb983eb52c024ecdfba1d6b3fff
Author: kwirth &lt;kwirth@perforce.com&gt;
Date:   Tue Jul 7 01:35:51 2009 -0800

    Fix spelling error on Jam doc page (cummulative -&gt; cumulative).</code></pre>
</div>
</div>
<div class="paragraph">
<p>Сега импортираното хранилище е готово да се публикува на Git сървър.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_custom_importer">Потребителски импортиращ инструмент</h3>
<div class="paragraph">
<p>

Ако системата ви не е сред дотук разгледаните, може да потърсите импортиращ инструмент в Интернет — качествени такива са налични за CVS, Clear Case, Visual Source Safe, дори за директория от архиви.
Ако никой от тях не работи в конкретния случай или се нуждаете от по-специфичен процес на импортиране, тогава може да използвате <code>git fast-import</code>.
Тази команда чете прости инструкции от стандартния вход за да записва специфични Git данни.
Много по-лесно е да създавате Git обекти по този начин, вместо да използвате raw Git командите или да се опитвате да записвате raw обекти (вижте <a href="{{< relurl "book/bg/v2/ch00/ch10-git-internals" >}}">Git на ниско ниво</a> за повече информация).
По този начин можете да напишете собствен импортиращ скрипт, който чете необходимата информация от системата, от която импортирате и печата последоветелно инструкции към стандартния изход.
Можете да пуснете програмата и да пренасочите изхода ѝ към <code>git fast-import</code>.</p>
</div>
<div class="paragraph">
<p>За демонстрация, ще напишем прост импортиращ инструмент.
Да приемем, че работите в директория <code>current</code>, редовно архивирате проекта си в отделни директории именувани <code>back_YYYY_MM_DD</code> според датата, и в един момент решавате да импортирате всичко това в Git хранилище.
Структурата на директориите изглежда така:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ls /opt/import_from
back_2014_01_02
back_2014_01_04
back_2014_01_14
back_2014_02_03
current</code></pre>
</div>
</div>
<div class="paragraph">
<p>За да импортираме Git директория, трябва да разгледаме как Git съхранява данните си.
Както може би помните, Git грубо казано е свързан списък от къмит обекти, които сочат към snapshot-и от съдържание.
Всичко, което трябва да укажете на <code>fast-import</code> е какво са snapshot-ите със съдържание, какви къмит данни сочат към тях и реда, по който идват.
Стратегията е да минаваме по snapshot-ите един след друг и да създаваме къмити със съдържанието на всяка директория свързвайки всеки къмит с предишния.</p>
</div>
<div class="paragraph">
<p>Както го направихме в <a href="{{< relurl "book/bg/v2/ch00/_an_example_git_enforced_policy" >}}">Примерна Git-Enforced политика</a>, ще пишем скрипта си на Ruby.
Бихте могли да използвате езика, с който вие се чувствате комфортно — просто трябва да печатате съответната информация на <code>stdout</code>.
Освен това, ако сте под Windows, трябва да внимавате да не вмъквате carriage returns символи в края на редовете — <code>git fast-import</code> е чувствителен за това и очаква само line feeds (LF) а не carriage return line feeds (CRLF), което нормално се случва под Windows.</p>
</div>
<div class="paragraph">
<p>За начало, влизаме в съответната директория и идентифицираме всяка поддиректория, която ще бъде snapshot, който да импортираме.
След това, печатаме командите, необходими за експорта.
Основният цикъл изглежда по такъв начин:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">last_mark = nil

# loop through the directories
Dir.chdir(ARGV[0]) do
  Dir.glob("*").each do |dir|
    next if File.file?(dir)

    # move into the target directory
    Dir.chdir(dir) do
      last_mark = print_export(dir, last_mark)
    end
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Изпълняваме <code>print_export</code> от всяка директория, което взема манифеста и маркировката на предишния snapshot и връща манифеста и маркировката на текущия. По този начин можем да ги свържем коректно.
Маркировката (“Mark”) във <code>fast-import</code> е термин за идентификатор, който давате на къмит. Когато създавате къмити, вие давате на всеки от тях маркировка, която може да се ползва за свързване към него от други къмити.
Така първото нещо, което трябва да направи метода <code>print_export</code>, е да генерира маркировка от името на директорията:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">mark = convert_dir_to_mark(dir)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ще направим това създавайки масив от директориите и ще използваме индексите като маркировки, защото те трябва да са цели числа.
Методът изглежда така:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">$marks = []
def convert_dir_to_mark(dir)
  if !$marks.include?(dir)
    $marks &lt;&lt; dir
  end
  ($marks.index(dir) + 1).to_s
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Сега имаме целочислено представяне на къмита и ни трябва дата за неговите метаданни.
Понеже казахме, че датата е отразена в името на директорията, ще я извлечем оттам.
Следващият ред от <code>print_export</code> файла е:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">date = convert_dir_to_date(dir)</code></pre>
</div>
</div>
<div class="paragraph">
<p>където <code>convert_dir_to_date</code> се дефинира като:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">def convert_dir_to_date(dir)
  if dir == 'current'
    return Time.now().to_i
  else
    dir = dir.gsub('back_', '')
    (year, month, day) = dir.split('_')
    return Time.local(year, month, day).to_i
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Това връща целочислена стойност за датата на всяка директория.
Последната необходима част за метаданните е информация за автора, която ще хардкоднем в глобална променлива:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">$author = 'John Doe &lt;john@example.com&gt;'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Сега сме готови да започнем печатането на къмит данните за нашия importer.
Началните данни твърдят, че създаваме къмит обект с данни за това в какъв клон е той, следвани от генерираната маркировка, информацията за автора и къмит съобщението и след това — предишния къмит, ако има такъв.
Кодът изглежда така:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby"># print the import information
puts 'commit refs/heads/master'
puts 'mark :' + mark
puts "committer #{$author} #{date} -0700"
export_data('imported from ' + dir)
puts 'from :' + last_mark if last_mark</code></pre>
</div>
</div>
<div class="paragraph">
<p>Тайм зоната е твърдо зададена на (-0700) за улеснение.
Ако импортираме от друга система, трябва да укажем тайм зоната като отместване.
Къмит съобщението трябва да се представи в специален формат:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>data (size)\n(contents)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Форматът представлява последователност от думата data, размерът на данните за прочитане, нов ред, и накрая, самите данни.
Тук ще използваме helper метод наречен <code>export_data</code>, защото по-късно се нуждаем от същия формат за указване на съдържанието на файловете.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">def export_data(string)
  print "data #{string.size}\n#{string}"
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Остана да укажем файловото съдържание на всеки snapshot.
Това е лесно, защото имаме всеки един в директория — можете да отпечатате командата <code>deleteall</code> последвана от съдържанието на всеки файл в директорията.
Git след това ще запише съответно всеки snapshot:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">puts 'deleteall'
Dir.glob("**/*").each do |file|
  next if !File.file?(file)
  inline_data(file)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Заб.: Понеже много системи представят версиите си като промени между два къмита, fast-import може също така да приема команди с всеки къмит, които да указват кои файлове са били добавени, премахнати или модифицирани и какво е новото съдържание.
Можете да изчислите разликите между snapshot-ите и да подадете само тези данни, но това е по-сложно и може да оставите на Git да го свърши като просто подадете всички данни.
Ако все пак искате това да е ваша работа, погледнете документацията на <code>fast-import</code> за повече подробности как точно да я извършите.</p>
</div>
<div class="paragraph">
<p>Форматът за подаване на ново файлово съдържание или за модифицирано такова е както следва:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>M 644 inline path/to/file
data (size)
(file contents)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Тук, 644 е режимът за файла (ако имате изпълними такива, трябва да ги установите и да ги подадете като 755), а inline казва, че ще предоставите съдържанието веднага след този ред.
Методът <code>inline_data</code> изглежда така:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">def inline_data(file, code = 'M', mode = '644')
  content = File.read(file)
  puts "#{code} #{mode} inline #{file}"
  export_data(content)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Използваме метода <code>export_data</code> дефиниран по-рано, понеже форматът е като за данните на къмит съобщенията.</p>
</div>
<div class="paragraph">
<p>Последното нещо, което трябва да сторим е да върнем текущата маркировка, така че тя да бъде изпратена към следващата итерация:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">return mark</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Забележка</div>
</td>
<td class="content">
<div class="paragraph">
<p>Под Windows трябва да добавите допълнителна стъпка.
Както вече казахме, Windows използва CRLF за символите за край на ред, докато <code>git fast-import</code> очаква само LF.
За да избегнете проблем, ще трябва да укажете на ruby да използва LF вместо CRLF:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">$stdout.binmode</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Това е.
Ето целия скрипт:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#!/usr/bin/env ruby

$stdout.binmode
$author = "John Doe &lt;john@example.com&gt;"

$marks = []
def convert_dir_to_mark(dir)
    if !$marks.include?(dir)
        $marks &lt;&lt; dir
    end
    ($marks.index(dir)+1).to_s
end

def convert_dir_to_date(dir)
    if dir == 'current'
        return Time.now().to_i
    else
        dir = dir.gsub('back_', '')
        (year, month, day) = dir.split('_')
        return Time.local(year, month, day).to_i
    end
end

def export_data(string)
    print "data #{string.size}\n#{string}"
end

def inline_data(file, code='M', mode='644')
    content = File.read(file)
    puts "#{code} #{mode} inline #{file}"
    export_data(content)
end

def print_export(dir, last_mark)
    date = convert_dir_to_date(dir)
    mark = convert_dir_to_mark(dir)

    puts 'commit refs/heads/master'
    puts "mark :#{mark}"
    puts "committer #{$author} #{date} -0700"
    export_data("imported from #{dir}")
    puts "from :#{last_mark}" if last_mark

    puts 'deleteall'
    Dir.glob("**/*").each do |file|
        next if !File.file?(file)
        inline_data(file)
    end
    mark
end

# Loop through the directories
last_mark = nil
Dir.chdir(ARGV[0]) do
    Dir.glob("*").each do |dir|
        next if File.file?(dir)

        # move into the target directory
        Dir.chdir(dir) do
            last_mark = print_export(dir, last_mark)
        end
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ако го изпълним, получаваме съдържание подобно на това:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ruby import.rb /opt/import_from
commit refs/heads/master
mark :1
committer John Doe &lt;john@example.com&gt; 1388649600 -0700
data 29
imported from back_2014_01_02deleteall
M 644 inline README.md
data 28
# Hello

This is my readme.
commit refs/heads/master
mark :2
committer John Doe &lt;john@example.com&gt; 1388822400 -0700
data 29
imported from back_2014_01_04from :1
deleteall
M 644 inline main.rb
data 34
#!/bin/env ruby

puts "Hey there"
M 644 inline README.md
(...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>За да стартираме importer-а, пренасочваме изхода през <code>git fast-import</code> докато сме в Git директорията, в която искаме да импортираме.
Може да създадем нова директория, да изпълним <code>git init</code> в нея за начална точка и да пуснем скрипта:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git init
Initialized empty Git repository in /opt/import_to/.git/
$ ruby import.rb /opt/import_from | git fast-import
git-fast-import statistics:
---------------------------------------------------------------------
Alloc'd objects:       5000
Total objects:           13 (         6 duplicates                  )
      blobs  :            5 (         4 duplicates          3 deltas of          5 attempts)
      trees  :            4 (         1 duplicates          0 deltas of          4 attempts)
      commits:            4 (         1 duplicates          0 deltas of          0 attempts)
      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)
Total branches:           1 (         1 loads     )
      marks:           1024 (         5 unique    )
      atoms:              2
Memory total:          2344 KiB
       pools:          2110 KiB
     objects:           234 KiB
---------------------------------------------------------------------
pack_report: getpagesize()            =       4096
pack_report: core.packedGitWindowSize = 1073741824
pack_report: core.packedGitLimit      = 8589934592
pack_report: pack_used_ctr            =         10
pack_report: pack_mmap_calls          =          5
pack_report: pack_open_windows        =          2 /          2
pack_report: pack_mapped              =       1457 /       1457
---------------------------------------------------------------------</code></pre>
</div>
</div>
<div class="paragraph">
<p>Както се вижда, при успешен завършек получавате подробна статистика за извършените дейности.
В този случай сме импортирали 13 обекта за 4 къмита в 1 клон.
Сега може да изпълним <code>git log</code> за да видим новополучената история:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -2
commit 3caa046d4aac682a55867132ccdfbe0d3fdee498
Author: John Doe &lt;john@example.com&gt;
Date:   Tue Jul 29 19:39:04 2014 -0700

    imported from current

commit 4afc2b945d0d3c8cd00556fbe2e8224569dc9def
Author: John Doe &lt;john@example.com&gt;
Date:   Mon Feb 3 01:00:00 2014 -0700

    imported from back_2014_02_03</code></pre>
</div>
</div>
<div class="paragraph">
<p>Получавате чисто ново Git хранилище.
Важно е да отбележим, че нищо не е извлечено на този етап — отначало работната директория е празна.
За да си получим файловете, трябва да върнем клона си там където е <code>master</code> в момента:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ls
$ git reset --hard master
HEAD is now at 3caa046 imported from current
$ ls
README.md main.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Можете да правите още много неща с <code>fast-import</code> инструмента — да обработвате различни режими, двоични данни, множество клонове и сливане, тагове, индикатори за прогрес и т.н.
Има много примери за по-сложни сценарии в директорията <code>contrib/fast-import</code> в сорс кода на Git.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>