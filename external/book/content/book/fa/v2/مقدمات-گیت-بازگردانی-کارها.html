---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: fa
  chapter:
    title: مقدمات گیت
    number: 2
  section:
    title: بازگردانی کارها
    number: 4
    cs_number: '2.4'
    previous: book/fa/v2/مقدمات-گیت-دیدن-تاریخچهٔ-کامیت‌ها
    next: book/fa/v2/مقدمات-گیت-کار-با-ریموت‌ها
title: Git - بازگردانی کارها
url: "/book/fa/v2/مقدمات-گیت-بازگردانی-کارها.html"
---
<h2 id="_undoing">بازگردانی کارها</h2>
<div class="paragraph">
<p>در هر مرحله، شاید بخواهید که چیزی را یا کاری را بازگردانی یا برگشت دهید.
اینجا برخی ابزار پایه‌ای برای بازگردانی تغییرات و کارهایی که انجام داده‌اید را بررسی خواهیم کرد.
توجه کنید، چرا که همیشه نمی‌توانید همهٔ همین بازگردانی‌ها را بازگردانی کنید.
اینجا یکی از معدود حیطه‌های گیت است که اگر اشتباه انجامش دهید امکان دارد مقداری از کارتان از دست برود.</p>
</div>
<div class="paragraph">
<p>یکی از متداول‌ترین بازگشت‌ها زمانی است که شما خیلی زود کامیت می‌گیرید و احتمالاً فراموش می‌کنید چند فایی اضافه کنید یا یا پیام کامیت‌تان را خراب کرده‌اید.
اگر می‌خواهید دوباره آن کامیت را بگیرید، تغییرات اضافه فراموش شده را اعمال کنید، آنها را استیج کنید و دوباره با استفاده از آپشن <code>--amend</code> کامیت کنید:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git commit --amend</code></pre>
</div>
</div>
<div class="paragraph">
<p>این دستور استیج شما را دریافت می‌کند و از آن برای کامیت استفاده می‌کند.
اگر از آخرین کامیتتان تغییری ایجاد نکرده باشید (برای مثال، دستور را به محض انجام کامیت قبلی اجرا کنید)، اسنپ‌شات شما دقیقاً به همان شکل خواهد بود و تمام چیزی که تغییر می‌کند فقط پیام کامیت شما است.</p>
</div>
<div class="paragraph">
<p>همان ویرایشگر پیام کامیت بالا می‌آید، اما از پیش حاوی پیام کامیت قبلی شما است.
مثل همیشه می‌توانید پیام را مانند همیشه اصلاح کنید، اما این عمل کامیت قبلی را بازنویسی می‌شود.</p>
</div>
<div class="paragraph">
<p>برای مثال، اگر کامیت کنید و سپس متوجه شوید فراموش کرده‌اید که تغییراتی در فایل را که می‌خواستید به این کامیت اضافه کنید استیج کنید، می‌توانید چنین کاری کنید:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git commit -m 'Initial commit'
$ git add forgotten_file
$ git commit --amend</code></pre>
</div>
</div>
<div class="paragraph">
<p>در نهایت کار شما با یک کامیت به پایان می‌رسد — کامیت دوم جایگزین نتایج کامیت اول می‌شود.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">یادداشت</div>
</td>
<td class="content">
<div class="paragraph">
<p>خیلی مهم است که بدانید که وقتی درحال امند کردن آخرین کامیت خود هستید، درواقع شما آن را آنچنان تعمیر نمی‌کنید چراکه آنرا با
یک ورودی کاملاً جدید و بهبودیافته <em>جایگزین</em> می‌سازید که کامیت قدیمی را کنار می‌زند و در جای آن می‌نشیند.
در نتیجه، انگار کامیت قبلی هرگز بوجود نیامده است و در تاریخچهٔ مخزن شما نمایش داده نمی‌شود.</p>
</div>
<div class="paragraph">
<p>فایده مشخص امند کردن کامیت‌هااین است که بدون ایجاد درهم ریختگی در تاریخچهٔ مخزن با پیغام کامیت‌های مثل
«اوه، اضافه کردن یک فایل فراموش شده بود‍‍» یا «اصلاح یک غلط املایی در کامیت آخر»، یک تغییر خیلی جزئی برای آخرین کامیت می‌سازید.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h3 id="_unstaging">آن‌استیج کردن یک فایل استیج‌شده</h3>
<div class="paragraph">
<p>دو قسمت بعدی نشان می‌دهند که چگونه با استیج خود و تغییرات پوشه کاری کار کنید.
قسمت قشنگ آن این است که دستوری که برای تعیین وضعیت آن دو بخش به کار می‌رود همچنین یاد‌آوری می‌کند که چگونه تغییرات به عقب برگردانید.
برای مثال، فرض کنیم شما دو فایل را تغییر داده‌اید و می‌خواهید آن‌ها را جدا از هم کامیت کنید، اما به اتفاقاً دستور <code>git add *</code> را وارد می‌کنید و هر دوی آن‌ها را استیج می‌کنید.
چطور می‌توانید یکی از آنها را آن‌استیج کنید؟
دستور <code>git status</code> به شما یادآوری می‌کند:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add *
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    renamed:    README.md -&gt; README
    modified:   CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>دقیقاً زیر متن «Changes to be comitted»، به شما می‌گوید از <code>git reset HEAD &lt;file&gt; ...</code> برای آن‌استیج استفاده کنید.
پس بایید به توصیه گیت گوش کنیم و فایل <code>CONTRIBURING.md</code> را آن‌استیج کنیم:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git reset HEAD CONTRIBUTING.md
Unstaged changes after reset:
M	CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    renamed:    README.md -&gt; README

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>دستور مقداری عجیب به نظر می‌رسد،‌ اما کار می‌کند.
فایل <code>CONTRIBUTING.md</code> تغییر کرده است اما دوباره به حال آن‌استیج درآمده است.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">یادداشت</div>
</td>
<td class="content">
<div class="paragraph">
<p>درست است که دستور <code>git reset</code> می‌تواند خطرناک باشد، مخصوصاً اگر از فلگ <code>--hard</code> را به آن بدهید.
با این حال، در این سناریو که بالا توضیح داده شد، فایلی که در پوشه کاری شما قرار دارد تغییر نیافته، پس نسبتاً ایمن است.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>در حال حاضر این توضیحات جادویی تمام چیزی بود که لازم بود درباره دستور <code>git reset</code> بدانید.
بعدتر در بخش <a href="{{< relurl "book/fa/v2/ch00/_git_reset" >}}">Reset Demystified</a> با جزئیات بیشتری وارد بحث <code>reset</code> می‌شویم که چه کاری می‌کند و چطور می‌توان در آن خبره شد تا کارهای  جالب‌تری انجام داد.</p>
</div>
</div>
<div class="sect3">
<h3 id="_بازگردانی_تغییرات_یک_فایل_تغییریافته">بازگردانی تغییرات یک فایل تغییریافته</h3>
<div class="paragraph">
<p>اگر ببینید که دیگر نمی‌خواهید تغییرات فایل <code>COUNTRIBUTING.md</code> را حفظ کنید چطور؟
چطور می‌شود تغییرات را به حالت قبل برگرداند — آن را به همان شکل که در آخرین کامیت شما (یا کلون اولیه، یا همانگونه که وارد پوشه کاری شما شده بود) بازگرداند؟
خوشبختانه، <code>git status</code> این را نیز به شما می‌گوید که چگونه آن را انجام دهید.
در خروجی آخرین مثال، بخش آن‌استیج چیزی شبیه به این بود:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>این به صراحت تمام به شما می‌گوید که تغییرات انجام شده را چگونه از بین ببریم.
بیایید کاری که می‌گوید را انجام دهیم:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -- CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    renamed:    README.md -&gt; README</code></pre>
</div>
</div>
<div class="paragraph">
<p>شما می‌‌توانید ببینید که تغییرات به حالت اول بازگشتند.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">مهم</div>
</td>
<td class="content">
<div class="paragraph">
<p>مهم است که بدانید دستور <code>git checkout -- &lt;file&gt;</code> دستور خطرناکی است.
هر تغییر محلی که به آن فایل اعمال شده بود از بین رفته است — گیت تغییرات فایل‌ها را با آخرین نسخه کامیت‌ شده جایگزین می‌کند.
هرگز از این دستور استفاده نکنید مگر اینکه کاملاً می‌دانید که نمی‌خواهید آن تغییرات ذخیره نشده محلی از بین برود.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>اگر مایل هستید تا تغییراتی که ایجاد کرده بودید را حفظ کنید اما باز هم لازم است که موقتاً آنها را از سر راهتان بردارید،
در <a href="{{< relurl "book/fa/v2/ch00/ch03-git-branching" >}}">شاخه‌سازی در گیت</a> به بررسی استش و شاخه‌سازی خواهیم پرداخت؛ به طور کل این‌ها راه‌های بهتری برای انجام این کار هستند.</p>
</div>
<div class="paragraph">
<p>یادتان باشد، هرچیزی که در گیت <em>کامیت‌</em> شده باشد تقریباً همیشه می‌تواند بازگردانی شود.
حتی کامیت‌هایی که بر روی شاخه‌هایی که حذف شده‌اند وجود داشتند یا
کامیت‌هایی که با فلگ <code>--amend</code> بازنویسی شده‌ بودند می‌توانند بازگردانی شوند (بخش <a href="{{< relurl "book/fa/v2/ch00/_data_recovery" >}}">Data Recovery</a> را برای بازیابی داده ببینید).
با این حال، هر چیزی را که از دست می‌دهید که هرگز کامیت نشده، قریب به یقین دیگر نخواهید دید.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>