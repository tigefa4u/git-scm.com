---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: fa
  chapter:
    title: Git Tools
    number: 7
  section:
    title: Rewriting History
    number: 6
    cs_number: '7.6'
    previous: book/fa/v2/Git-Tools-Searching
    next: book/fa/v2/Git-Tools-Reset-Demystified
title: Git - Rewriting History
---
<h2 id="_rewriting_history">Rewriting History</h2>
<div class="paragraph">
<p>Many times, when working with Git, you may want to revise your local commit history.
One of the great things about Git is that it allows you to make decisions at the last possible moment.
You can decide what files go into which commits right before you commit with the staging area, you can decide that you didn’t mean to be working on something yet with <code>git stash</code>, and you can rewrite commits that already happened so they look like they happened in a different way.
This can involve changing the order of the commits, changing messages or modifying files in a commit, squashing together or splitting apart commits, or removing commits entirely — all before you share your work with others.</p>
</div>
<div class="paragraph">
<p>In this section, you’ll see how to accomplish these tasks so that you can make your commit history look the way you want before you share it with others.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">یادداشت</div>
</td>
<td class="content">
<div class="title">Don’t push your work until you’re happy with it</div>
<div class="paragraph">
<p>One of the cardinal rules of Git is that, since so much work is local within your clone, you have a great deal of freedom to rewrite your history <em>locally</em>.
However, once you push your work, it is a different story entirely, and you should consider pushed work as final unless you have good reason to change it.
In short, you should avoid pushing your work until you’re happy with it and ready to share it with the rest of the world.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h3 id="_git_amend">Changing the Last Commit</h3>
<div class="paragraph">
<p>Changing your most recent commit is probably the most common rewriting of history that you’ll do.
You’ll often want to do two basic things to your last commit: simply change the commit message, or change the actual content of the commit by adding, removing and modifying files.</p>
</div>
<div class="paragraph">
<p>If you simply want to modify your last commit message, that’s easy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git commit --amend</code></pre>
</div>
</div>
<div class="paragraph">
<p>The command above loads the previous commit message into an editor session, where you can make changes to the message, save those changes and exit.
When you save and close the editor, the editor writes a new commit containing that updated commit message and makes it your new last commit.</p>
</div>
<div class="paragraph">
<p>If, on the other hand, you want to change the actual <em>content</em> of your last commit, the process works basically the same way — first make the changes you think you forgot, stage those changes, and the subsequent <code>git commit --amend</code> <em>replaces</em> that last commit with your new, improved commit.</p>
</div>
<div class="paragraph">
<p>You need to be careful with this technique because amending changes the SHA-1 of the commit.
It’s like a very small rebase — don’t amend your last commit if you’ve already pushed it.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">نکته</div>
</td>
<td class="content">
<div class="title">An amended commit may (or may not) need an amended commit message</div>
<div class="paragraph">
<p>When you amend a commit, you have the opportunity to change both the commit message and the content of the commit.
If you amend the content of the commit substantially, you should almost certainly update the commit message to reflect that amended content.</p>
</div>
<div class="paragraph">
<p>On the other hand, if your amendments are suitably trivial (fixing a silly typo or adding a file you forgot to stage) such that the earlier commit message is just fine, you can simply make the changes, stage them, and avoid the unnecessary editor session entirely with:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git commit --amend --no-edit</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h3 id="_changing_multiple">Changing Multiple Commit Messages</h3>
<div class="paragraph">
<p>To modify a commit that is farther back in your history, you must move to more complex tools.
Git doesn’t have a modify-history tool, but you can use the rebase tool to rebase a series of commits onto the HEAD they were originally based on instead of moving them to another one.
With the interactive rebase tool, you can then stop after each commit you want to modify and change the message, add files, or do whatever you wish.
You can run rebase interactively by adding the <code>-i</code> option to <code>git rebase</code>.
You must indicate how far back you want to rewrite commits by telling the command which commit to rebase onto.</p>
</div>
<div class="paragraph">
<p>For example, if you want to change the last three commit messages, or any of the commit messages in that group, you supply as an argument to <code>git rebase -i</code> the parent of the last commit you want to edit, which is <code>HEAD~2^</code> or <code>HEAD~3</code>.
It may be easier to remember the <code>~3</code> because you’re trying to edit the last three commits, but keep in mind that you’re actually designating four commits ago, the parent of the last commit you want to edit:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rebase -i HEAD~3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Remember again that this is a rebasing command — every commit in the range <code>HEAD~3..HEAD</code> with a changed message <em>and all of its descendants</em> will be rewritten.
Don’t include any commit you’ve already pushed to a central server — doing so will confuse other developers by providing an alternate version of the same change.</p>
</div>
<div class="paragraph">
<p>Running this command gives you a list of commits in your text editor that looks something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">pick f7f3f6d Change my name a bit
pick 310154e Update README formatting and add blame
pick a5f4a0d Add cat-file

# Rebase 710f0f8..a5f4a0d onto 710f0f8
#
# Commands:
# p, pick &lt;commit&gt; = use commit
# r, reword &lt;commit&gt; = use commit, but edit the commit message
# e, edit &lt;commit&gt; = use commit, but stop for amending
# s, squash &lt;commit&gt; = use commit, but meld into previous commit
# f, fixup &lt;commit&gt; = like "squash", but discard this commit's log message
# x, exec &lt;command&gt; = run command (the rest of the line) using shell
# b, break = stop here (continue rebase later with 'git rebase --continue')
# d, drop &lt;commit&gt; = remove commit
# l, label &lt;label&gt; = label current HEAD with a name
# t, reset &lt;label&gt; = reset HEAD to a label
# m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]
# .       create a merge commit using the original merge commit's
# .       message (or the oneline, if no original merge commit was
# .       specified). Use -c &lt;commit&gt; to reword the commit message.
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out</code></pre>
</div>
</div>
<div class="paragraph">
<p>It’s important to note that these commits are listed in the opposite order than you normally see them using the <code>log</code> command.
If you run a <code>log</code>, you see something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --pretty=format:"%h %s" HEAD~3..HEAD
a5f4a0d Add cat-file
310154e Update README formatting and add blame
f7f3f6d Change my name a bit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice the reverse order.
The interactive rebase gives you a script that it’s going to run.
It will start at the commit you specify on the command line (<code>HEAD~3</code>) and replay the changes introduced in each of these commits from top to bottom.
It lists the oldest at the top, rather than the newest, because that’s the first one it will replay.</p>
</div>
<div class="paragraph">
<p>You need to edit the script so that it stops at the commit you want to edit.
To do so, change the word ‘pick’ to the word ‘edit’ for each of the commits you want the script to stop after.
For example, to modify only the third commit message, you change the file to look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">edit f7f3f6d Change my name a bit
pick 310154e Update README formatting and add blame
pick a5f4a0d Add cat-file</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you save and exit the editor, Git rewinds you back to the last commit in that list and drops you on the command line with the following message:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rebase -i HEAD~3
Stopped at f7f3f6d... changed my name a bit
You can amend the commit now, with

       git commit --amend

Once you're satisfied with your changes, run

       git rebase --continue</code></pre>
</div>
</div>
<div class="paragraph">
<p>These instructions tell you exactly what to do.
Type</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git commit --amend</code></pre>
</div>
</div>
<div class="paragraph">
<p>Change the commit message, and exit the editor.
Then, run</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rebase --continue</code></pre>
</div>
</div>
<div class="paragraph">
<p>This command will apply the other two commits automatically, and then you’re done.
If you change pick to edit on more lines, you can repeat these steps for each commit you change to edit.
Each time, Git will stop, let you amend the commit, and continue when you’re finished.</p>
</div>
</div>
<div class="sect3">
<h3 id="_reordering_commits">Reordering Commits</h3>
<div class="paragraph">
<p>You can also use interactive rebases to reorder or remove commits entirely.
If you want to remove the “added cat-file” commit and change the order in which the other two commits are introduced, you can change the rebase script from this</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">pick f7f3f6d Change my name a bit
pick 310154e Update README formatting and add blame
pick a5f4a0d Add cat-file</code></pre>
</div>
</div>
<div class="paragraph">
<p>to this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">pick 310154e Update README formatting and add blame
pick f7f3f6d Change my name a bit</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you save and exit the editor, Git rewinds your branch to the parent of these commits, applies <code>310154e</code> and then <code>f7f3f6d</code>, and then stops.
You effectively change the order of those commits and remove the “added cat-file” commit completely.</p>
</div>
</div>
<div class="sect3">
<h3 id="_squashing">Squashing Commits</h3>
<div class="paragraph">
<p>It’s also possible to take a series of commits and squash them down into a single commit with the interactive rebasing tool.
The script puts helpful instructions in the rebase message:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">#
# Commands:
# p, pick &lt;commit&gt; = use commit
# r, reword &lt;commit&gt; = use commit, but edit the commit message
# e, edit &lt;commit&gt; = use commit, but stop for amending
# s, squash &lt;commit&gt; = use commit, but meld into previous commit
# f, fixup &lt;commit&gt; = like "squash", but discard this commit's log message
# x, exec &lt;command&gt; = run command (the rest of the line) using shell
# b, break = stop here (continue rebase later with 'git rebase --continue')
# d, drop &lt;commit&gt; = remove commit
# l, label &lt;label&gt; = label current HEAD with a name
# t, reset &lt;label&gt; = reset HEAD to a label
# m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]
# .       create a merge commit using the original merge commit's
# .       message (or the oneline, if no original merge commit was
# .       specified). Use -c &lt;commit&gt; to reword the commit message.
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out</code></pre>
</div>
</div>
<div class="paragraph">
<p>If, instead of “pick” or “edit”, you specify “squash”, Git applies both that change and the change directly before it and makes you merge the commit messages together.
So, if you want to make a single commit from these three commits, you make the script look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">pick f7f3f6d Change my name a bit
squash 310154e Update README formatting and add blame
squash a5f4a0d Add cat-file</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you save and exit the editor, Git applies all three changes and then puts you back into the editor to merge the three commit messages:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console"># This is a combination of 3 commits.
# The first commit's message is:
Change my name a bit

# This is the 2nd commit message:

Update README formatting and add blame

# This is the 3rd commit message:

Add cat-file</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you save that, you have a single commit that introduces the changes of all three previous commits.</p>
</div>
</div>
<div class="sect3">
<h3 id="_splitting_a_commit">Splitting a Commit</h3>
<div class="paragraph">
<p>Splitting a commit undoes a commit and then partially stages and commits as many times as commits you want to end up with.
For example, suppose you want to split the middle commit of your three commits.
Instead of “Update README formatting and add blame”, you want to split it into two commits: “Update README formatting” for the first, and “Add blame” for the second.
You can do that in the <code>rebase -i</code> script by changing the instruction on the commit you want to split to “edit”:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">pick f7f3f6d Change my name a bit
edit 310154e Update README formatting and add blame
pick a5f4a0d Add cat-file</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, when the script drops you to the command line, you reset that commit, take the changes that have been reset, and create multiple commits out of them.
When you save and exit the editor, Git rewinds to the parent of the first commit in your list, applies the first commit (<code>f7f3f6d</code>), applies the second (<code>310154e</code>), and drops you to the console.
There, you can do a mixed reset of that commit with <code>git reset HEAD^</code>, which effectively undoes that commit and leaves the modified files unstaged.
Now you can stage and commit files until you have several commits, and run <code>git rebase --continue</code> when you’re done:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git reset HEAD^
$ git add README
$ git commit -m 'Update README formatting'
$ git add lib/simplegit.rb
$ git commit -m 'Add blame'
$ git rebase --continue</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git applies the last commit (<code>a5f4a0d</code>) in the script, and your history looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -4 --pretty=format:"%h %s"
1c002dd Add cat-file
9b29157 Add blame
35cfb2b Update README formatting
f3cc40e Change my name a bit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once again, this changes the SHA-1s of all the commits in your list, so make sure no commit shows up in that list that you’ve already pushed to a shared repository.</p>
</div>
</div>
<div class="sect3">
<h3 id="_the_nuclear_option_filter_branch">The Nuclear Option: filter-branch</h3>
<div class="paragraph">
<p>There is another history-rewriting option that you can use if you need to rewrite a larger number of commits in some scriptable way — for instance, changing your email address globally or removing a file from every commit.
The command is <code>filter-branch</code>, and it can rewrite huge swaths of your history, so you probably shouldn’t use it unless your project isn’t yet public and other people haven’t based work off the commits you’re about to rewrite.
However, it can be very useful.
You’ll learn a few of the common uses so you can get an idea of some of the things it’s capable of.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<div class="title">گوشزد</div>
</td>
<td class="content">
<div class="paragraph">
<p><code>git filter-branch</code> has many pitfalls, and is no longer the recommended way to rewrite history.
Instead, consider using <code>git-filter-repo</code>, which is a Python script that does a better job for most applications where you would normally turn to <code>filter-branch</code>.
Its documentation and source code can be found at <a href="https://github.com/newren/git-filter-repo" class="bare">https://github.com/newren/git-filter-repo</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h4 id="_removing_file_every_commit">Removing a File from Every Commit</h4>
<div class="paragraph">
<p>This occurs fairly commonly.
Someone accidentally commits a huge binary file with a thoughtless <code>git add .</code>, and you want to remove it everywhere.
Perhaps you accidentally committed a file that contained a password, and you want to make your project open source.
<code>filter-branch</code> is the tool you probably want to use to scrub your entire history.
To remove a file named <code>passwords.txt</code> from your entire history, you can use the <code>--tree-filter</code> option to <code>filter-branch</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)
Ref 'refs/heads/master' was rewritten</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>--tree-filter</code> option runs the specified command after each checkout of the project and then recommits the results.
In this case, you remove a file called <code>passwords.txt</code> from every snapshot, whether it exists or not.
If you want to remove all accidentally committed editor backup files, you can run something like <code>git filter-branch --tree-filter 'rm -f *~' HEAD</code>.</p>
</div>
<div class="paragraph">
<p>You’ll be able to watch Git rewriting trees and commits and then move the branch pointer at the end.
It’s generally a good idea to do this in a testing branch and then hard-reset your <code>master</code> branch after you’ve determined the outcome is what you really want.
To run <code>filter-branch</code> on all your branches, you can pass <code>--all</code> to the command.</p>
</div>
</div>
<div class="sect4">
<h4 id="_making_a_subdirectory_the_new_root">Making a Subdirectory the New Root</h4>
<div class="paragraph">
<p>Suppose you’ve done an import from another source control system and have subdirectories that make no sense (<code>trunk</code>, <code>tags</code>, and so on).
If you want to make the <code>trunk</code> subdirectory be the new project root for every commit, <code>filter-branch</code> can help you do that, too:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git filter-branch --subdirectory-filter trunk HEAD
Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)
Ref 'refs/heads/master' was rewritten</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now your new project root is what was in the <code>trunk</code> subdirectory each time.
Git will also automatically remove commits that did not affect the subdirectory.</p>
</div>
</div>
<div class="sect4">
<h4 id="_changing_email_addresses_globally">Changing Email Addresses Globally</h4>
<div class="paragraph">
<p>Another common case is that you forgot to run <code>git config</code> to set your name and email address before you started working, or perhaps you want to open-source a project at work and change all your work email addresses to your personal address.
In any case, you can change email addresses in multiple commits in a batch with <code>filter-branch</code> as well.
You need to be careful to change only the email addresses that are yours, so you use <code>--commit-filter</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git filter-branch --commit-filter '
        if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];
        then
                GIT_AUTHOR_NAME="Scott Chacon";
                GIT_AUTHOR_EMAIL="schacon@example.com";
                git commit-tree "$@";
        else
                git commit-tree "$@";
        fi' HEAD</code></pre>
</div>
</div>
<div class="paragraph">
<p>This goes through and rewrites every commit to have your new address.
Because commits contain the SHA-1 values of their parents, this command changes every commit SHA-1 in your history, not just those that have the matching email address.</p>
</div>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>