---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: fa
  chapter:
    title: مقدمات گیت
    number: 2
  section:
    title: ثبت تغییرات در مخزن
    number: 2
    cs_number: '2.2'
    previous: book/fa/v2/مقدمات-گیت-دستیابی-به-یک-مخزن-گیت
    next: book/fa/v2/مقدمات-گیت-دیدن-تاریخچهٔ-کامیت‌ها
title: Git - ثبت تغییرات در مخزن
url: "/book/fa/v2/مقدمات-گیت-ثبت-تغییرات-در-مخزن.html"
---
<h2 id="_ثبت_تغییرات_در_مخزن">ثبت تغییرات در مخزن</h2>
<div class="paragraph">
<p>تا اینجا، باید یک مخزن واقعی گیت بر روی سیستم محلیتان داشته باشید و یک چک‌اوت یا <em>کپی کاری</em>  تمام فایل‌های موجود مقابل شما باشد.
معمولاً، شما می‌خواهید شروع به اعمال تغییرات کرده و هنگام رسیدن پروژه به درجهٔ خاصی، اسنپ‌شات‌های همان تغییرات را در مخزن کامیت کنید.</p>
</div>
<div class="paragraph">
<p>بخاطر داشته باشید که هر فایل در پوشه کاری شما می‌تواند یکی از این دو حالت را داشته باشد: <em>Tracked (رهگیری شده)</em> یا <em>Untracked (دنبال نشده)</em>.
فایل‌های رهگیری شده فایل‌هایی هستند که در آخرین اسنپ‌شات شما بوده‌اند؛ آن‌ها می‌توانند ویرایش‌نشده، ویرایش‌شده یا استیج‌شده داشته باشند.
به طور خلاصه، فایل‌های رهگیری شده آنهایی هستند که گیت آن‌ها را می‌شناسد.</p>
</div>
<div class="paragraph">
<p>فایل‌های رهگیری نشده مابقی فایل‌ها هستند — هر فایلی در اسنپ‌شات آخر شما نبوده باشد و شما آن را <em>add</em> نکرده باشید.
در ابتدا، هنگامی که مخزنی را کلون می‌کنید، همهٔ فایل‌ها رهگیری‌شده و دست نخورده هستند زیرا گیت همین الآن آنها را چک‌اوت کرده است و چیزی ویرایش نشده است.</p>
</div>
<div class="paragraph">
<p>به محض تغییر فایل‌ها، گیت وضعیت‌ آن‌ها را به ویرایش‌شده تغییر می‌دهد، چون شما آن را نسبت به کامیت آخر تغییر داده‌اید.
همانطور که کار می‌کنید، به طور انتخابی این فایل‌ها را استیج کرده و تغییرات اعمال شدهٔ تحت استیج را کامیت می‌کنید و این چرخه تکرار می‌شود.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/fa/v2/images/lifecycle.png" >}}" alt="The lifecycle of the status of your files.">
</div>
<div class="title">نمودار 8. چرخه عمر وضعیت فایل‌های شما.</div>
</div>
<div class="sect3">
<h3 id="_checking_status">بررسی وضعیت فایل‌ها</h3>
<div class="paragraph">
<p>ابزار اصلی که شما برای تعیین وضعیت فایل‌ها استفاده می‌کنید، دستور <code>git status</code> است.
اگر شما دستور را مستقیماً بعد از کلون اجرا کنید،‌ باید چیزی شبیه به این ببینید:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working directory clean</code></pre>
</div>
</div>
<div class="paragraph">
<p>این بدین معنی است که پوشه کاری شما تمیز است؛ به زبان دیگر، هیچ کدام از فایل‌های رهگیری‌شده شما ویرایش نشده‌اند.
علاوه بر این گیت هیچ فایل دنبال نشده‌ای نمی‌بینید، اگر می‌دید در اینجا لیست می‌شد.
در آخر، این دستور به شما می‌گوید که بر روی کدام شاخه و شعبه هستید و به شما اطلاع می‌دهد که شاخه مذکور از شاخه‌ای که از سرور آمده جدا نشده است.
فعلاً، آن شاخه همیشه <code>master</code> است که به صورت پیش فرض ساخته شده است؛ نگران نباشید در بخش <a href="{{< relurl "book/fa/v2/ch00/ch03-git-branching" >}}">شاخه‌سازی در گیت</a> درباره این موضوع با جزئیات بحث خواهد شد.</p>
</div>
<div class="paragraph">
<p>فرض کنیم یک فایل جدید به پروژه اضافه می‌کنیم، یک فایل <code>README</code> ساده.
اگر فایل از قبل وجود نداشت و <code>git status</code> را اجرا می‌کردید، فایل‌‌های رهگیری نشده را به شکل زیر می‌دیدید:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 'My Project' &gt; README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)

    README

nothing added to commit but untracked files present (use "git add" to track)</code></pre>
</div>
</div>
<div class="paragraph">
<p>همانطور که می‌بینید فایل <code>README</code> جدیدتان در حالت رهگیری‌نشده است، چون وضعیت فایل در زیر تیتر «Untracked files» خروجی است.
به طوری کلی رهگیری‌نشده به این معنی است که گیت فایلی یافته است که در اسنپ‌شات (کامیت) قبلی نداشته‌اید؛
گیت آن را به اسنپ‌شات کامیت‌های بعدی اضافه نمی‌کند تا زمانی که شما صراحتاً به گیت بگویید که این کار را کند.
گیت این کار را می‌کند تا شما‌ به صورت اتفاقی شروع به اضافه کردن فایل‌های اجرایی ساخته‌شده یا دیگر فایل‌هایی که نمی‌خواهید به مخزن اضافه شوند نکنید.
شما می‌خواهید شروع به اضافه کردن فایل <code>README</code> کنید، پس بیایید رهگیری آن را شروع کنیم.</p>
</div>
</div>
<div class="sect3">
<h3 id="_tracking_files">دنبال کردن فایل‌های جدید</h3>
<div class="paragraph">
<p>برای رهگیری یک فایل جدید، از دستور <code>git add</code> استفاده می‌کنید.
برای شروع پیگیری فایل <code>README</code> می‌توانید این دستور را اجرا کنید:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add README</code></pre>
</div>
</div>
<div class="paragraph">
<p>اگر دستور <code>git status</code> را دوباره وارد کنید، می‌توانید ببیند که حالا فایل <code>README</code> در حالت رهگیری‌شده و استیج‌شده قرار دارد تا کامیت شود:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git restore --staged &lt;file&gt;..." to unstage)

    new file:   README</code></pre>
</div>
</div>
<div class="paragraph">
<p>می‌توانید بگویید که فایل تحت استیج است چراکه فایل در زیر تیتر «Changes to be committed» قرار دارد.
اگر در این نقطه کامیتی بگیرید، نسخه‌ای از فایل در اسنپ‌شات متعاقب خواهد بود که در زمان اجرای <code>git add</code> وجود داشته است.
ممکن است به خاطر داشته باشید که پیشتر، دستور <code>git init</code> و پس از آن <code>git add &lt;files&gt;</code> را اجرا کردید — که برای رهگیری فایل‌های پوشهٔ شما بود.
دستور <code>git add</code> مسیری را برای یک فایل یا پوشه می‌گیرد؛ اگر یک پوشه باشد، دستور به صورت بازگشتی تمامی فایل‌های آن پوشه را اضافه می‌کند.</p>
</div>
</div>
<div class="sect3">
<h3 id="_استیجکردن_فایلهای_ویرایششده">استیج‌کردن فایل‌های ویرایش‌شده</h3>
<div class="paragraph">
<p>بیایید فایلی که در حال حاضر رهگیری‌شده است را تغییر دهیم.
اگر یک فایل از قبل رهگیری‌شده به نام <code>CONTRIBUTING.md</code> تغییر دهید و دوباره دستور <code>git status</code> را اجرا کنید، خروجی مشابه زیر می‌بینید:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    new file:   README

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>فایل <code>CONTRIBUTING.md</code> در بخشی به نام «Changes not staged for commit» ظاهر خواهد شد — به معنی که فایلی در پوشه کاری ویرایش شده است که هنوز آنرا استیج نکرده‌ایم.
برای استیج کردن آن می‌بایست دستور <code>git add</code> را اجرا کنید.
دستور <code>git add</code> چند منظوره است — از آن برای رهگیری کردن فایل‌های جدید، استیج کردن و برای انجام دیگر کارها مثل علامت زدن تداخلات فایل‌ها به عنوان حل شده استفاده می‌کنید.
ممکن است نگاه به آن به عنوان «این محتوا را به کامیت بعدی اضافه کن» قابل فهم‌تر باشد تا «این فایل را به پروژه اضافه کن».
بیایید دستور <code>git add</code> را اجرا کنیم تا فایل <code>CONTRIBUTING.md</code> را استیج کنیم، و بعد دستور <code>git status</code> را دوباره وارد کنیم:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>هر دو فایل استیج شده‌اند و به کامیت بعدی شما اضافه خواهند شد.
در این لحظه، فرض کنید که یادتان می‌آید که می‌خواهید قبل از اینکه کامیت کنید یک تغییر کوچک دیگر در فایل <code>CONTRIBUTING.md</code> ایجاد کنید.
فایل را دوباره باز می‌کنید و تغییرات را اعمال می‌کنید، حالا آماده کامیت هستید.
هرچند، بیایید دوباره دستور <code>git status</code> را اجرا کنیم:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ vim CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>چطور شد؟
فایل <code>CONTRIBUTING.md</code> هم به عنوان فایلی استیج‌شده و <em>همچنین‌</em> استیج‌نشده لیست شده است.
چطور امکان دارد؟
مشخص می‌شود که گیت فایل را دقیقاً به آن صورتی استیج می‌کند که هنگام اجرای دستور <code>git add</code> بوده است.
اگر الآن کامیت کنید، نسخهٔ <code>CONTRIBUTING.md</code> آن خواهد بود که آخرین بار <code>git add</code> را روی آن اجرا کرده‌اید و همانگونه به کامیت اضافه می‌شود، نه آن نسخه‌ای که هنگام اجرای <code>git commit</code> در پوشهٔ کاری شماست.
اگر فایلی را بعد از اجرای <code>git add</code> ویرایش کنید، باید <code>git add</code> را دوباره اجرا کنید تا آخرین نسخهٔ فایل را دوباره استیج کنید:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_وضعیتهای_کوتاه">وضعیت‌های کوتاه</h3>
<div class="paragraph">
<p>خروجی <code>git status</code> خیلی توصیفی و لغوی است؛
گیت همچنین فلگی برای اعلام وضعیت‌های کوتاه دارد که شما را قادر می‌کند تغییرات خود را به طور خلاصه‌تر ببینید.
اگر دستور <code>git status -s</code> یا <code>git status --short</code> را وارد کنید، یک خروجی ساده شده خواهید گرفت:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>فایل‌های جدیدی که هنوز رهگیری نشده‌اند علامت <code>??</code> مقابل آنان است، فایل‌های جدیدی که استیج شده‌اند علامت <code>A</code> دارند، فایل‌های ویرایش‌شده علامت <code>M</code> دارند و باقی نیز به همین ترتیب.
خروجی شامل دو ستون است — ستون سمت چپ نشان‌دهنده وضعیت استیج است و ستون سمت راست نشان‌دهنده وضعیت درخت کاری است.
برای مثال در خروجی بالا، فایل <code>README</code> در پوشه کاری تغییر یافته است اما هنوز استیج نشده، در حالی که فایل <code>lib/simplegit.rb</code> ویرایش و استیج شده است.
فایل <code>Rakefile</code> ویرایش، استیج و بعد دوباره ویرایش شده، به همین دلیل تغییرات آن هم استیج‌شده و استیج‌نشده هستند.</p>
</div>
</div>
<div class="sect3">
<h3 id="_ignoring">نادیده گرفتن فایل‌ها</h3>
<div class="paragraph">
<p>اغلب مجموعه‌ای از فایل‌ها خواهید داشت که نمی‌خواهید گیت به طور خودکار آنها را اضافه یا حتی به عنوان رهگیری نشده به شما نشان دهد.
به صورت کلی این فایل‌ها، فایل‌هایی هستند که به صورت خودکار ساخته می‌شوند مثل لاگ‌ها و فایل‌هایی که توسط سیستم ساخته می‌شوند.
در این گونه موارد، شما می‌توانید فایلی داشته باشید که همهٔ آنها را با الگوهایی مرتبط لیست می‌کند و آنرا <code>.gitignore</code> بنامید.
در اینجا مثالی برای فایل <code>.gitignore</code> داریم:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .gitignore
*.[oa]
*~</code></pre>
</div>
</div>
<div class="paragraph">
<p>خط اول به گیت می‌گوید که هر فایلی که با <code>.o</code> یا <code>.a</code> تمام ‌می‌شود را نادیده بگیرد — فایل‌های آرشیو یا آبجکت‌هایی که ممکن است حاصل خروجی کد شما باشند.
خط دوم به گیت می‌گوید که همهٔ فایل‌های که نامشان با علامت مد (<code>~</code>) پایان‌یافته است را نادیده بگیرد، علامتی که توسط کثیری از ویرایشگرها مانند ایمکس استفاده می‌شود تا فایل‌های موقت را علامت‌گذاری کنند.
شاید حتی یک پوشهٔ log، tmp و یا pid، فایل مستنداتی که خودکار ساخته شده‌اند و سایر را هم اضافه کنید.
راه‌اندازی یک فایل <code>.gitignore</code> برای مخزن جدیدتان پیش از اینکه کار خود را شروع کنید تمرین خوبی است چرا که نمی‌خواهید به طور اتفاقی فایل‌هایی را کامیت کنید که قصد ذخیره آنها را در مخزن گیت خود نداشته‌اید.</p>
</div>
<div class="paragraph">
<p>قوانین الگو‌هایی که می‌توانید در فایل <code>.gitignore</code> قرار دهید به این صورت است:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>خط‌های خالی یا خط‌هایی که با <code>#</code> شروع شوند نادیده گرفته می‌شوند.</p>
</li>
<li>
<p>الگو‌‌های استاندارد گلاب کار می‌کنند و به صورت بازگشتی بر روی درخت کاری شما اعمال می‌شوند.</p>
</li>
<li>
<p>می‌توانید الگوها را با یک اسلش رو به جلو (<code>/</code>) شروع کنید تا از حالت بازگشتی آن اجتناب کنید.</p>
</li>
<li>
<p>می‌توانید الگو‌ها را با یک اسلش رو به جول (<code>/</code>) تمام کنید تا پوشه‌ای را مشخص کنید.</p>
</li>
<li>
<p>می‌توانید الگویی را با اضافه کردن علامت تعجب (<code>!</code>) برعکس کنید.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>الگو‌های گلاب مانند عبارات منظم ساده شده‌ای هستند که شل‌ها از آن استفاده می‌کنند.
یک ستاره (<code>*</code>) با یک یا چند حرف تطبیق داده می‌شود؛ <code>[abc]</code> هر حرفی که داخل براکت یا قلاب باشد را تطبیق می‌دهد (در این مثال a، b، یا c هستند)؛
یک علامت سوال (<code>?</code>) یک تک حرف را تطبیق می‌دهد؛ و براکت‌هایی که حروفی را که با خط تیره از هم جدا شده باشند (<code>[9-0]</code>) را محاصره کرده باشند هر حرفی که
در آن مجموعه وجود داشته باشند را پیدا می‌کند (در این مورد هر عددی که بین 0 و 9 باشد).
همچنین می‌توانید از دو ستاره برای تطبیق پوشه‌های تو در تو استفاده کنید؛ <code>a/**/z</code> با <code>a/z</code>، <code>a/b/z</code>، <code>a/b/c/z</code> و ساختارهای مشابه تطبیق پیدا می‌کرد.</p>
</div>
<div class="paragraph">
<p>در اینجا مثال دیگری برای فایل <code>.gitignore</code> داریم:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code># ignore all .a files
*.a

# but do track lib.a, even though you're ignoring .a files above
!lib.a

# only ignore the TODO file in the current directory, not subdir/TODO
/TODO

# ignore all files in any directory named build
build/

# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt

# ignore all .pdf files in the doc/ directory and any of its subdirectories
doc/**/*.pdf</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">نکته</div>
</td>
<td class="content">
<div class="paragraph">
<p>گیت‌هاب لیست قابل فهم خوبی از نمونه فایل‌های <code>.gitignore</code> مملوع از مثال‌های مختلف برای زبان‌ها و پروژه‌های مختلف در <a href="https://github.com/github/gitignore" class="bare">https://github.com/github/gitignore</a> دارد، اگر دنبال یک نمونه آغازین برای پروژه خود هستید.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">یادداشت</div>
</td>
<td class="content">
<div class="paragraph">
<p>در این مثال‌های ساده، یک مخزن شاید یک فایل <code>.gitignore</code> در پوشه روت خود داشته باشد، که به صورت بازگشتی روی تمام پروژه اعمال می‌شود.
با این حال، این امکان هم وجود دارد که پروژه‌‌ها در زیر پوشه‌های خود باز هم فایل <code>.gitignore</code> داشته باشد.
قوانین درون این فایل‌های <code>.gitignore</code> تو در تو فقط روی فایل‌های زیر پوشه‌های آنها اعمال می‌شود
(مخزن منبع هسته لینوکس ۲۰۶ فایل <code>.gitignore</code> دارد.)</p>
</div>
<div class="paragraph">
<p>این موضوع و جزئیات فایل‌های <code>.gitignore</code> چندگانه خارج از بحث کتاب است؛ برای جزئیات بیشتر به <code>man gitignore</code> مراجعه کنید.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h3 id="_git_diff_staged">نمایش تغییرات استیج‌شده و استیج‌نشده</h3>
<div class="paragraph">
<p>اگر دستور <code>git status</code> کمی برایتان مبهم است — میخواهید بفهمید دقیقاً چه چیزی، نه فقط چه فایل‌هایی، را تغییر داده‌اید — می‌توانید از دستور <code>git diff</code> استفاده کنید.
درباره دستور <code>git diff</code> و جزئیات آن بعد می‌گوییم، اما احتمالاً شما از این دستور بیشتر برای پاسخ به دو سؤال استفاده کنید: چه چیزی را تغییر داده‌اید اما هنوز استیج نکرده‌اید؟
و چه چیزی را استیج کرده و در شرف کامیت کردن آن هستید؟
با اینکه دستور <code>git status</code> جواب آن سؤالات را به صورت کلی، به واسطه لیست کردن نام‌های فایل‌ها خواهد داد، اما <code>git diff</code> جزئیات دقیق خطوط اضافه و حذف شده — انگار پچ آنرا — به شما نشان می‌دهد.</p>
</div>
<div class="paragraph">
<p>فرض کنیم که شما از دوباره فایل <code>README</code> را تغییر داده و استیج کرده‌اید و سپس فایل <code>CONTRIBUTING.md</code> را بدون استیج کردن ویرایش کرده‌اید.
اگر دستور ‍<code>git status</code> را اجرا کنید، دگر بار چیزی شبیه به خروجی پایین می‌بینید:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    modified:   README

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>برای دیدن تغییراتی که انجام دادید ولی هنوز استیج نکرده‌اید، دستور <code>git diff</code> را بدون هیچ آرگومان دیگری وارد کنید:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's</code></pre>
</div>
</div>
<div class="paragraph">
<p>آن دستور چیز‌هایی که در پوشه کاری شما هست را با محتویات استیج مقایسه می‌کند.
نتیجه‌ تغییراتی را به شما نشان می‌دهد که اعمال کرده‌اید اما هنوز استیج نکرده‌اید.</p>
</div>
<div class="paragraph">
<p>اگر می‌خواهید ببینید چه چیزی را استیج کرده‌اید که در کامیت بعدی شما باشد، می‌توانید از <code>git diff --staged</code> استفاده کنید.
این دستور آخرین کامیتتان را با تغییرات استیج مقایسه می‌کند:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+My Project</code></pre>
</div>
</div>
<div class="paragraph">
<p>خیلی مهم است که دقت کنید که <code>git diff</code> خودش به تنهایی تمام تغییرات ایجاد شده از آخرین کامیت را نشان نمی‌دهد — بلکه فقط تغییراتی که هنوز استیج نشده‌اند را به نمایش می‌گذارد.
اگر شما تغییراتی را به استیج کنید، <code>git diff</code> خروجی به شما نمی‌دهد.</p>
</div>
<div class="paragraph">
<p>به عنوان مثالی دیگر، اگر شما فایل <code>CONTRIBUTING.md</code> را استیج کنید و سپس آن را تغییر دهید،
می‌توانید از دستور <code>git diff</code> استفاده کنید تا تغییرات استیج‌شده‌ و تغییرات استیج‌نشده را ببینید.
اگر محیط ما اینگونه باشد:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add CONTRIBUTING.md
$ echo '# test line' &gt;&gt; CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>حال می‌توانید از <code>git diff</code> برای دیدن مواردی که هنوز استیج نشده‌اند استفاده کنید:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 643e24f..87f08c8 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -119,3 +119,4 @@ at the
 ## Starter Projects

 See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).
+# test line</code></pre>
</div>
</div>
<div class="paragraph">
<p>و <code>git diff --cached</code> برای اینکه ببینید چه چیزی را تا اینجای کار استیج کرده‌اید (<code>--staged</code> و <code>--cached</code> مترادف هستند):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --cached
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">یادداشت</div>
</td>
<td class="content">
دستور <code>git diff</code> یک ابزار خارجی است.
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>در ادامهٔ کتاب از دستور <code>git diff</code> به طرق مختلفی استفاده خواهیم کرد.
اگر ابزارهای گرافیکی یا برنامه‌های نمایش دیف دیگری را ترجیح می‌دهید راه دیگری هم برای مشاهده این دیف هست.
اگر <code>git difftool</code> را به جای <code>git diff</code> اجرا کنید، می‌تواند هر کدام از این دیف‌ها را در نرم‌افزارهایی مثل emerge، vimdiff و غیره (شامل نرم‌افزارهای تجاری) ببینید.
دستور <code>git difftool --tool-help</code> را اجرا کنید تا ببنید که چه ابزارهایی بر روی سیستم شما موجود است.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_committing_changes">کامیت کردن تغییراتتان</h3>
<div class="paragraph">
<p>اکنون استیج شما آنطور که می‌خواستید آماده شده است، می‌توانید تغییرات خود را کامیت کنید.
به یاد داشته باشید که هر چیزی که همچنان استیج‌نشده است — هر فایلی که ساخته‌اید یا تغییر داده‌اید و هنوز دستور <code>git add</code> را برای استیج کردن آن‌ها اجرا نکرده‌اید — به کامیت اضافه نخواهند شد.
آن‌‌ها با عنوان فایل تغییر یافته بر روی دیسک شما باقی خواهد ماند.
در این مورد، فرض کنیم که آخرین باری که دستور <code>git status</code> اجرا کردید، مشاهده کرده‌اید که تمام تغییرات استیج شده‌اند، پس آماده‌اید تا تغییراتتان را کامیت کنید.
ساده‌ترین راه کامیت کردن نوشتن دستور <code>git commit</code> است:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>انجام این کار ویرایشگرتان را باز می‌کند.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">یادداشت</div>
</td>
<td class="content">
<div class="paragraph">
<p>ویرایشگر با متغیر محیطی <code>EDITOR</code> شل شما تنظیم می‌شود — معمولاً ویم یا ایمکس است، هرچند همانطور که در <a href="{{< relurl "book/fa/v2/ch00/ch01-getting-started" >}}">شروع به کار</a> مشاهده کردید،
می‌توانید آنرا با استفاده از دستور <code>git config --global core.editor</code> با هر چیزی که می‌خواهید جایگزین کنید.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>ویرایشگر متن زیر را به نمایش می‌گذارد (این مثال یک صفحه ویم است):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code># Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Your branch is up-to-date with 'origin/master'.
#
# Changes to be committed:
#	new file:   README
#	modified:   CONTRIBUTING.md
#
~
~
~
".git/COMMIT_EDITMSG" 9L, 283C</code></pre>
</div>
</div>
<div class="paragraph">
<p>می‌توانید ببینید که پیام کامیت پیش فرض شامل آخرین خروجی دستور <code>git status</code> به صورت کامنت شده و یک خط خالی در بالای آن است.
شما می‌توانید تمام این کامنت‌ها را حذف کرده و پیام خود را بنویسید، یا می‌توانید همانطور آنها رها کنید تا به شما یادآوری کنند که در حال کامیت کردن چه چیزی هستید.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">یادداشت</div>
</td>
<td class="content">
<div class="paragraph">
<p>برای یادآوری صریح‌تر مواردی که ویرایش کرده‌اید، آپشن <code>-v</code> را به <code>git commit</code> بدهید.
انجام این کار همچنین دیف تغییراتتان را در ویرایشگر قرار می‌دهد تا بتوانید ببینید دقیقاً چه تغییراتی را کامیت می‌کنید.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>وقتی از ادیتور خارج می‌شوید، گیت کامیت مورد نظر شما را با پیام کامیتی که نوشته‌اید (بدون کامنت‌ها و دیف‌ها) می‌سازد.</p>
</div>
<div class="paragraph">
<p>به عنوان یک روش دیگر، می‌توانید پیام کامیت خود را به صورت درون خطی همراه با دستور <code>git commit</code> با آپشن <code>-m</code> بنویسید،‌ مانند این:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git commit -m "Story 182: fix benchmarks for speed"
[master 463dc4f] Story 182: fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README</code></pre>
</div>
</div>
<div class="paragraph">
<p>حال شما اولین کامیت خود را ساختید!
می‌توانید ببینید که کامیت، چند خروجی درباره خودش به شما می‌دهد: بر روی کدام برنچ کامیت انجام شده است (<code>master</code>)، چه کد هش SHA-1 دارد (<code>463dc4f</code>)، چه فایل‌هایی تغییر کرده‌اند و آمارهایی در کامیت جاری
درباره خط‌هایی که اضافه یا حذف شده‌اند.</p>
</div>
<div class="paragraph">
<p>به یاد داشته باشید که کامیت، اسنپ‌شاتی را ثبت می‌کند که شما در استیج آماده‌سازی کرده‌اید.
هر چیزی که استیج نکرده‌اید همچنان با عنوان فایل تغییر یافته باقی مانده‌ است؛ می‌توانید کامیت دیگری بسازید و آن را به تاریخچهٔ تغییرات خود اضافه کنید.
هر زمانی که یک کامیت جدید می‌گیرید، در حال ثبت اسنپ‌شاتی از پروژه خود هستید که که در هر زمان می‌توانید پروژه را به آن برگردانید یا مقایسه کنید.</p>
</div>
</div>
<div class="sect3">
<h3 id="_گذر_از_استیج">گذر از استیج</h3>
<div class="paragraph">
<p>
هرچند که برای ساختن کامیت‌ها دقیقاً به آن نحوی که می‌خواهید استیج بسیار مفید است، اما گاهی بیش از نیاز برای روند کاریتان پیچیده است.
اگر می‌خواهید از مرحله استیج کردن فایل‌ها رد شوید، گیت میانبر ساده‌ای ارائه می‌کند.
اضافه کردن آپشن <code>-a</code> به دستور <code>git commit</code> گیت را وادار می‌کند که به طور خودکار هر فایلی را که پیش از کامیت گرفتن رهگیری شده را استیج کند که به شما این امکان را می‌دهد که از بخش <code>git add</code> گذر کنید:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

no changes added to commit (use "git add" and/or "git commit -a")
$ git commit -a -m 'Add new benchmarks'
[master 83e38c7] Add new benchmarks
 1 file changed, 5 insertions(+), 0 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>دقت کنید که در این مورد دیگر لازم نیست قبل از اینکه کامیت کنید، دستور <code>git add</code> را روی فایل <code>CONTRIBUTING.md</code> اجرا کنید.
این از این جهت است که آپشن <code>-a</code> تمام فایل‌‌هایی که تغییر کرده‌اند را در بر می‌گیرد.
این گزینهٔ راحتی است اما مراقب باشید؛ گاهی اوقات باعث می‌شود که تغییراتی را که نمی‌خواهید شامل کنید.</p>
</div>
</div>
<div class="sect3">
<h3 id="_removing_files">حذف‌ کردن فایل</h3>
<div class="paragraph">
<p>
برای حذف یک فایل از گیت،‌ باید آن را از فایل‌های رهگیری شده حذف کنید (به طور دقیق‌تر، آن را از استیج حذف کنید) و بعد کامیت کنید.
دستور <code>git rm</code> این کار را می‌کند و همچنین فایل را از پوشه کاریتان حذف می‌کند تا شما دفعهٔ بعد آن را به عنوان یک فایل رهگیری‌نشده نبینید.</p>
</div>
<div class="paragraph">
<p>اگر صرفاً فایل را از پوشه کاریتان حذف کنید،‌ آن را زیر تیتر «Changes not staged for commit» (معادل <em>unstaged</em>) خروجی <code>git status</code> خود می‌بینید:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add/rm &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

        deleted:    PROJECTS.md

no changes added to commit (use "git add" and/or "git commit -a")</code></pre>
</div>
</div>
<div class="paragraph">
<p>سپس، اگر دستور <code>git rm</code> را اجرا کنید، حذف فایل را استیج می‌کند:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rm PROJECTS.md
rm 'PROJECTS.md'
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    deleted:    PROJECTS.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>دفعه بعد که کامیت کنید، فایل از بین خواهد رفت و دیگر رهگیری نخواهد شد.
اگر فایل را تغییر داده‌اید یا آن را استیج کرده‌اید، باید با استفاده از آپشن <code>-f</code> حذف آنرا تحمیل کنید.
این یک امکان امنیتی برای جلوگیری از حذف تصادفی داده‌هایی است که هنوز در اسنپ‌شاتی ثبت نشده‌اند و نمی‌توانند توسط گیت بازیابی شوند.</p>
</div>
<div class="paragraph">
<p>کار مفید دیگری که ممکن است بخواهید انجام دهید، نگه‌داری فایل در پوشه کاری اما حذف آن از استیج است.
به بیان دیگر، ممکن است بخواهید فایل را در هارددیسک خود نگه‌دارید اما نخواهید گیت دیگر آنرا رهگیری کند.
این بخصوص وقتی مفید است که فراموش کرده‌اید چیزی را به <code>.gitignore</code> اضافه کنید و تصادفاً آن را استیج کرده‌اید، مانند یک فایل لاگ بزرگ یا تعدادی فایل ‍<code>.a</code> کامپایل شده.
برای انجام این کار از آپشن <code>--cached</code> استفاده کنید:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rm --cached README</code></pre>
</div>
</div>
<div class="paragraph">
<p>می‌توانید از الگو‌های فایل‌ها، پوشه‌ها و فایل-گلاب در دستور <code>git rm</code> استفاده کنید.
این به آن معناست که می‌توانید چنین کار‌هایی کنید:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rm log/\*.log</code></pre>
</div>
</div>
<div class="paragraph">
<p>به بک‌اسلش(‍<code>\</code>) مقابل <code>*</code> دقت کنید.
این لازم است چراکه گیت گسترش نام‌فایل (Filename Expansion) خودش را مازاد بر گسترش نام‌فایل شل شما انجام می‌دهد.
این دستور تمام فایل‌هایی که با پسوند <code>.log</code> درون پوشته <code>log/</code> را حذف می‌کند.
یا شما می‌توانید چیزی شبیه به دستور زیر را اجرا کنید:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rm \*~</code></pre>
</div>
</div>
<div class="paragraph">
<p>این دستور تمام فایل‌هایی که نام آن‌ها با یک <code>~</code> تمام می‌شود را حذف می‌کند.</p>
</div>
</div>
<div class="sect3">
<h3 id="_git_mv">جابه‌جایی فایل‌ها</h3>
<div class="paragraph">
<p>
بی‌تشابه به کثیری از سیستم‌های VCS دیگر، گیت به صراحت جابه‌جایی‌ها را دنبال نمی‌کند.
اگر شما نام فایلی را در گیت تغییر دهید، هیچ متادیتایی در گیت وجود ندارد که به آن بگوید که شما آن نام فایل را تغییر داده‌اید.
با این حال، پس از رخ دادن چنین موردی گیت در این باره هوشمندانه عمل می‌کند — جلوتر درباره جابه‌جایی فایل‌ها می‌پردازیم.</p>
</div>
<div class="paragraph">
<p>بنابراین شاید کمی گیج‌کننده باشد که گیت دستوری به نام <code>mv</code> دارد.
اگر بخواهید نام یک فایل را در گیت تغییر دهید، می‌توانید دستوری شبیه به زیر را اجرا کنید:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git mv file_from file_to</code></pre>
</div>
</div>
<div class="paragraph">
<p>و به خوبی کار می‌کند.
در حقیقت، اگر شما چیزی شبیه دستور زیر را اجرا کنید و وضعیت را بررسی کنید، می‌بینید که گیت آن را به عنوان فایل تغییر نام یافته در نظر می‌گیرد:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git mv README.md README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    renamed:    README.md -&gt; README</code></pre>
</div>
</div>
<div class="paragraph">
<p>با این حال، این معادل اجرا کردن چنین چیزی است:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ mv README.md README
$ git rm README.md
$ git add README</code></pre>
</div>
</div>
<div class="paragraph">
<p>گیت می‌فهمد که این یک تغییر نام ضمنی است، پس  مهم نیست که شما فایلی را اینگونه تغییر نام دهید یا با دستور <code>mv</code>.
تنها تفاوت اصلی این است که <code>git mv</code>، به جای سه دستور، یک دستور است — تابعی برای آسودگی کار است.
مهم‌ترآنکه می‌توانید از هر ابزاری برای تغییر نام یک فایل استفاده کنید و بعداً، قبل از کامیت، <code>git add/rm</code> را اجرا کنید.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>