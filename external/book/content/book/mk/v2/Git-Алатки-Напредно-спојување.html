---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: mk
  chapter:
    title: Git Алатки
    number: 7
  section:
    title: Напредно спојување
    number: 8
    cs_number: '7.8'
    previous: book/mk/v2/Git-Алатки-Reset-Demystified
    next: book/mk/v2/Git-Алатки-Rerere
title: Git - Напредно спојување
url: "/book/mk/v2/Git-Алатки-Напредно-спојување.html"
---
<h2 id="_advanced_merging">Напредно спојување</h2>
<div class="paragraph">
<p>Соединувањето во Git е обично прилично лесно.
Бидејќи Git го олеснува спојувањето на друга гранка повеќе пати, тоа значи дека можете да имате многу долго време, но можете да го задржите во тек со времето, кога често решите мали конфликти, наместо да бидете изненадени од еден огромен конфликт на крајот на серијата.</p>
</div>
<div class="paragraph">
<p>Сепак, понекогаш се појавуваат незгодни конфликти.
За разлика од некои други системи за контрола на верзии, Git не се обидува да биде премногу умен за решавањето на конфликтите на спојувањето.
Филозофијата на Гит треба да биде паметна за одредување кога резолуцијата за спојување е недвосмислена, но ако постои конфликт, не се обидува да биде умен за автоматско решавање на истата.
Затоа, ако чекате премногу долго за да споите две гранки кои брзо се разминуваат, можете да се справите со некои проблеми.</p>
</div>
<div class="paragraph">
<p>Во овој дел, ние ќе го надминеме она што некои од овие прашања може да се и кои алатки Git ви дава да помогне во справувањето со овие потешки ситуации.
Ние исто така ќе ги покриеме некои од различните, нестандардни типови на спојувања што можете да ги направите, како и да видите како да се вратите од спојувањата што сте ги направиле.</p>
</div>
<div class="sect3">
<h3 id="_спојување_на_конфликти">Спојување на конфликти</h3>
<div class="paragraph">
<p>Додека ние покриваме неколку основи за решавање на споровите за спојување во &lt;&lt; _basic_merge_conflicts &gt;&gt;, за посложени конфликти, Git обезбедува неколку алатки кои ќе ви помогнат да дознаете што се случува и како подобро да се справите со конфликтот.</p>
</div>
<div class="paragraph">
<p>Пред сè, ако е можно, обидете се да бидете сигурни дека вашиот работен директориум е чист пред да направите спојување кое може да има конфликти.
Ако имате работа во тек, или извршете ја во привремена гранка или со затворање.
Ова го прави така што можете да го вратите * нешто * што ќе се обидете овде.
Ако имате незачувани промени во вашиот работен директориум кога се обидувате да се спојат, некои од овие совети може да ви помогнат да ја изгубите таа работа.</p>
</div>
<div class="paragraph">
<p>Ајде да одиме низ многу едноставен пример.
Имаме едноставна датотека Ruby која печати "здраво свет".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
  puts 'hello world'
end

hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Во нашето складиште креираме нова филијала со име "белиот простор" и продолжуваме да ги менуваме сите завршни линии на Unix до крајот на DOS линијата, суштински менувајќи ја секоја линија на датотеката, но само со празни места.
Потоа ја менуваме линијата "здравиот свет" до "здраво мундо".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b whitespace
Switched to a new branch 'whitespace'

$ unix2dos hello.rb
unix2dos: converting file hello.rb to DOS format ...
$ git commit -am 'converted hello.rb to DOS'
[whitespace 3270f76] converted hello.rb to DOS
 1 file changed, 7 insertions(+), 7 deletions(-)

$ vim hello.rb
$ git diff -b
diff --git a/hello.rb b/hello.rb
index ac51efd..e85207e 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,7 @@
 #! /usr/bin/env ruby

 def hello
-  puts 'hello world'
+  puts 'hello mundo'^M
 end

 hello()

$ git commit -am 'hello mundo change'
[whitespace 6d338d2] hello mundo change
 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Сега се враќаме во нашата "господарска гранка" и додадеме некоја документација за функцијата.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
Switched to branch 'master'

$ vim hello.rb
$ git diff
diff --git a/hello.rb b/hello.rb
index ac51efd..36c06c8 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello world'
 end

$ git commit -am 'document the function'
[master bec6336] document the function
 1 file changed, 1 insertion(+)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Сега се обидуваме да се споиме во нашата гранка "whitespace" и ќе имаме конфликти поради промените на празнините.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge whitespace
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="sect4">
<h4 id="_abort_merge">Прекинување на Спојување</h4>
<div class="paragraph">
<p>Сега имаме неколку опции.
Прво, да покриеме како да излеземе од оваа ситуација.
Ако можеби не очекувавте конфликти и не сакате да се справите со ситуацијата, сепак можете едноставно да се ослободите од спојувањето со <code>git merge -abort</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status -sb
## master
UU hello.rb

$ git merge --abort

$ git status -sb
## master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Опцијата <code>git merge --abort</code> се обидува да се врати назад во вашата држава пред да го вклучите спојувањето.
Единствените случаи каде што можеби нема да може да го направите ова совршено, би било ако сте имале незасегнати, незавршени промени во вашиот работен директориум, кога го водевте, инаку треба да работи добро.</p>
</div>
<div class="paragraph">
<p>Ако поради некоја причина само сакате да започнете, можете исто така да ја стартувате <code>git reset -hard HEAD</code>, а вашето складиште ќе се врати во последната обврска.
Запомнете дека некоја неопределена работа ќе биде изгубена, затоа осигурајте се дека не сакате никакви промени.</p>
</div>
</div>
<div class="sect4">
<h4 id="_игнорирање_на_празни_места">Игнорирање на празни места</h4>
<div class="paragraph">
<p>Во овој конкретен случај, конфликтите се поврзани со празен простор.
Ова го знаеме затоа што случајот е едноставен, но исто така е прилично лесно да се каже во вистински случаи кога се разгледува конфликтот, бидејќи секоја линија е отстранета од една страна и се додава повторно од друга страна.
Стандардно, Git ги гледа сите овие линии како што се менуваат, така што не може да ги спои датотеките.</p>
</div>
<div class="paragraph">
<p>Стандардната стратегија за спојување може да ги земе аргументите, а неколку од нив се за правилно игнорирање на промени во празнините.
Ако видите дека имате многу проблеми со празнините во спојувањето, можете едноставно да го прекинете и повторно да го направите тоа, со <code>-Xignore-all-space</code> или` -Xignore-space-change`.
Првата опција игнорира празни места * целосно * кога се споредуваат линии, втората третира секвенци од еден или повеќе празни белези како еквивалентни.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge -Xignore-space-change whitespace
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Бидејќи во овој случај, вистинските промени на датотеката не беа спротивни, откако ќе ги игнорираме промените на празнините, сè се спојува сосема добро.</p>
</div>
<div class="paragraph">
<p>Ова е спасител ако имате некој во вашиот тим кој сака да реформатирате повремено од простори до табови или обратно.</p>
</div>
</div>
<div class="sect4">
<h4 id="_manual_remerge">Рачно спојување на датотеката</h4>
<div class="paragraph">
<p>Иако Git се справува со прелиминарна обработка на празни места прилично добро, постојат и други видови на промени кои можеби Git не може да се справи автоматски, но се поправки за сценарија.
Како пример, да се претпоставиме дека Git не може да се справи со промена на празнините и ние требаше да го направиме тоа рачно.</p>
</div>
<div class="paragraph">
<p>Она што навистина треба да го направиме е да ја извршиме датотеката со која се обидуваме да се споиме преку програмата <code>dos2unix</code>, пред да се обидеме да се спојат вистинските датотеки.
Па, како ќе го сториме тоа?</p>
</div>
<div class="paragraph">
<p>Прво, влегуваме во конфликтната состојба на спојувањето.
Потоа сакаме да добиеме копии од мојата верзија на датотеката, нивната верзија (од гранката со која се спојуваме) и заедничката верзија (од каде што двете страни се разгрануваат).
Потоа сакаме да одредиме или нивната страна или наша страна и повторно пробајте повторно да се спојат само за оваа единствена датотека.</p>
</div>
<div class="paragraph">
<p>Добивањето на три верзии на датотеки е прилично лесно.
Git ги зачувува сите овие верзии во индексот под ‘` фази <em>’, кои секој ги има броевите поврзани со нив.
Фаза 1 е заеднички предок, фазата 2 е вашата верзија и фазата 3 е од <code>MERGE_HEAD</code>, верзијата со која се спојувате (` `нив '</em>).</p>
</div>
<div class="paragraph">
<p>Можете да извадите копија од секоја од овие верзии на конфликтната датотека со командата <code>git show</code> и посебна синтакса.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show :1:hello.rb &gt; hello.common.rb
$ git show :2:hello.rb &gt; hello.ours.rb
$ git show :3:hello.rb &gt; hello.theirs.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ако сакате да добиете малку повеќе тврдо јадро, можете исто така да ја користите командата <code>ls-files-u</code> за да ги добиете вистинските SHA-1 на Git blobs за секоја од овие датотеки.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git ls-files -u
100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1	hello.rb
100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2	hello.rb
100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3	hello.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>На <code>: 1: hello.rb</code> е само стенографија за гледање на таа дупка SHA-1.</p>
</div>
<div class="paragraph">
<p>Сега кога ја имаме содржината на сите три фази во нашиот работен директориум, ние рачно можеме да ги решиме нивните проблеми за да го поправиме проблемот со празни празни места и повторно да ја споиме датотеката со малку позната команда <code>git merge-file</code> команда која го прави токму тоа.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ dos2unix hello.theirs.rb
dos2unix: converting file hello.theirs.rb to Unix format ...

$ git merge-file -p \
    hello.ours.rb hello.common.rb hello.theirs.rb &gt; hello.rb

$ git diff -b
diff --cc hello.rb
index 36c06c8,e85207e..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,8 -1,7 +1,8 @@@
  #! /usr/bin/env ruby

 +# prints out a greeting
  def hello
-   puts 'hello world'
+   puts 'hello mundo'
  end

  hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Во овој момент имаме убаво спојување на датотеката.
Всушност, ова всушност функционира подобро од опцијата <code>ignore-space-change</code>, бидејќи ова всушност ги поправа промените на празнините пред да се спојат, наместо едноставно да ги игнорираат.
Во спојувањето на <code>ignore-space-change</code>, всушност завршивме со неколку линии со завршетоци на DOS линијата, правејќи ги работите мешани.</p>
</div>
<div class="paragraph">
<p>Ако сакате да добиете идеја пред да ја финализирате оваа заложба за она што всушност е изменето помеѓу една или друга страна, можете да побарате <code>git diff</code> за да го споредите она што е во вашиот работен директориум што ќе го направите како резултат на се спојуваат со било која од овие фази.
Ајде да поминеме низ сите нив.</p>
</div>
<div class="paragraph">
<p>За да го споредите вашиот резултат со она што сте го имале во вашата гранка пред да се спојат, со други зборови, за да видите што се воведе во спојувањето, можете да го стартувате <code>git diff -ours</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --ours
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index 36c06c8..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -2,7 +2,7 @@

 # prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Значи тука лесно можеме да видиме дека она што се случи во нашата гранка, она што всушност го воведуваме во оваа датотека со овој спој, ја менува таа единствена линија.</p>
</div>
<div class="paragraph">
<p>Ако сакаме да видиме како резултатот од спојувањето се разликува од она што беше на нивна страна, можете да ракувате со "git diff -theirs".
Во овој и следниов пример, ние треба да го користиме <code>-b</code> да го избришаме празнината, бидејќи ние го споредуваме со она што е во Git, а не со нашата исчистена датотека` hello.theirs.rb`.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --theirs -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index e85207e..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello mundo'
 end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Конечно, можете да видите како датотеката се промени од двете страни со `git diff - base '.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --base -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index ac51efd..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,8 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Во овој момент можеме да ја користиме командата <code>git clean</code> за да ги исчистиме дополнителните датотеки што ги создадовме за да го направиме рачното спојување, но повеќе не ви требаат.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clean -f
Removing hello.common.rb
Removing hello.ours.rb
Removing hello.theirs.rb</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_checking_out_conflicts">Проверка на конфликти</h4>
<div class="paragraph">
<p>Можеби не сме задоволни со резолуцијата во овој момент поради некоја причина, или можеби рачното уредување на една или двете страни сеуште не функционира добро и ни треба повеќе контекст.</p>
</div>
<div class="paragraph">
<p>Ајде малку да го смениме примерот.
За овој пример, имаме две подолги живи гранки кои секој од нив има неколку обврски во нив, но создаваат легитимен конфликт во содржината кога ќе се спојат.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --graph --oneline --decorate --all
* f1270f7 (HEAD, master) update README
* 9af9d3b add a README
* 694971d update phrase to hola world
| * e3eb223 (mundo) add more tests
| * 7cff591 add testing script
| * c3ffff1 changed text to hello mundo
|/
* b7dcc89 initial hello world code</code></pre>
</div>
</div>
<div class="paragraph">
<p>Сега имаме три уникатни обврски кои живеат само на гранката "господар" и уште три други кои живеат во гранката "мундо".
Ако се обидеме да ја споиме "филијалата", ќе добиеме конфликт.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Би сакале да видиме што е конфликт на спојување.
Ако ја отвориме датотеката, ќе видиме нешто вака:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
  puts 'hola world'
=======
  puts 'hello mundo'
&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo
end

hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Двете страни од спојувањето додадоа содржина во оваа датотека, но некои од извршените промени ја смениле датотеката на истото место што го предизвикало овој конфликт.</p>
</div>
<div class="paragraph">
<p>Ајде да разгледаме неколку алатки кои сега ви ги имате на располагање за да одредите како се случил овој конфликт.
Можеби не е очигледно како точно треба да го надминете овој конфликт.
Треба повеќе контекст.</p>
</div>
<div class="paragraph">
<p>Една корисна алатка е <code>git checkout</code> со опцијата` --conflict '.
Ова повторно ќе ја провери датотеката и ќе ги замени маркерите за конфликт на спојување.
Ова може да биде корисно ако сакате да ги ресетирате маркерите и да се обидете повторно да ги решите.</p>
</div>
<div class="paragraph">
<p>Можете да го положат <code>--conflict</code> или` diff3` или <code>merge</code> (што е стандардно).
Ако го понесете <code>diff3</code>, Git ќе користи малку поинаква верзија на маркери за конфликти, не само што ви ги дава верзиите` <code>ours '' и '' theirs '', туку и '</code> base' 'верзија за да ви даде повеќе контекст.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout --conflict=diff3 hello.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Откако ќе го стартуваме тоа, датотеката ќе изгледа вака:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#! /usr/bin/env ruby

def hello
&lt;&lt;&lt;&lt;&lt;&lt;&lt; ours
  puts 'hola world'
||||||| base
  puts 'hello world'
=======
  puts 'hello mundo'
&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs
end

hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Доколку ви се допаѓа овој формат, можете да го поставите како стандардно за идните конфликти на спојување со поставување на поставката <code>merge.conflictstyle</code> во` diff3`.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git config --global merge.conflictstyle diff3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Командата <code>git checkout</code>, исто така, може да ги преземе опциите` --ours` и <code>--theirs</code>, што може да биде навистина брз начин за избор на една или друга страна без да се спојат работите.</p>
</div>
<div class="paragraph">
<p>Ова може да биде особено корисно за конфликти на бинарни датотеки каде што можете едноставно да одберете една страна, или каде што сакате да споите само одредени датотеки од друга гранка - можете да направите спојување, а потоа да одјавите одредени датотеки од една или друга страна пред да извршите .</p>
</div>
</div>
<div class="sect4">
<h4 id="_merge_log">Спојувај дневник</h4>
<div class="paragraph">
<p>Друга корисна алатка при решавањето на конфликтите за спојување е <code>git log</code>.
Ова може да ви помогне да добиете контекст за она што може да придонесе за конфликтите.
Разгледувајќи ја малку историјата за да се потсетиме зошто две линии на развој ја допирале истата област на кодот може понекогаш да бидат навистина корисни.</p>
</div>
<div class="paragraph">
<p>За да добиете целосна листа на сите уникатни обврски кои беа вклучени во било која гранка вклучена во ова спојување, можеме да ја користиме синтаксата `` тројна точка`` што ја научивме во &lt;&lt; _triple_dot &gt;&gt;.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --left-right HEAD...MERGE_HEAD
&lt; f1270f7 update README
&lt; 9af9d3b add a README
&lt; 694971d update phrase to hola world
&gt; e3eb223 add more tests
&gt; 7cff591 add testing script
&gt; c3ffff1 changed text to hello mundo</code></pre>
</div>
</div>
<div class="paragraph">
<p>Тоа е убава листа на вклучените шест вкупно обврски, како и која линија на развој се извршува.</p>
</div>
<div class="paragraph">
<p>Ние можеме понатаму да го поедноставиме ова иако да ни даде многу поспецифичен контекст.
Ако ја додадеме опцијата <code>--merge</code> во` git log`, таа ќе ги прикаже само обврските во двете страни на спојувањето што допираат до датотеката што е во моментов конфликтна.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --oneline --left-right --merge
&lt; 694971d update phrase to hola world
&gt; c3ffff1 changed text to hello mundo</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ако го користите тоа со опцијата <code>-p</code>, добивате само разлики во датотеката што заврши во конфликт.
Ова може да биде * навистина * корисно за брзо да ви даде контекст што ви е потребно за да помогнете да се разбере зошто нешто конфликти и како да се разумно да се разреши.</p>
</div>
</div>
<div class="sect4">
<h4 id="_комбиниран_дифф_формат">Комбиниран дифф формат</h4>
<div class="paragraph">
<p>Бидејќи Git ги спојува сите резултати на спојување кои се успешни, кога ќе го стартувате <code>git diff</code> додека сте во конфликтна состојба на спојување, добивате само она што во моментов е во конфликт.
Ова може да биде корисно да се види што сè уште треба да го решите.</p>
</div>
<div class="paragraph">
<p>Кога ќе го стартувате <code>git diff</code> директно по конфликт на спојување, тоа ќе ви даде информации во прилично уникатен формат на дифузна излез.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,11 @@@
  #! /usr/bin/env ruby

  def hello
++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
 +  puts 'hola world'
++=======
+   puts 'hello mundo'
++&gt;&gt;&gt;&gt;&gt;&gt;&gt; mundo
  end

  hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Форматот се нарекува "Комбинирана дифа" и ви дава две колони податоци до секоја линија.
Првата колона ви покажува дали таа линија е различна (додадена или отстранета) помеѓу "нашата" гранка и датотеката во вашиот работен директориум, а втората колона го прави истото помеѓу гранката "theirs" и вашата копија на работниот директориум .</p>
</div>
<div class="paragraph">
<p>Значи во тој пример можете да видите дека <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; 'и</code> &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `линиите се во работната копија, но не беа во двете страни на спојувањето.
Ова има смисла затоа што алатката за спојување ги заглавени таму за нашиот контекст, но се очекува да ги отстраниме.</p>
</div>
<div class="paragraph">
<p>Ако го решиме конфликтот и трчаме "git diff" повторно, ќе го видиме истото, но тоа е малку повеќе корисно.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ vim hello.rb
$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ова ни покажува дека "хола светот" беше во наша страна, но не во работната копија, дека "здраво мундо" беше во нивна страна, но не во работната копија и, конечно, дека "хола мундо" не беше во од двете страни, но сега е во работната копија.
Ова може да биде корисно да се прегледа пред да се изврши резолуцијата.</p>
</div>
<div class="paragraph">
<p>Можете исто така да го добиете ова од <code>git log</code> за какво било спојување за да видите како нешто се реши по факт.
Git ќе го изведе овој формат ако го стартувате <code>git show</code> на спојување или ако додадете опција` --cc` на <code>git log -p</code> (која по правило прикажува само закрпи за не-спојување).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --cc -p -1
commit 14f41939956d80b9e17bb8721354c33f8d5b5a79
Merge: f1270f7 e3eb223
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Sep 19 18:14:49 2014 +0200

    Merge branch 'mundo'

    Conflicts:
        hello.rb

diff --cc hello.rb
index 0399cd5,59727f0..e1d0799
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_undoing_merges">Отповикување на спојувањето</h3>
<div class="paragraph">
<p>Сега кога знаете како да креирате спојување, веројатно ќе направите по грешка.
Една од одличните работи за работа со Git е дека е во ред да се прават грешки, бидејќи е можно (и во многу случаи лесно) да ги поправат.</p>
</div>
<div class="paragraph">
<p>Комлетите за спојување не се разликуваат.
Да речеме дека почнавте да работите на филијала за теми, случајно сте ги споиле во <code>господар</code>, а сега вашата историја на извршенија изгледа вака:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/mk/v2/images/undomerge-start.png" >}}" alt="Accidental merge commit.">
</div>
<div class="title">Figure 133. Accidental merge commit</div>
</div>
<div class="paragraph">
<p>Постојат два начина да се пријде на овој проблем, во зависност од тоа кој е вашиот саканиот исход.</p>
</div>
<div class="sect4">
<h4 id="_поправете_ги_референците">Поправете ги референците</h4>
<div class="paragraph">
<p>Ако несаканото зачувување на спојувањето постои само во вашето локално складиште, најлесно и најдобро решение е да ги преместите гранките, така што ќе посочат каде што сакате.
Во повеќето случаи, ако го следите евидентното "git спојување" со <code>git reset -hard HEAD ~</code>, ова ќе ги ресетира покажувачите на гранки, за да изгледаат вака:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/mk/v2/images/undomerge-reset.png" >}}" alt="History after `git reset --hard HEAD~`.">
</div>
<div class="title">Figure 134. History after <code>git reset --hard HEAD~</code>
</div>
</div>
<div class="paragraph">
<p>Ги покривме <code>reset</code> назад во &lt;&lt; _git_reset &gt;&gt;, па затоа не треба да биде премногу тешко да дознаам што се случува овде.
Еве еден брз освежување: "reset -hard" обично поминува низ три чекори:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Помести ги гранките HEAD поени.
   Во овој случај, ние сакаме да го преместаме "господар" до тоа каде беше пред спојувањето (<code>C6</code>).</p>
</li>
<li>
<p>Направи индекс да изгледа како глава.</p>
</li>
<li>
<p>Направете го работниот директориум да изгледа како индекс.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Недостатоци на овој пристап е тоа што таа е препишувачка историја, која може да биде проблематична со споделено складиште.
Проверете &lt;&lt; _rebase_peril &gt;&gt; за повеќе за тоа што може да се случи; кратката верзија е дека ако другите луѓе ги имаат обврските што ги препишувате, веројатно треба да избегнете "ресетирање".
Овој пристап, исто така, нема да функционира ако се создадат други обврски од спојувањето; движењето на рефлектираните ефекти би ги изгубило тие промени.</p>
</div>
</div>
<div class="sect4">
<h4 id="_reverse_commit">Вратете го извршувањето</h4>
<div class="paragraph">
<p>Ако се движат покажувачите за гранка, нема да работи за вас, Git ви дава можност да направите нова обврска која ги отстранува сите промени од постоечката.
Git ја нарекува оваа операција ‘` вратена '’, и во ова конкретно сценарио, ќе го повикате вака:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git revert -m 1 HEAD
[master b1d8379] Revert "Merge branch 'topic'"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Знакот <code>-m 1</code> покажува кој родител е` <code>mainline '' и треба да се чува.
Кога ќе се повикате на спојување во `HEAD</code> (` git merge topic`), новиот commit има двајца родители: првиот е <code>HEAD</code> (` C6`), а вториот е врвот на филијалата што се спои во ( <code>C4</code>).
Во овој случај, ние сакаме да ги поништиме сите промени внесени со спојување во родител # 2 (<code>C4</code>), додека ги чуваме сите содржини од родител # 1 (` C6`).</p>
</div>
<div class="paragraph">
<p>Историјата со превртување ќе изгледа вака:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/mk/v2/images/undomerge-revert.png" >}}" alt="History after `git revert -m 1`.">
</div>
<div class="title">Figure 135. History after <code>git revert -m 1</code>
</div>
</div>
<div class="paragraph">
<p>Новата обврска <code>^ M</code> има иста содржина како" C6 ", така што почнувајќи од овде е како да не се случило спојувањето, со исклучок на тоа што сега сеуште ненадејните обврски се уште се во историјата на" HEAD ".
Git ќе се збуни ако се обидете повторно да го споите <code>темата</code> во` master`:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge topic
Already up-to-date.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Нема ништо во <code>темата</code> што не е веќе достапно од` master`.
Што е уште полошо, ако додадете работа на <code>тема</code> и повторно се спои, Git ќе ги внесе промените само од враќањето:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/mk/v2/images/undomerge-revert2.png" >}}" alt="History with a bad merge.">
</div>
<div class="title">Figure 136. History with a bad merge</div>
</div>
<div class="paragraph">
<p>Најдобар начин околу ова е да го вратите оригиналното спојување, бидејќи сега сакате да ги внесете промените што беа вратени, * тогаш * создадете нов запис за спојување:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git revert ^M
[master 09f0126] Revert "Revert "Merge branch 'topic'""
$ git merge topic</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/mk/v2/images/undomerge-revert3.png" >}}" alt="History after re-merging a reverted merge.">
</div>
<div class="title">Figure 137. History after re-merging a reverted merge</div>
</div>
<div class="paragraph">
<p>Во овој пример, <code>M</code> и` ^ M` се откажуваат.
<code>^ ^ M</code> ефективно се спојува во промените од` C3` и <code>C4</code>, а` C8` се спојува во промените од <code>C7</code>, па сега` темата` е целосно споена.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_други_видови_на_спојувања">Други видови на спојувања</h3>
<div class="paragraph">
<p>Досега го опфативме нормалното спојување на две гранки, вообичаено се ракува со она што се нарекува "рекурзивна" стратегија за спојување.
Меѓутоа, постојат и други начини за спојување на гранките.
Да ги покриеме неколку од нив брзо.</p>
</div>
<div class="sect4">
<h4 id="_нашата_или_нивна_предност">Нашата или нивна предност</h4>
<div class="paragraph">
<p>Прво, постои уште една корисна работа што можеме да ја направиме со нормалниот ‘` рекурзивен '’ начин на спојување.
Веќе ги видовме опциите <code>ignore-all-space</code> и` ignore-space-change` кои се пренесуваат со <code>-X</code>, но ние исто така можеме да му кажеме на Git да им се допадне на едната или на другата страна кога гледа конфликт.</p>
</div>
<div class="paragraph">
<p>Стандардно, кога Git гледа конфликт помеѓу две гранки што се спојуваат, тој ќе додаде маркери за конфликт на спојување во вашиот код и ќе ја означи датотеката како конфликтна и ќе ви дозволи да ја решите.
Ако претпочитате Git едноставно да одбереш одредена страна и да ја игнорираш другата страна, наместо да дозволиш рачно да го решиш конфликтот, можеш да ја пренесеш командата <code>спојување</code> или` -Xours` или <code>-Xtheirs</code>.</p>
</div>
<div class="paragraph">
<p>Ако Git го гледа ова, нема да додаде конфликтни маркери.
Сите разлики што се спојуваат, ќе се спојат.
Секоја разлики што се во конфликт, таа едноставно ќе ја одбере страната што ја одредувате во целина, вклучувајќи ги бинарните датотеки.</p>
</div>
<div class="paragraph">
<p>Ако се вратиме на примерот со "здравиот свет" што го користевме порано, можеме да видиме дека спојувањето во нашата гранка предизвикува конфликти.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved 'hello.rb' using previous resolution.
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Меѓутоа, ако го работиме со <code>-Xours</code> или` -Xtheirs`, тоа не го прави.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge -Xours mundo
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 test.sh  | 2 ++
 2 files changed, 3 insertions(+), 1 deletion(-)
 create mode 100644 test.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>Во тој случај, наместо да добива конфликтни маркери во датотеката со ‘` hello mundo <em>’ од една страна и `` hola world '</em> од друга страна, едноставно ќе го избере `` хола светот``.
Сепак, сите други неконфликтни промени на таа гранка се споени успешно.</p>
</div>
<div class="paragraph">
<p>Оваа опција исто така може да се пренесе во командата <code>git merge-file</code> што ја видовме порано со извршување на нешто како` git merge-file -ours` за поединечното спојување на датотеки.</p>
</div>
<div class="paragraph">
<p>Ако сакате да направите нешто слично, но не и да се обидете Git да ги спои промените од другата страна, постои повеќе драконска опција, што е "нашата" спој <em>стратегија</em>.
Ова е различно од ‘` our '’ рекурзивен спој <em>option</em>.</p>
</div>
<div class="paragraph">
<p>Ова во основа ќе направи лажен спој.
Тоа ќе го сними новото спојување со двете гранки како родители, но тоа дури и нема да ја разгледа гранката со која се спојувате.
Тоа едноставно ќе го сними како резултат на спојувањето на точниот код во вашата сегашна гранка.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge -s ours mundo
Merge made by the 'ours' strategy.
$ git diff HEAD HEAD~
$</code></pre>
</div>
</div>
<div class="paragraph">
<p>Можете да видите дека не постои разлика помеѓу гранката на која сме биле и резултатот од спојувањето.</p>
</div>
<div class="paragraph">
<p>Ова често може да биде корисно во основа да ги измами Гит во размислување дека гранката е веќе споена кога се спојува подоцна.
На пример, велат дека сте разгрането од гранката "ослободување" и направивте нешто на што ќе сакате да се вратите назад во вашата "мајсторска" гранка во некоја точка.
Во меѓувреме, некои "bugfix" на "господар" треба да се врати во вашиот "порака" филијала.
Можете да ги споите гранката bugfix во гранката "release" и исто така да "спојувајте ја нашата" истата гранка во вашата "господарна гранка" (иако фиксот е веќе таму), па кога подоцна ќе се спои повторно гранката "release" нема конфликти од bugfix.</p>
</div>
</div>
<div class="sect4">
<h4 id="_subtree_merge">Subtree Merging</h4>
<div class="paragraph">
<p>The idea of the subtree merge is that you have two projects, and one of the projects maps to a subdirectory of the other one.
When you specify a subtree merge, Git is often smart enough to figure out that one is a subtree of the other and merge appropriately.</p>
</div>
<div class="paragraph">
<p>We’ll go through an example of adding a separate project into an existing project and then merging the code of the second into a subdirectory of the first.</p>
</div>
<div class="paragraph">
<p>First, we’ll add the Rack application to our project.
We’ll add the Rack project as a remote reference in our own project and then check it out into its own branch:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add rack_remote https://github.com/rack/rack
$ git fetch rack_remote --no-tags
warning: no common commits
remote: Counting objects: 3184, done.
remote: Compressing objects: 100% (1465/1465), done.
remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.
Resolving deltas: 100% (1952/1952), done.
From https://github.com/rack/rack
 * [new branch]      build      -&gt; rack_remote/build
 * [new branch]      master     -&gt; rack_remote/master
 * [new branch]      rack-0.4   -&gt; rack_remote/rack-0.4
 * [new branch]      rack-0.9   -&gt; rack_remote/rack-0.9
$ git checkout -b rack_branch rack_remote/master
Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.
Switched to a new branch "rack_branch"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we have the root of the Rack project in our <code>rack_branch</code> branch and our own project in the <code>master</code> branch.
If you check out one and then the other, you can see that they have different project roots:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ls
AUTHORS         KNOWN-ISSUES   Rakefile      contrib         lib
COPYING         README         bin           example         test
$ git checkout master
Switched to branch "master"
$ ls
README</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is sort of a strange concept.
Not all the branches in your repository actually have to be branches of the same project.
It’s not common, because it’s rarely helpful, but it’s fairly easy to have branches contain completely different histories.</p>
</div>
<div class="paragraph">
<p>In this case, we want to pull the Rack project into our <code>master</code> project as a subdirectory.
We can do that in Git with <code>git read-tree</code>.
You’ll learn more about <code>read-tree</code> and its friends in <a href="{{< relurl "book/mk/v2/ch00/ch10-git-internals" >}}">Внатрешноста на Git</a>, but for now know that it reads the root tree of one branch into your current staging area and working directory.
We just switched back to your <code>master</code> branch, and we pull the <code>rack_branch</code> branch into the <code>rack</code> subdirectory of our <code>master</code> branch of our main project:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git read-tree --prefix=rack/ -u rack_branch</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we commit, it looks like we have all the Rack files under that subdirectory – as though we copied them in from a tarball.
What gets interesting is that we can fairly easily merge changes from one of the branches to the other.
So, if the Rack project updates, we can pull in upstream changes by switching to that branch and pulling:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout rack_branch
$ git pull</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, we can merge those changes back into our <code>master</code> branch.
To pull in the changes and prepopulate the commit message, use the <code>--squash</code> option, as well as the recursive merge strategy’s <code>-Xsubtree</code> option.
(The recursive strategy is the default here, but we include it for clarity.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
$ git merge --squash -s recursive -Xsubtree=rack rack_branch
Squash commit -- not updating HEAD
Automatic merge went well; stopped before committing as requested</code></pre>
</div>
</div>
<div class="paragraph">
<p>All the changes from the Rack project are merged in and ready to be committed locally.
You can also do the opposite – make changes in the <code>rack</code> subdirectory of your master branch and then merge them into your <code>rack_branch</code> branch later to submit them to the maintainers or push them upstream.</p>
</div>
<div class="paragraph">
<p>This gives us a way to have a workflow somewhat similar to the submodule workflow without using submodules (which we will cover in <a href="{{< relurl "book/mk/v2/ch00/_git_submodules" >}}">Submodules</a>).
We can keep branches with other related projects in our repository and subtree merge them into our project occasionally.
It is nice in some ways, for example all the code is committed to a single place.
However, it has other drawbacks in that it’s a bit more complex and easier to make mistakes in reintegrating changes or accidentally pushing a branch into an unrelated repository.</p>
</div>
<div class="paragraph">
<p>Another slightly weird thing is that to get a diff between what you have in your <code>rack</code> subdirectory and the code in your <code>rack_branch</code> branch – to see if you need to merge them – you can’t use the normal <code>diff</code> command.
Instead, you must run <code>git diff-tree</code> with the branch you want to compare to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff-tree -p rack_branch</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or, to compare what is in your <code>rack</code> subdirectory with what the <code>master</code> branch on the server was the last time you fetched, you can run</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff-tree -p rack_remote/master</code></pre>
</div>
</div>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>