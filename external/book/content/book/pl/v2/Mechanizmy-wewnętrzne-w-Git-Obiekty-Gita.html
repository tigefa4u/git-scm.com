---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: pl
  chapter:
    title: Mechanizmy wewnętrzne w Git
    number: 10
  section:
    title: Obiekty Gita
    number: 2
    cs_number: '10.2'
    previous: book/pl/v2/Mechanizmy-wewnętrzne-w-Git-Komendy-typu-plumbing-i-porcelain
    next: book/pl/v2/Mechanizmy-wewnętrzne-w-Git-Referencje-w-Git
title: Git - Obiekty Gita
url: "/book/pl/v2/Mechanizmy-wewnętrzne-w-Git-Obiekty-Gita.html"
---
<h2 id="_objects">Obiekty Gita</h2>
<div class="paragraph">
<p>Git jest systemem plików zorientowanym na treść.
Super.
Ale co to oznacza?
Oznacza to, że Git u podstaw, to baza danych w której znajdują się dane i przypisane do nich klucze (ang. <em>key-value datastore</em>).
Możesz zapisać w niej każdy rodzaj danych, a w odpowiedzi otrzymasz klucz, dzięki któremu będziesz mógł dostać się do tych danych w każdej chwili.
Aby zademonstrować jak to działa, możesz użyć komendy <code>hash-object</code>, która pobiera jakieś dane, zapisuje je w katalogu <code>.git</code> i zwraca klucz pod którym te dane zostały zapisane.
Najpierw zainicjujesz nowe repozytorium Gita i sprawdzisz, że katalog <code>objects</code> jest pusty:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git init test
Initialized empty Git repository in /tmp/test/.git/
$ cd test
$ find .git/objects
.git/objects
.git/objects/info
.git/objects/pack
$ find .git/objects -type f</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git zainicjował katalog <code>objects</code> oraz stworzył w nim dwa katalogi <code>pack</code> i <code>info</code>, jednak nie ma w nich żadnych plików.
Teraz zapisz jakieś dane w bazie danych Gita:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 'test content' | git hash-object -w --stdin
d670460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Opcja <code>-w</code> wskazuje komendzie <code>hash-object</code> aby zapisała obiekt, w przeciwnym wypadku pokazała by tylko jaki klucz byłby użyty.
Opcja <code>--stdin</code> wskazuje, aby dane zostały odczytane ze standardowego wejścia; jeżeli nie podasz tej opcji, <code>hash-object</code> będzie wymagał podania ścieżki do pliku.
Wynikiem działania tej komendy jest 40 znakowa suma kontrolna.
Jest to skrót SHA-1 – suma kontrolna zawartości którą zapisujesz, oraz nagłówków, o których dowiesz się za chwilę.
Teraz możesz zobaczyć w jaki sposób Git zachował dane:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ find .git/objects -type f
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Możesz zobaczyć nowy plik w katalogu <code>objects</code>.
W ten sposób Git początkowo zapisuje dane – jako pojedynczy plik dla każdej części danych, nazwany tak jak wyliczony skrót SHA-1 z treści danych i nagłówka.
Podkatalog jest nazwany od 2 pierwszych znaków SHA, a nazwa pliku to pozostałe 38 znaków.</p>
</div>
<div class="paragraph">
<p>Możesz pobrać dane z Gita za pomocą komendy <code>cat-file</code>.
Polecenie to, to coś w rodzaju szwajcarskiego scyzoryka dla inspekcji obiektów Gita.
Przekazanie opcji <code>-p</code> mówi <code>cat-file</code>, aby rozpoznała ona rodzaj przechowywanych danych i wypisała je na ekran:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
test content</code></pre>
</div>
</div>
<div class="paragraph">
<p>Teraz, możesz dodać dane do Gita i pobrać je z powrotem.
Możesz również to zrobić z danymi znajdującymi się w plikach.
Dla przykładu, dodajmy plik do systemu kontroli wersji.
Najpierw stwórzmy nowy plik i zapiszmy jego zawartość w bazie danych:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 'version 1' &gt; test.txt
$ git hash-object -w test.txt
83baae61804e65cc73a7201a7252750c76066a30</code></pre>
</div>
</div>
<div class="paragraph">
<p>Następnie wprowadź nowe dane do tego pliku i zapisz ponownie:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 'version 2' &gt; test.txt
$ git hash-object -w test.txt
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</code></pre>
</div>
</div>
<div class="paragraph">
<p>Twoja baza danych zawiera teraz dwie nowe wersje pliku, jak również początkową jego zawartość którą zapisałeś:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ find .git/objects -type f
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Teraz możesz cofnąć zawartość pliku do pierwszej wersji:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 &gt; test.txt
$ cat test.txt
version 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>lub drugiej wersji:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a &gt; test.txt
$ cat test.txt
version 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ale zapamiętywanie kluczy SHA-1 dla każdej wersji nie jest praktyczne; dodatkowo nie zachowujesz nazwy pliku – tylko treść.
Ten rodzaj obiektu nazywa się "blob".
Możesz uzyskać informacje o tym jaki typ obiektu kryje się pod danym skrótem SHA-1 za pomocą <code>cat-file -t</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
blob</code></pre>
</div>
</div>
<div class="sect3">
<h3 id="_tree_objects">Obiekty drzew</h3>
<div class="paragraph">
<p>Następnym typem obiektów ,który poznasz, są obiekty drzew (ang. <em>tree</em>), które rozwiązują problem przechowywania nazw plików oraz pozwalają na przechowywanie grupy plików razem.
Git przechowuje treść w sposób podobny do systemu plików UNIX, lecz z pewnymi uproszczeniami.
Wszystkie dane przechowywane są jako obiekty "tree" i "blob", z obiektami "tree" odpowiadającymi strukturze katalogów w systemie UNIX, oraz obiektami "blob", które w mniejszym lub większym stopniu odpowiadają <em>i</em>-węzłom lub treści plików.
Pojedynczy obiekt "tree" zawiera jeden lub więcej wpisów dotyczących ścieżki, z których każdy zawiera skrót SHA-1 wskazujący na obiekt "blob" lub poddrzewem (ang. <em>subtree</em>) z przypisanym trybem, typem i nazwą pliku.
Na przykład, najnowsze drzewo w projekcie może wygląda tak:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -p master^{tree}
100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README
100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile
040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib</code></pre>
</div>
</div>
<div class="paragraph">
<p>Składnia <code>master^{tree}</code> wskazuje na obiekt tree na który wskazuje ostatni commit w Twojej gałęzi <code>master</code>.
Zauważ, że podkatalog <code>lib</code> nie jest blobem, ale wskaźnikiem na inny obiekt tree.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0
100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>W ogólnym zarysie, dane, które przechowuje Git , wyglądają podobnie do tych pokazanych poniżej:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/pl/v2/images/data-model-1.png" >}}" alt="Prosta wersja modelu danych Git.">
</div>
<div class="title">Figure 149. Prosta wersja modelu danych Git.</div>
</div>
<div class="paragraph">
<p>Możesz stworzyć swój własny obiekt tree.
Git zazwyczaj tworzy taki obiekt poprzez pobranie stanu przechowalni lub indeksu i zapisanie obiektu tree z tych danych.
A więc, aby stworzyć obiekt tree, na początek musisz ustawić indeks poprzez dodanie do przechowalni plików.
Indeks z jednym elementem – z pierwszą wersją Twojego pliku test.txt – możesz stworzyć używając komendy <code>update-index</code>.
Możesz jej również do sztucznego dodania poprzedniej wersji pliku test.txt do przechowalni.
Musisz podać jej opcje <code>--add</code> ponieważ plik nie istnieje jeszcze w przechowalni (nie masz jeszcze nawet ustawionej przechowalni) oraz <code>--cacheinfo</code> ponieważ plik który dodajesz nie istnieje w katalogu, a tylko w bazie danych.
Następnie wskazujesz tryb, sumę SHA-1 oraz nazwę pliku:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git update-index --add --cacheinfo 100644 \
  83baae61804e65cc73a7201a7252750c76066a30 test.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>W tym przykładzie, podałeś tryb <code>100644</code>, który wskazuje na normalny plik.
Inne dostępne tryby to <code>100755</code>, który wskazuje na plik wykonywalny; oraz <code>120000</code>, który wskazuje na dowiązanie symboliczne.
Tryby bazują na normalnych uprawnieniach w systemie UNIX, ale mają znacznie mniej opcji – te trzy tryby są jedynymi, które mogą być stosowane do plików (blob-ów) w Gitcie (chociaż inne tryby mogą być użyte dla katalogów i podmodułów).</p>
</div>
<div class="paragraph">
<p>Teraz, możesz użyć komendy <code>write-tree</code>, w celu zapisania zawartości przechowani do obiektu tree.
Opcja <code>-w</code> nie jest potrzebna – wywołanie <code>write-tree</code> automatycznie tworzy obiekt tree ze stanu indeksu, jeżeli ten obiekt jeszcze nie istnieje.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git write-tree
d8329fc1cc938780ffdd9f94e0d364e0ea74f579
$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579
100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>Możesz również zweryfikować, że to jest obiekt tree:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579
tree</code></pre>
</div>
</div>
<div class="paragraph">
<p>Stworzysz teraz nowy obiekt tree, zawierający drugą wersję pliku test.txt oraz nowy plik:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 'new file' &gt; new.txt
$ git update-index test.txt
$ git update-index --add new.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>W Twojej przechowalni znajduje się teraz nowa wersja pliku test.txt oraz nowy plik new.txt.
Zapisz ten stan (pobierając stan z przechowalni lub indeksu do obiektu tree) i sprawdź jak on teraz wygląda:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git write-tree
0155eb4229851634a0f03eb265b69f5a2d56f341
$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>Zauważ, że to drzewo posiada oba wpisy dotyczące plików, oraz że suma SHA w pliku test.txt jest sumą przypisaną do "wersji 2" (<code>1f7a7a</code>).
Dla zabawy, dodasz pierwszy obiekt tree jako podkatalog w obecnym.
Możesz wczytać obiekt tree do swojej przechowalni poprzez wywołanie <code>read-tree</code>.
W takim wypadku, możesz wczytać obecne drzewo do swojej przechowalni i umieścić je w podkatalogu za pomocą opcji <code>--prefix</code> dodanej do <code>read-tree</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579
$ git write-tree
3c4e9cd789d88d8d89c1073707c3585e41b0e614
$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614
040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak
100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jeżeli odtworzyłeś katalog roboczy z drzewa które właśnie zapisałeś, otrzymałeś dwa pliki na najwyższym poziomie w tym katalogu, oraz podkatalog <code>bak</code>, który zawiera pierwszą wersję pliku test.txt.
Możesz myśleć o danych przechowywanych w Gitcie z tymi strukturami, tak jak przedstawiono to poniżej:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/pl/v2/images/data-model-2.png" >}}" alt="Struktura zawartości aktualnych danych Git.">
</div>
<div class="title">Figure 150. Struktura zawartości aktualnych danych Git.</div>
</div>
</div>
<div class="sect3">
<h3 id="_git_commit_objects">Obiekty commit</h3>
<div class="paragraph">
<p>Masz teraz trzy obiekty tree, które wskazują na różne migawki śledzonego projektu, ale poprzedni problem pozostał: musisz pamiętasz wszystkie trzy wartości SHA-1 aby przywrócić migawkę.
Nie masz również żadnych informacji o tym kto zapisał migawkę, kiedy była zapisana, ani dlaczego.
To są podstawowe informacje, które przechowywane są w obiektach typu commit.</p>
</div>
<div class="paragraph">
<p>Aby stworzyć obiekt commit, wywołaj <code>commit-tree</code> i podaj jedną sumę SHA-1 wskazującą na obiekt tree oraz obiekty commit, o ile były jakieś, które bezpośrednio go poprzedziły.
Zacznij od pierwszego obiektu tree, który napisałeś:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 'first commit' | git commit-tree d8329f
fdf4fc3344e67ab068f836878b6c4951e3b15f3d</code></pre>
</div>
</div>
<div class="paragraph">
<p>Możesz teraz zobaczyć jak wygląda nowy obiekt commit za pomocą <code>cat-file</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -p fdf4fc3
tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579
author Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700
committer Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700

first commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Format obiektu commit jest prosty: wskazuje on najnowszy obiekt tree dla migawki projektu w momencie tworzenia; informacje o autorze/integratorze zmiany pobrane z są ustawień konfiguracyjnych <code>user.name</code> i <code>user.email</code> wraz z obecnym znacznikiem czasu; pustą linię i potem treść komentarza do zmiany.</p>
</div>
<div class="paragraph">
<p>Następnie, zapiszesz dwa inne obiekty commit, z których każdy odwołuje się do commit-a który był bezpośrednio przed nim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 'second commit' | git commit-tree 0155eb -p fdf4fc3
cac0cab538b970a37ea1e769cbbde608743bc96d
$ echo 'third commit'  | git commit-tree 3c4e9c -p cac0cab
1a410efbd13591db07496601ebc7a059dd55cfe9</code></pre>
</div>
</div>
<div class="paragraph">
<p>Każdy z trzech obiektów commit wskazuje na jedną z trzech migawek które stworzyłeś.
Co ciekawe, masz teraz prawdziwą historię w Git, którą możesz obejrzeć za pomocą komendy <code>git log</code>, jeżeli uruchomisz ją na ostatniej sumą SHA-1 obiektu commit:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --stat 1a410e
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:15:24 2009 -0700

	third commit

 bak/test.txt | 1 +
 1 file changed, 1 insertion(+)

commit cac0cab538b970a37ea1e769cbbde608743bc96d
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:14:29 2009 -0700

	second commit

 new.txt  | 1 +
 test.txt | 2 +-
 2 files changed, 2 insertions(+), 1 deletion(-)

commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri May 22 18:09:34 2009 -0700

    first commit

 test.txt | 1 +
 1 file changed, 1 insertion(+)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Niesamowite.
Wykonałeś właśnie niskopoziomowe operacje i stworzyłeś historię w Git bez używania żadnej z komend użytkownika.
Jest to w zasadzie to, co Git robi kiedy uruchomisz komendy <code>git add</code> oraz <code>git commit</code> – zapisuje obiekty blob dla plików które zmieniłeś, aktualizuje indeks, zapisuje obiekt tree, oraz tworzy obiekt commit odnoszący się do obiektu tree oraz obiektów commit które wystąpiły bezpośrednio przed nim.
Te trzy główne obiekty Gita – blob, tree oraz commit – są na początku zapisywane jako pojedyncze pliki w katalogu <code>.git/objects</code>.
Poniżej widać wszystkie obiekty z naszego przykładu, z komentarzami wskazującymi na to co było w nich zapisane:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ find .git/objects -type f
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jeżeli prześledzisz wszystkie wskaźniki, dostaniesz widok obiektów podobny do poniższego:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/pl/v2/images/data-model-3.png" >}}" alt="Wszystkie obiekty w Twoim katalogu Git.">
</div>
<div class="title">Figure 151. Wszystkie obiekty w Twoim katalogu Git.</div>
</div>
</div>
<div class="sect3">
<h3 id="_przechowywanie_obiektów">Przechowywanie obiektów</h3>
<div class="paragraph">
<p>Wspomnieliśmy wcześniej, że nagłówek jest zapisywany wraz z treścią. Spójrzmy przez chwilę w jaki sposób Git zapisuje swoje obiekty. Zobaczysz jak zapisać obiekt blob – na przykładzie treści "what is up, doc?" – interaktywnie w języku skryptowym Ruby.</p>
</div>
<div class="paragraph">
<p>Możesz uruchomić tryb interaktywny w Rubym, za pomocą komendy <code>irb</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ irb
&gt;&gt; content = "what is up, doc?"
=&gt; "what is up, doc?"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git tworząc nagłówek na początku wskazuje jakiego typu jest obiekt, w tym wypadku blob.
Następnie, dodaje spację i wielkość treści, oraz na końcu pusty znak (<em>null</em>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">&gt;&gt; header = "blob #{content.length}\0"
=&gt; "blob 16\u0000"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git łączy nagłówek z treścią, a potem oblicza sumę SHA-1 całości.
Możesz obliczyć sumę SHA-1 dla treści w Ruby, po włączeniu biblioteki "SHA1 digest" za pomocą komendy <code>require</code>, oraz po wywołaniu <code>Digest::SHA1.hexdigest()</code> na nim:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">&gt;&gt; store = header + content
=&gt; "blob 16\u0000what is up, doc?"
&gt;&gt; require 'digest/sha1'
=&gt; true
&gt;&gt; sha1 = Digest::SHA1.hexdigest(store)
=&gt; "bd9dbf5aae1a3862dd1526723246b20206e5fc37"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git kompresuje nową treść za pomocą zlib, co możesz wykonać w Ruby przy użyciu biblioteki zlib.
Najpierw, musisz dodać wpis <code>require</code>, a potem uruchomić na treści <code>Zlib::Deflate.deflate()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">&gt;&gt; require 'zlib'
=&gt; true
&gt;&gt; zlib_content = Zlib::Deflate.deflate(store)
=&gt; "x\x9CK\xCA\xC9OR04c(\xCFH,Q\xC8,V(-\xD0QH\xC9O\xB6\a\x00_\x1C\a\x9D"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Na koniec, zapiszesz spakowaną treść jako obiektu na dysku.
Ustalisz ścieżkę dla obiektu który zapisujesz (pierwsze dwa znaki z sumy SHA-1 są nazwą podkatalogu, a pozostałe 38 znaków są nazwą pliku w tym katalogu).
W Ruby możesz użyć funkcji <code>FileUtils.mkdir_p()</code>, aby stworzyć podkatalog w przypadku gdy on nie istnieje.
Następnie otwórz plik za pomocą <code>File.open()</code> i zapisz otrzymaną skompresowaną zawartość do pliku za pomocą funkcji <code>write()</code> wywołanej na otrzymanym uchwycie pliku:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">&gt;&gt; path = '.git/objects/' + sha1[0,2] + '/' + sha1[2,38]
=&gt; ".git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37"
&gt;&gt; require 'fileutils'
=&gt; true
&gt;&gt; FileUtils.mkdir_p(File.dirname(path))
=&gt; ".git/objects/bd"
&gt;&gt; File.open(path, 'w') { |f| f.write zlib_content }
=&gt; 32</code></pre>
</div>
</div>
<div class="paragraph">
<p>To tyle – stworzyłeś poprawny obiekt blog w Gitcie.
Wszystkie obiekty w Git przechowywane są w taki sam sposób, tylko z innymi typami – zamiast ciągu znaków blob, nagłówek będzie rozpoczynał się od commit lub tree.
Choć obiekt blob może zawierać praktycznie dowolne dane, to jednak obiekty commit i tree są bardzo specyficznie sformatowane.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>