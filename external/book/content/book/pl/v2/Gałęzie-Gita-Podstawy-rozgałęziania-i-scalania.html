---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: pl
  chapter:
    title: Gałęzie Gita
    number: 3
  section:
    title: Podstawy rozgałęziania i scalania
    number: 2
    cs_number: '3.2'
    previous: book/pl/v2/Gałęzie-Gita-Czym-jest-gałąź
    next: book/pl/v2/Gałęzie-Gita-Zarządzanie-gałęziami
title: Git - Podstawy rozgałęziania i scalania
url: "/book/pl/v2/Gałęzie-Gita-Podstawy-rozgałęziania-i-scalania.html"
---
<h2 id="_podstawy_rozgałęziania_i_scalania">Podstawy rozgałęziania i scalania</h2>
<div class="paragraph">
<p>Zajmijmy się prostym przykładem rozgałęziania i scalania używając schematu, jakiego mógłbyś użyć w rzeczywistej pracy. W tym celu wykonasz następujące czynności:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Wykonasz pracę nad stroną internetową.</p>
</li>
<li>
<p>Stworzysz gałąź dla nowej funkcji, nad którą pracujesz.</p>
</li>
<li>
<p>Wykonasz jakąś pracę w tej gałęzi.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Na tym etapie otrzymasz telefon, że inny problem jest obecnie priorytetem i potrzeba błyskawicznej poprawki.
Oto, co robisz:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Powrócisz na gałąź produkcyjną.</p>
</li>
<li>
<p>Stworzysz nową gałąź, by dodać tam poprawkę.</p>
</li>
<li>
<p>Po przetestowaniu, scalisz gałąź z poprawką i wypchniesz zmiany na serwer produkcyjny.</p>
</li>
<li>
<p>Przełączysz się na powrót do gałęzi z nową funkcją i będziesz kontynuować pracę.</p>
</li>
</ol>
</div>
<div class="sect3">
<h3 id="_basic_branching">Podstawy rozgałęziania</h3>
<div class="paragraph">
<p>
Na początek załóżmy, że pracujesz nad swoim projektem i masz już zatwierdzonych kilka zestawów zmian.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/pl/v2/images/basic-branching-1.png" >}}" alt="A simple commit history.">
</div>
<div class="title">Figure 18. Krótka i prosta historia zmian.</div>
</div>
<div class="paragraph">
<p>Zdecydowałeś się zająć problemem #53 z systemu śledzenia zgłoszeń, którego używa Twoja firma, czymkolwiek by on nie był.
Aby utworzyć gałąź i jednocześnie się na nią przełączyć, możesz wykonać polecenie <code>git checkout</code> z przełącznikiem <code>-b</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b iss53
Switched to a new branch "iss53"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jest to krótsza wersja:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch iss53
$ git checkout iss53</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/pl/v2/images/basic-branching-2.png" >}}" alt="Creating a new branch pointer.">
</div>
<div class="title">Figure 19. Creating a new branch pointer</div>
</div>
<div class="paragraph">
<p>Pracujesz nad swoim serwisem WWW i zatwierdzasz kolejne zmiany. Każdorazowo naprzód przesuwa się także gałąź <code>iss53</code>, ponieważ jest aktywna (to znaczy, że wskazuje na nią wskaźnik HEAD):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ vim index.html
$ git commit -a -m 'added a new footer [issue 53]'</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/pl/v2/images/basic-branching-3.png" >}}" alt="The iss53 branch has moved forward with your work.">
</div>
<div class="title">Figure 20. Gałąź iss53 przesunęła się do przodu wraz z postępami w Twojej pracy</div>
</div>
<div class="paragraph">
<p>Teraz właśnie otrzymujesz telefon, że na stronie wykryto błąd i musisz go natychmiast poprawić. Z Gitem nie musisz wprowadzać poprawki razem ze zmianami wykonanymi w ramach pracy nad <code>iss35</code>. Co więcej, nie będzie cię również kosztować wiele wysiłku przywrócenie katalogu roboczego do stanu sprzed tych zmian, tak, by nanieść poprawki na kod, który używany jest na serwerze produkcyjnym. Wszystko, co musisz teraz zrobić, to przełączyć się z powrotem na gałąź <code>master</code>.</p>
</div>
<div class="paragraph">
<p>Jednakże, nim to zrobisz, zauważ, że, jeśli Twój katalog roboczy lub poczekalnia zawierają niezatwierdzone zmiany, które są w konflikcie z gałęzią, do której chcesz się teraz przełączyć, Git nie pozwoli ci zmienić gałęzi.
Przed przełączeniem gałęzi najlepiej jest doprowadzić katalog roboczy do czystego stanu.
Istnieją sposoby pozwalające obejść to ograniczenie (mianowicie schowek oraz poprawianie zatwierdzonych już zmian) i zajmiemy się nimi w rozdziale <a href="{{< relurl "book/pl/v2/ch00/_git_stashing" >}}">Schowek i czyszczenie</a>.
Póki co zatwierdziłeś wszystkie swoje zmiany, więc możesz przełączyć się na swoją gałąź master:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
Switched to branch 'master'</code></pre>
</div>
</div>
<div class="paragraph">
<p>W tym momencie Twój katalog roboczy projektu jest dokładnie w takim stanie, w jakim był zanim zacząłeś pracę nad problemem #53, więc możesz skoncentrować się na swojej poprawce. Jest to ważna informacja do zapamiętania: Git resetuje katalog roboczy, by wyglądał dokładnie jak migawka zestawu zmian wskazywanego przez aktywną gałąź.
Automatycznie dodaje, usuwa i modyfikuje pliki, by upewnić się, że kopia robocza wygląda tak, jak po ostatnich zatwierdzonych w niej zmianach.</p>
</div>
<div class="paragraph">
<p>Masz jednak teraz do wykonania ważną poprawkę.
Stwórzmy zatem gałąź, na której będziesz pracował do momentu poprawienia błędu:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout -b hotfix
Switched to a new branch 'hotfix'
$ vim index.html
$ git commit -a -m 'fixed the broken email address'
[hotfix 1fb7853] fixed the broken email address
 1 file changed, 2 insertions(+)</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/pl/v2/images/basic-branching-4.png" >}}" alt="Hotfix branch based on `master`.">
</div>
<div class="title">Figure 21. Gałąź hotfix bazująca na gałęzi <code>master</code>
</div>
</div>
<div class="paragraph">
<p>Możesz uruchomić swoje testy, upewnić się, że poprawka w gałęzi hotfix jest tym, czego potrzebujesz i scalić ją na powrót z gałęzią master, by następnie przenieść zmiany na serwer produkcyjny. Robi się to poleceniem <code>git merge</code>::</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
$ git merge hotfix
Updating f42c576..3a0874c
Fast-forward
 index.html | 2 ++
 1 file changed, 2 insertions(+)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Rezultat polecenia scalenia zawiera frazę “Fast forward”. Ponieważ zestaw zmian wskazywany przez scalaną gałąź był bezpośrednim rodzicem aktualnego zestawu zmian, Git przesuwa wskaźnik do przodu. Innymi słowy, jeśli próbujesz scalić zestaw zmian z innym, do którego dotrzeć można podążając wzdłuż historii tego pierwszego, Git upraszcza wszystko poprzez przesunięcie wskaźnika do przodu, ponieważ nie ma po drodze żadnych rozwidleń do scalenia — stąd nazwa “fast forward” („przewijanie”).</p>
</div>
<div class="paragraph">
<p>Twoja zmiana jest teraz częścią migawki zestawu zmian wskazywanego przez gałąź <code>master</code> i możesz zaktualizować kod na serwerze produkcyjnym.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/pl/v2/images/basic-branching-5.png" >}}" alt="`master` is fast-forwarded to `hotfix`.">
</div>
<div class="title">Figure 22. Po scaleniu Twoja gałąź <code>master</code> wskazuje to samo miejsce, co gałąź <code>hotfix</code>
</div>
</div>
<div class="paragraph">
<p>Po tym, jak Twoje niezwykle istotne poprawki trafią na serwer, jesteś gotowy powrócić do uprzednio przerwanej pracy. Najpierw jednak usuniesz gałąź hotfix, gdyż nie jest już ci potrzebna — gałąź <code>master</code> wskazuje to samo miejsce. Możesz ją usunąć używając opcji <code>-d</code> polecenia <code>git branch</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch -d hotfix
Deleted branch hotfix (3a0874c).</code></pre>
</div>
</div>
<div class="paragraph">
<p>Teraz możesz przełączyć się z powrotem do gałęzi z rozpoczętą wcześniej pracą nad problemem #53 i kontynuować pracę:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout iss53
Switched to branch "iss53"
$ vim index.html
$ git commit -a -m 'finished the new footer [issue 53]'
[iss53 ad82d7a] finished the new footer [issue 53]
1 file changed, 1 insertion(+)</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/pl/v2/images/basic-branching-6.png" >}}" alt="Work continues on `iss53`.">
</div>
<div class="title">Figure 23. Twoja gałąź iss53 może przesuwać się do przodu niezależnie.</div>
</div>
<div class="paragraph">
<p>Warto tu zauważyć, że praca, jaką wykonałeś na gałęzi <code>hotfix</code> nie jest uwzględniona w plikach w gałęzi <code>iss53</code>. Jeśli jej potrzebujesz, możesz scalić zmiany z gałęzi <code>master</code> do gałęzi <code>iss53</code>, uruchamiając <code>git merge master</code>, możesz też zaczekać z integracją zmian na moment, kiedy zdecydujesz się przenieść zmiany z gałęzi <code>iss53</code> z powrotem do gałęzi <code>master</code>.</p>
</div>
</div>
<div class="sect3">
<h3 id="_basic_merging">Podstawy scalania</h3>
<div class="paragraph">
<p>
Załóżmy, że zdecydowałeś, że praca nad problemem #53 dobiegła końca i jest gotowa, by scalić ją do gałęzi <code>master</code>. Aby to zrobić, scalisz zmiany z gałęzi <code>iss53</code> tak samo, jak wcześniej zrobiłeś to z gałęzią <code>hotfix</code>. Wszystko, co musisz zrobić, to przełączyć się na gałąź, do której chcesz zmiany scalić, a następnie uruchomić polecenie <code>git merge</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
Switched to branch 'master'
$ git merge iss53
Merge made by the 'recursive' strategy.
index.html |    1 +
1 file changed, 1 insertion(+)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Wygląda to odrobinę inaczej, niż w przypadku wcześniejszego scalenia gałęzi <code>hotfix</code>. W tym wypadku Twoja historia rozwoju została rozszczepiona na wcześniejszym etapie. Ponieważ zestaw zmian z gałęzi, na której obecnie jesteś, nie jest bezpośrednim potomkiem gałęzi, którą scalasz, Git musi w końcu popracować. W tym przypadku Git przeprowadza scalenie trójstronne (ang. three-way merge), używając dwóch migawek wskazywanych przez końcówki gałęzi oraz ich wspólnego przodka.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/pl/v2/images/basic-merging-1.png" >}}" alt="Three snapshots used in a typical merge.">
</div>
<div class="title">Figure 24. Trzy migawki używane w typowym scaleniu</div>
</div>
<div class="paragraph">
<p>Zamiast zwykłego przeniesienia wskaźnika gałęzi do przodu, Git tworzy nową migawkę, która jest wynikiem wspomnianego scalenia trójstronnego i automatycznie tworzy nowy zestaw zmian, wskazujący na ową migawkę. Określane jest to mianem zmiany scalającej (ang. merge commit), która jest o tyle wyjątkowa, że posiada więcej niż jednego rodzica.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/pl/v2/images/basic-merging-2.png" >}}" alt="A merge commit.">
</div>
<div class="title">Figure 25. Zmiana łącząca(merge commit)</div>
</div>
<div class="paragraph">
<p>Warto zaznaczyć, że Git sam określa najlepszego wspólnego przodka do wykorzystania jako punkt wyjściowy scalenia; różni się to od zachowania CVS czy Subversion (przed wersją 1.5), gdzie osoba scalająca zmiany musi punkt wyjściowy scalania znaleźć samodzielnie. Czyni to scalanie w Gicie znacznie łatwiejszym, niż w przypadku tamtych systemów.</p>
</div>
<div class="paragraph">
<p>Teraz, kiedy Twoja praca jest już scalona, nie potrzebujesz dłużej gałęzi <code>iss53</code>. Możesz ją usunąć, a następnie ręcznie zamknąć zgłoszenie w swoim systemie śledzenia zadań:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch -d iss53</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_basic_merge_conflicts">Podstawowe konflikty scalania</h3>
<div class="paragraph">
<p>
Od czasu do czasu proces scalania nie przebiega tak gładko. Jeśli ten sam plik zmieniłeś w różny sposób w obu scalanych gałęziach, Git nie będzie w stanie scalić ich samodzielnie. Jeśli Twoja poprawka problemu #53 zmieniła tę samą część pliku, co zmiana w gałęzi <code>hotfix</code>, podczas scalania otrzymasz komunikat o konflikcie, wyglądający jak poniżej:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git nie zatwierdził automatycznie zmiany scalającej. Wstrzymał on cały proces do czasu rozwiązania konfliktu przez Ciebie. Jeśli chcesz zobaczyć, które pliki pozostałe niescalone w dowolnym momencie po wystąpieniu konfliktu, możesz uruchomić <code>git status</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")

Unmerged paths:
  (use "git add &lt;file&gt;..." to mark resolution)

    both modified:      index.html

no changes added to commit (use "git add" and/or "git commit -a")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cokolwiek spowodowało konflikty i nie zostało automatycznie rozstrzygnięte, jest tutaj wymienione jako „unmerged” (niescalone). Git dodaje do problematycznych plików standardowe znaczniki rozwiązania konfliktu, możesz więc owe pliki otworzyć i samodzielnie rozwiązać konflikty. Twój plik zawiera teraz sekcję, która wygląda mniej więcej tak:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html
&lt;div id="footer"&gt;contact : email.support@github.com&lt;/div&gt;
=======
&lt;div id="footer"&gt;
 please contact us at support@github.com
&lt;/div&gt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</code></pre>
</div>
</div>
<div class="paragraph">
<p>Oznacza to, że wersja wskazywana przez HEAD (Twoja gałąź master, ponieważ tam właśnie byłeś podczas uruchamiania polecenia scalania) znajduje się w górnej części bloku (wszystko powyżej <code>======</code>), a wersja z gałęzi <code>iss53</code> to wszystko poniżej. Aby rozwiązać konflikt, musisz wybrać jedną lub druga wersję albo własnoręcznie połączyć zawartość obu. Dla przykładu możesz rozwiązać konflikt, zastępując cały blok poniższą zawartością:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;div id="footer"&gt;
please contact us at email.support@github.com
&lt;/div&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To rozwiązanie ma po trochu z obu części, całkowicie usunąłem także linie <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>, <code>=======</code> i <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>. Po rozstrzygnięciu wszystkich takich sekcji w każdym z problematycznych plików, uruchom <code>git add</code> na każdym z nich, aby oznaczyć go jako rozwiązany. Przeniesienie do poczekalni oznacza w Gicie rozwiązanie konfliktu.</p>
</div>
<div class="paragraph">
<p>Jeśli chcesz do rozwiązania tych problemów użyć narzędzia graficznego, możesz wydać polecenie <code>git mergetool</code>. Uruchomi ono odpowiednie narzędzie graficzne, które przeprowadzi cię przez wszystkie konflikty:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git mergetool

This message is displayed because 'merge.tool' is not configured.
See 'git mergetool --tool-help' or 'git help config' for more details.
'git mergetool' will now attempt to use one of the following tools:
opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge
Merging:
index.html

Normal merge conflict for 'index.html':
  {local}: modified file
  {remote}: modified file
Hit return to start merge resolution tool (opendiff):</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jeśli chcesz użyć narzędzia innego niż domyślne (Git w tym przypadku wybrał dla mnie <code>opendiff</code>, ponieważ pracuję na Maku), możesz zobaczyć wszystkie wspierane narzędzia wymienione na samej górze, zaraz za „merge tool candidates”. Wpisz nazwę narzędzia, którego wolałbyś użyć. W Rozdziale 7 dowiemy się, jak zmienić domyślną wartość dla twojego środowiska pracy.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Jeśli potrzebujesz bardziej zaawansowanego narzędzia do rozwiązywania konfliktów, zajmiemy się tym w rozdziale <a href="{{< relurl "book/pl/v2/ch00/_advanced_merging" >}}">Advanced Merging</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Po opuszczeniu narzędzia do scalania, Git zapyta, czy wszystko przebiegło pomyślnie. Jeśli odpowiesz skryptowi, że tak właśnie było, plik zostanie umieszczony w poczekalni, by konflikt oznaczyć jako rozwiązany.
Możesz uruchomić polecenie <code>git status</code> ponownie, by upewnić się, że wszystkie konflikty zostały rozwiązane:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
On branch master
All conflicts fixed but you are still merging.
  (use "git commit" to conclude merge)

Changes to be committed:

    modified:   index.html</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jeśli jesteś zadowolony i potwierdziłeś, że wszystkie problematyczne pliki zostały umieszczone w poczekalni, możesz wpisać <code>git commit</code>, by tym samym zatwierdzić zestaw zmian scalających. Jego domyślny opis wygląda jak poniżej:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">Merge branch 'iss53'

Conflicts:
    index.html
#
# It looks like you may be committing a merge.
# If this is not correct, please remove the file
#	.git/MERGE_HEAD
# and try again.


# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# All conflicts fixed but you are still merging.
#
# Changes to be committed:
#	modified:   index.html
#</code></pre>
</div>
</div>
<div class="paragraph">
<p>Możesz go zmodyfikować, dodając szczegółowy opis sposobu scalenia zmian, jeśli tylko uważasz, że taka informacja będzie pomocna innym, gdy przyjdzie im oglądać efekt scalenia w przyszłości — dlaczego zrobiłeś to w taki, a nie inny sposób, jeśli nie jest to oczywiste.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>