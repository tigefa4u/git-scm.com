---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: pl
  chapter:
    title: Mechanizmy wewnętrzne w Git
    number: 10
  section:
    title: Protokoły transferu
    number: 6
    cs_number: '10.6'
    previous: book/pl/v2/Mechanizmy-wewnętrzne-w-Git-Refspec
    next: book/pl/v2/Mechanizmy-wewnętrzne-w-Git-Konserwacja-i-odzyskiwanie-danych
title: Git - Protokoły transferu
url: "/book/pl/v2/Mechanizmy-wewnętrzne-w-Git-Protokoły-transferu.html"
---
<h2 id="_protokoły_transferu">Protokoły transferu</h2>
<div class="paragraph">
<p>Git może przesyłać dane pomiędzy dwoma repozytoriami na dwa główne sposoby: wykorzystując protokół "prosty" (<em>dumb</em>) lub protokół "inteligentny" (<em>smart</em>).
W tej sekcji pokrótce omówimy jak działają te dwa główne protokoły.</p>
</div>
<div class="sect3">
<h3 id="_protokół_prosty">Protokół prosty</h3>
<div class="paragraph">
<p>Jeśli konfigurujesz repozytorium, które ma być obsługiwane tylko do odczytu przez HTTP, prawdopodobnie użyty zostanie "prosty" protokół.
Protokół ten nazywany jest "prostym", ponieważ nie wymaga żadnego specyficznego dla Git kodu po stronie serwera podczas procesu transportu danych; proces pobierania danych jest serią żądań HTTP <code>GET</code>, gdzie klient może przyjąć pewną strukturę repozytorium Git umieszczonego na serwerze.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Protokół "prosty" jest obecnie dość rzadko używany.
Trudno go zabezpieczyć lub uczynić prywatnym, więc większość hostów Git (zarówno w chmurze, jak i w instancjach lokalnych) odmówi jego użycia.
Ogólnie zaleca się używanie protokołu "inteligentnego", który opisujemy nieco dalej.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Prześledźmy proces <code>http-fetch</code> dla biblioteki simplegit:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone http://server/simplegit-progit.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pierwszą rzeczą jaką wykonuje ta komenda, jest pobranie pliku <code>info/refs</code>.
Plik ten jest zapisywany przez komendę <code>update-server-info</code>, dlatego też musisz włączyć komendę <code>post-receive</code>, aby przesyłanie danych przez HTTP działało poprawnie:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET info/refs
ca82a6dff817ec66f44342007202690a93763949     refs/heads/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Masz teraz listę zdalnych referencji oraz ich sumy SHA-1. Następnie sprawdzasz co znajduje się w HEAD, tak aby było wiadomo jaką gałąź pobrać po zakończeniu:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET HEAD
ref: refs/heads/master</code></pre>
</div>
</div>
<div class="paragraph">
<p>Musisz pobrać gałąź <code>master</code> po ukończeniu całego procesu.
W tym momencie możesz rozpocząć proces odnajdowania struktury repozytorium.
Elementem początkowym jest commit <code>ca82a6</code>, który zobaczyłeś w pliku <code>info/refs</code>, pobierz go jako pierwszego:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET objects/ca/82a6dff817ec66f44342007202690a93763949
(179 bytes of binary data)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Otrzymujesz w odpowiedzi obiekt – pobrany z serwera obiekt jest w luźnym formacie i został pobrany poprzez zapytanie HTTP <code>GET</code>.
Możesz rozpakować ten plik, usunąć nagłówki i odczytać jego zawartość:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git cat-file -p ca82a6dff817ec66f44342007202690a93763949
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
author Scott Chacon &lt;schacon@gmail.com&gt; 1205815931 -0700
committer Scott Chacon &lt;schacon@gmail.com&gt; 1240030591 -0700

changed the version number</code></pre>
</div>
</div>
<div class="paragraph">
<p>W następnej kolejności masz dwa obiekty do pobrania – <code>cfda3b</code>, który jest obiektem tree z zawartością na którą wskazuje pobrany commit; oraz <code>085bb3</code>, który jest poprzednim commitem:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET objects/08/5bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
(179 bytes of data)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Otrzymałeś więc kolejny obiekt commit.
Pobierz zawartość obiektu tree:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET objects/cf/da3bf379e4f8dba8717dee55aab78aef7f4daf
(404 - Not Found)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ojej – wygląda na to, że obiekt tree nie jest w luźnym formacie na serwerze, dlatego otrzymałeś odpowiedź 404.
Przyczyn takiego stanu rzeczy może być kilka – obiekt może być w alternatywnym repozytorium, lub może być w pliku packfile w tym samym repozytorium.
Git najpierw sprawdza czy są jakieś alternatywne repozytoria dodane:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET objects/info/http-alternates
(empty file)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jeżeli zwrócona zostanie lista alternatywnych adresów URL, Git sprawdzi czy istnieją w nich szukane pliki w luźnym formacie lub spakowane pliki packfile – jest to bardzo fajny mechanizm umożliwiający współdzielenie plików dla projektów które rozwidlają się (ang. <em>fork</em>) jeden od drugiego.
Jednak, ze względu na to, że nie ma żadnych alternatywnych plików w tym przykładzie, szukany obiekt musi być w spakowanym pliku packfile.
Aby zobaczyć jakie pliki packfile są dostępne na serwerze, musisz pobrać plik <code>objects/info/packs</code> zawierający ich listę (ten plik jest również tworzony przez <code>update-server-info</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET objects/info/packs
P pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jest tylko jeden plik packfile na serwerze, więc szukany obiekt jest na pewno w nim, sprawdź jednak plik indeks aby mieć pewność.
Jest to również przydatne, gdy masz wiele plików packfile na serwerze, tak abyś mógł zobaczyć który z nich zawiera obiekt którego szukasz:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.idx
(4k of binary data)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Teraz, gdy pobrałeś już indeks pliku packfile, możesz zobaczyć jakie obiekty się w nim znajdują – ponieważ zawiera on listę sum SHA-1 obiektów oraz informacje o tym w którym miejscu w pliku packfile ten obiekt się znajduje.
Twój obiekt w nim jest, pobierz więc cały plik packfile:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack
(13k of binary data)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Masz już obiekt tree, możesz więc kontynuować przechodzenie przez wszystkie zmiany.
Wszystkie one zawarte są również w pliku packfile który właśnie pobrałeś, nie musisz więc wykonywać żadnych dodatkowych zapytań do serwera.
Git pobierze kopię roboczą z gałęzi <code>master</code>, na którą wskazywała referencja pobrana z HEAD na początku całego procesu.</p>
</div>
</div>
<div class="sect3">
<h3 id="_protokół_inteligentny">Protokół inteligentny</h3>
<div class="paragraph">
<p>Protokół "prosty" jest <em>nomen omen</em> prosty, ale trochę nieefektywny i nie radzi sobie z zapisem danych od klienta do serwera.
Protokół "inteligentny" jest bardziej powszechną metodą przesyłania danych, ale wymaga on procesu na serwerze zdalnym, który rozumnie ogarnia Gita – może on odczytywać lokalne dane, oraz może wygenerować dane dla konkretnego klienta na podstawie tego jakie informacje on już posiada.
Są dwa rodzaje procesów do przesyłania danych: para procesów do wgrywania danych, oraz para do pobierania.</p>
</div>
<div class="sect4">
<h4 id="_wgrywanie_danych">Wgrywanie danych</h4>
<div class="paragraph">
<p>
Aby wgrać dane do zdalnego repozytorium, Git używa procesów <code>send-pack</code> oraz <code>receive-pack</code>.
Proces <code>send-pack</code> uruchomiony jest po stronie klienta i łączy się do procesu <code>receive-pack</code> uruchomionego na zdalnym serwerze.</p>
</div>
<div class="sect5">
<h6 id="_ssh">SSH</h6>
<div class="paragraph">
<p>Na przykład, załóżmy że uruchamiasz <code>git push origin master</code> w swoim projekcie, a <code>origin</code> jest zdefiniowany jako URL używający protokołu SSH.
Git uruchamia proces <code>send-pack</code>, który zainicjuje połączenie przez SSH do Twojego serwera.
Stara się on uruchomić komendę na zdalnym serwerze przez SSH, podobną do poniższej:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ssh -x git@server "git-receive-pack 'simplegit-progit.git'"
005bca82a6dff817ec66f4437202690a93763949 refs/heads/master report-status \
	delete-refs side-band-64k quiet ofs-delta \
	agent=git/2:2.1.1+github-607-gfba4028 delete-refs
003e085bb3bcb608e1e84b2432f8ecbe6306e7e7 refs/heads/topic
0000</code></pre>
</div>
</div>
<div class="paragraph">
<p>Komenda <code>git-receive-pack</code> od razu odpowiada jedną linią dla każdej referencji którą aktualnie zawiera – w tym przypadku, tylko gałąź <code>master</code> oraz jej SHA-1.
Pierwsza linia zawiera również listę funkcji serwera (tutaj <code>report-status</code>, <code>delete-refs</code> i inne, włączając w to identyfikator klienta).</p>
</div>
<div class="paragraph">
<p>Każda linia rozpoczyna się 4-znakową liczbą szesnastkową wskazującą na to, jak długa jest reszta linii.
Pierwsza linia rozpoczyna się 005b, co daje 91 w systemie dziesiętnym, co oznacza że 91 bajtów pozostało w tej linii.
Następna linia rozpoczyna się od 003e, czyli 62 w systemie dziesiętnym, odczytujesz więc pozostałe 62 bajty.
Kolejna linia to 0000, oznaczająca że serwer zakończył listowanie referencji.</p>
</div>
<div class="paragraph">
<p>Teraz, gdy zna on już stan który jest na serwerze, Twój proces <code>send-pack</code> ustala które z posiadanych commitów nie istnieją na serwerze.
Dla każdej referencji która zostanie zaktualizowana podczas tego pusha, proces <code>send-pack</code> przekazuje <code>receive-pack</code> te informacje.
Na przykład, jeżeli aktualizujesz gałąź <code>master</code> oraz dodajesz gałąź <code>experiment</code>, odpowiedź <code>send-pack</code> może wyglądać tak:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>0085ca82a6dff817ec66f44342007202690a93763949  15027957951b64cf874c3557a0f3547bd83b3ff6 \
	refs/heads/master report-status
00670000000000000000000000000000000000000000 cdfdb42577e2506715f8cfeacdbabc092bf63e8d \
	refs/heads/experiment
0000</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git wysyła wiersz dla każdej aktualizowanej referencji z długością wiersza, starym SHA-1, nowym SHA-1 i referencją, która jest aktualizowana.
Pierwsza linia zawiera również parametry klienta.
Wartość SHA-1 składająca się z samych <em>0</em> oznacza że nic nie było wcześniej – ponieważ dodajesz referencję experiment. Jeżeli usuwasz referencję, zobaczyć sytuację odwrotną: same zera po prawej stronie.</p>
</div>
<div class="paragraph">
<p>Następnie klient wysyła packfile zawierający wszystkie obiekty, których serwer jeszcze nie posiada.
Na koniec serwer odpowiada z informacją o powodzeniu (lub niepowodzeniu):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>000Aunpack ok</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_https">HTTP(S)</h6>
<div class="paragraph">
<p>Proces ten jest w większości taki sam jak w przypadku protokołu HTTP, choć sposób przekazywania danych jest nieco inny.
Połączenie jest inicjowane przez poniższe żądanie:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET http://server/simplegit-progit.git/info/refs?service=git-receive-pack
001f# service=git-receive-pack
000000ab6c5f0e45abd7832bf23074a333f739977c9e8188 refs/heads/master \
	report-status delete-refs side-band-64k quiet ofs-delta \
	agent=git/2:2.1.1~vmg-bitmaps-bugaloo-608-g116744e
0000</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jest to koniec pierwszej wymiany danych pomiędzy klientem a serwerem.
Następnie klient wykonuje kolejne żądanie, tym razem <code>POST</code>, z danymi, które dostarcza <code>git-upload-pack</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; POST http://server/simplegit-progit.git/git-receive-pack</code></pre>
</div>
</div>
<div class="paragraph">
<p>Żądanie <code>POST</code> zawiera wyjście <code>send-pack</code> i plik packfile jako jego payload.
Serwer następnie wskazuje swoją odpowiedzią HTTP sukces lub niepowodzenie.</p>
</div>
</div>
</div>
<div class="sect4">
<h4 id="_pobieranie_danych">Pobieranie danych</h4>
<div class="paragraph">
<p>
Podczas pobierania danych, procesy <code>fetch-pack</code> oraz <code>upload-pack</code> są używane.
Po stronie klienta uruchamiany jest proces <code>fetch-pack</code>, łączący się do <code>upload-pack</code> na drugim końcu, w celu ustalenia które dane mają być pobrane.</p>
</div>
<div class="sect5">
<h6 id="_ssh_2">SSH</h6>
<div class="paragraph">
<p>Jeśli wykonujesz pobieranie przez SSH, <code>fetch-pack</code> uruchamia coś takiego:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ssh -x git@server "git-upload-pack 'simplegit-progit.git'"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Po połączeniu się z <code>fetch-pack</code>, <code>upload-pack</code> odsyła coś w tym stylu:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>00dfca82a6dff817ec66f44342007202690a93763949 HEADmulti_ack thin-pack \
	side-band side-band-64k ofs-delta shallow no-progress include-tag \
	multi_ack_detailed symref=HEAD:refs/heads/master \
	agent=git/2:2.1.1+github-607-gfba4028
003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master
0000</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jest to bardzo podobna odpowiedź to tej którą zwrócił <code>receive-pack</code>, ale z innymi obsługiwanymi funkcjami.
Dodatkowo, odsyła to, na co wskazuje HEAD (<code>symref=HEAD:refs/heads/master</code>), więc klient wie, co sprawdzić, jeśli jest to klonowanie.</p>
</div>
<div class="paragraph">
<p>W tym momencie, proces <code>fetch-pack</code> sprawdza jakie obiekty posiada i wysyła odpowiedź z obiektami które potrzebuje za pomocą "want" oraz sumy SHA-1.
Wysyła informację o tym jakie obiekty już posiada za pomocą "have" oraz SHA-1.
Na końcu listy, wypisuje "done", aby proces <code>upload-pack</code> wiedział że ma rozpocząć wysyłanie spakowanych plików packfile z danymi które są potrzebne:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>0054want ca82a6dff817ec66f44342007202690a93763949 ofs-delta
0032have 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
0000
0009done</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_https_2">HTTP(S)</h6>
<div class="paragraph">
<p>Potwierdzenie nawiązania łączności dla operacji pobierania wymaga dwóch żądań HTTP.
Pierwsze z nich to <code>GET</code> do tego samego punktu końcowego, który jest używany w protokole "prostym":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; GET $GIT_URL/info/refs?service=git-upload-pack
001e# service=git-upload-pack
000000e7ca82a6dff817ec66f44342007202690a93763949 HEADmulti_ack thin-pack \
	side-band side-band-64k ofs-delta shallow no-progress include-tag \
	multi_ack_detailed no-done symref=HEAD:refs/heads/master \
	agent=git/2:2.1.1+github-607-gfba4028
003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master
0000</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jest to bardzo podobne do wywołania <code>git-upload-pack</code> przez połączenie SSH, ale druga wymiana jest wykonywana jako oddzielne żądanie:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>=&gt; POST $GIT_URL/git-upload-pack HTTP/1.0
0032want 0a53e9ddeaddad63ad106860237bbf53411d11a7
0032have 441b40d833fdfa93eb2908e52742248faf0ee993
0000</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ponownie, jest to taki sam format jak powyżej.
Odpowiedź na to żądanie wskazuje sukces lub porażkę, i zawiera plik packfile.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_podsumowanie_protokołów">Podsumowanie protokołów</h3>
<div class="paragraph">
<p>Powyższa sekcja zawiera bardzo podstawowy przegląd protokołów transferu.
Protokoły zawierają wiele innych funkcji, takich jak <code>multi_ack</code> czy <code>side-band</code>, ale ich omówienie wykracza poza zakres tej książki.
Staraliśmy się dać Ci poczucie ogólnego przepływu informacji pomiędzy klientem a serwerem; jeśli potrzebujesz więcej informacji na ten temat, prawdopodobnie będziesz chciał zajrzeć do kodu źródłowego Git.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>