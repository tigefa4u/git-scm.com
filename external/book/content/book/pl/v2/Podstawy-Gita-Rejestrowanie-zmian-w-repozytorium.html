---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: pl
  chapter:
    title: Podstawy Gita
    number: 2
  section:
    title: Rejestrowanie zmian w repozytorium
    number: 2
    cs_number: '2.2'
    previous: book/pl/v2/Podstawy-Gita-Pierwsze-repozytorium-Gita
    next: book/pl/v2/Podstawy-Gita-Podgląd-historii-rewizji
title: Git - Rejestrowanie zmian w repozytorium
---
<h2 id="_rejestrowanie_zmian_w_repozytorium">Rejestrowanie zmian w repozytorium</h2>
<div class="paragraph">
<p>Posiadasz już repozytorium Gita i ostatnią wersję lub kopię roboczą wybranego projektu. Za każdym razem, kiedy po naniesieniu zmian projekt osiągnie stan, który chcesz zapamiętać, musisz nowe wersje plików zatwierdzić w swoim repozytorium.</p>
</div>
<div class="paragraph">
<p>Pamiętaj, że każdy plik w twoim katalogu roboczym może być w jednym z dwóch stanów: śledzony lub nieśledzony. Śledzone pliki to te, które znalazły się w ostatniej migawce; mogą być niezmodyfikowane, zmodyfikowane lub oczekiwać w poczekalni. Nieśledzone pliki to cała reszta — są to jakiekolwiek pliki w twoim katalogu roboczym, które nie znalazły się w ostatniej migawce i nie znajdują się w poczekalni, gotowe do zatwierdzenia. Początkowo, kiedy klonujesz repozytorium, wszystkie twoje pliki będą śledzone i niezmodyfikowane, ponieważ dopiero co zostały wybrane i nie zmieniałeś jeszcze niczego.</p>
</div>
<div class="paragraph">
<p>Kiedy zmieniasz pliki, Git rozpoznaje je jako zmodyfikowane, ponieważ różnią się od ostatniej zatwierdzonej zmiany. Zmodyfikowane pliki umieszczasz w poczekalni, a następnie zatwierdzasz oczekujące tam zmiany i tak powtarza się cały cykl.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/pl/v2/images/lifecycle.png" >}}" alt="The lifecycle of the status of your files.">
</div>
<div class="title">Figure 8. Cykl stanów twoich plików.</div>
</div>
<div class="sect3">
<h3 id="_checking_status">Sprawdzanie stanu twoich plików</h3>
<div class="paragraph">
<p>Podstawowe narzędzie używane do sprawdzenia stanu plików to polecenie <code>git status</code>. Jeśli uruchomisz je bezpośrednio po sklonowaniu repozytorium, zobaczysz wynik podobny do poniższego:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
On branch master
nothing to commit, working directory clean</code></pre>
</div>
</div>
<div class="paragraph">
<p>Oznacza to, że posiadasz czysty katalog roboczy — innymi słowy nie zawiera on śledzonych i zmodyfikowanych plików. Git nie widzi także żadnych plików nieśledzonych, w przeciwnym wypadku wyświetliłby ich listę. W końcu polecenie pokazuje również gałąź, na której aktualnie pracujesz. Póki co, jest to zawsze master, wartość domyślna; nie martw się tym jednak teraz. Następny rozdział w szczegółach omawia gałęzie oraz odniesienia.</p>
</div>
<div class="paragraph">
<p>Powiedzmy, że dodajesz do repozytorium nowy, prosty plik README. Jeżeli nie istniał on wcześniej, po uruchomieniu <code>git status</code> zobaczysz go jako plik nieśledzony, jak poniżej:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ echo 'My Project' &gt; README
$ git status
On branch master
Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)

    README

nothing added to commit but untracked files present (use "git add" to track)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Widać, że twój nowy plik README nie jest jeszcze śledzony, ponieważ znajduje się pod nagłówkiem „Untracked files” (Nieśledzone pliki) w informacji o stanie. Nieśledzony oznacza, że Git widzi plik, którego nie miałeś w poprzedniej migawce (zatwierdzonej kopii); Git nie zacznie umieszczać go w przyszłych migawkach, dopóki sam mu tego nie polecisz. Zachowuje się tak, by uchronić cię od przypadkowego umieszczenia w migawkach wyników działania programu lub innych plików, których nie miałeś zamiaru tam dodawać. W tym przypadku chcesz, aby README został uwzględniony, więc zacznijmy go śledzić.</p>
</div>
</div>
<div class="sect3">
<h3 id="_tracking_files">Śledzenie nowych plików</h3>
<div class="paragraph">
<p>Aby rozpocząć śledzenie nowego pliku, użyj polecenia <code>git add</code>. Aby zacząć śledzić plik README, możesz wykonać:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add README</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jeśli uruchomisz teraz ponownie polecenie <code>status</code>, zobaczysz, że twój plik README jest już śledzony i znalazł się w poczekalni:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    new file:   README</code></pre>
</div>
</div>
<div class="paragraph">
<p>Widać, że jest w poczekalni, ponieważ znajduje się pod nagłówkiem „Changes to be commited“ (Zmiany do zatwierdzenia). Jeśli zatwierdzisz zmiany w tym momencie, jako migawka w historii zostanie zapisana wersja pliku z momentu wydania polecenia <code>git add</code>. Być może pamiętasz, że po uruchomieniu <code>git init</code> wydałeś polecenie <code>git add (pliki)</code> — miało to na celu rozpoczęcie ich śledzenia. Polecenie <code>git add</code> bierze jako parametr ścieżkę do pliku lub katalogu; jeśli jest to katalog, polecenie dodaje wszystkie pliki z tego katalogu i podkatalogów.</p>
</div>
</div>
<div class="sect3">
<h3 id="_dodawanie_zmodyfikowanych_plików_do_poczekalni">Dodawanie zmodyfikowanych plików do poczekalni</h3>
<div class="paragraph">
<p>Zmodyfikujmy teraz plik, który był już śledzony. Jeśli zmienisz śledzony wcześniej plik o nazwie <code>CONTRIBUTING.md</code>, a następnie uruchomisz polecenie <code>status</code>, zobaczysz coś podobnego:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    new file:   README

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>Plik <code>CONTRIBUTING.md</code> pojawia się w sekcji „Changes not staged for commit“ (Zmienione ale nie zaktualizowane), co oznacza, że śledzony plik został zmodyfikowany, ale zmiany nie trafiły jeszcze do poczekalni. Aby je tam wysłać, uruchom polecenie <code>git add</code> (jest to wielozadaniowe polecenie — używa się go do rozpoczynania śledzenia nowych plików, umieszczania ich w poczekalni, oraz innych zadań, takich jak oznaczanie rozwiązanych konfliktów scalania). Uruchom zatem <code>git add</code> by umieścić <code>CONTRIBUTING.md</code> w poczekalni, a następnie ponownie wykonaj <code>git status</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>Oba pliki znajdują się już w poczekalni i zostaną uwzględnione podczas kolejnego zatwierdzenia zmian. Załóżmy, że w tym momencie przypomniałeś sobie o dodatkowej małej zmianie, którą koniecznie chcesz wprowadzić do pliku <code>CONTRIBUTING.md</code> jeszcze przed zatwierdzeniem. Otwierasz go zatem, wprowadzasz zmianę i jesteś gotowy do zatwierdzenia. Uruchom jednak <code>git status</code> raz jeszcze:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ vim CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>Co do licha? Plik <code>CONTRIBUTING.md</code> widnieje teraz jednocześnie w poczekalni i poza nią. Jak to możliwe? Okazuje się, że Git umieszcza plik w poczekalni dokładnie z taką zawartością, jak w momencie uruchomienia polecenia <code>git add</code>. Jeśli w tej chwili zatwierdzisz zmiany, zostanie użyta wersja <code>CONTRIBUTING.md</code> dokładnie z momentu uruchomienia polecenia <code>git add</code>, nie zaś ta, którą widzisz w katalogu roboczym w momencie wydania polecenia <code>git commit</code>. Jeśli modyfikujesz plik po uruchomieniu <code>git add</code>, musisz ponownie użyć <code>git add</code>, aby najnowsze zmiany zostały umieszczone w poczekalni:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_zwięzły_stan">Zwięzły stan</h3>
<div class="paragraph">
<p>Rezultat polecenia <code>git status</code> jest dość szczegółowy, ale też zbyt rozległy. Git posiada też opcję zwięzłego stanu, więc możesz zobaczyć swoje zmiany w bardziej zwartej postaci. Jeśli wykonasz <code>git status -s</code> lub <code>git status --short</code> uzyskasz znacznie uproszczony wynik tego polecania.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nowe nieśledzone pliki mają obok siebie <code>??</code>, nowe pliki dodane do poczekalni <code>A</code>, zmodyfikowane pliki mają natomiast <code>M</code>. Mamy tutaj tylko dwie kolumny - lewa wskazuje na to czy plik jest w poczekalni, a prawa czy jest zmieniony. Przykład dla powyższego rezultatu, plik <code>README</code> został zmodyfikowany w katalogu roboczym ale nie został dodany do poczekalni, podczas gdy <code>lib/simplegit.rb</code> został zmodyfikowany i dodany do poczekalni. Plik <code>Rakefile</code> został zmodyfikowany, dodany do poczekalni i zmodyfikowany ponownie, więc jego zmiany są jednocześnie w poczekalni i poza nią.</p>
</div>
</div>
<div class="sect3">
<h3 id="_ignoring">Ignorowanie plików</h3>
<div class="paragraph">
<p>Często spotkasz się z klasą plików, w przypadku których nie chcesz, by Git automatycznie dodawał je do repozytorium, czy nawet pokazywał je jako nieśledzone. Są to ogólnie pliki generowane automatycznie, takie jak dzienniki zdarzeń, czy pliki tworzone w czasie budowania projektu. W takich wypadkach tworzysz plik zawierający listę wzorców do nich pasujących i nazywasz go <code>.gitignore</code>. Poniżej znajdziesz przykładowy plik <code>.gitignore</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cat .gitignore
*.[oa]
*~</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pierwsza linia mówi Gitowi, by ignorował pliki kończące się na .o lub .a — pliki obiektów i archiwa, które mogą być produktem kompilacji kodu. Druga linia mówi Gitowi, żeby pomijał również wszystkie pliki, które nazwy kończą się tyldą (<code>~</code>), której to używa wiele edytorów tekstu, takich jak Emacs, do oznaczania plików tymczasowych. Możesz też dołączyć katalog log, tmp lub pid, automatycznie wygenerowaną dokumentację itp. Zajęcie się plikiem <code>.gitignore</code> jeszcze przed przystąpieniem do pracy jest zwykle dobrym pomysłem i pozwoli ci uniknąć przypadkowego dodania do repozytorium Git niechcianych plików.</p>
</div>
<div class="paragraph">
<p>Zasady przetwarzania wyrażeń, które możesz umieścić w pliku <code>.gitignore</code> są następujące:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Puste linie lub linie rozpoczynające się od # są ignorowane.</p>
</li>
<li>
<p>Działają standardowe wyrażenia glob.</p>
</li>
<li>
<p>Możesz zakończyć wyrażenie znakiem ukośnika (<code>/</code>) aby sprecyzować, że chodzi o katalog.</p>
</li>
<li>
<p>Możesz negować wyrażenia rozpoczynając je wykrzyknikiem (<code>!</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Wyrażenia glob są jak uproszczone wyrażenia regularne, używane przez powłokę. Gwiazdka (<code>*</code>) dopasowuje zero lub więcej znaków; <code>[abc]</code> dopasowuje dowolny znak znajdujący się wewnątrz nawiasu kwadratowego (w tym przypadku a, b lub c); znak zapytania (<code>?</code>) dopasowuje pojedynczy znak; nawias kwadratowy zawierający znaki rozdzielone myślnikiem (<code>[0-9]</code>) dopasowuje dowolny znajdujący się pomiędzy nimi znak (w tym przypadku od 0 do 9).</p>
</div>
<div class="paragraph">
<p>Możesz użyć dwóch gwiazdek aby dopasować katalogi zagnieżdżone; <code>a/**/z</code> would match <code>a/z</code>, <code>a/b/z</code>, <code>a/b/c/z</code> i tak dalej.</p>
</div>
<div class="paragraph">
<p>Poniżej znajdziesz kolejny przykład pliku <code>.gitignore</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code># no .a files
*.a

# but do track lib.a, even though you're ignoring .a files above
!lib.a

# only ignore the root TODO file, not subdir/TODO
/TODO

# ignore all files in the build/ directory
build/

# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt

# ignore all .txt files in the doc/ directory
doc/**/*.txt</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<div class="title">Wskazówka</div>
</td>
<td class="content">
<div class="paragraph">
<p>Github zarządza dość obszerną listą przykładowych plików <code>.gitignore</code> dla wielu projektów i języków <a href="https://github.com/github/gitignore" class="bare">https://github.com/github/gitignore</a> jeśli chcesz mieć punkt wyjścia dla swojego projektu.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h3 id="_git_diff_staged">Podgląd zmian w poczekalni i poza nią</h3>
<div class="paragraph">
<p>Jeśli polecenie <code>git status</code> jest dla ciebie zbyt nieprecyzyjne — chcesz wiedzieć, co dokładnie zmieniłeś, nie zaś, które pliki zostały zmienione — możesz użyć polecenia <code>git diff</code>. W szczegółach zajmiemy się nim później; prawdopodobnie najczęściej będziesz używał go aby uzyskać odpowiedź na dwa pytania: Co zmieniłeś, ale jeszcze nie trafiło do poczekalni? Oraz, co znajduje się już w poczekalni, a co za chwilę zostanie zatwierdzone? Choć <code>git status</code> bardzo ogólnie odpowiada na oba te pytania, <code>git diff</code> pokazuje, które dokładnie linie zostały dodane, a które usunięte — w postaci łatki.</p>
</div>
<div class="paragraph">
<p>Powiedzmy, że zmieniłeś i ponownie dodałeś do poczekalni plik README, a następnie zmodyfikowałeś plik <code>CONTRIBUTING.md</code>, jednak bez umieszczania go wśród oczekujących. Jeśli uruchomisz teraz polecenie <code>status</code>, zobaczysz coś podobnego:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    new file:   README

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aby zobaczyć, co zmieniłeś ale nie wysłałeś do poczekalni, wpisz <code>git diff</code> bez żadnych argumentów:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if you patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's</code></pre>
</div>
</div>
<div class="paragraph">
<p>Powyższe polecenie porównuje zawartość katalogu roboczego z tym, co znajduje się w poczekalni. Wynik pokaże ci te zmiany, które nie trafiły jeszcze do poczekalni.</p>
</div>
<div class="paragraph">
<p>Jeśli chcesz zobaczyć zawartość poczekalni, która trafi do repozytorium z najbliższym zatwierdzeniem, możesz użyć polecenia <code>git diff --staged</code>. To polecenie porówna zmiany z poczekalni z ostatnią zmianą:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+My Project</code></pre>
</div>
</div>
<div class="paragraph">
<p>Istotnym jest, że samo polecenie <code>git diff</code> nie pokazuje wszystkich zmian dokonanych od ostatniego zatwierdzenia — ­jedynie te, które nie trafiły do poczekalni. Może być to nieco mylące, ponieważ jeżeli wszystkie twoje zmiany są już w poczekalni, wynik <code>git diff</code> będzie pusty.</p>
</div>
<div class="paragraph">
<p>Jeszcze jeden przykład — jeżeli wyślesz do poczekalni plik <code>CONTRIBUTING.md</code>, a następnie zmodyfikujesz go ponownie, możesz użyć <code>git status</code>, by obejrzeć zmiany znajdujące się w poczekalni, jak i te poza nią:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git add CONTRIBUTING.md
$ echo 'test line' &gt;&gt; CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>Teraz możesz użyć <code>git diff</code>, by zobaczyć zmiany spoza poczekalni</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 643e24f..87f08c8 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -119,3 +119,4 @@ at the
 ## Starter Projects

 See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).
+# test line</code></pre>
</div>
</div>
<div class="paragraph">
<p>oraz <code>git diff --cached</code>, aby zobaczyć zmiany wysłane do poczekalni(--staged i --cached działają identycznie):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git diff --cached
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if you patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Uwaga</div>
</td>
<td class="content">
<div class="title">Git Diff jako narzędzie zewnętrzne</div>
<div class="paragraph">
<p>Będziemy kontynuować używanie polecenia <code>git diff</code> na wiele sposobów w dalszej części książki. Jest jeszcze inny sposób aby przyjrzeć się tym zmianom jeżeli preferujesz graficzny lub zewnętrzny program do porównywania. Jeśli wykonasz <code>git difftool</code> zamiast <code>git diff</code> możesz zobaczyć te różnice w programach takich jak Araxis, emerge, vimdiff i wielu innych. Uruchom <code>git difftool --tool-help</code> aby zobaczyć, które z nich są dostępne w twoim systemie.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h3 id="_committing_changes">Zatwierdzanie zmian</h3>
<div class="paragraph">
<p>Teraz, kiedy twoja poczekalnia zawiera dokładnie to, co powinna, możesz zatwierdzić swoje zmiany. Pamiętaj, że wszystko czego nie ma jeszcze w poczekalni — każdy plik, który utworzyłeś lub zmodyfikowałeś, a na którym później nie uruchomiłeś polecenia <code>git add</code> — nie zostanie uwzględnione wśród zatwierdzanych zmian. Pozostanie wyłącznie w postaci zmodyfikowanych plików na twoim dysku.</p>
</div>
<div class="paragraph">
<p>W tym wypadku, kiedy ostatnio uruchamiałeś <code>git status</code>, zobaczyłeś, że wszystkie twoje zmiany są już w poczekalni, więc jesteś gotowy do ich zatwierdzenia. Najprostszy sposób zatwierdzenia zmian to wpisanie <code>git commit</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Zostanie uruchomiony wybrany przez ciebie edytor tekstu. (Wybiera się go za pośrednictwem zmiennej środowiskową <code>$EDITOR</code> — zazwyczaj jest to vim lub emacs, możesz jednak wybrać własną aplikację używając polecenia <code>git config --global core.editor</code>, które poznałeś w Rozdziale 1.).</p>
</div>
<div class="paragraph">
<p>Edytor zostanie otwarty z następującym tekstem (poniższy przykład pokazuje ekran Vima):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code># Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#	new file:   README
#	modified:   CONTRIBUTING.md
#
~
~
~
".git/COMMIT_EDITMSG" 9L, 283C</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jak widzisz, domyślny opis zmian zawiera aktualny wynik polecenia <code>git status</code> w postaci komentarza oraz jedną pustą linię na samej górze. Możesz usunąć komentarze i wpisać własny opis, lub pozostawić je, co pomoże zapamiętać zakres zatwierdzonych zmian. (Aby uzyskać jeszcze precyzyjniejsze przypomnienie, możesz przekazać do <code>git commit</code> parametr <code>-v</code>. Jeśli to zrobisz, do komentarza trafią również poszczególne zmodyfikowane wiersze, pokazując, co dokładnie zrobiłeś.). Po opuszczeniu edytora, Git stworzy nową migawkę opatrzoną twoim opisem zmian (uprzednio usuwając z niego komentarze i podsumowanie zmian).</p>
</div>
<div class="paragraph">
<p>Alternatywnie opis rewizji możesz podać już wydając polecenie <code>commit</code>, poprzedzając go flagą <code>-m</code>, jak poniżej:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git commit -m "Story 182: Fix benchmarks for speed"
[master 463dc4f] Story 182: Fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README</code></pre>
</div>
</div>
<div class="paragraph">
<p>Właśnie zatwierdziłeś swoje pierwsze zmiany! Sama operacja rewizji zwróciła dodatkowo garść informacji, między innymi, gałąź do której dorzuciłeś zmiany (master), ich sumę kontrolną SHA-1 (<code>463dc4f</code>), ilość zmienionych plików oraz statystyki dodanych i usuniętych linii kodu.</p>
</div>
<div class="paragraph">
<p>Pamiętaj, że operacja commit zapamiętała migawkę zmian z poczekalni. Wszystko czego nie dodałeś do poczekalni, ciągle czeka zmienione w swoim miejscu - możesz to uwzględnić przy następnym zatwierdzaniu zmian. Każdorazowe wywołanie polecenia <code>git commit</code> powoduje zapamiętanie migawki projektu, którą możesz następnie odtworzyć albo porównać do innej migawki.</p>
</div>
</div>
<div class="sect3">
<h3 id="_pomijanie_poczekalni">Pomijanie poczekalni</h3>
<div class="paragraph">
<p>Chociaż poczekalnia może być niesamowicie przydatna przy ustalaniu rewizji dokładnie takich, jakimi chcesz je mieć później w historii, czasami możesz uznać ją za odrobinę zbyt skomplikowaną aniżeli wymaga tego twoja praca. Jeśli chcesz pominąć poczekalnię, Git udostępnia prosty skrót. Po dodaniu do składni polecenia <code>git commit</code> opcji <code>-a</code> każdy zmieniony plik, który jest już śledzony, automatycznie trafi do poczekalni, dzięki czemu pominiesz część <code>git add</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git status
On branch master
Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

no changes added to commit (use "git add" and/or "git commit -a")
$ git commit -a -m 'added new benchmarks'
[master 83e38c7] added new benchmarks
 1 file changed, 5 insertions(+), 0 deletions(-)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Zauważ, że w tym wypadku przed zatwierdzeniem zmian i wykonaniem rewizji nie musiałeś uruchamiać <code>git add</code> na pliku CONTRIBUTING.md.</p>
</div>
</div>
<div class="sect3">
<h3 id="_removing_files">Usuwanie plików</h3>
<div class="paragraph">
<p>
Aby usunąć plik z Gita, należy go najpierw wyrzucić ze zbioru plików śledzonych, a następnie zatwierdzić zmiany. Służy do tego polecenie <code>git rm</code>, które dodatkowo usuwa plik z katalogu roboczego. Nie zobaczysz go już zatem w sekcji plików nieśledzonych przy następnej okazji.</p>
</div>
<div class="paragraph">
<p>Jeżeli po prostu usuniesz plik z katalogu roboczego i wykonasz polecenie <code>git status</code> zobaczysz go w sekcji "Zmienione ale nie zaktualizowane" (Changes not staged for commit) (czyli, poza poczekalnią):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add/rm &lt;file&gt;..." to update what will be committed)
  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)

        deleted:    PROJECTS.md

no changes added to commit (use "git add" and/or "git commit -a")</code></pre>
</div>
</div>
<div class="paragraph">
<p>W dalszej kolejności, uruchomienie <code>git rm</code> doda do poczekalni operację usunięcia pliku:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rm PROJECTS.md
rm 'PROJECTS.md'
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    deleted:    PROJECTS.md</code></pre>
</div>
</div>
<div class="paragraph">
<p>Przy kolejnej rewizji, plik zniknie i nie będzie dłużej śledzony. Jeśli zmodyfikowałeś go wcześniej i dodałeś już do indeksu oczekujących zmian, musisz wymusić usunięcie opcją <code>-f</code>. Spowodowane jest to wymogami bezpieczeństwa, aby uchronić cię przed usunięciem danych, które nie zostały jeszcze zapamiętane w żadnej migawce i które później nie będą mogły być odtworzone z repozytorium Gita.</p>
</div>
<div class="paragraph">
<p>Kolejną przydatną funkcją jest możliwość zachowywania plików w drzewie roboczym ale usuwania ich z poczekalni. Innymi słowy, możesz chcieć trzymać plik na dysku ale nie chcieć, żeby Git go dalej śledził. Jest to szczególnie przydatne w sytuacji kiedy zapomniałeś dodać czegoś do <code>.gitignore</code> i przez przypadek umieściłeś w poczekalni np. duży plik dziennika lub garść plików <code>.a</code>. Wystarczy wówczas wywołać polecenie rm wraz opcją <code>--cached</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rm --cached README</code></pre>
</div>
</div>
<div class="paragraph">
<p>Do polecenia <code>git -rm</code> możesz przekazywać pliki, katalogi lub wyrażenia glob - możesz na przykład napisać coś takiego:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rm log/\*.log</code></pre>
</div>
</div>
<div class="paragraph">
<p>Zwróć uwagę na odwrotny ukośnik (<code>\</code>) na początku <code>*</code>. Jest on niezbędny gdyż Git dodatkowo do tego co robi powłoka, sam ewaluuje sobie nazwy plików. Przywołane polecenie usuwa wszystkie pliki z rozszerzeniem <code>.log</code>, znajdujące się w katalogu <code>log/</code>. Możesz także wywołać następujące polecenie:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rm \*~</code></pre>
</div>
</div>
<div class="paragraph">
<p>Usuwa ona wszystkie pliki, które kończą się tyldą <code>~</code>.</p>
</div>
</div>
<div class="sect3">
<h3 id="_git_mv">Zmiana nazw plików</h3>
<div class="paragraph">
<p>W odróżnieniu do wielu innych systemów kontroli wersji, Git nie śledzi bezpośrednio przesunięć plików. Nie przechowuje on żadnych metadanych, które mogłyby mu pomóc w rozpoznawaniu operacji zmiany nazwy śledzonych plików. Jednakże, Git jest całkiem sprytny jeżeli chodzi o rozpoznawanie tego po fakcie - zajmiemy się tym tematem odrobinę dalej.</p>
</div>
<div class="paragraph">
<p>Nieco mylący jest fakt, że Git posiada polecenie <code>mv</code>. Służy ono do zmiany nazwy pliku w repozytorium, np.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git mv file_from file_to</code></pre>
</div>
</div>
<div class="paragraph">
<p>W rzeczywistości, uruchomienie takiego polecenia spowoduje, że Git zapamięta w poczekalni operację zmiany nazwy - możesz to sprawdzić wyświetlając wynik operacji status:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git mv README.md README
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD &lt;file&gt;..." to unstage)

    renamed:    README.md -&gt; README</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jest to równoważne z uruchomieniem poleceń:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ mv README.md README
$ git rm README.md
$ git add README</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git rozpozna w tym przypadku, że jest to operacja zmiany nazwy - nie ma zatem znaczenia, czy zmienisz ją w ten czy opisany wcześniej (<code>mv</code>) sposób. Jedyna realna różnica polega na tym, że <code>mv</code> to jedno polecenie zamiast trzech - kwestia wygody. Co ważniejsze, samą nazwę możesz zmienić dowolnym narzędziem a resztą zajmą się już polecenia add i rm których musisz użyć przed zatwierdzeniem zmian.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>