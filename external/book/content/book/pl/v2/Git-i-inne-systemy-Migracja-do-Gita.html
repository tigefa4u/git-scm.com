---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: pl
  chapter:
    title: Git i inne systemy
    number: 9
  section:
    title: Migracja do Gita
    number: 2
    cs_number: '9.2'
    previous: book/pl/v2/Git-i-inne-systemy-Git-jako-klient
    next: book/pl/v2/Git-i-inne-systemy-Podsumowanie
title: Git - Migracja do Gita
---
<h2 id="_migrating">Migracja do Gita</h2>
<div class="paragraph">
<p>
Jeżeli masz obecny kod projektu w innym systemie kontroli wersji, ale zdecydowałeś się na używanie Gita, musisz w jakiś sposób go zmigrować.
Ta sekcja przedstawia kilka importerów, które są dostarczane razem z Gitem dla najczęściej używanych systemów, a w dalszej części pokazuje jak stworzyć swój własny importer.
Dowiesz się, jak importować dane z kilku największych, profesjonalnie używanych systemów kontroli wersji, ponieważ stanowią one źródło większości użytkowników, którzy zmieniają system, a także dlatego, że Git posiada dla nich dopracowane narzędzia.</p>
</div>
<div class="sect3">
<h3 id="_subversion">Subversion</h3>
<div class="paragraph">
<p>

Jeżeli przeczytałeś poprzednią sekcję na temat używania <code>git svn</code>, możesz z łatwością użyć tamtych instrukcji aby sklonować za pomocą <code>git svn clone</code> repozytorium; następnie, przestań używać serwera Subversion, wypchaj zmiany do serwera Git i zacznij tylko na nim współpracować.
Jeżeli potrzebujesz historii projektu, będziesz mógł to osiągnąć tak szybko, jak tylko możesz ściągnąć dana z serwera Subversion (co może chwilę zająć).</p>
</div>
<div class="paragraph">
<p>Niemniej, importowanie nie jest idealnym rozwiązaniem; a dlatego że zajmie to dużo czasu, powinieneś zrobić to raz a dobrze.
Pierwszym problemem są informacje o autorze.
W Subversion, każda osoba wgrywająca zmiany posiada konto systemowe na serwerze który zapisuje zmiany.
Przykłady w poprzedniej sekcji, pokazują użytkownika <code>schacon</code> w kilku miejscach, takich jak wynik komendy <code>blame</code> czy <code>git svn log</code>.
Jeżeli chciałbyś zamienić je na dane zgodne z Gitem, musisz stworzyć mapowania z użytkownika Subversion na autora w Git.
Stwórz plik <code>users.txt</code>, który ma przypisane adresy w ten sposób:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>schacon = Scott Chacon &lt;schacon@geemail.com&gt;
selse = Someo Nelse &lt;selse@geemail.com&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aby otrzymać listę autorów używanych przez SVN, uruchom komendę:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ svn log --xml | grep author | sort -u | \
  perl -pe 's/.*&gt;(.*?)&lt;.*/$1 = /'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Generuje to wyjście dziennika w formacie XML, następnie zachowuje tylko linie z informacjami o autorze, odrzuca duplikaty i usuwa znaczniki XML.
(Oczywiście działa to tylko na maszynie z zainstalowanymi programami <code>grep</code>, <code>sort</code> i <code>perl</code>).
Następnie przekieruj wynik komendy do pliku users.txt, tak abyś mógł dodać odpowiednik użytkownika w Gitcie dla każdego wpisu.</p>
</div>
<div class="paragraph">
<p>Możesz przekazać ten plik do komendy <code>git svn</code>, aby pomóc jej lepiej zmapować dane przypisane do autorów.
Możesz również wskazać <code>git svn</code>, aby nie zaciągał meta-danych, które normalnie Subversion importuje, poprzez dodanie opcji <code>--no-metadata</code> do komend <code>clone</code> lub <code>init</code>.
Twoja komenda <code>import</code> wygląda więc tak:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git svn clone http://my-project.googlecode.com/svn/ \
      --authors-file=users.txt --no-metadata -s my_project</code></pre>
</div>
</div>
<div class="paragraph">
<p>Teraz powinieneś mieć lepiej wyglądający projekt z Subversion w swoim katalogu <code>my_project</code>.
Zamiast commitów, które wyglądają tak te:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>commit 37efa680e8473b615de980fa935944215428a35a
Author: schacon &lt;schacon@4c93b258-373f-11de-be05-5f7a86268029&gt;
Date:   Sun May 3 00:12:22 2009 +0000

    fixed install - go to trunk

    git-svn-id: https://my-project.googlecode.com/svn/trunk@94 4c93b258-373f-11de-
    be05-5f7a86268029</code></pre>
</div>
</div>
<div class="paragraph">
<p>masz takie:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>commit 03a8785f44c8ea5cdb0e8834b7c8e6c469be2ff2
Author: Scott Chacon &lt;schacon@geemail.com&gt;
Date:   Sun May 3 00:12:22 2009 +0000

    fixed install - go to trunk</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nie tylko dane dotyczące autora ("Author") wyglądają lepiej, ale nie ma również znaczników <code>git-svn-id</code>.</p>
</div>
<div class="paragraph">
<p>Musisz jeszcze trochę posprzątać po imporcie.
Na początek, powinieneś poprawić dziwne referencje które ustawił <code>git svn</code>.
Najpierw przeniesiesz tagi, tak aby były normalnymi tagami, zamiast dziwnych zdalnych gałęzi, następnie przeniesiesz resztę gałęzi tak aby były lokalne.</p>
</div>
<div class="paragraph">
<p>Aby przenieść etykiety i zrobić z nich prawidłowe tagi Gita, uruchom:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cp -Rf .git/refs/remotes/origin/tags/* .git/refs/tags/
$ rm -Rf .git/refs/remotes/origin/tags</code></pre>
</div>
</div>
<div class="paragraph">
<p>Pobierze to referencje które były zdalnymi gałęziami rozpoczynającymi się od <code>remotes/origin/tags/</code> i zrobi z nich normalne (lekkie) etykiety.</p>
</div>
<div class="paragraph">
<p>Następnie, przenieś resztę referencji z <code>refs/remotes</code>, tak aby stały się lokalnymi gałęziami:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cp -Rf .git/refs/remotes/* .git/refs/heads/
$ rm -Rf .git/refs/remotes</code></pre>
</div>
</div>
<div class="paragraph">
<p>Teraz wszystkie stare gałęzie są prawdziwymi gałęziami Gita, a stare tagi prawdziwymi tagami w Git.
Ostatnią rzeczą do zrobienia jest dodanie nowego serwera Git jako zdalnego i wypchnięcie danych do niego.
Poniżej znajduje się przykład dodania Twojego serwera jako zdalnego:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add origin git@my-git-server:myrepository.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ponieważ chcesz aby wszystkie gałęzie i etykiety były na repozytorium, możesz uruchomić:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git push origin --all</code></pre>
</div>
</div>
<div class="paragraph">
<p>Wszystkie gałęzie i tagi powinny być już na Twoim serwerze Gita, zaimportowane w czysty i zgrabny sposób.</p>
</div>
</div>
<div class="sect3">
<h3 id="_mercurial">Mercurial</h3>
<div class="paragraph">
<p>
Since Mercurial and Git have fairly similar models for representing versions, and since Git is a bit more flexible, converting a repository from Mercurial to Git is fairly straightforward, using a tool called "hg-fast-export", which you’ll need a copy of:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone http://repo.or.cz/r/fast-export.git /tmp/fast-export</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first step in the conversion is to get a full clone of the Mercurial repository you want to convert:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ hg clone &lt;remote repo URL&gt; /tmp/hg-repo</code></pre>
</div>
</div>
<div class="paragraph">
<p>The next step is to create an author mapping file.
Mercurial is a bit more forgiving than Git for what it will put in the author field for changesets, so this is a good time to clean house.
Generating this is a one-line command in a <code>bash</code> shell:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cd /tmp/hg-repo
$ hg log | grep user: | sort | uniq | sed 's/user: *//' &gt; ../authors</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will take a few seconds, depending on how long your project’s history is, and afterwards the <code>/tmp/authors</code> file will look something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>bob
bob@localhost
bob &lt;bob@company.com&gt;
bob jones &lt;bob &lt;AT&gt; company &lt;DOT&gt; com&gt;
Bob Jones &lt;bob@company.com&gt;
Joe Smith &lt;joe@company.com&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, the same person (Bob) has created changesets under four different names, one of which actually looks correct, and one of which would be completely invalid for a Git commit.
Hg-fast-export lets us fix this by adding <code>={new name and email address}</code> at the end of every line we want to change, and removing the lines for any usernames that we want to leave alone.
If all the usernames look fine, we won’t need this file at all.
In this example, we want our file to look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>bob=Bob Jones &lt;bob@company.com&gt;
bob@localhost=Bob Jones &lt;bob@company.com&gt;
bob jones &lt;bob &lt;AT&gt; company &lt;DOT&gt; com&gt;=Bob Jones &lt;bob@company.com&gt;
bob &lt;bob@company.com&gt;=Bob Jones &lt;bob@company.com&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The next step is to create our new Git repository, and run the export script:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git init /tmp/converted
$ cd /tmp/converted
$ /tmp/fast-export/hg-fast-export.sh -r /tmp/hg-repo -A /tmp/authors</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>-r</code> flag tells hg-fast-export where to find the Mercurial repository we want to convert, and the <code>-A</code> flag tells it where to find the author-mapping file.
The script parses Mercurial changesets and converts them into a script for Git’s "fast-import" feature (which we’ll discuss in detail a bit later on).
This takes a bit (though it’s <em>much</em> faster than it would be over the network), and the output is fairly verbose:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ /tmp/fast-export/hg-fast-export.sh -r /tmp/hg-repo -A /tmp/authors
Loaded 4 authors
master: Exporting full revision 1/22208 with 13/0/0 added/changed/removed files
master: Exporting simple delta revision 2/22208 with 1/1/0 added/changed/removed files
master: Exporting simple delta revision 3/22208 with 0/1/0 added/changed/removed files
[…]
master: Exporting simple delta revision 22206/22208 with 0/4/0 added/changed/removed files
master: Exporting simple delta revision 22207/22208 with 0/2/0 added/changed/removed files
master: Exporting thorough delta revision 22208/22208 with 3/213/0 added/changed/removed files
Exporting tag [0.4c] at [hg r9] [git :10]
Exporting tag [0.4d] at [hg r16] [git :17]
[…]
Exporting tag [3.1-rc] at [hg r21926] [git :21927]
Exporting tag [3.1] at [hg r21973] [git :21974]
Issued 22315 commands
git-fast-import statistics:
---------------------------------------------------------------------
Alloc'd objects:     120000
Total objects:       115032 (    208171 duplicates                  )
      blobs  :        40504 (    205320 duplicates      26117 deltas of      39602 attempts)
      trees  :        52320 (      2851 duplicates      47467 deltas of      47599 attempts)
      commits:        22208 (         0 duplicates          0 deltas of          0 attempts)
      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)
Total branches:         109 (         2 loads     )
      marks:        1048576 (     22208 unique    )
      atoms:           1952
Memory total:          7860 KiB
       pools:          2235 KiB
     objects:          5625 KiB
---------------------------------------------------------------------
pack_report: getpagesize()            =       4096
pack_report: core.packedGitWindowSize = 1073741824
pack_report: core.packedGitLimit      = 8589934592
pack_report: pack_used_ctr            =      90430
pack_report: pack_mmap_calls          =      46771
pack_report: pack_open_windows        =          1 /          1
pack_report: pack_mapped              =  340852700 /  340852700
---------------------------------------------------------------------

$ git shortlog -sn
   369  Bob Jones
   365  Joe Smith</code></pre>
</div>
</div>
<div class="paragraph">
<p>That’s pretty much all there is to it.
All of the Mercurial tags have been converted to Git tags, and Mercurial branches and bookmarks have been converted to Git branches.
Now you’re ready to push the repository up to its new server-side home:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add origin git@my-git-server:myrepository.git
$ git push origin --all</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_perforce_import">Perforce</h3>
<div class="paragraph">
<p>
Następnym systemem, któremu się przyjrzymy z perspektywy importu, jest Perforce.
Jak wspomnieliśmy powyżej, istnieją dwa sposoby, aby Git i Perforce mogły ze sobą rozmawiać: git-p4 oraz Perforce Git Fusion.</p>
</div>
<div class="sect4">
<h4 id="_perforce_git_fusion">Perforce Git Fusion</h4>
<div class="paragraph">
<p>Git Fusion czyni ten proces dość bezbolesnym.
Wystarczy za pomocą pliku konfiguracyjnego skonfigurować ustawienia projektu, mapowania użytkowników i gałęzie (tak jak omówiono w <a href="{{< relurl "book/pl/v2/ch00/_p4_git_fusion" >}}">Git Fusion</a>), a następnie sklonować repozytorium.
Git Fusion w wyniku daje Ci coś, co wygląda jak natywne repozytorium Git, które jest gotowe do wysłania do natywnego hosta Git.
Możesz nawet użyć Perforce jako swojego hosta Git.</p>
</div>
</div>
<div class="sect4">
<h4 id="_git_p4">Git-p4</h4>
<div class="paragraph">
<p>Git-p4 może również działać jako narzędzie do importowania.
Jako przykład, zaimportujemy projekt Jam z Perforce Public Depot.
Aby skonfigurować swojego klienta, musisz wyeksportować zmienną środowiskową P4PORT, aby wskazywała na magazyn Perforce:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ export P4PORT=public.perforce.com:1666</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Aby móc kontynuować, będziesz potrzebował magazynu Perforce, z którym będziesz mógł się połączyć.
Do naszych przykładów użyjemy publicznego magazynu pod adresem public.perforce.com, ale możesz użyć dowolnego magazynu, do którego masz dostęp.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>
Uruchom komendę <code>git-p4 clone</code>, aby zaimportować projekt Jam z serwera Perforce wskazując magazyn i ścieżkę projektu, oraz katalog do którego chcesz go zaimportować:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git-p4 clone //guest/perforce_software/jam@all p4import
Importing from //guest/perforce_software/jam@all into p4import
Initialized empty Git repository in /private/tmp/p4import/.git/
Import destination: refs/remotes/p4/master
Importing revision 9957 (100%)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ten konkretny projekt ma tylko jedną gałąź, ale jeśli masz gałęzie, które są skonfigurowane z widokami gałęzi (lub po prostu zestawem katalogów), możesz użyć flagi <code>--detect-branches</code> do <code>git p4 clone</code> aby zaimportować wszystkie gałęzie projektu.
Zajrzyj do <a href="{{< relurl "book/pl/v2/ch00/_git_p4_branches" >}}">Branching</a> aby uzyskać więcej szczegółów na ten temat.</p>
</div>
<div class="paragraph">
<p>W tym momencie prawie zakończyłeś już pracę.
Jeśli przejdziesz do katalogu <code>p4import</code> i uruchomisz <code>git log</code>, możesz zobaczyć zaimportowane dane:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -2
commit e5da1c909e5db3036475419f6379f2c73710c4e6
Author: giles &lt;giles@giles@perforce.com&gt;
Date:   Wed Feb 8 03:13:27 2012 -0800

    Correction to line 355; change &lt;/UL&gt; to &lt;/OL&gt;.

    [git-p4: depot-paths = "//public/jam/src/": change = 8068]

commit aa21359a0a135dda85c50a7f7cf249e4f7b8fd98
Author: kwirth &lt;kwirth@perforce.com&gt;
Date:   Tue Jul 7 01:35:51 2009 -0800

    Fix spelling error on Jam doc page (cummulative -&gt; cumulative).

    [git-p4: depot-paths = "//public/jam/src/": change = 7304]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Możesz zauważyć, że każdy commit posiada identyfikator <code>git-p4</code>.
Może on zostać, w razie gdybyś potrzebował dotrzeć do informacji o numerze zmiany zapisanym w Perforce.
Jednak, gdybyś chciał usunąć ten identyfikator, teraz jest dobry moment aby to zrobić – przed wprowadzeniem jakichkolwiek zmian w nowym repozytorium.

Możesz użyć <code>git filter-branch</code> aby usunąć wszystkie identyfikatory:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git filter-branch --msg-filter 'sed -e "/^\[git-p4:/d"'
Rewrite e5da1c909e5db3036475419f6379f2c73710c4e6 (125/125)
Ref 'refs/heads/master' was rewritten</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jeżeli uruchomisz <code>git log</code>, zobaczysz że wszystkie sumy SHA-1 dla commitów zostały zmienione i nie ma już identyfikatorów pozostawionych przez <code>git-p4</code> w treściach komentarzy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -2
commit b17341801ed838d97f7800a54a6f9b95750839b7
Author: giles &lt;giles@giles@perforce.com&gt;
Date:   Wed Feb 8 03:13:27 2012 -0800

    Correction to line 355; change &lt;/UL&gt; to &lt;/OL&gt;.

commit 3e68c2e26cd89cb983eb52c024ecdfba1d6b3fff
Author: kwirth &lt;kwirth@perforce.com&gt;
Date:   Tue Jul 7 01:35:51 2009 -0800

    Fix spelling error on Jam doc page (cummulative -&gt; cumulative).</code></pre>
</div>
</div>
<div class="paragraph">
<p>Twój kod jest teraz gotowy do wypchnięcia na nowy serwer Gita.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_git_tfs">TFS</h3>
<div class="paragraph">
<p>
If your team is converting their source control from TFVC to Git, you’ll want the highest-fidelity conversion you can get.
This means that, while we covered both git-tfs and git-tf for the interop section, we’ll only be covering git-tfs for this part, because git-tfs supports branches, and this is prohibitively difficult using git-tf.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>This is a one-way conversion.
The resulting Git repository won’t be able to connect with the original TFVC project.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The first thing to do is map usernames.
TFVC is fairly liberal with what goes into the author field for changesets, but Git wants a human-readable name and email address.
You can get this information from the <code>tf</code> command-line client, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-powershell" data-lang="powershell">PS&gt; tf history $/myproject -recursive &gt; AUTHORS_TMP</code></pre>
</div>
</div>
<div class="paragraph">
<p>This grabs all of the changesets in the history of the project and put it in the AUTHORS_TMP file that we will process to extract the data of the <em>User</em> column (the 2nd one).
Open the file and find at which characters start and end the column and replace, in the following command-line, the parameters <code>11-20</code> of the <code>cut</code> command with the ones found:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-powershell" data-lang="powershell">PS&gt; cat AUTHORS_TMP | cut -b 11-20 | tail -n+3 | uniq | sort &gt; AUTHORS</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>cut</code> command keeps only the characters between 11 and 20 from each line.
The <code>tail</code> command skips the first two lines, which are field headers and ASCII-art underlines.
The result of all of this is piped to <code>uniq</code> to eliminate duplicates, and saved to a file named <code>AUTHORS</code>.
The next step is manual; in order for git-tfs to make effective use of this file, each line must be in this format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">DOMAIN\username = User Name &lt;email@address.com&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The portion on the left is the “User” field from TFVC, and the portion on the right side of the equals sign is the user name that will be used for Git commits.</p>
</div>
<div class="paragraph">
<p>Once you have this file, the next thing to do is make a full clone of the TFVC project you’re interested in:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-powershell" data-lang="powershell">PS&gt; git tfs clone --with-branches --authors=AUTHORS https://username.visualstudio.com/DefaultCollection $/project/Trunk project_git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next you’ll want to clean the <code>git-tfs-id</code> sections from the bottom of the commit messages.
The following command will do that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-powershell" data-lang="powershell">PS&gt; git filter-branch -f --msg-filter 'sed "s/^git-tfs-id:.*$//g"' -- --all</code></pre>
</div>
</div>
<div class="paragraph">
<p>That uses the <code>sed</code> command from the Git-bash environment to replace any line starting with “git-tfs-id:” with emptiness, which Git will then ignore.</p>
</div>
<div class="paragraph">
<p>Once that’s all done, you’re ready to add a new remote, push all your branches up, and have your team start working from Git.</p>
</div>
</div>
<div class="sect3">
<h3 id="_custom_importer">Własny skrypt importujący</h3>
<div class="paragraph">
<p>

Jeżeli Twój system kontroli wersji to nie jest żadnym ze wspomnianych wcześniej, powinieneś spojrzeć na importery dostępne w sieci – dobrej jakości importery dostępne są dla CVS, Clear Case, Visual Source Safe, a nawet zwykłego katalogu z archiwami.
Jeżeli żadne z tych narzędzi nie zadziała, lub używasz mniej popularnego systemu, lub jeżeli potrzebujesz bardziej dostosowanego importu, powinieneś użyć <code>git fast-import</code>.
Ta komenda odczytuje instrukcje przekazane na standardowe wejście programu i zapisuje dane w Git.
Dużo łatwiej w ten sposób tworzyć obiekty Gita, niż uruchamiać jego niskopoziomowe komendy czy zapisywać surowe obiekty (por. <a href="{{< relurl "book/pl/v2/ch00/_git_internals" >}}">Mechanizmy wewnętrzne w Git</a>).
W ten sposób możesz napisać skrypt importujący, który odczyta wszystkie potrzebne informacje z systemu z którego importujesz i wypisze instrukcje do wykonania na standardowe wyjście.
Możesz następnie uruchomić ten program i przekazać wynik do <code>git fast-import</code>.</p>
</div>
<div class="paragraph">
<p>W celach demonstracyjnych, napiszesz prosty skrypt importujący.
Załóżmy, że pracujesz na najnowszej kopii kodu źródłowego i wykonujesz czasami kopie zapasowe poprzez skopiowanie danych do katalogu z datą w formacie <code>back_YYYY_MM_DD</code> i chciałbyś je zaimportować do Gita.
Twoja struktura katalogów wygląda następująco:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ls /opt/import_from
back_2014_01_02
back_2014_01_04
back_2014_01_14
back_2014_02_03
current</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aby zaimportować katalog do Gita, musisz przypomnieć sobie w jaki sposób Git przechowuje dane.
Być może pamiętasz, Git z założenia jest zbiorem połączonych obiektów dotyczących commitów, które wskazują na ostatnią migawkę z zawartością.
Wszystko co musisz zrobić, to wskazać <code>fast-import</code> jaka jest zawartość migawek, który commit na nie wskazuje, oraz kolejność w której występują.
Twoją strategią będzie przejście kolejno przez wszystkie migawki, oraz stworzenie commitów z zawartością dla każdego z nich, łącząc każdy commit z poprzednim.</p>
</div>
<div class="paragraph">
<p>ak robiłeś już to w sekcji <a href="{{< relurl "book/pl/v2/ch00/_an_example_git_enforced_policy" >}}">An Example Git-Enforced Policy</a>, również napiszemy to w Ruby, ponieważ to na nim zazwyczaj pracuję, a jego kod jest dość czytelny.
Możesz stworzyć ten przykład bardzo szybko, w praktycznie każdym innym języku który dobrze znasz – musi on wypisać na standardowe wyjście właściwe informacje.
A jeżeli pracujesz na systemie Windows, będziesz musiał zwrócić szczególną uwagę, aby nie wprowadzić znaków powrotu karetki na końcach linii – <code>git fast-import</code> potrzebuje linie zakończone znakami nowej linii (LF), a nie powrotem karetki (CRLF), których używa Windows.</p>
</div>
<div class="paragraph">
<p>Aby rozpocząć, przejdziesz do docelowego katalogu i znajdziesz wszystkie podkatalogi, z których znajdują się migawki które chcesz zaimportować.
Następnie wejdziesz do każdego podkatalogu i wypiszesz komendy konieczne do eksportu.
Twoja pętla główna w programie wygląda tak:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">last_mark = nil

# loop through the directories
Dir.chdir(ARGV[0]) do
  Dir.glob("*").each do |dir|
    next if File.file?(dir)

    # move into the target directory
    Dir.chdir(dir) do
      last_mark = print_export(dir, last_mark)
    end
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Uruchamiasz <code>print_export</code> w każdym katalogu, która przyjmuje jako parametry nazwę katalogu oraz znacznik poprzedniej migawki, a zwraca znacznik obecnej; w ten sposób możesz połączyć je poprawnie ze sobą.
"Mark" jest terminem używanym przez <code>fast-import</code>, dla identyfikatora który przypisujesz do commita; podczas tworzenia kolejnych commitów, nadajesz każdemu z nich znacznik, który będzie użyty do połączenia go z innymi commitami.
Dlatego pierwszą rzeczą którą robisz w metodzie <code>print_export</code> jest wygenerowanie znacznika pobranego z nazwy katalogu:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">mark = convert_dir_to_mark(dir)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Zrobisz to poprzez wygenerowanie tablicy z nazwami katalogów, która używa jako indeksu znacznika będącego liczbą całkowitą.
Twoja metoda wygląda więc tak:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">$marks = []
def convert_dir_to_mark(dir)
  if !$marks.include?(dir)
    $marks &lt;&lt; dir
  end
  ($marks.index(dir) + 1).to_s
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Teraz, gdy masz już liczbę reprezentującą Twój commit, potrzebujesz daty do zamieszczenia w meta-danych commita.
Ponieważ data jest użyta w nazwie katalogu, pobierzesz ją z nazwy.
Następną linią w pliku <code>print_export</code> jest:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">date = convert_dir_to_date(dir)</code></pre>
</div>
</div>
<div class="paragraph">
<p>gdzie <code>convert_dir_to_date</code> jest zdefiniowane jako:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">def convert_dir_to_date(dir)
  if dir == 'current'
    return Time.now().to_i
  else
    dir = dir.gsub('back_', '')
    (year, month, day) = dir.split('_')
    return Time.local(year, month, day).to_i
  end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Zwraca to liczbę całkowitą dla daty z katalogu.
Ostatnią rzeczą potrzebną do zapisania meta-danych są informacje o osobie wprowadzającej zmiany, którą zapisujesz na stałe w zmiennej globalnej:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">$author = 'John Doe &lt;john@example.com&gt;'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Teraz możesz rozpocząć wypisywanie danych dotyczących commitów dla swojego programu importującego.
Początkowe informacje wskazują, że definiujesz nowy obiekt commit, oraz nazwę gałęzi do której będzie on przypisany, następnie podajesz znaczki który wygenerowałeś, informacje o osobie wprowadzającej zmiany oraz treść komentarza do zmiany, a na końcu poprzedni znacznik commita.
Kod wygląda tak:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby"># print the import information
puts 'commit refs/heads/master'
puts 'mark :' + mark
puts "committer #{$author} #{date} -0700"
export_data('imported from ' + dir)
puts 'from :' + last_mark if last_mark</code></pre>
</div>
</div>
<div class="paragraph">
<p>Wpisujesz na sztywno strefę czasową (-0700), ponieważ jest to najprostsze podejście.
Jeżeli importujesz z innego systemu, musisz wskazać strefę czasową jako przesunięcie (ang. <em>offset</em>).
Treść komentarza do zmiany musi być wyrażona w specjalnym formacie:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>data (size)\n(contents)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Format składa się z słowa kluczowego data, długości danych do wczytania, znaku nowej linii, oraz na końcu samych danych.
Ponieważ musisz używać tego samego formatu, do przekazania zawartości plików w dalszych etapach, stwórz metodę pomocniczą, <code>export_data</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">def export_data(string)
  print "data #{string.size}\n#{string}"
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jedyne co pozostało, to wskazanie zawartości pliku dla każdej migawki.
Jest to proste, ponieważ masz wszystkie pliki w katalogu – możesz wypisać komendę <code>deleteall</code>, a następnie zawartość wszystkich plików w katalogu.
Następnie Git zapisze każdą migawkę:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">puts 'deleteall'
Dir.glob("**/*").each do |file|
  next if !File.file?(file)
  inline_data(file)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Uwaga:  Ponieważ spora część systemów kontroli wersji myśli o kolejnych rewizjach jako o zmianach z jednego commita do drugiego, <code>fast-import</code> może również pobrać komendy dla każdego commita, w których można wskazać jakie pliki zostały dodane, usunięte, lub zmodyfikowane i jaka jest ich nowa zawartość.
Mógłbyś obliczyć różnice między migawkami i dostarczyć tylko te dane, ale działanie w ten sposób jest bardziej skomplikowane – łatwiej wskazać Gitowi wszystkie dane, a on sam się zajmie obliczaniem różnic.
Jeżeli jednak uważasz, że ten sposób jest bardziej dopasowany do danych które posiadasz, sprawdź podręcznik systemowy dla komendy <code>fast-import</code>, aby dowiedzieć się w jaki sposób przekazać jej dane.</p>
</div>
<div class="paragraph">
<p>Format przekazywania zawartości nowego pliku lub wskazywania zmodyfikowanego z nową zawartością jest następujący:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>M 644 inline path/to/file
data (size)
(file contents)</code></pre>
</div>
</div>
<div class="paragraph">
<p>W tym przykładzie, 644 oznacza uprawnienia do pliku (jeżeli masz pliki wykonywalne, musisz wskazać 755), a inline mówi o tym, że będziesz przekazywał dane zaraz po tej linii.
Twoja metoda <code>inline_data</code> wygląda tak:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">def inline_data(file, code = 'M', mode = '644')
  content = File.read(file)
  puts "#{code} #{mode} inline #{file}"
  export_data(content)
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Używasz ponownie metody <code>export_data</code>, którą zdefiniowałeś wcześniej, ponieważ działa to tak samo jak podczas wskazywania treści komentarza do commita.</p>
</div>
<div class="paragraph">
<p>Ostatnią rzeczą, którą musisz zrobić, jest zwrócenie bieżącego znaku, aby można go było przekazać do następnej iteracji:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">return mark</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Jeżeli pracujesz na systemie Windows, musisz upewnić się, że dodajesz jeszcze jeden krok.
Jak wspomniałem wcześniej, system Windows używa znaków CRLF jak znaczników końca linii, a <code>git fast-import</code> oczekuje tylko LF.
Aby obejść ten problem i uszczęśliwić <code>git fast-import</code>, musisz wskazać ruby, aby używał znaków LF zamiast CRLF:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">$stdout.binmode</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Tylko tyle.
Oto cały skrypt:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ruby" data-lang="ruby">#!/usr/bin/env ruby

$stdout.binmode
$author = "John Doe &lt;john@example.com&gt;"

$marks = []
def convert_dir_to_mark(dir)
    if !$marks.include?(dir)
        $marks &lt;&lt; dir
    end
    ($marks.index(dir)+1).to_s
end


def convert_dir_to_date(dir)
    if dir == 'current'
        return Time.now().to_i
    else
        dir = dir.gsub('back_', '')
        (year, month, day) = dir.split('_')
        return Time.local(year, month, day).to_i
    end
end

def export_data(string)
    print "data #{string.size}\n#{string}"
end

def inline_data(file, code='M', mode='644')
    content = File.read(file)
    puts "#{code} #{mode} inline #{file}"
    export_data(content)
end

def print_export(dir, last_mark)
    date = convert_dir_to_date(dir)
    mark = convert_dir_to_mark(dir)

    puts 'commit refs/heads/master'
    puts "mark :#{mark}"
    puts "committer #{$author} #{date} -0700"
    export_data("imported from #{dir}")
    puts "from :#{last_mark}" if last_mark

    puts 'deleteall'
    Dir.glob("**/*").each do |file|
        next if !File.file?(file)
        inline_data(file)
    end
    mark
end


# Loop through the directories
last_mark = nil
Dir.chdir(ARGV[0]) do
    Dir.glob("*").each do |dir|
        next if File.file?(dir)

        # move into the target directory
        Dir.chdir(dir) do
            last_mark = print_export(dir, last_mark)
        end
    end
end</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jeżeli uruchomisz ten skrypt, otrzymasz wynik podobny do tego:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ruby import.rb /opt/import_from
commit refs/heads/master
mark :1
committer John Doe &lt;john@example.com&gt; 1388649600 -0700
data 29
imported from back_2014_01_02deleteall
M 644 inline README.md
data 28
# Hello

This is my readme.
commit refs/heads/master
mark :2
committer John Doe &lt;john@example.com&gt; 1388822400 -0700
data 29
imported from back_2014_01_04from :1
deleteall
M 644 inline main.rb
data 34
#!/bin/env ruby

puts "Hey there"
M 644 inline README.md
(...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aby uruchomić importer, przekaż wynik do <code>git fast-import</code> będąc w katalogu z repozytorium Gita do którego chcesz zaimportować dane.
Możesz stworzyć nowy katalog, następnie uruchomić <code>git init</code> w nim, a potem uruchomić skrypt:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git init
Initialized empty Git repository in /opt/import_to/.git/
$ ruby import.rb /opt/import_from | git fast-import
git-fast-import statistics:
---------------------------------------------------------------------
Alloc'd objects:       5000
Total objects:           13 (         6 duplicates                  )
      blobs  :            5 (         4 duplicates          3 deltas of          5 attempts)
      trees  :            4 (         1 duplicates          0 deltas of          4 attempts)
      commits:            4 (         1 duplicates          0 deltas of          0 attempts)
      tags   :            0 (         0 duplicates          0 deltas of          0 attempts)
Total branches:           1 (         1 loads     )
      marks:           1024 (         5 unique    )
      atoms:              2
Memory total:          2344 KiB
       pools:          2110 KiB
     objects:           234 KiB
---------------------------------------------------------------------
pack_report: getpagesize()            =       4096
pack_report: core.packedGitWindowSize = 1073741824
pack_report: core.packedGitLimit      = 8589934592
pack_report: pack_used_ctr            =         10
pack_report: pack_mmap_calls          =          5
pack_report: pack_open_windows        =          2 /          2
pack_report: pack_mapped              =       1457 /       1457
---------------------------------------------------------------------</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jak widzisz, gdy zakończy się powodzeniem, pokaże Ci trochę statystyk na temat tego co zdziałał.
W tym przypadku, zaimportowałeś do jednej gałęzi łącznie 13 obiektów z 4 commitów.
Teraz możesz uruchomić <code>git log</code>, aby zobaczyć swoją nową historię projektu:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -2
commit 3caa046d4aac682a55867132ccdfbe0d3fdee498
Author: John Doe &lt;john@example.com&gt;
Date:   Tue Jul 29 19:39:04 2014 -0700

    imported from current

commit 4afc2b945d0d3c8cd00556fbe2e8224569dc9def
Author: John Doe &lt;john@example.com&gt;
Date:   Mon Feb 3 01:00:00 2014 -0700

    imported from back_2014_02_03</code></pre>
</div>
</div>
<div class="paragraph">
<p>Proszę bardzo – ładne, czyste repozytorium Git.
Warto zauważyć, że żadne dane nie zostały pobrane – nie masz żadnych plików w swoim katalogu roboczym
 Aby je pobrać, musisz wykonać reset do momentu, w którym teraz jest <code>master</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ ls
$ git reset --hard master
HEAD is now at 3caa046 imported from current
$ ls
README.md main.rb</code></pre>
</div>
</div>
<div class="paragraph">
<p>Możesz zrobić dużo więcej przy pomocy narzędzia <code>fast-import</code> – obsłużyć różne tryby, dane binarne, gałęzie i ich łączenie, etykiety, wskaźniki postępu i inne. Wiele przykładów o bardziej skomplikowanych scenariuszach działania jest dostępnych w katalogu <code>contrib/fast-import</code> w kodzie źródłowym Gita.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>