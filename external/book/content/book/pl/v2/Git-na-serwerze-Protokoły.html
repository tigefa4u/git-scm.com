---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: pl
  chapter:
    title: Git na serwerze
    number: 4
  section:
    title: Protokoły
    number: 1
    cs_number: '4.1'
    previous: book/pl/v2/Gałęzie-Gita-Podsumowanie
    next: book/pl/v2/Git-na-serwerze-Uruchomienie-Git-na-serwerze
title: Git - Protokoły
url: "/book/pl/v2/Git-na-serwerze-Protokoły.html"
---
<p>
Powinieneś być już w stanie realizować większość codziennych zadań podczas pracy z Git.
Jednakże do współpracy z innymi potrzebne będzie zdalne repozytorium Git.
Choć, technicznie rzecz biorąc, możesz pchać zmiany i pobierać je z repozytoriów pojedynczych osób, nie jest to zalecana technika, ponieważ jeśli nie jest się ostrożnym, bardzo łatwo zrobić bałagan w czyjejś pracy.
Dodatkowo niezbędny jest dostęp do Twojego repozytorium przez innych nawet gdy nie masz połączenia z siecią – bardzo przydatne jest posiadanie wiarygodnego, wspólnego repozytorium.
Z tego powodu zalecaną metodą współpracy z innymi jest stworzenie pośredniego repozytorium, do którego wszyscy mają dostęp i wykonywanie operacji pchania i pobierania danych właśnie z niego.</p><p>Zarządzanie serwerem Git jest proste.
Po pierwsze określasz protokoły dostępu do tego serwera.
Pierwsza część tego rozdziału zawiera informacje o dostępnych protokołach oraz ich wadach i zaletach.
Kolejne części zawierają opisy typowych konfiguracji wykorzystujących te protokoły oraz opis właściwych ustawień serwera.
W końcu opiszemy dostępne opcje hostingu, jeśli nie przeszkadza Ci przechowywanie kodu na obcym serwerze i nie masz ochoty na tworzenie i zarządzanie własnym serwerem.</p><p>Jeśli nie masz zamiaru tworzyć własnego serwera możesz przejść od razu do ostatniej części tego rozdziału, aby sprawdzić dostępne możliwości tworzenia konta w zewnętrznej usłudze, a następnie możesz przejść do kolejnego rozdziału, który zawiera dyskusję na temat różnych aspektów pracy w rozproszonym środowisku kontroli wersji.</p><p>Zdalne repozytorium to nic innego jak samo repozytorium bez kopii roboczej (ang. <em>bare repository</em>).
Ponieważ repozytorium to jest wykorzystywane wyłącznie jako miejsce współpracy, nie ma potrzeby by na dysku istniała migawka jakiejkolwiek wersji; to po prostu dane Git.
Mówiąc krótko – takie repozytorium to wyłącznie zawartość katalogu <code>.git</code>.</p>
<h2 id="_protokoły">Protokoły</h2>
<div class="paragraph">
<p>Git potrafi korzystać z czterech podstawowych protokołów sieciowych do przesyłu danych: lokalnego, Secure Shell (SSH), Git, oraz HTTP.
Poniżej opiszemy czym się charakteryzują i w jakich sytuacjach warto korzystać (lub wręcz przeciwnie) z jednego z nich.</p>
</div>
<div class="sect3">
<h3 id="_protokół_lokalny">Protokół lokalny</h3>
<div class="paragraph">
<p>
Najbardziej podstawowym protokołem jest <em>protokół lokalny</em>, w którym zdalne repozytorium to po prostu inny katalog na dysku.
Taką konfigurację często wykorzystuje się, gdy wszyscy z Twojego zespołu mają dostęp do jednego współdzielonego systemu plików, np. NFS lub, co mniej prawdopodobne, gdy wszyscy logują się do tego samego komputera.
Ten drugi scenariusz nie jest zalecany z tego powodu, że wszystkie kopie repozytorium znajdują się na tej samej fizycznej maszynie, co może być katastrofalne w skutkach.</p>
</div>
<div class="paragraph">
<p>Jeśli posiadasz współdzielony, zamontowany system plików, możesz z niego klonować, pchać do niego własne zmiany oraz pobierać zmiany innych korzystając z plikowego repozytorium lokalnego.
Aby sklonować takie repozytorium, albo wskazać jedno z takich repozytoriów jako repozytorium zdalne, skorzystaj ze ścieżki do katalogu jako adresu URL.
Np. aby sklonować lokalne repozytorium możesz wywołać polecenie podobne do poniższego:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone /opt/git/project.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Możesz też użyć takiej formy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone file:///opt/git/project.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git działa odrobinę inaczej, gdy jawnie użyjesz przedrostka <code>file://</code> w adresie URL.
Jeśli podasz samą ścieżkę, Git spróbuje użyć twardych linków albo po prostu skopiować potrzebne pliki.
Jeśli podasz <code>file://</code>, Git uruchomi procesy normalnie wykorzystane do transferu sieciowego, co zwykle jest znacznie mniej efektywną metodą przesyłania danych.
Głównym powodem podawania przedrostka <code>file://</code> jest chęć posiadania czystej kopii repozytorium bez niepotrzebnych referencji, czy obiektów, które zwykle powstają po zaimportowaniu repozytorium z innego systemu kontroli wersji (rozdział <a href="{{< relurl "book/pl/v2/ch00/_git_internals" >}}">Mechanizmy wewnętrzne w Git</a> zawiera informacje na temat zadań administracyjnych).
Tutaj skorzystamy ze zwykłej ścieżki do katalogu, ponieważ prawie zawsze tak będzie szybciej.</p>
</div>
<div class="paragraph">
<p>Aby dodać do istniejącego projektu repozytorium plikowe jako repozytorium zdalne, wykonaj polecenie:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git remote add local_proj /opt/git/project.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Od tej chwili możesz pchać i pobierać z repozytorium zdalnego tak samo jakby repozytorium to istniało w sieci.</p>
</div>
<div class="sect4">
<h4 id="_zalety">Zalety</h4>
<div class="paragraph">
<p>Zaletą plikowego repozytorium jest prostota i możliwość skorzystania z istniejących uprawnień plikowych i sieciowych.
Jeśli już posiadasz współdzielony sieciowy system plików, do którego Twój zespół posiada dostęp, konfiguracja takiego repozytorium jest bardzo prosta.
Umieszczasz kopię czystego repozytorium w miejscu, do którego każdy zainteresowany ma dostęp i ustawiasz prawa odczytu/zapisu tak samo jak do każdego innego współdzielonego zasobu.
Informacja o tym jak w tym celu wyeksportować czyste repozytorium znajduje się w następnej części <a href="{{< relurl "book/pl/v2/ch00/_git_on_the_server" >}}">Uruchomienie Git na serwerze</a>.</p>
</div>
<div class="paragraph">
<p>Opcja ta jest interesująca także w przypadku, gdy chcemy szybko pobrać zmiany z czyjegoś repozytorium.
Jeśli działasz z kimś w tym samym projekcie i ktoś chce pokazać Ci swoje zmiany, wykonanie polecenia <code>git pull /home/john/project</code> jest często prostsze od czekania aż ktoś wypchnie zmiany na serwer, aby później je stamtąd pobrać.</p>
</div>
</div>
<div class="sect4">
<h4 id="_wady">Wady</h4>
<div class="paragraph">
<p>Wadą tej metody jest to, że współdzielony dostęp plikowy dla wielu osób jest zwykle trudniejszy w konfiguracji niż prosty dostęp sieciowy.
Jeśli chcesz pchać swoje zmiany z laptopa z domu, musisz zamontować zdalny dysk, co może być trudniejsze i wolniejsze niż dostęp sieciowy.</p>
</div>
<div class="paragraph">
<p>Warto również wspomnieć, że korzystanie z pewnego rodzaju sieciowego zasobu współdzielonego niekoniecznie jest najszybszą metodą dostępu.
Lokalne repozytorium jest szybkie tylko wtedy, gdy masz szybki dostęp do danych.
Repozytorium umieszczone w zasobie NFS jest często wolniejsze od repozytorium udostępnianego po SSH nawet jeśli znajduje się na tym samym serwerze, a jednocześnie pozwala na korzystanie z Git na lokalnych dyskach w każdym z systemów.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_the_http_protocols">The HTTP Protocols</h3>
<div class="paragraph">
<p>Git can communicate over HTTP in two different modes.
Prior to Git 1.6.6 there was only one way it could do this which was very simple and generally read-only.
In version 1.6.6 a new, smarter protocol was introduced that involved Git being able to intelligently negotiate data transfer in a manner similar to how it does over SSH.
In the last few years, this new HTTP protocol has become very popular since it’s simpler for the user and smarter about how it communicates.
The newer version is often referred to as the “Smart” HTTP protocol and the older way as “Dumb” HTTP.
We’ll cover the newer “smart” HTTP protocol first.</p>
</div>
<div class="sect4">
<h4 id="_smart_http">Smart HTTP</h4>
<div class="paragraph">
<p>
The “smart” HTTP protocol operates very similarly to the SSH or Git protocols but runs over standard HTTP/S ports and can use various HTTP authentication mechanisms, meaning it’s often easier on the user than something like SSH, since you can use things like username/password basic authentication rather than having to set up SSH keys.</p>
</div>
<div class="paragraph">
<p>It has probably become the most popular way to use Git now, since it can be set up to both serve anonymously like the <code>git://</code> protocol, and can also be pushed over with authentication and encryption like the SSH protocol. Instead of having to set up different URLs for these things, you can now use a single URL for both. If you try to push and the repository requires authentication (which it normally should), the server can prompt for a username and password. The same goes for read access.</p>
</div>
<div class="paragraph">
<p>In fact, for services like GitHub, the URL you use to view the repository online (for example, “<a href="https://github.com/schacon/simplegit" class="bare">https://github.com/schacon/simplegit</a>”) is the same URL you can use to clone and, if you have access, push over.</p>
</div>
</div>
<div class="sect4">
<h4 id="_tryb_dumb">Tryb <em>dumb</em>
</h4>
<div class="paragraph">
<p>
Jeśli serwer nie odpowie usługą Git HTTP <em>smart</em>, to klient Git będzie próbował powrócić do prostszego protokołu HTTP <em>dumb</em> (z ang. głupi).
Protokół <em>dumb</em> oczekuje, że czyste repozytorium Git będzie obsługiwane jak normalne pliki z serwera WWW.
Piękno tego protokołu polega na prostocie jego konfiguracji.
Zwykle wystarczy umieścić czyste repozytorium Git poniżej katalogu głównego WWW oraz skonfigurować specjalny hook <code>post-update</code> i…​ to tyle (por. rozdział <a href="{{< relurl "book/pl/v2/ch00/_git_hooks" >}}">Git Hooks</a>).
Od tej chwili każdy, kto posiada dostęp do serwera WWW, w którym umieściłeś repozytorium może je sklonować.
Aby umożliwić dostęp tylko do odczytu przez HTTP, wykonaj coś takiego:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ cd /var/www/htdocs/
$ git clone --bare /path/to/git_project gitproject.git
$ cd gitproject.git
$ mv hooks/post-update.sample hooks/post-update
$ chmod a+x hooks/post-update</code></pre>
</div>
</div>
<div class="paragraph">
<p>I tyle.
Hook <code>post-update</code>, który jest częścią Git uruchamia odpowiednie polecenie (<code>git update-server-info</code>) po to, aby pobieranie i klonowanie po HTTP działało poprawnie.
To polecenie wykonywane jest, gdy do repozytorium pchasz dane (prawdopodobnie po SSH); potem inni mogą sklonować je za pomocą:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone https://example.com/gitproject.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>W tym konkretnym przypadku korzystamy ze ścieżki <code>/var/www/htdocs</code>, która jest standardowa dla serwera Apache, ale można skorzystać z dowolnego statycznego serwera WWW – wystarczy umieścić w nim czyste repozytorium.
Dane Git udostępniane są jako proste pliki statyczne (rozdział <a href="{{< relurl "book/pl/v2/ch00/_git_internals" >}}">Mechanizmy wewnętrzne w Git</a> zawiera więcej szczegółów na temat udostępniania danych w ten sposób).</p>
</div>
<div class="paragraph">
<p>Ogólnie rzecz biorąc, można albo uruchomić serwer HTTP w trybie <em>smart</em> z możliwością odczytu/zapisu, albo po prostu udostępnić pliki tylko do odczytu w trybie <em>dumb</em>. Rzadko się zdarza, aby trzeba było uruchomić dwie takie usługi jednocześnie.</p>
</div>
</div>
<div class="sect4">
<h4 id="_the_pros">The Pros</h4>
<div class="paragraph">
<p>We’ll concentrate on the pros of the Smart version of the HTTP protocol.</p>
</div>
<div class="paragraph">
<p>The simplicity of having a single URL for all types of access and having the server prompt only when authentication is needed makes things very easy for the end user.
Being able to authenticate with a username and password is also a big advantage over SSH, since users don’t have to generate SSH keys locally and upload their public key to the server before being able to interact with it.
For less sophisticated users, or users on systems where SSH is less common, this is a major advantage in usability.
It is also a very fast and efficient protocol, similar to the SSH one.</p>
</div>
<div class="paragraph">
<p>You can also serve your repositories read-only over HTTPS, which means you can encrypt the content transfer; or you can go so far as to make the clients use specific signed SSL certificates.</p>
</div>
<div class="paragraph">
<p>Another nice thing is that HTTP/S are such commonly used protocols that corporate firewalls are often set up to allow traffic through these ports.</p>
</div>
</div>
<div class="sect4">
<h4 id="_the_cons">The Cons</h4>
<div class="paragraph">
<p>Git over HTTP/S can be a little more tricky to set up compared to SSH on some servers.
Other than that, there is very little advantage that other protocols have over the “Smart” HTTP protocol for serving Git.</p>
</div>
<div class="paragraph">
<p>If you’re using HTTP for authenticated pushing, providing your credentials is sometimes more complicated than using keys over SSH. There are however several credential caching tools you can use, including Keychain access on OSX and Credential Manager on Windows, to make this pretty painless. Read <a href="{{< relurl "book/pl/v2/ch00/_credential_caching" >}}">Credential Storage</a> to see how to set up secure HTTP password caching on your system.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_protokół_ssh">Protokół SSH</h3>
<div class="paragraph">
<p>
A common transport protocol for Git when self-hosting is over SSH.
This is because SSH access to servers is already set up in most places – and if it isn’t, it’s easy to do.
SSH is also an authenticated network protocol; and because it’s ubiquitous, it’s generally easy to set up and use.</p>
</div>
<div class="paragraph">
<p>Aby sklonować repozytorium Git po SSH, użyj przedrostka <code>ssh://</code> jak poniżej:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone ssh://user@server/project.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Możesz także użyć krótszego zapisu, który wykorzystuje program <code>scp</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git clone user@server:project.git</code></pre>
</div>
</div>
<div class="paragraph">
<p>Możesz także pominąć użytkownika – Git zakłada użytkownika na którego jesteś aktualnie zalogowany.</p>
</div>
<div class="sect4">
<h4 id="_zalety_2">Zalety</h4>
<div class="paragraph">
<p>Istnieje wiele zalet korzystania z SSH.
Po pierwsze, SSH jest relatywnie łatwe do skonfigurowania – demony SSH są powszechnie wykorzystywane, wielu administratorów sieciowych jest doświadczonych w ich administracji, a wiele systemów operacyjnych posiada je zainstalowane standardowo, bądź zawiera niezbędne do ich zarządzania narzędzia.
Po drugie, dostęp po SSH jest bezpieczny – cała transmisja jest szyfrowana i uwierzytelniona.
Wreszcie, podobnie jak HTTP/S, Git i lokalne protokoły, SSH jest protokołem efektywnym i pozwalającym na optymalny transfer danych z punktu widzenia przepustowości.</p>
</div>
</div>
<div class="sect4">
<h4 id="_wady_2">Wady</h4>
<div class="paragraph">
<p>Wadą dostępu po SSH jest to, że nie istnieje dostęp anonimowy do repozytorium.
Programiści lub inne zainteresowane osoby muszą posiadać dostęp do serwera po SSH nawet gdy chcą jedynie odczytać dane z repozytorium, co sprawia, że taki rodzaj dostępu nie jest interesujący z punktu widzenia projektów Open Source.
Jeśli korzystasz z SSH wyłącznie w sieci korporacyjnej firmy, SSH z powodzeniem może być jedynym protokołem dostępu.
Jeśli konieczny jest anonimowy dostęp do projektów tylko do odczytu, SSH jest potrzebny by pchać do nich zmiany, ale do pobierania danych przez innych wymagany jest inny rodzaj dostępu.</p>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_protokół_git">Protokół Git</h3>
<div class="paragraph">
<p>
Następnie mamy protokół Git.
To specjalny rodzaj procesu demona, który dostępny jest w pakiecie z Gitem; słucha na dedykowanym porcie (9418) i udostępnia usługi podobne do protokołu SSH, ale całkowicie bez obsługi uwierzytelnienia.
Aby repozytorium mogło być udostępnione po protokole Git konieczne jest utworzenie pliku <code>git-daemon-export-ok</code> – bez niego demon nie udostępni repozytorium – ale to jedyne zabezpieczenie.
Albo wszyscy mogą klonować dane repozytorium, albo nikt.
Generalnie oznacza to że nie można pchać zmian po tym protokole.
Można włączyć taką możliwość; ale biorąc pod uwagę brak mechanizmów uwierzytelniania, jeśli włączysz możliwość zapisu, każdy w Internecie, kto odkryje adres Twojego projektu może pchać do niego zmiany.
Wystarczy powiedzieć, że nie spotyka się często takich sytuacji.</p>
</div>
<div class="sect4">
<h4 id="_zalety_3">Zalety</h4>
<div class="paragraph">
<p>Protokół Git to najszybszy dostępny protokół dostępu.
Jeśli obsługujesz duży ruch sieciowy w publicznie dostępnych projektach, albo udostępniasz spory projekt, który nie wymaga uwierzytelniania dla dostępu tylko do odczytu, bardzo prawdopodobne jest, że skorzystasz w tym celu z demona Git.
Korzysta on z tych samych mechanizmów transferu danych jak protokół SSH, ale bez narzutów związanych z szyfrowaniem i uwierzytelnieniem.</p>
</div>
</div>
<div class="sect4">
<h4 id="_wady_3">Wady</h4>
<div class="paragraph">
<p>Wadą protokołu Git jest brak mechanizmów uwierzytelniania.
Zwykle nie jest wskazane, by był to jedyny protokół dostępu do repozytoriów Git.
Najczęściej stosuje się go wraz z protokołem SSH, który obsługuje zapis (pchanie zmian), podczas gdy odczyt przez wszystkich odbywa się z wykorzystaniem <code>git://</code>.
Prawdopodobnie jest to także protokół najtrudniejszy w konfiguracji.
Musi działać w procesie dedykowanego demona wymaga konfiguracji <code>xinetd</code> lub analogicznej, co nie zawsze jest trywialne.
Wymaga również osobnej reguły dla firewalla, który musi pozwalać na dostęp po niestandardowym porcie 9418, co zwykle nie jest proste do wymuszenia na korporacyjnych administratorach.</p>
</div>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>