---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: pl
  chapter:
    title: Gałęzie Gita
    number: 3
  section:
    title: Zmiana bazy
    number: 6
    cs_number: '3.6'
    previous: book/pl/v2/Gałęzie-Gita-Gałęzie-zdalne
    next: book/pl/v2/Gałęzie-Gita-Podsumowanie
title: Git - Zmiana bazy
url: "/book/pl/v2/Gałęzie-Gita-Zmiana-bazy.html"
---
<h2 id="_rebasing">Zmiana bazy</h2>
<div class="paragraph">
<p>
W Git istnieją dwa podstawowe sposoby integrowania zmian z jednej gałęzi do drugiej: scalanie (polecenie <code>merge</code>) oraz zmiana bazy (polecenie <code>rebase</code>).
W tym rozdziale dowiesz się, czym jest zmiana bazy, jak ją przeprowadzić, dlaczego jest to świetne narzędzie i w jakich przypadkach lepiej się powstrzymać od jego wykorzystania.</p>
</div>
<div class="sect3">
<h3 id="_typowa_zmiana_bazy">Typowa zmiana bazy</h3>
<div class="paragraph">
<p>Jeśli cofniesz się do poprzedniego przykładu z sekcji <a href="{{< relurl "book/pl/v2/ch00/_basic_merging" >}}">Podstawy scalania</a>, zobaczysz, że rozszczepiłeś swoją pracę i wykonywałeś zmiany w dwóch różnych gałęziach.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/pl/v2/images/basic-rebase-1.png" >}}" alt="Początkowa historia po rozszczepieniu.">
</div>
<div class="title">Figure 35. Początkowa historia po rozszczepieniu</div>
</div>
<div class="paragraph">
<p>Najprostszym sposobem, aby zintegrować gałęzie - jak już napisaliśmy - jest polecenie <code>merge</code>. Przeprowadza ono trójstronne scalanie pomiędzy dwoma ostatnimi migawkami gałęzi (<code>C3</code> i <code>C4</code>) oraz ich ostatnim wspólnym przodkiem (<code>C2</code>), tworząc nową migawkę (oraz rewizję).</p>
</div>
<div id="rebasing-merging-example" class="imageblock">
<div class="content">
<img src="{{< relurl "book/pl/v2/images/basic-rebase-2.png" >}}" alt="Scalanie gałęzi integrujące rozszczepioną historię zmian.">
</div>
<div class="title">Figure 36. Scalanie gałęzi integrujące rozszczepioną historię zmian</div>
</div>
<div class="paragraph">
<p>Jednakże istnieje inny sposób: możesz stworzyć łatkę ze zmianami wprowadzonymi w <code>C4</code> i zaaplikować ją na rewizję <code>C3</code>. W Gicie nazywa się to zmianą bazy (ang. <em>rebase</em>). Dzięki poleceniu <code>rebase</code> możesz wziąć wszystkie zmiany, które zostały zatwierdzone w jednej gałęzi i zaaplikować je w innej.</p>
</div>
<div class="paragraph">
<p>W tym wypadku, mógłbyś uruchomić następujące polecenie:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command</code></pre>
</div>
</div>
<div class="paragraph">
<p>Polecenie to działa przesuwając się do ostatniego wspólnego przodka obu gałęzi (tej w której się znajdujesz oraz tej <em>do</em> której robisz zmianę bazy), pobierając różnice opisujące kolejne zmiany (ang. <em>diffs</em>) wprowadzane przez kolejne rewizje w gałęzi w której się znajdujesz, zapisując je w tymczasowych plikach, następnie resetuje bieżącą gałąź do tej samej rewizji <em>do</em> której wykonujesz operację zmiany bazy, po czym aplikuje po kolei zapisane zmiany.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/pl/v2/images/basic-rebase-3.png" >}}" alt="Zmiana bazy dla zmian wprowadzonych w `C4` do `C3`..">
</div>
<div class="title">Figure 37. Zmiana bazy dla zmian wprowadzonych w <code>C4</code> do <code>C3</code>.</div>
</div>
<div class="paragraph">
<p>W tym momencie możesz wrócić do gałęzi <code>master</code> i scalić zmiany wykonując proste przesunięcie wskaźnika (co przesunie wskaźnik master na koniec).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
$ git merge experiment</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/pl/v2/images/basic-rebase-4.png" >}}" alt="Przesunięcie gałęzi master po operacji zmiany bazy.">
</div>
<div class="title">Figure 38. Przesunięcie gałęzi master po operacji zmiany bazy</div>
</div>
<div class="paragraph">
<p>Teraz migawka wskazywana przez <code>C4'</code> jest dokładnie taka sama jak ta, na którą wskazuje <code>C5</code> w <a href="{{< relurl "book/pl/v2/ch00/rebasing-merging-example" >}}">przykładzie ze scalaniem</a>.
Nie ma różnicy w produkcie końcowym integracji. Zmiana bazy tworzy jednak czystszą historię.
Jeśli przejrzysz historię gałęzi po operacji <code>rebase</code>, wygląda ona na liniową: wygląda jakby cała praca była wykonywana stopniowo, nawet jeśli oryginalnie odbywała się równolegle.</p>
</div>
<div class="paragraph">
<p>Warto korzystać z tej funkcji, by mieć pewność, że rewizje zaaplikują się w bezproblemowy sposób do zdalnej gałęzi – być może w projekcie w którym próbujesz się udzielać, a którym nie zarządzasz.
W takim wypadku będziesz wykonywał swoją pracę we własnej gałęzi, a następnie zmieniał jej bazę na <code>origin/master</code>, jak tylko będziesz gotowy do przesłania własnych poprawek do głównego projektu.
W ten sposób osoba utrzymująca projekt nie będzie musiała dodatkowo wykonywać integracji – jedynie prostolinijne scalenie lub czyste zastosowanie zmian.</p>
</div>
<div class="paragraph">
<p>Zauważ, że migawka wskazywana przez wynikową rewizję bez względu na to, czy jest to ostatnia rewizja po zmianie bazy lub ostatnia rewizja scalająca po operacji scalania, to taka sama migawka – różnica istnieje jedynie w historii.
Zmiana bazy nanosi zmiany z jednej linii pracy do innej w kolejności, w jakiej były one wprowadzane, w odróżnieniu od scalania, które bierze dwie końcówki i integruje je ze sobą.</p>
</div>
</div>
<div class="sect3">
<h3 id="_ciekawsze_operacje_zmiany_bazy">Ciekawsze operacje zmiany bazy</h3>
<div class="paragraph">
<p>Poleceniem <code>rebase</code> możesz także zastosować zmiany na innej gałęzi niż ta, której zmieniasz bazę
Dla przykładu – weź historię taką jak w przykładzie <a href="{{< relurl "book/pl/v2/ch00/rbdiag_e" >}}">Historia z gałęzią tematyczną utworzoną na podstawie innej gałęzi tematycznej.</a>.
Utworzyłeś gałąź tematyczną (<code>server</code>), żeby dodać nowe funkcje do kodu serwerowego, po czym utworzyłeś rewizję.
Następnie utworzyłeś gałąź, żeby wykonać zmiany w kliencie (<code>client</code>) i kilkukrotnie zatwierdziłeś zmiany.
Ostatecznie wróciłeś do gałęzi <code>server</code> i wykonałeś kilka kolejnych rewizji.</p>
</div>
<div id="rbdiag_e" class="imageblock">
<div class="content">
<img src="{{< relurl "book/pl/v2/images/interesting-rebase-1.png" >}}" alt="Historia z gałęzią tematyczną utworzoną na podstawie innej gałęzi tematycznej.">
</div>
<div class="title">Figure 39. Historia z gałęzią tematyczną utworzoną na podstawie innej gałęzi tematycznej.</div>
</div>
<div class="paragraph">
<p>Załóżmy, że zdecydowałeś się scalić zmiany w kliencie do kodu głównego, ale chcesz się jeszcze wstrzymać ze zmianami po stronie serwera, dopóki nie zostaną one dokładniej przetestowane.
Możesz wziąć zmiany w kodzie klienta, których nie ma w kodzie serwera (<code>C8</code> i <code>C9</code>) i zastosować je na gałęzi głównej używając opcji <code>--onto</code> polecenia <code>git rebase</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rebase --onto master server client</code></pre>
</div>
</div>
<div class="paragraph">
<p>Oznacza to mniej więcej "Przełącz się do gałęzi klienta, określ zmiany wprowadzone od wspólnego przodka gałęzi <code>client</code> i <code>server</code>, a następnie nanieś te zmiany na gałąź główną <code>master</code>".
Jest to nieco skomplikowane, ale wynik jest całkiem niezły.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/pl/v2/images/interesting-rebase-2.png" >}}" alt="Zmiana bazy gałęzi tematycznej odbitej z innej gałęzi tematycznej.">
</div>
<div class="title">Figure 40. Zmiana bazy gałęzi tematycznej odbitej z innej gałęzi tematycznej</div>
</div>
<div class="paragraph">
<p>Teraz możesz zwyczajnie przesunąć wskaźnik gałęzi głównej do przodu (por. <a href="{{< relurl "book/pl/v2/ch00/rbdiag_g" >}}">Przesunięcie do przodu gałęzi master w celu uwzględnienia zmian z gałęzi client</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
$ git merge client</code></pre>
</div>
</div>
<div id="rbdiag_g" class="imageblock">
<div class="content">
<img src="{{< relurl "book/pl/v2/images/interesting-rebase-3.png" >}}" alt="Przesunięcie do przodu gałęzi master w celu uwzględnienia zmian z gałęzi client.">
</div>
<div class="title">Figure 41. Przesunięcie do przodu gałęzi master w celu uwzględnienia zmian z gałęzi client</div>
</div>
<div class="paragraph">
<p>Powiedzmy, że zdecydujesz się pobrać i scalić zmiany z gałęzi <code>server</code>.
Możesz zmienić bazę gałęzi <code>server</code> na wskazywaną przez <code>master</code> bez konieczności przełączania się do gałęzi <code>server</code> używając <code>git rebase [gałąź bazowa] [gałąź tematyczna]</code> – w ten sposób zmiany z gałęzi <code>server</code> zostaną zaaplikowane do gałęzi bazowej <code>master</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rebase master server</code></pre>
</div>
</div>
<div class="paragraph">
<p>Polecenie odtwarza zmiany z gałęzi <code>server</code> na gałęzi <code>master</code> tak, jak pokazuje to <a href="{{< relurl "book/pl/v2/ch00/rbdiag_h" >}}">Zmiana bazy gałęzi <code>server</code> na koniec gałęzi <code>master</code></a>.</p>
</div>
<div id="rbdiag_h" class="imageblock">
<div class="content">
<img src="{{< relurl "book/pl/v2/images/interesting-rebase-4.png" >}}" alt="Zmiana bazy gałęzi `server` na koniec gałęzi `master`.">
</div>
<div class="title">Figure 42. Zmiana bazy gałęzi <code>server</code> na koniec gałęzi <code>master</code>
</div>
</div>
<div class="paragraph">
<p>Następnie możesz przesunąć gałąź bazową (<code>master</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git checkout master
$ git merge server</code></pre>
</div>
</div>
<div class="paragraph">
<p>Możesz teraz usunąć gałęzie <code>client</code> i <code>server</code>, ponieważ cała praca jest już zintegrowana i więcej ich nie potrzebujesz, pozostawiając historię w stanie takim, jaki obrazuje <a href="{{< relurl "book/pl/v2/ch00/rbdiag_i" >}}">Ostateczna historia rewizji</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git branch -d client
$ git branch -d server</code></pre>
</div>
</div>
<div id="rbdiag_i" class="imageblock">
<div class="content">
<img src="{{< relurl "book/pl/v2/images/interesting-rebase-5.png" >}}" alt="Ostateczna historia rewizji.">
</div>
<div class="title">Figure 43. Ostateczna historia rewizji</div>
</div>
</div>
<div class="sect3">
<h3 id="_rebase_peril">Zagrożenia operacji zmiany bazy</h3>
<div class="paragraph">
<p>
Błogosławieństwo, jakie daje możliwość zmiany bazy, ma swoją mroczną stronę. Można ją podsumować jednym zdaniem:</p>
</div>
<div class="paragraph">
<p><strong>Nie zmieniaj bazy rewizji, które wypchnąłeś już do publicznego repozytorium.</strong></p>
</div>
<div class="paragraph">
<p>Jeśli będziesz się stosował do tej reguły, wszystko będzie dobrze.
W przeciwnym razie ludzie cię znienawidzą, a rodzina i przyjaciele zaczną omijać szerokim łukiem.</p>
</div>
<div class="paragraph">
<p>Stosując operację zmiany bazy porzucasz istniejące rewizje i tworzysz nowe, które są podobne, ale inne.
Wypychasz gdzieś swoje zmiany, inni je pobierają, scalają i pracują na nich, a następnie nadpisujesz te zmiany poleceniem <code>git rebase</code> i wypychasz ponownie na serwer. Twoi współpracownicy będą musieli scalić swoją pracę raz jeszcze i zrobi się bałagan, kiedy spróbujesz pobrać i scalić ich zmiany z powrotem z twoimi.</p>
</div>
<div class="paragraph">
<p>Spójrzmy na przykład obrazujący, jak operacja zmiany bazy może spowodować problemy.
Załóżmy, że sklonujesz repozytorium z centralnego serwera, a następnie wykonasz bazując na tym nowe zmiany.
Twoja historia rewizji wygląda następująco:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/pl/v2/images/perils-of-rebasing-1.png" >}}" alt="Sklonowane repozytorium i dokonane zmiany.">
</div>
<div class="title">Figure 44. Sklonowane repozytorium i dokonane zmiany</div>
</div>
<div class="paragraph">
<p>Teraz ktoś inny wykonuje inną pracę, która obejmuje scalenie, i wypycha ją na centralny serwer.
Pobierasz zmiany, scalasz nową, zdalną gałąź z własną pracą, w wyniku czego historia wygląda mniej więcej tak:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="{{< relurl "book/pl/v2/images/perils-of-rebasing-2.png" >}}" alt="Pobranie kolejnych rewizji i scalenie ich z własnymi zmianami.">
</div>
<div class="title">Figure 45. Pobranie kolejnych rewizji i scalenie ich z własnymi zmianami</div>
</div>
<div class="paragraph">
<p>Następnie osoba, która wypchnęła scalone zmiany, rozmyśliła się i zdecydowała zamiast scalenia zmienić bazę swoich zmian; wykonuje <code>git push --force</code>, żeby zastąpić historię na serwerze.
Następnie ty pobierasz dane z serwera ściągając nowe rewizje.</p>
</div>
<div id="_pre_merge_rebase_work" class="imageblock">
<div class="content">
<img src="{{< relurl "book/pl/v2/images/perils-of-rebasing-3.png" >}}" alt="Ktoś wypycha rewizje po operacji zmiany bazy" width="porzucając rewizje" height="na których ty oparłeś swoje zmiany.">
</div>
<div class="title">Figure 46. Ktoś wypycha rewizje po operacji zmiany bazy, porzucając rewizje, na których ty oparłeś swoje zmiany</div>
</div>
<div class="paragraph">
<p>Teraz obaj znaleźliście się w trudnej sytuacji.
Jeśli wykonasz <code>git pull</code>, utworzysz rewizję scalającą, która będzie zawierała obie linie historii, a twoje repozytorium będzie wyglądało tak:</p>
</div>
<div id="_merge_rebase_work" class="imageblock">
<div class="content">
<img src="{{< relurl "book/pl/v2/images/perils-of-rebasing-4.png" >}}" alt="Scalasz tą samą pracę raz jeszcze tworząc nową rewizję scalającą.">
</div>
<div class="title">Figure 47. Scalasz tą samą pracę raz jeszcze tworząc nową rewizję scalającą</div>
</div>
<div class="paragraph">
<p>Jeśli uruchomisz <code>git log</code> dla takiej historii, zobaczysz dwie rewizje mające tego samego autora, datę oraz komentarz, co będzie mylące.
Co więcej, jeśli wypchniesz tę historię z powrotem na serwer, raz jeszcze wprowadzisz wszystkie rewizje powstałe w wyniku operacji zmiany bazy na serwer centralny, co może dalej mylić i denerwować ludzi.
Można bezpiecznie przyjąć, że drugi deweloper nie chce, aby <code>C4</code> i <code>C6</code> były w historii; z tego właśnie powodu w pierwszej kolejności dokonał zmiany bazy.</p>
</div>
</div>
<div class="sect3">
<h3 id="_rebase_rebase">Rebase When You Rebase</h3>
<div class="paragraph">
<p>If you <strong>do</strong> find yourself in a situation like this, Git has some further magic that might help you out. If someone on your team force pushes changes that overwrite work that you’ve based work on, your challenge is to figure out what is yours and what they’ve rewritten.</p>
</div>
<div class="paragraph">
<p>It turns out that in addition to the commit SHA-1 checksum, Git also calculates a checksum that is based just on the patch introduced with the commit. This is called a “patch-id”.</p>
</div>
<div class="paragraph">
<p>If you pull down work that was rewritten and rebase it on top of the new commits from your partner, Git can often successfully figure out what is uniquely yours and apply them back on top of the new branch.</p>
</div>
<div class="paragraph">
<p>For instance, in the previous scenario, if instead of doing a merge when we’re at <a href="{{< relurl "book/pl/v2/ch00/_pre_merge_rebase_work" >}}">Ktoś wypycha rewizje po operacji zmiany bazy, porzucając rewizje, na których ty oparłeś swoje zmiany</a> we run <code>git rebase teamone/master</code>, Git will:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Determine what work is unique to our branch (C2, C3, C4, C6, C7)</p>
</li>
<li>
<p>Determine which are not merge commits (C2, C3, C4)</p>
</li>
<li>
<p>Determine which have not been rewritten into the target branch (just C2 and C3, since C4 is the same patch as C4')</p>
</li>
<li>
<p>Apply those commits to the top of <code>teamone/master</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So instead of the result we see in <a href="{{< relurl "book/pl/v2/ch00/_merge_rebase_work" >}}">Scalasz tą samą pracę raz jeszcze tworząc nową rewizję scalającą</a>, we would end up with something more like <a href="{{< relurl "book/pl/v2/ch00/_rebase_rebase_work" >}}">Rebase on top of force-pushed rebase work.</a>.</p>
</div>
<div id="_rebase_rebase_work" class="imageblock">
<div class="content">
<img src="{{< relurl "book/pl/v2/images/perils-of-rebasing-5.png" >}}" alt="Rebase on top of force-pushed rebase work.">
</div>
<div class="title">Figure 48. Rebase on top of force-pushed rebase work.</div>
</div>
<div class="paragraph">
<p>This only works if C4 and C4' that your partner made are almost exactly the same patch. Otherwise the rebase won’t be able to tell that it’s a duplicate and will add another C4-like patch (which will probably fail to apply cleanly, since the changes would already be at least somewhat there).</p>
</div>
<div class="paragraph">
<p>You can also simplify this by running a <code>git pull --rebase</code> instead of a normal <code>git pull</code>. Or you could do it manually with a <code>git fetch</code> followed by a <code>git rebase teamone/master</code> in this case.</p>
</div>
<div class="paragraph">
<p>If you are using <code>git pull</code> and want to make <code>--rebase</code> the default, you can set the <code>pull.rebase</code> config value with something like <code>git config --global pull.rebase true</code>.</p>
</div>
<div class="paragraph">
<p>If you treat rebasing as a way to clean up and work with commits before you push them, and if you only rebase commits that have never been available publicly, then you’ll be fine.
If you rebase commits that have already been pushed publicly, and people may have based work on those commits, then you may be in for some frustrating trouble, and the scorn of your teammates.</p>
</div>
<div class="paragraph">
<p>If you or a partner does find it necessary at some point, make sure everyone knows to run <code>git pull --rebase</code> to try to make the pain after it happens a little bit simpler.</p>
</div>
</div>
<div class="sect3">
<h3 id="_rebase_vs_merge">Rebase vs. Merge</h3>
<div class="paragraph">
<p>
Now that you’ve seen rebasing and merging in action, you may be wondering which one is better.
Before we can answer this, let’s step back a bit and talk about what history means.</p>
</div>
<div class="paragraph">
<p>One point of view on this is that your repository’s commit history is a <strong>record of what actually happened.</strong>
It’s a historical document, valuable in its own right, and shouldn’t be tampered with.
From this angle, changing the commit history is almost blasphemous; you’re <em>lying</em> about what actually transpired.
So what if there was a messy series of merge commits?
That’s how it happened, and the repository should preserve that for posterity.</p>
</div>
<div class="paragraph">
<p>The opposing point of view is that the commit history is the <strong>story of how your project was made.</strong>
You wouldn’t publish the first draft of a book, and the manual for how to maintain your software deserves careful editing.
This is the camp that uses tools like rebase and filter-branch to tell the story in the way that’s best for future readers.</p>
</div>
<div class="paragraph">
<p>Now, to the question of whether merging or rebasing is better: hopefully you’ll see that it’s not that simple.
Git is a powerful tool, and allows you to do many things to and with your history, but every team and every project is different.
Now that you know how both of these things work, it’s up to you to decide which one is best for your particular situation.</p>
</div>
<div class="paragraph">
<p>In general the way to get the best of both worlds is to rebase local changes you’ve made but haven’t shared yet before you push them in order to clean up your story, but never rebase anything you’ve pushed somewhere.</p>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>