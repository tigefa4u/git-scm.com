---
### DO NOT EDIT! Generated by script/update-book2.rb
category: book
section: documentation
subsection: book
sidebar: book
book:
  language_code: pl
  chapter:
    title: Narzędzia Gita
    number: 7
  section:
    title: Wskazywanie rewizji
    number: 1
    cs_number: '7.1'
    previous: book/pl/v2/GitHub-Summary
    next: book/pl/v2/Narzędzia-Gita-Interaktywne-używanie-przechowali
title: Git - Wskazywanie rewizji
url: "/book/pl/v2/Narzędzia-Gita-Wskazywanie-rewizji.html"
---
<p>Do tej chwili poznałeś większość komend potrzebnych do codziennej pracy, oraz do prowadzenia repozytorium ze swoim kodem.
Wykonywałeś podstawowe zadania dotyczące śledzenia i wprowadzania zmian, oraz wykorzystywałeś przechowalnię, jak również rozgałęzianie oraz łączenie różnych gałęzi.</p><p>Teraz dowiesz się o kolejnych rzeczach, które Git ma do zaoferowania, z których być może nie będziesz korzystał codziennie, ale które z pewnością będą przydatne.</p>
<h2 id="_revision_selection">Wskazywanie rewizji</h2>
<div class="paragraph">
<p>Git umożliwia wskazanie konkretnej zmiany lub zakresu zmian na kilka sposobów.
Nie koniecznie są one oczywiste, ale na pewno są warte uwagi.</p>
</div>
<div class="sect3">
<h3 id="_pojedyncze_rewizje">Pojedyncze rewizje</h3>
<div class="paragraph">
<p>Jak wiesz, możesz odwoływać się do pojedynczej zmiany poprzez skrót SHA-1, istnieją jednak bardziej przyjazne sposoby.
Ta sekcja opisuje kilka z nich.</p>
</div>
</div>
<div class="sect3">
<h3 id="_krótki_sha_1">Krótki SHA-1</h3>
<div class="paragraph">
<p>Git jest na tyle inteligentny, że potrafi domyśleć się o którą zmianę Ci chodziło po dodaniu zaledwie kilku znaków, o ile ta część sumy SHA-1 ma przynajmniej 4 znaki i jest unikalna, co oznacza, że istnieje tylko jeden obiekt w repozytorium, który od nich się zaczyna.</p>
</div>
<div class="paragraph">
<p>Dla przykładu, aby zobaczyć konkretną zmianę, uruchamiasz komendę <code>git log</code> i wybierasz zmianę w której dodałeś jakąś funkcjonalność:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log
commit 734713bc047d87bf7eac9674765ae793478c50d3
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'

commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff</code></pre>
</div>
</div>
<div class="paragraph">
<p>W tym przypadku, powiedzmy, że interesuje nas commit, którego hash zaczyna się od <code>1c002dd...</code>. Możesz sprawdzić ten commit za pomocą dowolnej z poniższych odmian <code>git show</code> (zakładając, że krótsze wersje są jednoznaczne):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b
$ git show 1c002dd4b536e7479f
$ git show 1c002d</code></pre>
</div>
</div>
<div class="paragraph">
<p>Git może sam odnaleźć unikalne występowania wartości SHA-1.
Jeżeli przekażesz parametr <code>--abbrev-commit</code> do komendy <code>git log</code>, jej wynik pokaże krótsze wartości SHA-1, przy zachowaniu ich unikalności; domyślnie stosuje długość 7 znaków, ale może ją zwiększyć, aby zachować unikalność sum kontrolnych:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --abbrev-commit --pretty=oneline
ca82a6d changed the version number
085bb3b removed unnecessary test code
a11bef0 first commit</code></pre>
</div>
</div>
<div class="paragraph">
<p>Generalnie, 8 do 10 znaków to wystarczająca ilość, aby mieć unikalne wartości w projekcie.</p>
</div>
<div class="paragraph">
<p>Dla przykładu, jądro Linux, które jest całkiem dużym projektem z ponad 450 tys. commitów i 3.6 milionami obiektów, nie ma dwóch obiektów, których SHA-1 pokrywają się bardziej niż pierwsze 11 znaków.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="title">KRÓTKA UWAGA NA TEMAT SHA-1</div>
<div class="paragraph">
<p>Duża liczba osób zaniepokoiła się, gdy ze względu na jakiś szczęśliwy przypadek, mieli w swoim repozytorium dwa różne obiekty posiadające tą samą wartość SHA-1.
Co wtedy?</p>
</div>
<div class="paragraph">
<p>Jeżeli zdarzy Ci się zapisać obiekt który ma sumę kontrolną SHA-1 taką samą jak inny obiekt będący już w repozytorium, Git zauważy, że obiekt taki już istnieje i założy, że został on już zapisany.
Jeżeli spróbujesz pobrać jego zawartość, zawsze otrzymasz dane pierwszego obiektu.</p>
</div>
<div class="paragraph">
<p>Powinieneś wiedzieć jednak, że taki scenariusz jest strasznie rzadki. Skrót SHA-1 ma długość 20 bajtów lub 160 bitów. Ilość losowych obiektów potrzebnych do zapewnienia 50% prawdopodobieństwa kolizji to około 2<sup>80</sup>
(wzór na obliczenie prawdopodobieństwa kolizji to <code>p = (n(n-1)/2) * (1/2^160)</code>). 2<sup>80</sup>
to 1,2 x 10<sup>24</sup>
lub 1 milion miliardów miliardów. To 1200 razy więcej niż liczba ziaren piasku na ziemi.</p>
</div>
<div class="paragraph">
<p>Weźmy przykład, aby zaprezentować Ci jak trudne jest wygenerowanie kolizji SHA-1.
Jeżeli wszyscy z 6,5 miliarda osób na ziemi byłaby programistami i w każdej sekundzie, każdy z nich tworzyłby kod wielkości całego jądra Linuksa (1 milion obiektów Gita) i wgrywał go do ogromnego repozytorium Gita, zajęłoby około 5 lat, zanim w repozytorium byłoby tyle obiektów, aby mieć pewność 50% wystąpienia kolizji.
Istnieje większe prawdopodobieństwo, że każdy z członków Twojego zespołu programistycznego zostanie zaatakowany i zabity przez wilki, w nie związanych ze sobą zdarzeniach, w ciągu tej samej nocy.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h3 id="_branch_references">Odniesienie do gałęzi</h3>
<div class="paragraph">
<p>Najprostszym sposobem na wskazanie konkretnej zmiany, jest stworzenie odniesienia do gałęzi wskazującej na nią.
Następnie, będziesz mógł używać nazwy gałęzi we wszystkich komendach Gita które przyjmują jako parametr obiekt lub wartość SHA-1.
Na przykład, jeżeli chcesz pokazać ostatni zmieniony obiekt w gałęzi, podane niżej komendy są identyczne, przy założeniu, że <code>topic1</code> wskazuje na <code>ca82a6d</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show ca82a6dff817ec66f44342007202690a93763949
$ git show topic1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jeżeli chciałbyś zobaczyć, na jaką sumę SHA-1 wskazuje dana gałąź, lub jeżeli chcesz zobaczyć na jaką sumę SHA-1 każdy z tych przykładów się rozwiązuje, możesz użyć komendy <code>rev-parse</code>.
Możesz zobaczyć również rozdział <a href="{{< relurl "book/pl/v2/ch00/_git_internals" >}}">Mechanizmy wewnętrzne w Git</a>, aby dowiedzieć się o tym narzędziu więcej; zasadniczo <code>rev-parse</code> wykonuje operacje niskopoziomowo i nie jest stworzony do codziennej pracy.
Jednakże potrafi być czasami przydatny, jeżeli musisz zobaczyć co tak naprawdę się dzieje.
Możesz teraz wywołać <code>rev-parse</code> na swojej gałęzi.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git rev-parse topic1
ca82a6dff817ec66f44342007202690a93763949</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h3 id="_git_reflog">Skróty do RefLog</h3>
<div class="paragraph">
<p>Jedną z rzeczy które Git robi w tle w czasie Twojej pracy, jest utrzymywanie tzw. <em>refloga</em> – zapisanych informacji o tym, jak wyglądały odwołania HEAD-a i innych gałęzi w ciągu ostatnich miesięcy.</p>
</div>
<div class="paragraph">
<p>Możesz zobaczyć refloga za pomocą komendy <code>git reflog</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git reflog
734713b HEAD@{0}: commit: fixed refs handling, added gc auto, updated
d921970 HEAD@{1}: merge phedders/rdocs: Merge made by recursive.
1c002dd HEAD@{2}: commit: added some blame and merge stuff
1c36188 HEAD@{3}: rebase -i (squash): updating HEAD
95df984 HEAD@{4}: commit: # This is a combination of two commits.
1c36188 HEAD@{5}: rebase -i (squash): updating HEAD
7e05da5 HEAD@{6}: rebase -i (pick): updating HEAD</code></pre>
</div>
</div>
<div class="paragraph">
<p>Za każdym razem, gdy Twoja gałąź się przesuwa, Git przechowuje tą informację w tej tymczasowej historii.
Za jej pomocą, możesz wskazać również starsze zmiany.
Jeżeli chcesz zobaczyć zawartość HEAD-a sprzed 5 zmian, możesz użyć odwołania <code>@{n}</code>, które widać w wyniku komendy reflog:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show HEAD@{5}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Możesz również użyć tej składni, aby dowiedzieć się, jak wyglądała dana gałąź jakiś czas temu.
Na przykład, aby zobaczyć gdzie była gałąź <code>master</code> wczoraj, możesz wywołać:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show master@{yesterday}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Co pokaże Ci, na jakim etapie znajdowała się ta gałąź wczoraj.
Ta technika zadziała tylko dla danych które są jeszcze w Twoim reflogu, nie możesz więc jej użyć do sprawdzenia zmian starszych niż kilka miesięcy.</p>
</div>
<div class="paragraph">
<p>Aby zobaczyć wynik reflog-a w formacie podobnym do wyniku <code>git log</code>, możesz uruchomić <code>git log -g</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log -g master
commit 734713bc047d87bf7eac9674765ae793478c50d3
Reflog: master@{0} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: commit: fixed refs handling, added gc auto, updated
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Reflog: master@{1} (Scott Chacon &lt;schacon@gmail.com&gt;)
Reflog message: merge phedders/rdocs: Merge made by recursive.
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Należy zaznaczyć, że informacje z reflog-a są wyłącznie lokalne – jest to zapis zmian które wprowadzałeś w swoim repozytorium.
Referencje nie będą takie same na kopii repozytorium u kogoś innego; a od razu po pierwszym sklonowaniu repozytorium, będziesz miał pusty reflog, ze względu na to, że żadna aktywność nie została wykonana.
Uruchomienie <code>git show HEAD{2.months.ago}</code> zadziała tylko wówczas, gdy sklonowałeś swoje repozytorium przynajmniej dwa miesiące temu – jeżeli sklonowałeś je pięć minut temu, otrzymasz pusty wynik.</p>
</div>
</div>
<div class="sect3">
<h3 id="_referencje_przodków">Referencje przodków</h3>
<div class="paragraph">
<p>Innym często używanym sposobem na wskazanie konkretnego commit-a jest wskazanie przodka. Jeżeli umieścisz znak <code>^</code> na końcu referencji, Git rozwinie to do rodzica tego commit-a.
Załóżmy, że spojrzałeś na historię zmian w swoim projekcie:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --pretty=format:'%h %s' --graph
* 734713b fixed refs handling, added gc auto, updated tests
*   d921970 Merge commit 'phedders/rdocs'
|\
| * 35cfb2b Some rdoc changes
* | 1c002dd added some blame and merge stuff
|/
* 1c36188 ignore *.gem
* 9b29157 add open3_detach to gemspec file list</code></pre>
</div>
</div>
<div class="paragraph">
<p>Następne, możesz zobaczyć poprzednią zmianę, poprzez użycie <code>HEAD^</code>, co oznacza "rodzic HEAD-a":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show HEAD^
commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Możesz również określić liczbę po <code>^</code> - na przykład, <code>d921970^2</code> oznacza "drugi rodzic d921970".
Taka składnia jest użyteczna podczas łączenia zmian, które mają więcej niż jednego rodzica.
Pierwszym rodzicem jest gałąź na której byłeś podczas łączenia zmian, a drugim jest zmiana w gałęzi którą łączyłeś:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show d921970^
commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon &lt;schacon@gmail.com&gt;
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff

$ git show d921970^2
commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548
Author: Paul Hedderly &lt;paul+git@mjr.org&gt;
Date:   Wed Dec 10 22:22:03 2008 +0000

    Some rdoc changes</code></pre>
</div>
</div>
<div class="paragraph">
<p>Kolejnym wskaźnikiem przodka jest <code>~</code>.
On również wskazuje na pierwszego rodzica, więc <code>HEAD~</code> i <code>HEAD^</code> są równoznaczne.
Różnica zaczyna być widoczna po sprecyzowaniu liczby.
<code>HEAD~2</code> oznacza "pierwszy rodzic pierwszego rodzica", lub inaczej "dziadek" – przemierza to pierwszych rodziców ilość razy którą wskażesz.
Na przykład, w historii pokazanej wcześniej, <code>HEAD~3</code> będzie:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show HEAD~3
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem</code></pre>
</div>
</div>
<div class="paragraph">
<p>Może to być również zapisane jako <code>HEAD^^^</code>, co znowu daje pierwszego rodzica, pierwszego rodzica, pierwszego rodzica:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git show HEAD^^^
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem</code></pre>
</div>
</div>
<div class="paragraph">
<p>Możesz również łączyć obie składnie - możesz dostać drugiego rodzica poprzedniej referencji (zakładając że było to łączenie zmian) przy użyciu <code>HEAD~3^2</code>, i tak dalej.</p>
</div>
</div>
<div class="sect3">
<h3 id="_commit_ranges">Zakresy zmian</h3>
<div class="paragraph">
<p>Teraz gdy możesz już wskazywać pojedyncze zmiany, sprawdźmy jak wskazać ich zakres.
Jest to szczególnie przydatne podczas zarządzania gałęziami – w sytuacji, gdy masz dużą ilość gałęzi, możesz użyć wskaźnika zakresu zmian, aby odpowiedzieć na pytanie, w stylu "Jakie są zmiany na obecnej gałęzi, których jeszcze nie włączyłem do gałęzi głównej?".</p>
</div>
<div class="sect4">
<h4 id="_podwójna_kropka">Podwójna kropka</h4>
<div class="paragraph">
<p>Najczęściej używaną składnią wskazywania zakresu zmian jest podwójna kropka.
Mówi ona Gitowi, aby rozwinął zakres zmian które są osiągalne z pierwszego commitu, ale nie są z drugiego.
Na przykład, załóżmy że masz historię zmian która wygląda tak jak na <a href="{{< relurl "book/pl/v2/ch00/double_dot" >}}">Przykładowa historia dla wskazania zakresu zmian.</a>.</p>
</div>
<div id="double_dot" class="imageblock">
<div class="content">
<img src="{{< relurl "book/pl/v2/images/double-dot.png" >}}" alt="Przykładowa historia dla wskazania zakresu zmian.">
</div>
<div class="title">Figure 137. Przykładowa historia dla wskazania zakresu zmian.</div>
</div>
<div class="paragraph">
<p>Chcesz zobaczyć co z tego co znajduje się w Twojej gałęzi <code>experiment</code> nie zostało jeszcze włączone do gałęzi <code>master</code>.
Możesz poprosić Gita, aby pokazał Ci logi z informacjami o tych zmianach przy pomocy <code>master..experiment</code> – co oznacza "wszystkie zmiany dostępne z <code>experiment</code> które nie są dostępne przez <code>master</code>".
Dla zachowania zwięzłości i przejrzystości w tych przykładach, użyjemy liter ze zmian znajdujących się na wykresie zamiast pełnego wyniku komendy, w kolejności w jakiej się pokażą:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log master..experiment
D
C</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jeżeli, z drugiej strony, chcesz zobaczyć odwrotne działanie – wszystkie zmiany z <code>master</code> których nie ma w <code>experiment</code> – możesz odwrócić nazwy gałęzi.
<code>experiment..master</code> pokaże wszystko to z <code>master</code>, co nie jest dostępne z <code>experiment</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log experiment..master
F
E</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jest to przydatne, jeżeli zamierzasz utrzymywać gałąź <code>experiment</code> zaktualizowaną, oraz przeglądać co będziesz integrował.
Innym bardzo często używanym przykładem użycia tej składni jest sprawdzenie, co zamierzasz wypchnąć do zdalnego repozytorium:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log origin/master..HEAD</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ta komenda pokaże wszystkie zmiany z Twojej obecnej gałęzi, których nie ma w zdalnej gałęzi <code>master</code> w repozytorium.
Jeżeli uruchomisz <code>git push</code>, a Twoja obecna gałąź śledzi <code>origin/master</code>, zmiany pokazane przez <code>git log origin/master..HEAD</code> to te, które będą wysłane na serwer.
Możesz również pominąć jedną ze stron tej składni, aby Git założył HEAD.
Dla przykładu, możesz otrzymać takie same wyniki jak w poprzednim przykładzie wywołując <code>git log origin/master..</code> – Git wstawi HEAD jeżeli jednej ze stron brakuje.</p>
</div>
</div>
<div class="sect4">
<h4 id="_wielokrotne_punkty">Wielokrotne punkty</h4>
<div class="paragraph">
<p>Składnie z dwiema kropkami jest użyteczna jako skrót; ale możesz chcieć wskazać więcej niż dwie gałęzie, jak na przykład zobaczenie które zmiany są w obojętnie której z gałęzi, ale nie są w gałęzi w której się obecnie znajdujesz.
Git pozwala Ci na zrobienie tego poprzez użycie znaku <code>^</code>, lub opcji <code>--not</code> podanej przed referencją z której nie chcesz widzieć zmian.
Dlatego też, te trzy komendy są równoznaczne:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log refA..refB
$ git log ^refA refB
$ git log refB --not refA</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jest to bardzo fajne, ponieważ przy użyciu tej składni możesz wskazać więcej niż dwie referencje w swoim zapytaniu, czego nie możesz osiągnąć przy pomocy składni z dwiema kropkami.
Dla przykładu, jeżeli chcesz zobaczyć zmiany które są dostępne z <code>refA</code> lub <code>refB</code>, ale nie z <code>refC</code>, możesz użyć:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log refA refB ^refC
$ git log refA refB --not refC</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tworzy to bardzo użyteczną składnię zapytań, która powinna Ci pomóc dowiedzieć się, co jest w Twoich gałęziach.</p>
</div>
</div>
<div class="sect4">
<h4 id="_triple_dot">Potrójna kropka</h4>
<div class="paragraph">
<p>Ostatnią z głównych składni zakresu jest składnia z trzema kropkami, która wskazuje na wszystkie zmiany które są dostępne z jednej z dwóch referencji, ale nie z obu.
Spójrz ponownie na przykład z historią zmian na <a href="{{< relurl "book/pl/v2/ch00/double_dot" >}}">Przykładowa historia dla wskazania zakresu zmian.</a>.
Jeżeli chcesz zobaczyć co jest zmienione w <code>master</code> lub <code>experiment</code>, poza wspólnymi, możesz uruchomić:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log master...experiment
F
E
D
C</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ponownie, otrzymasz normalny wynik <code>log</code>, ale pokazujący tylko informacje o czterech zmianach, występujących w normalnej kolejności.</p>
</div>
<div class="paragraph">
<p>Często używaną opcją do komendy <code>log</code> jest <code>--left-right</code>, która pokazuje po której stronie każda zmiana występuje.
Pozwala to na uzyskanie użyteczniejszych informacji:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-console" data-lang="console">$ git log --left-right master...experiment
&lt; F
&lt; E
&gt; D
&gt; C</code></pre>
</div>
</div>
<div class="paragraph">
<p>Przy pomocy tych narzędzi, możesz dużo łatwiej wskazać którą zmianę lub zmiany chcesz zobaczyć.</p>
</div>
</div>
</div>
<div id="nav"><a href="{{< previous-section >}}">prev</a> | <a href="{{< next-section >}}">next</a></div>